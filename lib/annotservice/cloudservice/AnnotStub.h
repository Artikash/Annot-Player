/* AnnotStub.h
   Generated by gSOAP 2.8.15 from cloudservice.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under ONE of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#ifndef AnnotStub_H
#define AnnotStub_H
#include <vector>
#define SOAP_NAMESPACE_OF_ns1	""
#define SOAP_NAMESPACE_OF_tns	"http://service.annot.me/"
#ifndef WITH_NOGLOBAL
#define WITH_NOGLOBAL
#endif
#include "stdsoap2.h"
#if GSOAP_VERSION != 20815
# error "GSOAP VERSION MISMATCH IN GENERATED CODE: PLEASE REINSTALL PACKAGE"
#endif


namespace Annot {

/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_Annot_tns__gameHook
#define SOAP_TYPE_Annot_tns__gameHook (8)
/* tns:gameHook */
class SOAP_CMAC tns__gameHook
{
public:
	LONG64 flags;	/* required element of type xsd:long */
	LONG64 id;	/* required element of type xsd:long */
	std::string *text;	/* optional element of type xsd:string */
	LONG64 tokenId;	/* required element of type xsd:long */
	LONG64 updateIp;	/* required element of type xsd:long */
	LONG64 updateTime;	/* required element of type xsd:long */
	LONG64 userId;	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 8; } /* = unique id SOAP_TYPE_Annot_tns__gameHook */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__gameHook() { tns__gameHook::soap_default(NULL); }
	virtual ~tns__gameHook() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__gameThread
#define SOAP_TYPE_Annot_tns__gameThread (9)
/* tns:gameThread */
class SOAP_CMAC tns__gameThread
{
public:
	int encoding;	/* required element of type xsd:int */
	LONG64 flags;	/* required element of type xsd:long */
	LONG64 id;	/* required element of type xsd:long */
	std::string *provider;	/* optional element of type xsd:string */
	LONG64 signature;	/* required element of type xsd:long */
	LONG64 tokenId;	/* required element of type xsd:long */
	int type;	/* required element of type xsd:int */
	LONG64 updateIp;	/* required element of type xsd:long */
	LONG64 updateTime;	/* required element of type xsd:long */
	LONG64 userId;	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 9; } /* = unique id SOAP_TYPE_Annot_tns__gameThread */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__gameThread() { tns__gameThread::soap_default(NULL); }
	virtual ~tns__gameThread() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__mediaAnnotation
#define SOAP_TYPE_Annot_tns__mediaAnnotation (10)
/* tns:mediaAnnotation */
class SOAP_CMAC tns__mediaAnnotation
{
public:
	int blessCount;	/* required element of type xsd:int */
	int blockCount;	/* required element of type xsd:int */
	LONG64 createTime;	/* required element of type xsd:long */
	LONG64 createIp;	/* required element of type xsd:long */
	int curseCount;	/* required element of type xsd:int */
	LONG64 flags;	/* required element of type xsd:long */
	LONG64 id;	/* required element of type xsd:long */
	int language;	/* required element of type xsd:int */
	LONG64 pos;	/* required element of type xsd:long */
	int posType;	/* required element of type xsd:int */
	int time;	/* required element of type xsd:int */
	int status;	/* required element of type xsd:int */
	std::string *text;	/* optional element of type xsd:string */
	LONG64 tokenId;	/* required element of type xsd:long */
	LONG64 updateIp;	/* required element of type xsd:long */
	LONG64 updateTime;	/* required element of type xsd:long */
	std::string *userAlias;	/* optional element of type xsd:string */
	LONG64 userId;	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 10; } /* = unique id SOAP_TYPE_Annot_tns__mediaAnnotation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__mediaAnnotation() { tns__mediaAnnotation::soap_default(NULL); }
	virtual ~tns__mediaAnnotation() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__mediaToken
#define SOAP_TYPE_Annot_tns__mediaToken (11)
/* tns:mediaToken */
class SOAP_CMAC tns__mediaToken
{
public:
	int annotCount;	/* required element of type xsd:int */
	int blessCount;	/* required element of type xsd:int */
	int blockCount;	/* required element of type xsd:int */
	LONG64 createIp;	/* required element of type xsd:long */
	LONG64 createTime;	/* required element of type xsd:long */
	int curseCount;	/* required element of type xsd:int */
	std::string *digest;	/* optional element of type xsd:string */
	LONG64 flags;	/* required element of type xsd:long */
	LONG64 id;	/* required element of type xsd:long */
	int section;	/* required element of type xsd:int */
	int status;	/* required element of type xsd:int */
	int type;	/* required element of type xsd:int */
	std::string *url;	/* optional element of type xsd:string */
	LONG64 userId;	/* required element of type xsd:long */
	int visitCount;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 11; } /* = unique id SOAP_TYPE_Annot_tns__mediaToken */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__mediaToken() { tns__mediaToken::soap_default(NULL); }
	virtual ~tns__mediaToken() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__mediaAlias
#define SOAP_TYPE_Annot_tns__mediaAlias (12)
/* tns:mediaAlias */
class SOAP_CMAC tns__mediaAlias
{
public:
	int blessCount;	/* required element of type xsd:int */
	int blockCount;	/* required element of type xsd:int */
	int curseCount;	/* required element of type xsd:int */
	LONG64 flags;	/* required element of type xsd:long */
	LONG64 id;	/* required element of type xsd:long */
	int language;	/* required element of type xsd:int */
	int status;	/* required element of type xsd:int */
	std::string *text;	/* optional element of type xsd:string */
	LONG64 tokenId;	/* required element of type xsd:long */
	int type;	/* required element of type xsd:int */
	LONG64 updateIp;	/* required element of type xsd:long */
	LONG64 updateTime;	/* required element of type xsd:long */
	LONG64 userId;	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 12; } /* = unique id SOAP_TYPE_Annot_tns__mediaAlias */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__mediaAlias() { tns__mediaAlias::soap_default(NULL); }
	virtual ~tns__mediaAlias() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__user
#define SOAP_TYPE_Annot_tns__user (13)
/* tns:user */
class SOAP_CMAC tns__user
{
public:
	int annotCount;	/* required element of type xsd:int */
	int blessCount;	/* required element of type xsd:int */
	int blockCount;	/* required element of type xsd:int */
	LONG64 createIp;	/* required element of type xsd:long */
	LONG64 createTime;	/* required element of type xsd:long */
	int curseCount;	/* required element of type xsd:int */
	std::string *email;	/* optional element of type xsd:string */
	LONG64 flags;	/* required element of type xsd:long */
	LONG64 id;	/* required element of type xsd:long */
	int language;	/* required element of type xsd:int */
	LONG64 loginCount;	/* required element of type xsd:long */
	LONG64 loginIp;	/* required element of type xsd:long */
	LONG64 loginTime;	/* required element of type xsd:long */
	std::string *name;	/* optional element of type xsd:string */
	std::string *nickname;	/* optional element of type xsd:string */
	std::string *password;	/* optional element of type xsd:string */
	int status;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 13; } /* = unique id SOAP_TYPE_Annot_tns__user */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__user() { tns__user::soap_default(NULL); }
	virtual ~tns__user() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__blessMediaAliasWithId
#define SOAP_TYPE_Annot_tns__blessMediaAliasWithId (14)
/* tns:blessMediaAliasWithId */
class SOAP_CMAC tns__blessMediaAliasWithId
{
public:
	LONG64 id;	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 14; } /* = unique id SOAP_TYPE_Annot_tns__blessMediaAliasWithId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__blessMediaAliasWithId() { tns__blessMediaAliasWithId::soap_default(NULL); }
	virtual ~tns__blessMediaAliasWithId() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__blessMediaAliasWithIdResponse
#define SOAP_TYPE_Annot_tns__blessMediaAliasWithIdResponse (15)
/* tns:blessMediaAliasWithIdResponse */
class SOAP_CMAC tns__blessMediaAliasWithIdResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 15; } /* = unique id SOAP_TYPE_Annot_tns__blessMediaAliasWithIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__blessMediaAliasWithIdResponse() { tns__blessMediaAliasWithIdResponse::soap_default(NULL); }
	virtual ~tns__blessMediaAliasWithIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__blessMediaAnnotationWithId
#define SOAP_TYPE_Annot_tns__blessMediaAnnotationWithId (16)
/* tns:blessMediaAnnotationWithId */
class SOAP_CMAC tns__blessMediaAnnotationWithId
{
public:
	LONG64 id;	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 16; } /* = unique id SOAP_TYPE_Annot_tns__blessMediaAnnotationWithId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__blessMediaAnnotationWithId() { tns__blessMediaAnnotationWithId::soap_default(NULL); }
	virtual ~tns__blessMediaAnnotationWithId() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__blessMediaAnnotationWithIdResponse
#define SOAP_TYPE_Annot_tns__blessMediaAnnotationWithIdResponse (17)
/* tns:blessMediaAnnotationWithIdResponse */
class SOAP_CMAC tns__blessMediaAnnotationWithIdResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 17; } /* = unique id SOAP_TYPE_Annot_tns__blessMediaAnnotationWithIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__blessMediaAnnotationWithIdResponse() { tns__blessMediaAnnotationWithIdResponse::soap_default(NULL); }
	virtual ~tns__blessMediaAnnotationWithIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__blessMediaTokenWithId
#define SOAP_TYPE_Annot_tns__blessMediaTokenWithId (18)
/* tns:blessMediaTokenWithId */
class SOAP_CMAC tns__blessMediaTokenWithId
{
public:
	LONG64 id;	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 18; } /* = unique id SOAP_TYPE_Annot_tns__blessMediaTokenWithId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__blessMediaTokenWithId() { tns__blessMediaTokenWithId::soap_default(NULL); }
	virtual ~tns__blessMediaTokenWithId() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__blessMediaTokenWithIdResponse
#define SOAP_TYPE_Annot_tns__blessMediaTokenWithIdResponse (19)
/* tns:blessMediaTokenWithIdResponse */
class SOAP_CMAC tns__blessMediaTokenWithIdResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 19; } /* = unique id SOAP_TYPE_Annot_tns__blessMediaTokenWithIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__blessMediaTokenWithIdResponse() { tns__blessMediaTokenWithIdResponse::soap_default(NULL); }
	virtual ~tns__blessMediaTokenWithIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__blessUserWithId
#define SOAP_TYPE_Annot_tns__blessUserWithId (20)
/* tns:blessUserWithId */
class SOAP_CMAC tns__blessUserWithId
{
public:
	LONG64 id;	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 20; } /* = unique id SOAP_TYPE_Annot_tns__blessUserWithId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__blessUserWithId() { tns__blessUserWithId::soap_default(NULL); }
	virtual ~tns__blessUserWithId() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__blessUserWithIdResponse
#define SOAP_TYPE_Annot_tns__blessUserWithIdResponse (21)
/* tns:blessUserWithIdResponse */
class SOAP_CMAC tns__blessUserWithIdResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 21; } /* = unique id SOAP_TYPE_Annot_tns__blessUserWithIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__blessUserWithIdResponse() { tns__blessUserWithIdResponse::soap_default(NULL); }
	virtual ~tns__blessUserWithIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__blockMediaAliasWithId
#define SOAP_TYPE_Annot_tns__blockMediaAliasWithId (22)
/* tns:blockMediaAliasWithId */
class SOAP_CMAC tns__blockMediaAliasWithId
{
public:
	LONG64 id;	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 22; } /* = unique id SOAP_TYPE_Annot_tns__blockMediaAliasWithId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__blockMediaAliasWithId() { tns__blockMediaAliasWithId::soap_default(NULL); }
	virtual ~tns__blockMediaAliasWithId() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__blockMediaAliasWithIdResponse
#define SOAP_TYPE_Annot_tns__blockMediaAliasWithIdResponse (23)
/* tns:blockMediaAliasWithIdResponse */
class SOAP_CMAC tns__blockMediaAliasWithIdResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 23; } /* = unique id SOAP_TYPE_Annot_tns__blockMediaAliasWithIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__blockMediaAliasWithIdResponse() { tns__blockMediaAliasWithIdResponse::soap_default(NULL); }
	virtual ~tns__blockMediaAliasWithIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__blockMediaAnnotationWithId
#define SOAP_TYPE_Annot_tns__blockMediaAnnotationWithId (24)
/* tns:blockMediaAnnotationWithId */
class SOAP_CMAC tns__blockMediaAnnotationWithId
{
public:
	LONG64 id;	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 24; } /* = unique id SOAP_TYPE_Annot_tns__blockMediaAnnotationWithId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__blockMediaAnnotationWithId() { tns__blockMediaAnnotationWithId::soap_default(NULL); }
	virtual ~tns__blockMediaAnnotationWithId() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__blockMediaAnnotationWithIdResponse
#define SOAP_TYPE_Annot_tns__blockMediaAnnotationWithIdResponse (25)
/* tns:blockMediaAnnotationWithIdResponse */
class SOAP_CMAC tns__blockMediaAnnotationWithIdResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 25; } /* = unique id SOAP_TYPE_Annot_tns__blockMediaAnnotationWithIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__blockMediaAnnotationWithIdResponse() { tns__blockMediaAnnotationWithIdResponse::soap_default(NULL); }
	virtual ~tns__blockMediaAnnotationWithIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__blockUserWithId
#define SOAP_TYPE_Annot_tns__blockUserWithId (26)
/* tns:blockUserWithId */
class SOAP_CMAC tns__blockUserWithId
{
public:
	LONG64 id;	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 26; } /* = unique id SOAP_TYPE_Annot_tns__blockUserWithId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__blockUserWithId() { tns__blockUserWithId::soap_default(NULL); }
	virtual ~tns__blockUserWithId() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__blockUserWithIdResponse
#define SOAP_TYPE_Annot_tns__blockUserWithIdResponse (27)
/* tns:blockUserWithIdResponse */
class SOAP_CMAC tns__blockUserWithIdResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 27; } /* = unique id SOAP_TYPE_Annot_tns__blockUserWithIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__blockUserWithIdResponse() { tns__blockUserWithIdResponse::soap_default(NULL); }
	virtual ~tns__blockUserWithIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__chat
#define SOAP_TYPE_Annot_tns__chat (28)
/* tns:chat */
class SOAP_CMAC tns__chat
{
public:
	std::string *text;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 28; } /* = unique id SOAP_TYPE_Annot_tns__chat */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__chat() { tns__chat::soap_default(NULL); }
	virtual ~tns__chat() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__chatResponse
#define SOAP_TYPE_Annot_tns__chatResponse (29)
/* tns:chatResponse */
class SOAP_CMAC tns__chatResponse
{
public:
	std::string *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 29; } /* = unique id SOAP_TYPE_Annot_tns__chatResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__chatResponse() { tns__chatResponse::soap_default(NULL); }
	virtual ~tns__chatResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__curseMediaAliasWithId
#define SOAP_TYPE_Annot_tns__curseMediaAliasWithId (30)
/* tns:curseMediaAliasWithId */
class SOAP_CMAC tns__curseMediaAliasWithId
{
public:
	LONG64 id;	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 30; } /* = unique id SOAP_TYPE_Annot_tns__curseMediaAliasWithId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__curseMediaAliasWithId() { tns__curseMediaAliasWithId::soap_default(NULL); }
	virtual ~tns__curseMediaAliasWithId() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__curseMediaAliasWithIdResponse
#define SOAP_TYPE_Annot_tns__curseMediaAliasWithIdResponse (31)
/* tns:curseMediaAliasWithIdResponse */
class SOAP_CMAC tns__curseMediaAliasWithIdResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 31; } /* = unique id SOAP_TYPE_Annot_tns__curseMediaAliasWithIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__curseMediaAliasWithIdResponse() { tns__curseMediaAliasWithIdResponse::soap_default(NULL); }
	virtual ~tns__curseMediaAliasWithIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__curseMediaAnnotationWithId
#define SOAP_TYPE_Annot_tns__curseMediaAnnotationWithId (32)
/* tns:curseMediaAnnotationWithId */
class SOAP_CMAC tns__curseMediaAnnotationWithId
{
public:
	LONG64 id;	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 32; } /* = unique id SOAP_TYPE_Annot_tns__curseMediaAnnotationWithId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__curseMediaAnnotationWithId() { tns__curseMediaAnnotationWithId::soap_default(NULL); }
	virtual ~tns__curseMediaAnnotationWithId() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__curseMediaAnnotationWithIdResponse
#define SOAP_TYPE_Annot_tns__curseMediaAnnotationWithIdResponse (33)
/* tns:curseMediaAnnotationWithIdResponse */
class SOAP_CMAC tns__curseMediaAnnotationWithIdResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 33; } /* = unique id SOAP_TYPE_Annot_tns__curseMediaAnnotationWithIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__curseMediaAnnotationWithIdResponse() { tns__curseMediaAnnotationWithIdResponse::soap_default(NULL); }
	virtual ~tns__curseMediaAnnotationWithIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__curseMediaTokenWithId
#define SOAP_TYPE_Annot_tns__curseMediaTokenWithId (34)
/* tns:curseMediaTokenWithId */
class SOAP_CMAC tns__curseMediaTokenWithId
{
public:
	LONG64 id;	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 34; } /* = unique id SOAP_TYPE_Annot_tns__curseMediaTokenWithId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__curseMediaTokenWithId() { tns__curseMediaTokenWithId::soap_default(NULL); }
	virtual ~tns__curseMediaTokenWithId() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__curseMediaTokenWithIdResponse
#define SOAP_TYPE_Annot_tns__curseMediaTokenWithIdResponse (35)
/* tns:curseMediaTokenWithIdResponse */
class SOAP_CMAC tns__curseMediaTokenWithIdResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 35; } /* = unique id SOAP_TYPE_Annot_tns__curseMediaTokenWithIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__curseMediaTokenWithIdResponse() { tns__curseMediaTokenWithIdResponse::soap_default(NULL); }
	virtual ~tns__curseMediaTokenWithIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__curseUserWithId
#define SOAP_TYPE_Annot_tns__curseUserWithId (36)
/* tns:curseUserWithId */
class SOAP_CMAC tns__curseUserWithId
{
public:
	LONG64 id;	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 36; } /* = unique id SOAP_TYPE_Annot_tns__curseUserWithId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__curseUserWithId() { tns__curseUserWithId::soap_default(NULL); }
	virtual ~tns__curseUserWithId() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__curseUserWithIdResponse
#define SOAP_TYPE_Annot_tns__curseUserWithIdResponse (37)
/* tns:curseUserWithIdResponse */
class SOAP_CMAC tns__curseUserWithIdResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 37; } /* = unique id SOAP_TYPE_Annot_tns__curseUserWithIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__curseUserWithIdResponse() { tns__curseUserWithIdResponse::soap_default(NULL); }
	virtual ~tns__curseUserWithIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__deleteMediaAliasWithId
#define SOAP_TYPE_Annot_tns__deleteMediaAliasWithId (38)
/* tns:deleteMediaAliasWithId */
class SOAP_CMAC tns__deleteMediaAliasWithId
{
public:
	LONG64 id;	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 38; } /* = unique id SOAP_TYPE_Annot_tns__deleteMediaAliasWithId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__deleteMediaAliasWithId() { tns__deleteMediaAliasWithId::soap_default(NULL); }
	virtual ~tns__deleteMediaAliasWithId() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__deleteMediaAliasWithIdResponse
#define SOAP_TYPE_Annot_tns__deleteMediaAliasWithIdResponse (39)
/* tns:deleteMediaAliasWithIdResponse */
class SOAP_CMAC tns__deleteMediaAliasWithIdResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 39; } /* = unique id SOAP_TYPE_Annot_tns__deleteMediaAliasWithIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__deleteMediaAliasWithIdResponse() { tns__deleteMediaAliasWithIdResponse::soap_default(NULL); }
	virtual ~tns__deleteMediaAliasWithIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__deleteMediaAnnotationWithId
#define SOAP_TYPE_Annot_tns__deleteMediaAnnotationWithId (40)
/* tns:deleteMediaAnnotationWithId */
class SOAP_CMAC tns__deleteMediaAnnotationWithId
{
public:
	LONG64 id;	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 40; } /* = unique id SOAP_TYPE_Annot_tns__deleteMediaAnnotationWithId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__deleteMediaAnnotationWithId() { tns__deleteMediaAnnotationWithId::soap_default(NULL); }
	virtual ~tns__deleteMediaAnnotationWithId() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__deleteMediaAnnotationWithIdResponse
#define SOAP_TYPE_Annot_tns__deleteMediaAnnotationWithIdResponse (41)
/* tns:deleteMediaAnnotationWithIdResponse */
class SOAP_CMAC tns__deleteMediaAnnotationWithIdResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 41; } /* = unique id SOAP_TYPE_Annot_tns__deleteMediaAnnotationWithIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__deleteMediaAnnotationWithIdResponse() { tns__deleteMediaAnnotationWithIdResponse::soap_default(NULL); }
	virtual ~tns__deleteMediaAnnotationWithIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__getUser
#define SOAP_TYPE_Annot_tns__getUser (42)
/* tns:getUser */
class SOAP_CMAC tns__getUser
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 42; } /* = unique id SOAP_TYPE_Annot_tns__getUser */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__getUser() { tns__getUser::soap_default(NULL); }
	virtual ~tns__getUser() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__getUserResponse
#define SOAP_TYPE_Annot_tns__getUserResponse (43)
/* tns:getUserResponse */
class SOAP_CMAC tns__getUserResponse
{
public:
	tns__user *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tns:user */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 43; } /* = unique id SOAP_TYPE_Annot_tns__getUserResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__getUserResponse() { tns__getUserResponse::soap_default(NULL); }
	virtual ~tns__getUserResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__isAuthorized
#define SOAP_TYPE_Annot_tns__isAuthorized (44)
/* tns:isAuthorized */
class SOAP_CMAC tns__isAuthorized
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 44; } /* = unique id SOAP_TYPE_Annot_tns__isAuthorized */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__isAuthorized() { tns__isAuthorized::soap_default(NULL); }
	virtual ~tns__isAuthorized() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__isAuthorizedResponse
#define SOAP_TYPE_Annot_tns__isAuthorizedResponse (45)
/* tns:isAuthorizedResponse */
class SOAP_CMAC tns__isAuthorizedResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 45; } /* = unique id SOAP_TYPE_Annot_tns__isAuthorizedResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__isAuthorizedResponse() { tns__isAuthorizedResponse::soap_default(NULL); }
	virtual ~tns__isAuthorizedResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__isConnected
#define SOAP_TYPE_Annot_tns__isConnected (46)
/* tns:isConnected */
class SOAP_CMAC tns__isConnected
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 46; } /* = unique id SOAP_TYPE_Annot_tns__isConnected */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__isConnected() { tns__isConnected::soap_default(NULL); }
	virtual ~tns__isConnected() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__isConnectedResponse
#define SOAP_TYPE_Annot_tns__isConnectedResponse (47)
/* tns:isConnectedResponse */
class SOAP_CMAC tns__isConnectedResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 47; } /* = unique id SOAP_TYPE_Annot_tns__isConnectedResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__isConnectedResponse() { tns__isConnectedResponse::soap_default(NULL); }
	virtual ~tns__isConnectedResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__isLatestApp
#define SOAP_TYPE_Annot_tns__isLatestApp (48)
/* tns:isLatestApp */
class SOAP_CMAC tns__isLatestApp
{
public:
	std::string *version;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 48; } /* = unique id SOAP_TYPE_Annot_tns__isLatestApp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__isLatestApp() { tns__isLatestApp::soap_default(NULL); }
	virtual ~tns__isLatestApp() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__isLatestAppResponse
#define SOAP_TYPE_Annot_tns__isLatestAppResponse (49)
/* tns:isLatestAppResponse */
class SOAP_CMAC tns__isLatestAppResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 49; } /* = unique id SOAP_TYPE_Annot_tns__isLatestAppResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__isLatestAppResponse() { tns__isLatestAppResponse::soap_default(NULL); }
	virtual ~tns__isLatestAppResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__login
#define SOAP_TYPE_Annot_tns__login (50)
/* tns:login */
class SOAP_CMAC tns__login
{
public:
	std::string *userName;	/* optional element of type xsd:string */
	std::string *password;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 50; } /* = unique id SOAP_TYPE_Annot_tns__login */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__login() { tns__login::soap_default(NULL); }
	virtual ~tns__login() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__loginResponse
#define SOAP_TYPE_Annot_tns__loginResponse (51)
/* tns:loginResponse */
class SOAP_CMAC tns__loginResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 51; } /* = unique id SOAP_TYPE_Annot_tns__loginResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__loginResponse() { tns__loginResponse::soap_default(NULL); }
	virtual ~tns__loginResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__selectGameHookWithTokenDigest
#define SOAP_TYPE_Annot_tns__selectGameHookWithTokenDigest (52)
/* tns:selectGameHookWithTokenDigest */
class SOAP_CMAC tns__selectGameHookWithTokenDigest
{
public:
	std::string *tokenDigest;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 52; } /* = unique id SOAP_TYPE_Annot_tns__selectGameHookWithTokenDigest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__selectGameHookWithTokenDigest() { tns__selectGameHookWithTokenDigest::soap_default(NULL); }
	virtual ~tns__selectGameHookWithTokenDigest() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__selectGameHookWithTokenDigestResponse
#define SOAP_TYPE_Annot_tns__selectGameHookWithTokenDigestResponse (53)
/* tns:selectGameHookWithTokenDigestResponse */
class SOAP_CMAC tns__selectGameHookWithTokenDigestResponse
{
public:
	tns__gameHook *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tns:gameHook */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 53; } /* = unique id SOAP_TYPE_Annot_tns__selectGameHookWithTokenDigestResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__selectGameHookWithTokenDigestResponse() { tns__selectGameHookWithTokenDigestResponse::soap_default(NULL); }
	virtual ~tns__selectGameHookWithTokenDigestResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__selectGameHookWithTokenId
#define SOAP_TYPE_Annot_tns__selectGameHookWithTokenId (54)
/* tns:selectGameHookWithTokenId */
class SOAP_CMAC tns__selectGameHookWithTokenId
{
public:
	LONG64 tokenId;	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 54; } /* = unique id SOAP_TYPE_Annot_tns__selectGameHookWithTokenId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__selectGameHookWithTokenId() { tns__selectGameHookWithTokenId::soap_default(NULL); }
	virtual ~tns__selectGameHookWithTokenId() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__selectGameHookWithTokenIdResponse
#define SOAP_TYPE_Annot_tns__selectGameHookWithTokenIdResponse (55)
/* tns:selectGameHookWithTokenIdResponse */
class SOAP_CMAC tns__selectGameHookWithTokenIdResponse
{
public:
	tns__gameHook *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tns:gameHook */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 55; } /* = unique id SOAP_TYPE_Annot_tns__selectGameHookWithTokenIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__selectGameHookWithTokenIdResponse() { tns__selectGameHookWithTokenIdResponse::soap_default(NULL); }
	virtual ~tns__selectGameHookWithTokenIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__selectGameThreadWithTokenDigest
#define SOAP_TYPE_Annot_tns__selectGameThreadWithTokenDigest (56)
/* tns:selectGameThreadWithTokenDigest */
class SOAP_CMAC tns__selectGameThreadWithTokenDigest
{
public:
	std::string *tokenDigest;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 56; } /* = unique id SOAP_TYPE_Annot_tns__selectGameThreadWithTokenDigest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__selectGameThreadWithTokenDigest() { tns__selectGameThreadWithTokenDigest::soap_default(NULL); }
	virtual ~tns__selectGameThreadWithTokenDigest() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__selectGameThreadWithTokenDigestResponse
#define SOAP_TYPE_Annot_tns__selectGameThreadWithTokenDigestResponse (57)
/* tns:selectGameThreadWithTokenDigestResponse */
class SOAP_CMAC tns__selectGameThreadWithTokenDigestResponse
{
public:
	tns__gameThread *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tns:gameThread */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 57; } /* = unique id SOAP_TYPE_Annot_tns__selectGameThreadWithTokenDigestResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__selectGameThreadWithTokenDigestResponse() { tns__selectGameThreadWithTokenDigestResponse::soap_default(NULL); }
	virtual ~tns__selectGameThreadWithTokenDigestResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__selectGameThreadWithTokenId
#define SOAP_TYPE_Annot_tns__selectGameThreadWithTokenId (58)
/* tns:selectGameThreadWithTokenId */
class SOAP_CMAC tns__selectGameThreadWithTokenId
{
public:
	LONG64 tokenId;	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 58; } /* = unique id SOAP_TYPE_Annot_tns__selectGameThreadWithTokenId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__selectGameThreadWithTokenId() { tns__selectGameThreadWithTokenId::soap_default(NULL); }
	virtual ~tns__selectGameThreadWithTokenId() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__selectGameThreadWithTokenIdResponse
#define SOAP_TYPE_Annot_tns__selectGameThreadWithTokenIdResponse (59)
/* tns:selectGameThreadWithTokenIdResponse */
class SOAP_CMAC tns__selectGameThreadWithTokenIdResponse
{
public:
	tns__gameThread *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tns:gameThread */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 59; } /* = unique id SOAP_TYPE_Annot_tns__selectGameThreadWithTokenIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__selectGameThreadWithTokenIdResponse() { tns__selectGameThreadWithTokenIdResponse::soap_default(NULL); }
	virtual ~tns__selectGameThreadWithTokenIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__selectMediaAliasesWithTokenId
#define SOAP_TYPE_Annot_tns__selectMediaAliasesWithTokenId (60)
/* tns:selectMediaAliasesWithTokenId */
class SOAP_CMAC tns__selectMediaAliasesWithTokenId
{
public:
	LONG64 tokenId;	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 60; } /* = unique id SOAP_TYPE_Annot_tns__selectMediaAliasesWithTokenId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__selectMediaAliasesWithTokenId() { tns__selectMediaAliasesWithTokenId::soap_default(NULL); }
	virtual ~tns__selectMediaAliasesWithTokenId() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__selectMediaAliasesWithTokenIdResponse
#define SOAP_TYPE_Annot_tns__selectMediaAliasesWithTokenIdResponse (61)
/* tns:selectMediaAliasesWithTokenIdResponse */
class SOAP_CMAC tns__selectMediaAliasesWithTokenIdResponse
{
public:
	std::vector<tns__mediaAlias * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tns:mediaAlias */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 61; } /* = unique id SOAP_TYPE_Annot_tns__selectMediaAliasesWithTokenIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__selectMediaAliasesWithTokenIdResponse() { tns__selectMediaAliasesWithTokenIdResponse::soap_default(NULL); }
	virtual ~tns__selectMediaAliasesWithTokenIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__selectMediaAnnotationsWithTokenId
#define SOAP_TYPE_Annot_tns__selectMediaAnnotationsWithTokenId (62)
/* tns:selectMediaAnnotationsWithTokenId */
class SOAP_CMAC tns__selectMediaAnnotationsWithTokenId
{
public:
	LONG64 tokenId;	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 62; } /* = unique id SOAP_TYPE_Annot_tns__selectMediaAnnotationsWithTokenId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__selectMediaAnnotationsWithTokenId() { tns__selectMediaAnnotationsWithTokenId::soap_default(NULL); }
	virtual ~tns__selectMediaAnnotationsWithTokenId() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__selectMediaAnnotationsWithTokenIdResponse
#define SOAP_TYPE_Annot_tns__selectMediaAnnotationsWithTokenIdResponse (63)
/* tns:selectMediaAnnotationsWithTokenIdResponse */
class SOAP_CMAC tns__selectMediaAnnotationsWithTokenIdResponse
{
public:
	std::vector<tns__mediaAnnotation * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tns:mediaAnnotation */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 63; } /* = unique id SOAP_TYPE_Annot_tns__selectMediaAnnotationsWithTokenIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__selectMediaAnnotationsWithTokenIdResponse() { tns__selectMediaAnnotationsWithTokenIdResponse::soap_default(NULL); }
	virtual ~tns__selectMediaAnnotationsWithTokenIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__selectMediaTokenIdWithDigest
#define SOAP_TYPE_Annot_tns__selectMediaTokenIdWithDigest (64)
/* tns:selectMediaTokenIdWithDigest */
class SOAP_CMAC tns__selectMediaTokenIdWithDigest
{
public:
	std::string *digest;	/* optional element of type xsd:string */
	int section;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 64; } /* = unique id SOAP_TYPE_Annot_tns__selectMediaTokenIdWithDigest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__selectMediaTokenIdWithDigest() { tns__selectMediaTokenIdWithDigest::soap_default(NULL); }
	virtual ~tns__selectMediaTokenIdWithDigest() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__selectMediaTokenIdWithDigestResponse
#define SOAP_TYPE_Annot_tns__selectMediaTokenIdWithDigestResponse (65)
/* tns:selectMediaTokenIdWithDigestResponse */
class SOAP_CMAC tns__selectMediaTokenIdWithDigestResponse
{
public:
	LONG64 return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 65; } /* = unique id SOAP_TYPE_Annot_tns__selectMediaTokenIdWithDigestResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__selectMediaTokenIdWithDigestResponse() { tns__selectMediaTokenIdWithDigestResponse::soap_default(NULL); }
	virtual ~tns__selectMediaTokenIdWithDigestResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__selectMediaTokenIdWithUrl
#define SOAP_TYPE_Annot_tns__selectMediaTokenIdWithUrl (66)
/* tns:selectMediaTokenIdWithUrl */
class SOAP_CMAC tns__selectMediaTokenIdWithUrl
{
public:
	std::string *url;	/* optional element of type xsd:string */
	int section;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 66; } /* = unique id SOAP_TYPE_Annot_tns__selectMediaTokenIdWithUrl */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__selectMediaTokenIdWithUrl() { tns__selectMediaTokenIdWithUrl::soap_default(NULL); }
	virtual ~tns__selectMediaTokenIdWithUrl() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__selectMediaTokenIdWithUrlResponse
#define SOAP_TYPE_Annot_tns__selectMediaTokenIdWithUrlResponse (67)
/* tns:selectMediaTokenIdWithUrlResponse */
class SOAP_CMAC tns__selectMediaTokenIdWithUrlResponse
{
public:
	LONG64 return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 67; } /* = unique id SOAP_TYPE_Annot_tns__selectMediaTokenIdWithUrlResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__selectMediaTokenIdWithUrlResponse() { tns__selectMediaTokenIdWithUrlResponse::soap_default(NULL); }
	virtual ~tns__selectMediaTokenIdWithUrlResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__selectMediaTokenWithDigest
#define SOAP_TYPE_Annot_tns__selectMediaTokenWithDigest (68)
/* tns:selectMediaTokenWithDigest */
class SOAP_CMAC tns__selectMediaTokenWithDigest
{
public:
	std::string *digest;	/* optional element of type xsd:string */
	int section;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 68; } /* = unique id SOAP_TYPE_Annot_tns__selectMediaTokenWithDigest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__selectMediaTokenWithDigest() { tns__selectMediaTokenWithDigest::soap_default(NULL); }
	virtual ~tns__selectMediaTokenWithDigest() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__selectMediaTokenWithDigestResponse
#define SOAP_TYPE_Annot_tns__selectMediaTokenWithDigestResponse (69)
/* tns:selectMediaTokenWithDigestResponse */
class SOAP_CMAC tns__selectMediaTokenWithDigestResponse
{
public:
	tns__mediaToken *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tns:mediaToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 69; } /* = unique id SOAP_TYPE_Annot_tns__selectMediaTokenWithDigestResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__selectMediaTokenWithDigestResponse() { tns__selectMediaTokenWithDigestResponse::soap_default(NULL); }
	virtual ~tns__selectMediaTokenWithDigestResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__selectMediaTokenWithId
#define SOAP_TYPE_Annot_tns__selectMediaTokenWithId (70)
/* tns:selectMediaTokenWithId */
class SOAP_CMAC tns__selectMediaTokenWithId
{
public:
	LONG64 id;	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 70; } /* = unique id SOAP_TYPE_Annot_tns__selectMediaTokenWithId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__selectMediaTokenWithId() { tns__selectMediaTokenWithId::soap_default(NULL); }
	virtual ~tns__selectMediaTokenWithId() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__selectMediaTokenWithIdResponse
#define SOAP_TYPE_Annot_tns__selectMediaTokenWithIdResponse (71)
/* tns:selectMediaTokenWithIdResponse */
class SOAP_CMAC tns__selectMediaTokenWithIdResponse
{
public:
	tns__mediaToken *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tns:mediaToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 71; } /* = unique id SOAP_TYPE_Annot_tns__selectMediaTokenWithIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__selectMediaTokenWithIdResponse() { tns__selectMediaTokenWithIdResponse::soap_default(NULL); }
	virtual ~tns__selectMediaTokenWithIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__selectRelatedMediaAliasesWithTokenId
#define SOAP_TYPE_Annot_tns__selectRelatedMediaAliasesWithTokenId (72)
/* tns:selectRelatedMediaAliasesWithTokenId */
class SOAP_CMAC tns__selectRelatedMediaAliasesWithTokenId
{
public:
	LONG64 tokenId;	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 72; } /* = unique id SOAP_TYPE_Annot_tns__selectRelatedMediaAliasesWithTokenId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__selectRelatedMediaAliasesWithTokenId() { tns__selectRelatedMediaAliasesWithTokenId::soap_default(NULL); }
	virtual ~tns__selectRelatedMediaAliasesWithTokenId() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__selectRelatedMediaAliasesWithTokenIdResponse
#define SOAP_TYPE_Annot_tns__selectRelatedMediaAliasesWithTokenIdResponse (73)
/* tns:selectRelatedMediaAliasesWithTokenIdResponse */
class SOAP_CMAC tns__selectRelatedMediaAliasesWithTokenIdResponse
{
public:
	std::vector<tns__mediaAlias * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tns:mediaAlias */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 73; } /* = unique id SOAP_TYPE_Annot_tns__selectRelatedMediaAliasesWithTokenIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__selectRelatedMediaAliasesWithTokenIdResponse() { tns__selectRelatedMediaAliasesWithTokenIdResponse::soap_default(NULL); }
	virtual ~tns__selectRelatedMediaAliasesWithTokenIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__selectRelatedMediaAnnotationsWithTokenId
#define SOAP_TYPE_Annot_tns__selectRelatedMediaAnnotationsWithTokenId (74)
/* tns:selectRelatedMediaAnnotationsWithTokenId */
class SOAP_CMAC tns__selectRelatedMediaAnnotationsWithTokenId
{
public:
	LONG64 tokenId;	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 74; } /* = unique id SOAP_TYPE_Annot_tns__selectRelatedMediaAnnotationsWithTokenId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__selectRelatedMediaAnnotationsWithTokenId() { tns__selectRelatedMediaAnnotationsWithTokenId::soap_default(NULL); }
	virtual ~tns__selectRelatedMediaAnnotationsWithTokenId() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__selectRelatedMediaAnnotationsWithTokenIdResponse
#define SOAP_TYPE_Annot_tns__selectRelatedMediaAnnotationsWithTokenIdResponse (75)
/* tns:selectRelatedMediaAnnotationsWithTokenIdResponse */
class SOAP_CMAC tns__selectRelatedMediaAnnotationsWithTokenIdResponse
{
public:
	std::vector<tns__mediaAnnotation * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tns:mediaAnnotation */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 75; } /* = unique id SOAP_TYPE_Annot_tns__selectRelatedMediaAnnotationsWithTokenIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__selectRelatedMediaAnnotationsWithTokenIdResponse() { tns__selectRelatedMediaAnnotationsWithTokenIdResponse::soap_default(NULL); }
	virtual ~tns__selectRelatedMediaAnnotationsWithTokenIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__setUserAnonymous
#define SOAP_TYPE_Annot_tns__setUserAnonymous (76)
/* tns:setUserAnonymous */
class SOAP_CMAC tns__setUserAnonymous
{
public:
	bool value;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 76; } /* = unique id SOAP_TYPE_Annot_tns__setUserAnonymous */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__setUserAnonymous() { tns__setUserAnonymous::soap_default(NULL); }
	virtual ~tns__setUserAnonymous() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__setUserAnonymousResponse
#define SOAP_TYPE_Annot_tns__setUserAnonymousResponse (77)
/* tns:setUserAnonymousResponse */
class SOAP_CMAC tns__setUserAnonymousResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 77; } /* = unique id SOAP_TYPE_Annot_tns__setUserAnonymousResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__setUserAnonymousResponse() { tns__setUserAnonymousResponse::soap_default(NULL); }
	virtual ~tns__setUserAnonymousResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__setUserLanguage
#define SOAP_TYPE_Annot_tns__setUserLanguage (78)
/* tns:setUserLanguage */
class SOAP_CMAC tns__setUserLanguage
{
public:
	int value;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 78; } /* = unique id SOAP_TYPE_Annot_tns__setUserLanguage */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__setUserLanguage() { tns__setUserLanguage::soap_default(NULL); }
	virtual ~tns__setUserLanguage() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__setUserLanguageResponse
#define SOAP_TYPE_Annot_tns__setUserLanguageResponse (79)
/* tns:setUserLanguageResponse */
class SOAP_CMAC tns__setUserLanguageResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 79; } /* = unique id SOAP_TYPE_Annot_tns__setUserLanguageResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__setUserLanguageResponse() { tns__setUserLanguageResponse::soap_default(NULL); }
	virtual ~tns__setUserLanguageResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__submitGameHook
#define SOAP_TYPE_Annot_tns__submitGameHook (80)
/* tns:submitGameHook */
class SOAP_CMAC tns__submitGameHook
{
public:
	tns__gameHook *hook;	/* optional element of type tns:gameHook */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 80; } /* = unique id SOAP_TYPE_Annot_tns__submitGameHook */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__submitGameHook() { tns__submitGameHook::soap_default(NULL); }
	virtual ~tns__submitGameHook() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__submitGameHookResponse
#define SOAP_TYPE_Annot_tns__submitGameHookResponse (81)
/* tns:submitGameHookResponse */
class SOAP_CMAC tns__submitGameHookResponse
{
public:
	LONG64 return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 81; } /* = unique id SOAP_TYPE_Annot_tns__submitGameHookResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__submitGameHookResponse() { tns__submitGameHookResponse::soap_default(NULL); }
	virtual ~tns__submitGameHookResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__submitGameThread
#define SOAP_TYPE_Annot_tns__submitGameThread (82)
/* tns:submitGameThread */
class SOAP_CMAC tns__submitGameThread
{
public:
	tns__gameThread *thread;	/* optional element of type tns:gameThread */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 82; } /* = unique id SOAP_TYPE_Annot_tns__submitGameThread */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__submitGameThread() { tns__submitGameThread::soap_default(NULL); }
	virtual ~tns__submitGameThread() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__submitGameThreadResponse
#define SOAP_TYPE_Annot_tns__submitGameThreadResponse (83)
/* tns:submitGameThreadResponse */
class SOAP_CMAC tns__submitGameThreadResponse
{
public:
	LONG64 return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 83; } /* = unique id SOAP_TYPE_Annot_tns__submitGameThreadResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__submitGameThreadResponse() { tns__submitGameThreadResponse::soap_default(NULL); }
	virtual ~tns__submitGameThreadResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__submitMediaAlias
#define SOAP_TYPE_Annot_tns__submitMediaAlias (84)
/* tns:submitMediaAlias */
class SOAP_CMAC tns__submitMediaAlias
{
public:
	tns__mediaAlias *alias;	/* optional element of type tns:mediaAlias */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 84; } /* = unique id SOAP_TYPE_Annot_tns__submitMediaAlias */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__submitMediaAlias() { tns__submitMediaAlias::soap_default(NULL); }
	virtual ~tns__submitMediaAlias() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__submitMediaAliasResponse
#define SOAP_TYPE_Annot_tns__submitMediaAliasResponse (85)
/* tns:submitMediaAliasResponse */
class SOAP_CMAC tns__submitMediaAliasResponse
{
public:
	LONG64 return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 85; } /* = unique id SOAP_TYPE_Annot_tns__submitMediaAliasResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__submitMediaAliasResponse() { tns__submitMediaAliasResponse::soap_default(NULL); }
	virtual ~tns__submitMediaAliasResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__submitMediaAliasTextAndTokenDigest
#define SOAP_TYPE_Annot_tns__submitMediaAliasTextAndTokenDigest (86)
/* tns:submitMediaAliasTextAndTokenDigest */
class SOAP_CMAC tns__submitMediaAliasTextAndTokenDigest
{
public:
	std::string *text;	/* optional element of type xsd:string */
	int type;	/* required element of type xsd:int */
	std::string *tokenDigest;	/* optional element of type xsd:string */
	int tokenSection;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 86; } /* = unique id SOAP_TYPE_Annot_tns__submitMediaAliasTextAndTokenDigest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__submitMediaAliasTextAndTokenDigest() { tns__submitMediaAliasTextAndTokenDigest::soap_default(NULL); }
	virtual ~tns__submitMediaAliasTextAndTokenDigest() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__submitMediaAliasTextAndTokenDigestResponse
#define SOAP_TYPE_Annot_tns__submitMediaAliasTextAndTokenDigestResponse (87)
/* tns:submitMediaAliasTextAndTokenDigestResponse */
class SOAP_CMAC tns__submitMediaAliasTextAndTokenDigestResponse
{
public:
	LONG64 return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 87; } /* = unique id SOAP_TYPE_Annot_tns__submitMediaAliasTextAndTokenDigestResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__submitMediaAliasTextAndTokenDigestResponse() { tns__submitMediaAliasTextAndTokenDigestResponse::soap_default(NULL); }
	virtual ~tns__submitMediaAliasTextAndTokenDigestResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__submitMediaAliasTextWithTokenId
#define SOAP_TYPE_Annot_tns__submitMediaAliasTextWithTokenId (88)
/* tns:submitMediaAliasTextWithTokenId */
class SOAP_CMAC tns__submitMediaAliasTextWithTokenId
{
public:
	std::string *text;	/* optional element of type xsd:string */
	int type;	/* required element of type xsd:int */
	LONG64 tokenId;	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 88; } /* = unique id SOAP_TYPE_Annot_tns__submitMediaAliasTextWithTokenId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__submitMediaAliasTextWithTokenId() { tns__submitMediaAliasTextWithTokenId::soap_default(NULL); }
	virtual ~tns__submitMediaAliasTextWithTokenId() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__submitMediaAliasTextWithTokenIdResponse
#define SOAP_TYPE_Annot_tns__submitMediaAliasTextWithTokenIdResponse (89)
/* tns:submitMediaAliasTextWithTokenIdResponse */
class SOAP_CMAC tns__submitMediaAliasTextWithTokenIdResponse
{
public:
	LONG64 return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 89; } /* = unique id SOAP_TYPE_Annot_tns__submitMediaAliasTextWithTokenIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__submitMediaAliasTextWithTokenIdResponse() { tns__submitMediaAliasTextWithTokenIdResponse::soap_default(NULL); }
	virtual ~tns__submitMediaAliasTextWithTokenIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__submitMediaAnnotation
#define SOAP_TYPE_Annot_tns__submitMediaAnnotation (90)
/* tns:submitMediaAnnotation */
class SOAP_CMAC tns__submitMediaAnnotation
{
public:
	tns__mediaAnnotation *annot;	/* optional element of type tns:mediaAnnotation */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 90; } /* = unique id SOAP_TYPE_Annot_tns__submitMediaAnnotation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__submitMediaAnnotation() { tns__submitMediaAnnotation::soap_default(NULL); }
	virtual ~tns__submitMediaAnnotation() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__submitMediaAnnotationResponse
#define SOAP_TYPE_Annot_tns__submitMediaAnnotationResponse (91)
/* tns:submitMediaAnnotationResponse */
class SOAP_CMAC tns__submitMediaAnnotationResponse
{
public:
	LONG64 return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 91; } /* = unique id SOAP_TYPE_Annot_tns__submitMediaAnnotationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__submitMediaAnnotationResponse() { tns__submitMediaAnnotationResponse::soap_default(NULL); }
	virtual ~tns__submitMediaAnnotationResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__submitMediaAnnotationTextAndTokenDigest
#define SOAP_TYPE_Annot_tns__submitMediaAnnotationTextAndTokenDigest (92)
/* tns:submitMediaAnnotationTextAndTokenDigest */
class SOAP_CMAC tns__submitMediaAnnotationTextAndTokenDigest
{
public:
	std::string *text;	/* optional element of type xsd:string */
	LONG64 pos;	/* required element of type xsd:long */
	int posType;	/* required element of type xsd:int */
	std::string *tokenDigest;	/* optional element of type xsd:string */
	int tokenSection;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 92; } /* = unique id SOAP_TYPE_Annot_tns__submitMediaAnnotationTextAndTokenDigest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__submitMediaAnnotationTextAndTokenDigest() { tns__submitMediaAnnotationTextAndTokenDigest::soap_default(NULL); }
	virtual ~tns__submitMediaAnnotationTextAndTokenDigest() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__submitMediaAnnotationTextAndTokenDigestResponse
#define SOAP_TYPE_Annot_tns__submitMediaAnnotationTextAndTokenDigestResponse (93)
/* tns:submitMediaAnnotationTextAndTokenDigestResponse */
class SOAP_CMAC tns__submitMediaAnnotationTextAndTokenDigestResponse
{
public:
	LONG64 return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 93; } /* = unique id SOAP_TYPE_Annot_tns__submitMediaAnnotationTextAndTokenDigestResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__submitMediaAnnotationTextAndTokenDigestResponse() { tns__submitMediaAnnotationTextAndTokenDigestResponse::soap_default(NULL); }
	virtual ~tns__submitMediaAnnotationTextAndTokenDigestResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__submitMediaAnnotationTextWithTokenId
#define SOAP_TYPE_Annot_tns__submitMediaAnnotationTextWithTokenId (94)
/* tns:submitMediaAnnotationTextWithTokenId */
class SOAP_CMAC tns__submitMediaAnnotationTextWithTokenId
{
public:
	std::string *text;	/* optional element of type xsd:string */
	LONG64 pos;	/* required element of type xsd:long */
	int posType;	/* required element of type xsd:int */
	LONG64 tokenId;	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 94; } /* = unique id SOAP_TYPE_Annot_tns__submitMediaAnnotationTextWithTokenId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__submitMediaAnnotationTextWithTokenId() { tns__submitMediaAnnotationTextWithTokenId::soap_default(NULL); }
	virtual ~tns__submitMediaAnnotationTextWithTokenId() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__submitMediaAnnotationTextWithTokenIdResponse
#define SOAP_TYPE_Annot_tns__submitMediaAnnotationTextWithTokenIdResponse (95)
/* tns:submitMediaAnnotationTextWithTokenIdResponse */
class SOAP_CMAC tns__submitMediaAnnotationTextWithTokenIdResponse
{
public:
	LONG64 return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 95; } /* = unique id SOAP_TYPE_Annot_tns__submitMediaAnnotationTextWithTokenIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__submitMediaAnnotationTextWithTokenIdResponse() { tns__submitMediaAnnotationTextWithTokenIdResponse::soap_default(NULL); }
	virtual ~tns__submitMediaAnnotationTextWithTokenIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__submitMediaToken
#define SOAP_TYPE_Annot_tns__submitMediaToken (96)
/* tns:submitMediaToken */
class SOAP_CMAC tns__submitMediaToken
{
public:
	tns__mediaToken *token;	/* optional element of type tns:mediaToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 96; } /* = unique id SOAP_TYPE_Annot_tns__submitMediaToken */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__submitMediaToken() { tns__submitMediaToken::soap_default(NULL); }
	virtual ~tns__submitMediaToken() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__submitMediaTokenResponse
#define SOAP_TYPE_Annot_tns__submitMediaTokenResponse (97)
/* tns:submitMediaTokenResponse */
class SOAP_CMAC tns__submitMediaTokenResponse
{
public:
	LONG64 return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 97; } /* = unique id SOAP_TYPE_Annot_tns__submitMediaTokenResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__submitMediaTokenResponse() { tns__submitMediaTokenResponse::soap_default(NULL); }
	virtual ~tns__submitMediaTokenResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__submitMediaTokenDigest
#define SOAP_TYPE_Annot_tns__submitMediaTokenDigest (98)
/* tns:submitMediaTokenDigest */
class SOAP_CMAC tns__submitMediaTokenDigest
{
public:
	std::string *digest;	/* optional element of type xsd:string */
	int section;	/* required element of type xsd:int */
	int type;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 98; } /* = unique id SOAP_TYPE_Annot_tns__submitMediaTokenDigest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__submitMediaTokenDigest() { tns__submitMediaTokenDigest::soap_default(NULL); }
	virtual ~tns__submitMediaTokenDigest() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__submitMediaTokenDigestResponse
#define SOAP_TYPE_Annot_tns__submitMediaTokenDigestResponse (99)
/* tns:submitMediaTokenDigestResponse */
class SOAP_CMAC tns__submitMediaTokenDigestResponse
{
public:
	LONG64 return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 99; } /* = unique id SOAP_TYPE_Annot_tns__submitMediaTokenDigestResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__submitMediaTokenDigestResponse() { tns__submitMediaTokenDigestResponse::soap_default(NULL); }
	virtual ~tns__submitMediaTokenDigestResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__submitMediaTokenUrl
#define SOAP_TYPE_Annot_tns__submitMediaTokenUrl (100)
/* tns:submitMediaTokenUrl */
class SOAP_CMAC tns__submitMediaTokenUrl
{
public:
	std::string *url;	/* optional element of type xsd:string */
	int section;	/* required element of type xsd:int */
	int type;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 100; } /* = unique id SOAP_TYPE_Annot_tns__submitMediaTokenUrl */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__submitMediaTokenUrl() { tns__submitMediaTokenUrl::soap_default(NULL); }
	virtual ~tns__submitMediaTokenUrl() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__submitMediaTokenUrlResponse
#define SOAP_TYPE_Annot_tns__submitMediaTokenUrlResponse (101)
/* tns:submitMediaTokenUrlResponse */
class SOAP_CMAC tns__submitMediaTokenUrlResponse
{
public:
	LONG64 return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 101; } /* = unique id SOAP_TYPE_Annot_tns__submitMediaTokenUrlResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__submitMediaTokenUrlResponse() { tns__submitMediaTokenUrlResponse::soap_default(NULL); }
	virtual ~tns__submitMediaTokenUrlResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__updateGameHookTextWithId
#define SOAP_TYPE_Annot_tns__updateGameHookTextWithId (102)
/* tns:updateGameHookTextWithId */
class SOAP_CMAC tns__updateGameHookTextWithId
{
public:
	std::string *text;	/* optional element of type xsd:string */
	LONG64 id;	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 102; } /* = unique id SOAP_TYPE_Annot_tns__updateGameHookTextWithId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__updateGameHookTextWithId() { tns__updateGameHookTextWithId::soap_default(NULL); }
	virtual ~tns__updateGameHookTextWithId() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__updateGameHookTextWithIdResponse
#define SOAP_TYPE_Annot_tns__updateGameHookTextWithIdResponse (103)
/* tns:updateGameHookTextWithIdResponse */
class SOAP_CMAC tns__updateGameHookTextWithIdResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 103; } /* = unique id SOAP_TYPE_Annot_tns__updateGameHookTextWithIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__updateGameHookTextWithIdResponse() { tns__updateGameHookTextWithIdResponse::soap_default(NULL); }
	virtual ~tns__updateGameHookTextWithIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__updateGameThread
#define SOAP_TYPE_Annot_tns__updateGameThread (104)
/* tns:updateGameThread */
class SOAP_CMAC tns__updateGameThread
{
public:
	tns__gameThread *thread;	/* optional element of type tns:gameThread */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 104; } /* = unique id SOAP_TYPE_Annot_tns__updateGameThread */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__updateGameThread() { tns__updateGameThread::soap_default(NULL); }
	virtual ~tns__updateGameThread() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__updateGameThreadResponse
#define SOAP_TYPE_Annot_tns__updateGameThreadResponse (105)
/* tns:updateGameThreadResponse */
class SOAP_CMAC tns__updateGameThreadResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 105; } /* = unique id SOAP_TYPE_Annot_tns__updateGameThreadResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__updateGameThreadResponse() { tns__updateGameThreadResponse::soap_default(NULL); }
	virtual ~tns__updateGameThreadResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__updateMediaAnnotationLanguageWithId
#define SOAP_TYPE_Annot_tns__updateMediaAnnotationLanguageWithId (106)
/* tns:updateMediaAnnotationLanguageWithId */
class SOAP_CMAC tns__updateMediaAnnotationLanguageWithId
{
public:
	int language;	/* required element of type xsd:int */
	LONG64 id;	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 106; } /* = unique id SOAP_TYPE_Annot_tns__updateMediaAnnotationLanguageWithId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__updateMediaAnnotationLanguageWithId() { tns__updateMediaAnnotationLanguageWithId::soap_default(NULL); }
	virtual ~tns__updateMediaAnnotationLanguageWithId() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__updateMediaAnnotationLanguageWithIdResponse
#define SOAP_TYPE_Annot_tns__updateMediaAnnotationLanguageWithIdResponse (107)
/* tns:updateMediaAnnotationLanguageWithIdResponse */
class SOAP_CMAC tns__updateMediaAnnotationLanguageWithIdResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 107; } /* = unique id SOAP_TYPE_Annot_tns__updateMediaAnnotationLanguageWithIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__updateMediaAnnotationLanguageWithIdResponse() { tns__updateMediaAnnotationLanguageWithIdResponse::soap_default(NULL); }
	virtual ~tns__updateMediaAnnotationLanguageWithIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__updateMediaAnnotationTextWithId
#define SOAP_TYPE_Annot_tns__updateMediaAnnotationTextWithId (108)
/* tns:updateMediaAnnotationTextWithId */
class SOAP_CMAC tns__updateMediaAnnotationTextWithId
{
public:
	std::string *text;	/* optional element of type xsd:string */
	LONG64 id;	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 108; } /* = unique id SOAP_TYPE_Annot_tns__updateMediaAnnotationTextWithId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__updateMediaAnnotationTextWithId() { tns__updateMediaAnnotationTextWithId::soap_default(NULL); }
	virtual ~tns__updateMediaAnnotationTextWithId() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__updateMediaAnnotationTextWithIdResponse
#define SOAP_TYPE_Annot_tns__updateMediaAnnotationTextWithIdResponse (109)
/* tns:updateMediaAnnotationTextWithIdResponse */
class SOAP_CMAC tns__updateMediaAnnotationTextWithIdResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 109; } /* = unique id SOAP_TYPE_Annot_tns__updateMediaAnnotationTextWithIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__updateMediaAnnotationTextWithIdResponse() { tns__updateMediaAnnotationTextWithIdResponse::soap_default(NULL); }
	virtual ~tns__updateMediaAnnotationTextWithIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__updateMediaAnnotationUserIdWithId
#define SOAP_TYPE_Annot_tns__updateMediaAnnotationUserIdWithId (110)
/* tns:updateMediaAnnotationUserIdWithId */
class SOAP_CMAC tns__updateMediaAnnotationUserIdWithId
{
public:
	LONG64 userId;	/* required element of type xsd:long */
	LONG64 id;	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 110; } /* = unique id SOAP_TYPE_Annot_tns__updateMediaAnnotationUserIdWithId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__updateMediaAnnotationUserIdWithId() { tns__updateMediaAnnotationUserIdWithId::soap_default(NULL); }
	virtual ~tns__updateMediaAnnotationUserIdWithId() { }
};
#endif

#ifndef SOAP_TYPE_Annot_tns__updateMediaAnnotationUserIdWithIdResponse
#define SOAP_TYPE_Annot_tns__updateMediaAnnotationUserIdWithIdResponse (111)
/* tns:updateMediaAnnotationUserIdWithIdResponse */
class SOAP_CMAC tns__updateMediaAnnotationUserIdWithIdResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 111; } /* = unique id SOAP_TYPE_Annot_tns__updateMediaAnnotationUserIdWithIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__updateMediaAnnotationUserIdWithIdResponse() { tns__updateMediaAnnotationUserIdWithIdResponse::soap_default(NULL); }
	virtual ~tns__updateMediaAnnotationUserIdWithIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_Annot___tns__blessMediaAliasWithId
#define SOAP_TYPE_Annot___tns__blessMediaAliasWithId (128)
/* Operation wrapper: */
struct __tns__blessMediaAliasWithId
{
public:
	tns__blessMediaAliasWithId *tns__blessMediaAliasWithId_;	/* optional element of type tns:blessMediaAliasWithId */
public:
	int soap_type() const { return 128; } /* = unique id SOAP_TYPE_Annot___tns__blessMediaAliasWithId */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__blessMediaAnnotationWithId
#define SOAP_TYPE_Annot___tns__blessMediaAnnotationWithId (132)
/* Operation wrapper: */
struct __tns__blessMediaAnnotationWithId
{
public:
	tns__blessMediaAnnotationWithId *tns__blessMediaAnnotationWithId_;	/* optional element of type tns:blessMediaAnnotationWithId */
public:
	int soap_type() const { return 132; } /* = unique id SOAP_TYPE_Annot___tns__blessMediaAnnotationWithId */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__blessMediaTokenWithId
#define SOAP_TYPE_Annot___tns__blessMediaTokenWithId (136)
/* Operation wrapper: */
struct __tns__blessMediaTokenWithId
{
public:
	tns__blessMediaTokenWithId *tns__blessMediaTokenWithId_;	/* optional element of type tns:blessMediaTokenWithId */
public:
	int soap_type() const { return 136; } /* = unique id SOAP_TYPE_Annot___tns__blessMediaTokenWithId */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__blessUserWithId
#define SOAP_TYPE_Annot___tns__blessUserWithId (140)
/* Operation wrapper: */
struct __tns__blessUserWithId
{
public:
	tns__blessUserWithId *tns__blessUserWithId_;	/* optional element of type tns:blessUserWithId */
public:
	int soap_type() const { return 140; } /* = unique id SOAP_TYPE_Annot___tns__blessUserWithId */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__blockMediaAliasWithId
#define SOAP_TYPE_Annot___tns__blockMediaAliasWithId (144)
/* Operation wrapper: */
struct __tns__blockMediaAliasWithId
{
public:
	tns__blockMediaAliasWithId *tns__blockMediaAliasWithId_;	/* optional element of type tns:blockMediaAliasWithId */
public:
	int soap_type() const { return 144; } /* = unique id SOAP_TYPE_Annot___tns__blockMediaAliasWithId */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__blockMediaAnnotationWithId
#define SOAP_TYPE_Annot___tns__blockMediaAnnotationWithId (148)
/* Operation wrapper: */
struct __tns__blockMediaAnnotationWithId
{
public:
	tns__blockMediaAnnotationWithId *tns__blockMediaAnnotationWithId_;	/* optional element of type tns:blockMediaAnnotationWithId */
public:
	int soap_type() const { return 148; } /* = unique id SOAP_TYPE_Annot___tns__blockMediaAnnotationWithId */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__blockUserWithId
#define SOAP_TYPE_Annot___tns__blockUserWithId (152)
/* Operation wrapper: */
struct __tns__blockUserWithId
{
public:
	tns__blockUserWithId *tns__blockUserWithId_;	/* optional element of type tns:blockUserWithId */
public:
	int soap_type() const { return 152; } /* = unique id SOAP_TYPE_Annot___tns__blockUserWithId */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__chat
#define SOAP_TYPE_Annot___tns__chat (156)
/* Operation wrapper: */
struct __tns__chat
{
public:
	tns__chat *tns__chat_;	/* optional element of type tns:chat */
public:
	int soap_type() const { return 156; } /* = unique id SOAP_TYPE_Annot___tns__chat */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__curseMediaAliasWithId
#define SOAP_TYPE_Annot___tns__curseMediaAliasWithId (160)
/* Operation wrapper: */
struct __tns__curseMediaAliasWithId
{
public:
	tns__curseMediaAliasWithId *tns__curseMediaAliasWithId_;	/* optional element of type tns:curseMediaAliasWithId */
public:
	int soap_type() const { return 160; } /* = unique id SOAP_TYPE_Annot___tns__curseMediaAliasWithId */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__curseMediaAnnotationWithId
#define SOAP_TYPE_Annot___tns__curseMediaAnnotationWithId (164)
/* Operation wrapper: */
struct __tns__curseMediaAnnotationWithId
{
public:
	tns__curseMediaAnnotationWithId *tns__curseMediaAnnotationWithId_;	/* optional element of type tns:curseMediaAnnotationWithId */
public:
	int soap_type() const { return 164; } /* = unique id SOAP_TYPE_Annot___tns__curseMediaAnnotationWithId */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__curseMediaTokenWithId
#define SOAP_TYPE_Annot___tns__curseMediaTokenWithId (168)
/* Operation wrapper: */
struct __tns__curseMediaTokenWithId
{
public:
	tns__curseMediaTokenWithId *tns__curseMediaTokenWithId_;	/* optional element of type tns:curseMediaTokenWithId */
public:
	int soap_type() const { return 168; } /* = unique id SOAP_TYPE_Annot___tns__curseMediaTokenWithId */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__curseUserWithId
#define SOAP_TYPE_Annot___tns__curseUserWithId (172)
/* Operation wrapper: */
struct __tns__curseUserWithId
{
public:
	tns__curseUserWithId *tns__curseUserWithId_;	/* optional element of type tns:curseUserWithId */
public:
	int soap_type() const { return 172; } /* = unique id SOAP_TYPE_Annot___tns__curseUserWithId */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__deleteMediaAliasWithId
#define SOAP_TYPE_Annot___tns__deleteMediaAliasWithId (176)
/* Operation wrapper: */
struct __tns__deleteMediaAliasWithId
{
public:
	tns__deleteMediaAliasWithId *tns__deleteMediaAliasWithId_;	/* optional element of type tns:deleteMediaAliasWithId */
public:
	int soap_type() const { return 176; } /* = unique id SOAP_TYPE_Annot___tns__deleteMediaAliasWithId */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__deleteMediaAnnotationWithId
#define SOAP_TYPE_Annot___tns__deleteMediaAnnotationWithId (180)
/* Operation wrapper: */
struct __tns__deleteMediaAnnotationWithId
{
public:
	tns__deleteMediaAnnotationWithId *tns__deleteMediaAnnotationWithId_;	/* optional element of type tns:deleteMediaAnnotationWithId */
public:
	int soap_type() const { return 180; } /* = unique id SOAP_TYPE_Annot___tns__deleteMediaAnnotationWithId */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__getUser
#define SOAP_TYPE_Annot___tns__getUser (184)
/* Operation wrapper: */
struct __tns__getUser
{
public:
	tns__getUser *tns__getUser_;	/* optional element of type tns:getUser */
public:
	int soap_type() const { return 184; } /* = unique id SOAP_TYPE_Annot___tns__getUser */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__isAuthorized
#define SOAP_TYPE_Annot___tns__isAuthorized (188)
/* Operation wrapper: */
struct __tns__isAuthorized
{
public:
	tns__isAuthorized *tns__isAuthorized_;	/* optional element of type tns:isAuthorized */
public:
	int soap_type() const { return 188; } /* = unique id SOAP_TYPE_Annot___tns__isAuthorized */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__isConnected
#define SOAP_TYPE_Annot___tns__isConnected (192)
/* Operation wrapper: */
struct __tns__isConnected
{
public:
	tns__isConnected *tns__isConnected_;	/* optional element of type tns:isConnected */
public:
	int soap_type() const { return 192; } /* = unique id SOAP_TYPE_Annot___tns__isConnected */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__isLatestApp
#define SOAP_TYPE_Annot___tns__isLatestApp (196)
/* Operation wrapper: */
struct __tns__isLatestApp
{
public:
	tns__isLatestApp *tns__isLatestApp_;	/* optional element of type tns:isLatestApp */
public:
	int soap_type() const { return 196; } /* = unique id SOAP_TYPE_Annot___tns__isLatestApp */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__login
#define SOAP_TYPE_Annot___tns__login (200)
/* Operation wrapper: */
struct __tns__login
{
public:
	tns__login *tns__login_;	/* optional element of type tns:login */
public:
	int soap_type() const { return 200; } /* = unique id SOAP_TYPE_Annot___tns__login */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__selectGameHookWithTokenDigest
#define SOAP_TYPE_Annot___tns__selectGameHookWithTokenDigest (204)
/* Operation wrapper: */
struct __tns__selectGameHookWithTokenDigest
{
public:
	tns__selectGameHookWithTokenDigest *tns__selectGameHookWithTokenDigest_;	/* optional element of type tns:selectGameHookWithTokenDigest */
public:
	int soap_type() const { return 204; } /* = unique id SOAP_TYPE_Annot___tns__selectGameHookWithTokenDigest */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__selectGameHookWithTokenId
#define SOAP_TYPE_Annot___tns__selectGameHookWithTokenId (208)
/* Operation wrapper: */
struct __tns__selectGameHookWithTokenId
{
public:
	tns__selectGameHookWithTokenId *tns__selectGameHookWithTokenId_;	/* optional element of type tns:selectGameHookWithTokenId */
public:
	int soap_type() const { return 208; } /* = unique id SOAP_TYPE_Annot___tns__selectGameHookWithTokenId */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__selectGameThreadWithTokenDigest
#define SOAP_TYPE_Annot___tns__selectGameThreadWithTokenDigest (212)
/* Operation wrapper: */
struct __tns__selectGameThreadWithTokenDigest
{
public:
	tns__selectGameThreadWithTokenDigest *tns__selectGameThreadWithTokenDigest_;	/* optional element of type tns:selectGameThreadWithTokenDigest */
public:
	int soap_type() const { return 212; } /* = unique id SOAP_TYPE_Annot___tns__selectGameThreadWithTokenDigest */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__selectGameThreadWithTokenId
#define SOAP_TYPE_Annot___tns__selectGameThreadWithTokenId (216)
/* Operation wrapper: */
struct __tns__selectGameThreadWithTokenId
{
public:
	tns__selectGameThreadWithTokenId *tns__selectGameThreadWithTokenId_;	/* optional element of type tns:selectGameThreadWithTokenId */
public:
	int soap_type() const { return 216; } /* = unique id SOAP_TYPE_Annot___tns__selectGameThreadWithTokenId */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__selectMediaAliasesWithTokenId
#define SOAP_TYPE_Annot___tns__selectMediaAliasesWithTokenId (220)
/* Operation wrapper: */
struct __tns__selectMediaAliasesWithTokenId
{
public:
	tns__selectMediaAliasesWithTokenId *tns__selectMediaAliasesWithTokenId_;	/* optional element of type tns:selectMediaAliasesWithTokenId */
public:
	int soap_type() const { return 220; } /* = unique id SOAP_TYPE_Annot___tns__selectMediaAliasesWithTokenId */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__selectMediaAnnotationsWithTokenId
#define SOAP_TYPE_Annot___tns__selectMediaAnnotationsWithTokenId (224)
/* Operation wrapper: */
struct __tns__selectMediaAnnotationsWithTokenId
{
public:
	tns__selectMediaAnnotationsWithTokenId *tns__selectMediaAnnotationsWithTokenId_;	/* optional element of type tns:selectMediaAnnotationsWithTokenId */
public:
	int soap_type() const { return 224; } /* = unique id SOAP_TYPE_Annot___tns__selectMediaAnnotationsWithTokenId */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__selectMediaTokenIdWithDigest
#define SOAP_TYPE_Annot___tns__selectMediaTokenIdWithDigest (228)
/* Operation wrapper: */
struct __tns__selectMediaTokenIdWithDigest
{
public:
	tns__selectMediaTokenIdWithDigest *tns__selectMediaTokenIdWithDigest_;	/* optional element of type tns:selectMediaTokenIdWithDigest */
public:
	int soap_type() const { return 228; } /* = unique id SOAP_TYPE_Annot___tns__selectMediaTokenIdWithDigest */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__selectMediaTokenIdWithUrl
#define SOAP_TYPE_Annot___tns__selectMediaTokenIdWithUrl (232)
/* Operation wrapper: */
struct __tns__selectMediaTokenIdWithUrl
{
public:
	tns__selectMediaTokenIdWithUrl *tns__selectMediaTokenIdWithUrl_;	/* optional element of type tns:selectMediaTokenIdWithUrl */
public:
	int soap_type() const { return 232; } /* = unique id SOAP_TYPE_Annot___tns__selectMediaTokenIdWithUrl */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__selectMediaTokenWithDigest
#define SOAP_TYPE_Annot___tns__selectMediaTokenWithDigest (236)
/* Operation wrapper: */
struct __tns__selectMediaTokenWithDigest
{
public:
	tns__selectMediaTokenWithDigest *tns__selectMediaTokenWithDigest_;	/* optional element of type tns:selectMediaTokenWithDigest */
public:
	int soap_type() const { return 236; } /* = unique id SOAP_TYPE_Annot___tns__selectMediaTokenWithDigest */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__selectMediaTokenWithId
#define SOAP_TYPE_Annot___tns__selectMediaTokenWithId (240)
/* Operation wrapper: */
struct __tns__selectMediaTokenWithId
{
public:
	tns__selectMediaTokenWithId *tns__selectMediaTokenWithId_;	/* optional element of type tns:selectMediaTokenWithId */
public:
	int soap_type() const { return 240; } /* = unique id SOAP_TYPE_Annot___tns__selectMediaTokenWithId */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__selectRelatedMediaAliasesWithTokenId
#define SOAP_TYPE_Annot___tns__selectRelatedMediaAliasesWithTokenId (244)
/* Operation wrapper: */
struct __tns__selectRelatedMediaAliasesWithTokenId
{
public:
	tns__selectRelatedMediaAliasesWithTokenId *tns__selectRelatedMediaAliasesWithTokenId_;	/* optional element of type tns:selectRelatedMediaAliasesWithTokenId */
public:
	int soap_type() const { return 244; } /* = unique id SOAP_TYPE_Annot___tns__selectRelatedMediaAliasesWithTokenId */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__selectRelatedMediaAnnotationsWithTokenId
#define SOAP_TYPE_Annot___tns__selectRelatedMediaAnnotationsWithTokenId (248)
/* Operation wrapper: */
struct __tns__selectRelatedMediaAnnotationsWithTokenId
{
public:
	tns__selectRelatedMediaAnnotationsWithTokenId *tns__selectRelatedMediaAnnotationsWithTokenId_;	/* optional element of type tns:selectRelatedMediaAnnotationsWithTokenId */
public:
	int soap_type() const { return 248; } /* = unique id SOAP_TYPE_Annot___tns__selectRelatedMediaAnnotationsWithTokenId */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__setUserAnonymous
#define SOAP_TYPE_Annot___tns__setUserAnonymous (252)
/* Operation wrapper: */
struct __tns__setUserAnonymous
{
public:
	tns__setUserAnonymous *tns__setUserAnonymous_;	/* optional element of type tns:setUserAnonymous */
public:
	int soap_type() const { return 252; } /* = unique id SOAP_TYPE_Annot___tns__setUserAnonymous */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__setUserLanguage
#define SOAP_TYPE_Annot___tns__setUserLanguage (256)
/* Operation wrapper: */
struct __tns__setUserLanguage
{
public:
	tns__setUserLanguage *tns__setUserLanguage_;	/* optional element of type tns:setUserLanguage */
public:
	int soap_type() const { return 256; } /* = unique id SOAP_TYPE_Annot___tns__setUserLanguage */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__submitGameHook
#define SOAP_TYPE_Annot___tns__submitGameHook (260)
/* Operation wrapper: */
struct __tns__submitGameHook
{
public:
	tns__submitGameHook *tns__submitGameHook_;	/* optional element of type tns:submitGameHook */
public:
	int soap_type() const { return 260; } /* = unique id SOAP_TYPE_Annot___tns__submitGameHook */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__submitGameThread
#define SOAP_TYPE_Annot___tns__submitGameThread (264)
/* Operation wrapper: */
struct __tns__submitGameThread
{
public:
	tns__submitGameThread *tns__submitGameThread_;	/* optional element of type tns:submitGameThread */
public:
	int soap_type() const { return 264; } /* = unique id SOAP_TYPE_Annot___tns__submitGameThread */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__submitMediaAlias
#define SOAP_TYPE_Annot___tns__submitMediaAlias (268)
/* Operation wrapper: */
struct __tns__submitMediaAlias
{
public:
	tns__submitMediaAlias *tns__submitMediaAlias_;	/* optional element of type tns:submitMediaAlias */
public:
	int soap_type() const { return 268; } /* = unique id SOAP_TYPE_Annot___tns__submitMediaAlias */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__submitMediaAliasTextAndTokenDigest
#define SOAP_TYPE_Annot___tns__submitMediaAliasTextAndTokenDigest (272)
/* Operation wrapper: */
struct __tns__submitMediaAliasTextAndTokenDigest
{
public:
	tns__submitMediaAliasTextAndTokenDigest *tns__submitMediaAliasTextAndTokenDigest_;	/* optional element of type tns:submitMediaAliasTextAndTokenDigest */
public:
	int soap_type() const { return 272; } /* = unique id SOAP_TYPE_Annot___tns__submitMediaAliasTextAndTokenDigest */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__submitMediaAliasTextWithTokenId
#define SOAP_TYPE_Annot___tns__submitMediaAliasTextWithTokenId (276)
/* Operation wrapper: */
struct __tns__submitMediaAliasTextWithTokenId
{
public:
	tns__submitMediaAliasTextWithTokenId *tns__submitMediaAliasTextWithTokenId_;	/* optional element of type tns:submitMediaAliasTextWithTokenId */
public:
	int soap_type() const { return 276; } /* = unique id SOAP_TYPE_Annot___tns__submitMediaAliasTextWithTokenId */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__submitMediaAnnotation
#define SOAP_TYPE_Annot___tns__submitMediaAnnotation (280)
/* Operation wrapper: */
struct __tns__submitMediaAnnotation
{
public:
	tns__submitMediaAnnotation *tns__submitMediaAnnotation_;	/* optional element of type tns:submitMediaAnnotation */
public:
	int soap_type() const { return 280; } /* = unique id SOAP_TYPE_Annot___tns__submitMediaAnnotation */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__submitMediaAnnotationTextAndTokenDigest
#define SOAP_TYPE_Annot___tns__submitMediaAnnotationTextAndTokenDigest (284)
/* Operation wrapper: */
struct __tns__submitMediaAnnotationTextAndTokenDigest
{
public:
	tns__submitMediaAnnotationTextAndTokenDigest *tns__submitMediaAnnotationTextAndTokenDigest_;	/* optional element of type tns:submitMediaAnnotationTextAndTokenDigest */
public:
	int soap_type() const { return 284; } /* = unique id SOAP_TYPE_Annot___tns__submitMediaAnnotationTextAndTokenDigest */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__submitMediaAnnotationTextWithTokenId
#define SOAP_TYPE_Annot___tns__submitMediaAnnotationTextWithTokenId (288)
/* Operation wrapper: */
struct __tns__submitMediaAnnotationTextWithTokenId
{
public:
	tns__submitMediaAnnotationTextWithTokenId *tns__submitMediaAnnotationTextWithTokenId_;	/* optional element of type tns:submitMediaAnnotationTextWithTokenId */
public:
	int soap_type() const { return 288; } /* = unique id SOAP_TYPE_Annot___tns__submitMediaAnnotationTextWithTokenId */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__submitMediaToken
#define SOAP_TYPE_Annot___tns__submitMediaToken (292)
/* Operation wrapper: */
struct __tns__submitMediaToken
{
public:
	tns__submitMediaToken *tns__submitMediaToken_;	/* optional element of type tns:submitMediaToken */
public:
	int soap_type() const { return 292; } /* = unique id SOAP_TYPE_Annot___tns__submitMediaToken */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__submitMediaTokenDigest
#define SOAP_TYPE_Annot___tns__submitMediaTokenDigest (296)
/* Operation wrapper: */
struct __tns__submitMediaTokenDigest
{
public:
	tns__submitMediaTokenDigest *tns__submitMediaTokenDigest_;	/* optional element of type tns:submitMediaTokenDigest */
public:
	int soap_type() const { return 296; } /* = unique id SOAP_TYPE_Annot___tns__submitMediaTokenDigest */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__submitMediaTokenUrl
#define SOAP_TYPE_Annot___tns__submitMediaTokenUrl (300)
/* Operation wrapper: */
struct __tns__submitMediaTokenUrl
{
public:
	tns__submitMediaTokenUrl *tns__submitMediaTokenUrl_;	/* optional element of type tns:submitMediaTokenUrl */
public:
	int soap_type() const { return 300; } /* = unique id SOAP_TYPE_Annot___tns__submitMediaTokenUrl */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__updateGameHookTextWithId
#define SOAP_TYPE_Annot___tns__updateGameHookTextWithId (304)
/* Operation wrapper: */
struct __tns__updateGameHookTextWithId
{
public:
	tns__updateGameHookTextWithId *tns__updateGameHookTextWithId_;	/* optional element of type tns:updateGameHookTextWithId */
public:
	int soap_type() const { return 304; } /* = unique id SOAP_TYPE_Annot___tns__updateGameHookTextWithId */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__updateGameThread
#define SOAP_TYPE_Annot___tns__updateGameThread (308)
/* Operation wrapper: */
struct __tns__updateGameThread
{
public:
	tns__updateGameThread *tns__updateGameThread_;	/* optional element of type tns:updateGameThread */
public:
	int soap_type() const { return 308; } /* = unique id SOAP_TYPE_Annot___tns__updateGameThread */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__updateMediaAnnotationLanguageWithId
#define SOAP_TYPE_Annot___tns__updateMediaAnnotationLanguageWithId (312)
/* Operation wrapper: */
struct __tns__updateMediaAnnotationLanguageWithId
{
public:
	tns__updateMediaAnnotationLanguageWithId *tns__updateMediaAnnotationLanguageWithId_;	/* optional element of type tns:updateMediaAnnotationLanguageWithId */
public:
	int soap_type() const { return 312; } /* = unique id SOAP_TYPE_Annot___tns__updateMediaAnnotationLanguageWithId */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__updateMediaAnnotationTextWithId
#define SOAP_TYPE_Annot___tns__updateMediaAnnotationTextWithId (316)
/* Operation wrapper: */
struct __tns__updateMediaAnnotationTextWithId
{
public:
	tns__updateMediaAnnotationTextWithId *tns__updateMediaAnnotationTextWithId_;	/* optional element of type tns:updateMediaAnnotationTextWithId */
public:
	int soap_type() const { return 316; } /* = unique id SOAP_TYPE_Annot___tns__updateMediaAnnotationTextWithId */
};
#endif

#ifndef SOAP_TYPE_Annot___tns__updateMediaAnnotationUserIdWithId
#define SOAP_TYPE_Annot___tns__updateMediaAnnotationUserIdWithId (320)
/* Operation wrapper: */
struct __tns__updateMediaAnnotationUserIdWithId
{
public:
	tns__updateMediaAnnotationUserIdWithId *tns__updateMediaAnnotationUserIdWithId_;	/* optional element of type tns:updateMediaAnnotationUserIdWithId */
public:
	int soap_type() const { return 320; } /* = unique id SOAP_TYPE_Annot___tns__updateMediaAnnotationUserIdWithId */
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_Annot_SOAP_ENV__Header
#define SOAP_TYPE_Annot_SOAP_ENV__Header (321)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	int soap_type() const { return 321; } /* = unique id SOAP_TYPE_Annot_SOAP_ENV__Header */
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_Annot_SOAP_ENV__Code
#define SOAP_TYPE_Annot_SOAP_ENV__Code (322)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
public:
	int soap_type() const { return 322; } /* = unique id SOAP_TYPE_Annot_SOAP_ENV__Code */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_Annot_SOAP_ENV__Detail
#define SOAP_TYPE_Annot_SOAP_ENV__Detail (324)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
public:
	int soap_type() const { return 324; } /* = unique id SOAP_TYPE_Annot_SOAP_ENV__Detail */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_Annot_SOAP_ENV__Reason
#define SOAP_TYPE_Annot_SOAP_ENV__Reason (327)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
public:
	int soap_type() const { return 327; } /* = unique id SOAP_TYPE_Annot_SOAP_ENV__Reason */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_Annot_SOAP_ENV__Fault
#define SOAP_TYPE_Annot_SOAP_ENV__Fault (328)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
public:
	int soap_type() const { return 328; } /* = unique id SOAP_TYPE_Annot_SOAP_ENV__Fault */
};
#endif

#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE_Annot__QName
#define SOAP_TYPE_Annot__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE_Annot__XML
#define SOAP_TYPE_Annot__XML (6)
typedef char *_XML;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


} // namespace Annot


#endif

/* End of AnnotStub.h */
