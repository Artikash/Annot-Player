/* AnnotC.cpp
   Generated by gSOAP 2.8.10 from cloudservice.h

Copyright(C) 2000-2012, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
1) GPL or 2) Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "AnnotH.h"

namespace Annot {

SOAP_SOURCE_STAMP("@(#) AnnotC.cpp ver 2.8.10 2012-08-31 01:17:18 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_Annot_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_Annot_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_Annot_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_Annot_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_Annot_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_Annot_tns__updateMediaAnnotationUserIdWithIdResponse:
		return soap_in_tns__updateMediaAnnotationUserIdWithIdResponse(soap, NULL, NULL, "tns:updateMediaAnnotationUserIdWithIdResponse");
	case SOAP_TYPE_Annot_tns__updateMediaAnnotationUserIdWithId:
		return soap_in_tns__updateMediaAnnotationUserIdWithId(soap, NULL, NULL, "tns:updateMediaAnnotationUserIdWithId");
	case SOAP_TYPE_Annot_tns__updateMediaAnnotationTextWithIdResponse:
		return soap_in_tns__updateMediaAnnotationTextWithIdResponse(soap, NULL, NULL, "tns:updateMediaAnnotationTextWithIdResponse");
	case SOAP_TYPE_Annot_tns__updateMediaAnnotationTextWithId:
		return soap_in_tns__updateMediaAnnotationTextWithId(soap, NULL, NULL, "tns:updateMediaAnnotationTextWithId");
	case SOAP_TYPE_Annot_tns__updateMediaAnnotationLanguageWithIdResponse:
		return soap_in_tns__updateMediaAnnotationLanguageWithIdResponse(soap, NULL, NULL, "tns:updateMediaAnnotationLanguageWithIdResponse");
	case SOAP_TYPE_Annot_tns__updateMediaAnnotationLanguageWithId:
		return soap_in_tns__updateMediaAnnotationLanguageWithId(soap, NULL, NULL, "tns:updateMediaAnnotationLanguageWithId");
	case SOAP_TYPE_Annot_tns__updateGameThreadResponse:
		return soap_in_tns__updateGameThreadResponse(soap, NULL, NULL, "tns:updateGameThreadResponse");
	case SOAP_TYPE_Annot_tns__updateGameThread:
		return soap_in_tns__updateGameThread(soap, NULL, NULL, "tns:updateGameThread");
	case SOAP_TYPE_Annot_tns__submitMediaTokenUrlResponse:
		return soap_in_tns__submitMediaTokenUrlResponse(soap, NULL, NULL, "tns:submitMediaTokenUrlResponse");
	case SOAP_TYPE_Annot_tns__submitMediaTokenUrl:
		return soap_in_tns__submitMediaTokenUrl(soap, NULL, NULL, "tns:submitMediaTokenUrl");
	case SOAP_TYPE_Annot_tns__submitMediaTokenDigestResponse:
		return soap_in_tns__submitMediaTokenDigestResponse(soap, NULL, NULL, "tns:submitMediaTokenDigestResponse");
	case SOAP_TYPE_Annot_tns__submitMediaTokenDigest:
		return soap_in_tns__submitMediaTokenDigest(soap, NULL, NULL, "tns:submitMediaTokenDigest");
	case SOAP_TYPE_Annot_tns__submitMediaTokenResponse:
		return soap_in_tns__submitMediaTokenResponse(soap, NULL, NULL, "tns:submitMediaTokenResponse");
	case SOAP_TYPE_Annot_tns__submitMediaToken:
		return soap_in_tns__submitMediaToken(soap, NULL, NULL, "tns:submitMediaToken");
	case SOAP_TYPE_Annot_tns__submitMediaAnnotationTextWithTokenIdResponse:
		return soap_in_tns__submitMediaAnnotationTextWithTokenIdResponse(soap, NULL, NULL, "tns:submitMediaAnnotationTextWithTokenIdResponse");
	case SOAP_TYPE_Annot_tns__submitMediaAnnotationTextWithTokenId:
		return soap_in_tns__submitMediaAnnotationTextWithTokenId(soap, NULL, NULL, "tns:submitMediaAnnotationTextWithTokenId");
	case SOAP_TYPE_Annot_tns__submitMediaAnnotationTextAndTokenDigestResponse:
		return soap_in_tns__submitMediaAnnotationTextAndTokenDigestResponse(soap, NULL, NULL, "tns:submitMediaAnnotationTextAndTokenDigestResponse");
	case SOAP_TYPE_Annot_tns__submitMediaAnnotationTextAndTokenDigest:
		return soap_in_tns__submitMediaAnnotationTextAndTokenDigest(soap, NULL, NULL, "tns:submitMediaAnnotationTextAndTokenDigest");
	case SOAP_TYPE_Annot_tns__submitMediaAnnotationResponse:
		return soap_in_tns__submitMediaAnnotationResponse(soap, NULL, NULL, "tns:submitMediaAnnotationResponse");
	case SOAP_TYPE_Annot_tns__submitMediaAnnotation:
		return soap_in_tns__submitMediaAnnotation(soap, NULL, NULL, "tns:submitMediaAnnotation");
	case SOAP_TYPE_Annot_tns__submitMediaAliasTextWithTokenIdResponse:
		return soap_in_tns__submitMediaAliasTextWithTokenIdResponse(soap, NULL, NULL, "tns:submitMediaAliasTextWithTokenIdResponse");
	case SOAP_TYPE_Annot_tns__submitMediaAliasTextWithTokenId:
		return soap_in_tns__submitMediaAliasTextWithTokenId(soap, NULL, NULL, "tns:submitMediaAliasTextWithTokenId");
	case SOAP_TYPE_Annot_tns__submitMediaAliasTextAndTokenDigestResponse:
		return soap_in_tns__submitMediaAliasTextAndTokenDigestResponse(soap, NULL, NULL, "tns:submitMediaAliasTextAndTokenDigestResponse");
	case SOAP_TYPE_Annot_tns__submitMediaAliasTextAndTokenDigest:
		return soap_in_tns__submitMediaAliasTextAndTokenDigest(soap, NULL, NULL, "tns:submitMediaAliasTextAndTokenDigest");
	case SOAP_TYPE_Annot_tns__submitMediaAliasResponse:
		return soap_in_tns__submitMediaAliasResponse(soap, NULL, NULL, "tns:submitMediaAliasResponse");
	case SOAP_TYPE_Annot_tns__submitMediaAlias:
		return soap_in_tns__submitMediaAlias(soap, NULL, NULL, "tns:submitMediaAlias");
	case SOAP_TYPE_Annot_tns__submitGameThreadResponse:
		return soap_in_tns__submitGameThreadResponse(soap, NULL, NULL, "tns:submitGameThreadResponse");
	case SOAP_TYPE_Annot_tns__submitGameThread:
		return soap_in_tns__submitGameThread(soap, NULL, NULL, "tns:submitGameThread");
	case SOAP_TYPE_Annot_tns__setUserLanguageResponse:
		return soap_in_tns__setUserLanguageResponse(soap, NULL, NULL, "tns:setUserLanguageResponse");
	case SOAP_TYPE_Annot_tns__setUserLanguage:
		return soap_in_tns__setUserLanguage(soap, NULL, NULL, "tns:setUserLanguage");
	case SOAP_TYPE_Annot_tns__setUserAnonymousResponse:
		return soap_in_tns__setUserAnonymousResponse(soap, NULL, NULL, "tns:setUserAnonymousResponse");
	case SOAP_TYPE_Annot_tns__setUserAnonymous:
		return soap_in_tns__setUserAnonymous(soap, NULL, NULL, "tns:setUserAnonymous");
	case SOAP_TYPE_Annot_tns__selectRelatedMediaAnnotationsWithTokenIdResponse:
		return soap_in_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(soap, NULL, NULL, "tns:selectRelatedMediaAnnotationsWithTokenIdResponse");
	case SOAP_TYPE_Annot_tns__selectRelatedMediaAnnotationsWithTokenId:
		return soap_in_tns__selectRelatedMediaAnnotationsWithTokenId(soap, NULL, NULL, "tns:selectRelatedMediaAnnotationsWithTokenId");
	case SOAP_TYPE_Annot_tns__selectRelatedMediaAliasesWithTokenIdResponse:
		return soap_in_tns__selectRelatedMediaAliasesWithTokenIdResponse(soap, NULL, NULL, "tns:selectRelatedMediaAliasesWithTokenIdResponse");
	case SOAP_TYPE_Annot_tns__selectRelatedMediaAliasesWithTokenId:
		return soap_in_tns__selectRelatedMediaAliasesWithTokenId(soap, NULL, NULL, "tns:selectRelatedMediaAliasesWithTokenId");
	case SOAP_TYPE_Annot_tns__selectMediaTokenWithIdResponse:
		return soap_in_tns__selectMediaTokenWithIdResponse(soap, NULL, NULL, "tns:selectMediaTokenWithIdResponse");
	case SOAP_TYPE_Annot_tns__selectMediaTokenWithId:
		return soap_in_tns__selectMediaTokenWithId(soap, NULL, NULL, "tns:selectMediaTokenWithId");
	case SOAP_TYPE_Annot_tns__selectMediaTokenWithDigestResponse:
		return soap_in_tns__selectMediaTokenWithDigestResponse(soap, NULL, NULL, "tns:selectMediaTokenWithDigestResponse");
	case SOAP_TYPE_Annot_tns__selectMediaTokenWithDigest:
		return soap_in_tns__selectMediaTokenWithDigest(soap, NULL, NULL, "tns:selectMediaTokenWithDigest");
	case SOAP_TYPE_Annot_tns__selectMediaTokenIdWithUrlResponse:
		return soap_in_tns__selectMediaTokenIdWithUrlResponse(soap, NULL, NULL, "tns:selectMediaTokenIdWithUrlResponse");
	case SOAP_TYPE_Annot_tns__selectMediaTokenIdWithUrl:
		return soap_in_tns__selectMediaTokenIdWithUrl(soap, NULL, NULL, "tns:selectMediaTokenIdWithUrl");
	case SOAP_TYPE_Annot_tns__selectMediaTokenIdWithDigestResponse:
		return soap_in_tns__selectMediaTokenIdWithDigestResponse(soap, NULL, NULL, "tns:selectMediaTokenIdWithDigestResponse");
	case SOAP_TYPE_Annot_tns__selectMediaTokenIdWithDigest:
		return soap_in_tns__selectMediaTokenIdWithDigest(soap, NULL, NULL, "tns:selectMediaTokenIdWithDigest");
	case SOAP_TYPE_Annot_tns__selectMediaAnnotationsWithTokenIdResponse:
		return soap_in_tns__selectMediaAnnotationsWithTokenIdResponse(soap, NULL, NULL, "tns:selectMediaAnnotationsWithTokenIdResponse");
	case SOAP_TYPE_Annot_tns__selectMediaAnnotationsWithTokenId:
		return soap_in_tns__selectMediaAnnotationsWithTokenId(soap, NULL, NULL, "tns:selectMediaAnnotationsWithTokenId");
	case SOAP_TYPE_Annot_tns__selectMediaAliasesWithTokenIdResponse:
		return soap_in_tns__selectMediaAliasesWithTokenIdResponse(soap, NULL, NULL, "tns:selectMediaAliasesWithTokenIdResponse");
	case SOAP_TYPE_Annot_tns__selectMediaAliasesWithTokenId:
		return soap_in_tns__selectMediaAliasesWithTokenId(soap, NULL, NULL, "tns:selectMediaAliasesWithTokenId");
	case SOAP_TYPE_Annot_tns__selectGameThreadWithTokenIdResponse:
		return soap_in_tns__selectGameThreadWithTokenIdResponse(soap, NULL, NULL, "tns:selectGameThreadWithTokenIdResponse");
	case SOAP_TYPE_Annot_tns__selectGameThreadWithTokenId:
		return soap_in_tns__selectGameThreadWithTokenId(soap, NULL, NULL, "tns:selectGameThreadWithTokenId");
	case SOAP_TYPE_Annot_tns__selectGameThreadWithTokenDigestResponse:
		return soap_in_tns__selectGameThreadWithTokenDigestResponse(soap, NULL, NULL, "tns:selectGameThreadWithTokenDigestResponse");
	case SOAP_TYPE_Annot_tns__selectGameThreadWithTokenDigest:
		return soap_in_tns__selectGameThreadWithTokenDigest(soap, NULL, NULL, "tns:selectGameThreadWithTokenDigest");
	case SOAP_TYPE_Annot_tns__loginResponse:
		return soap_in_tns__loginResponse(soap, NULL, NULL, "tns:loginResponse");
	case SOAP_TYPE_Annot_tns__login:
		return soap_in_tns__login(soap, NULL, NULL, "tns:login");
	case SOAP_TYPE_Annot_tns__isLatestAppResponse:
		return soap_in_tns__isLatestAppResponse(soap, NULL, NULL, "tns:isLatestAppResponse");
	case SOAP_TYPE_Annot_tns__isLatestApp:
		return soap_in_tns__isLatestApp(soap, NULL, NULL, "tns:isLatestApp");
	case SOAP_TYPE_Annot_tns__isConnectedResponse:
		return soap_in_tns__isConnectedResponse(soap, NULL, NULL, "tns:isConnectedResponse");
	case SOAP_TYPE_Annot_tns__isConnected:
		return soap_in_tns__isConnected(soap, NULL, NULL, "tns:isConnected");
	case SOAP_TYPE_Annot_tns__isAuthorizedResponse:
		return soap_in_tns__isAuthorizedResponse(soap, NULL, NULL, "tns:isAuthorizedResponse");
	case SOAP_TYPE_Annot_tns__isAuthorized:
		return soap_in_tns__isAuthorized(soap, NULL, NULL, "tns:isAuthorized");
	case SOAP_TYPE_Annot_tns__getUserResponse:
		return soap_in_tns__getUserResponse(soap, NULL, NULL, "tns:getUserResponse");
	case SOAP_TYPE_Annot_tns__getUser:
		return soap_in_tns__getUser(soap, NULL, NULL, "tns:getUser");
	case SOAP_TYPE_Annot_tns__deleteMediaAnnotationWithIdResponse:
		return soap_in_tns__deleteMediaAnnotationWithIdResponse(soap, NULL, NULL, "tns:deleteMediaAnnotationWithIdResponse");
	case SOAP_TYPE_Annot_tns__deleteMediaAnnotationWithId:
		return soap_in_tns__deleteMediaAnnotationWithId(soap, NULL, NULL, "tns:deleteMediaAnnotationWithId");
	case SOAP_TYPE_Annot_tns__deleteMediaAliasWithIdResponse:
		return soap_in_tns__deleteMediaAliasWithIdResponse(soap, NULL, NULL, "tns:deleteMediaAliasWithIdResponse");
	case SOAP_TYPE_Annot_tns__deleteMediaAliasWithId:
		return soap_in_tns__deleteMediaAliasWithId(soap, NULL, NULL, "tns:deleteMediaAliasWithId");
	case SOAP_TYPE_Annot_tns__curseUserWithIdResponse:
		return soap_in_tns__curseUserWithIdResponse(soap, NULL, NULL, "tns:curseUserWithIdResponse");
	case SOAP_TYPE_Annot_tns__curseUserWithId:
		return soap_in_tns__curseUserWithId(soap, NULL, NULL, "tns:curseUserWithId");
	case SOAP_TYPE_Annot_tns__curseMediaTokenWithIdResponse:
		return soap_in_tns__curseMediaTokenWithIdResponse(soap, NULL, NULL, "tns:curseMediaTokenWithIdResponse");
	case SOAP_TYPE_Annot_tns__curseMediaTokenWithId:
		return soap_in_tns__curseMediaTokenWithId(soap, NULL, NULL, "tns:curseMediaTokenWithId");
	case SOAP_TYPE_Annot_tns__curseMediaAnnotationWithIdResponse:
		return soap_in_tns__curseMediaAnnotationWithIdResponse(soap, NULL, NULL, "tns:curseMediaAnnotationWithIdResponse");
	case SOAP_TYPE_Annot_tns__curseMediaAnnotationWithId:
		return soap_in_tns__curseMediaAnnotationWithId(soap, NULL, NULL, "tns:curseMediaAnnotationWithId");
	case SOAP_TYPE_Annot_tns__curseMediaAliasWithIdResponse:
		return soap_in_tns__curseMediaAliasWithIdResponse(soap, NULL, NULL, "tns:curseMediaAliasWithIdResponse");
	case SOAP_TYPE_Annot_tns__curseMediaAliasWithId:
		return soap_in_tns__curseMediaAliasWithId(soap, NULL, NULL, "tns:curseMediaAliasWithId");
	case SOAP_TYPE_Annot_tns__chatResponse:
		return soap_in_tns__chatResponse(soap, NULL, NULL, "tns:chatResponse");
	case SOAP_TYPE_Annot_tns__chat:
		return soap_in_tns__chat(soap, NULL, NULL, "tns:chat");
	case SOAP_TYPE_Annot_tns__blockUserWithIdResponse:
		return soap_in_tns__blockUserWithIdResponse(soap, NULL, NULL, "tns:blockUserWithIdResponse");
	case SOAP_TYPE_Annot_tns__blockUserWithId:
		return soap_in_tns__blockUserWithId(soap, NULL, NULL, "tns:blockUserWithId");
	case SOAP_TYPE_Annot_tns__blockMediaAnnotationWithIdResponse:
		return soap_in_tns__blockMediaAnnotationWithIdResponse(soap, NULL, NULL, "tns:blockMediaAnnotationWithIdResponse");
	case SOAP_TYPE_Annot_tns__blockMediaAnnotationWithId:
		return soap_in_tns__blockMediaAnnotationWithId(soap, NULL, NULL, "tns:blockMediaAnnotationWithId");
	case SOAP_TYPE_Annot_tns__blockMediaAliasWithIdResponse:
		return soap_in_tns__blockMediaAliasWithIdResponse(soap, NULL, NULL, "tns:blockMediaAliasWithIdResponse");
	case SOAP_TYPE_Annot_tns__blockMediaAliasWithId:
		return soap_in_tns__blockMediaAliasWithId(soap, NULL, NULL, "tns:blockMediaAliasWithId");
	case SOAP_TYPE_Annot_tns__blessUserWithIdResponse:
		return soap_in_tns__blessUserWithIdResponse(soap, NULL, NULL, "tns:blessUserWithIdResponse");
	case SOAP_TYPE_Annot_tns__blessUserWithId:
		return soap_in_tns__blessUserWithId(soap, NULL, NULL, "tns:blessUserWithId");
	case SOAP_TYPE_Annot_tns__blessMediaTokenWithIdResponse:
		return soap_in_tns__blessMediaTokenWithIdResponse(soap, NULL, NULL, "tns:blessMediaTokenWithIdResponse");
	case SOAP_TYPE_Annot_tns__blessMediaTokenWithId:
		return soap_in_tns__blessMediaTokenWithId(soap, NULL, NULL, "tns:blessMediaTokenWithId");
	case SOAP_TYPE_Annot_tns__blessMediaAnnotationWithIdResponse:
		return soap_in_tns__blessMediaAnnotationWithIdResponse(soap, NULL, NULL, "tns:blessMediaAnnotationWithIdResponse");
	case SOAP_TYPE_Annot_tns__blessMediaAnnotationWithId:
		return soap_in_tns__blessMediaAnnotationWithId(soap, NULL, NULL, "tns:blessMediaAnnotationWithId");
	case SOAP_TYPE_Annot_tns__blessMediaAliasWithIdResponse:
		return soap_in_tns__blessMediaAliasWithIdResponse(soap, NULL, NULL, "tns:blessMediaAliasWithIdResponse");
	case SOAP_TYPE_Annot_tns__blessMediaAliasWithId:
		return soap_in_tns__blessMediaAliasWithId(soap, NULL, NULL, "tns:blessMediaAliasWithId");
	case SOAP_TYPE_Annot_tns__user:
		return soap_in_tns__user(soap, NULL, NULL, "tns:user");
	case SOAP_TYPE_Annot_tns__mediaAlias:
		return soap_in_tns__mediaAlias(soap, NULL, NULL, "tns:mediaAlias");
	case SOAP_TYPE_Annot_tns__mediaToken:
		return soap_in_tns__mediaToken(soap, NULL, NULL, "tns:mediaToken");
	case SOAP_TYPE_Annot_tns__mediaAnnotation:
		return soap_in_tns__mediaAnnotation(soap, NULL, NULL, "tns:mediaAnnotation");
	case SOAP_TYPE_Annot_tns__gameThread:
		return soap_in_tns__gameThread(soap, NULL, NULL, "tns:gameThread");
	case SOAP_TYPE_Annot_PointerTotns__updateMediaAnnotationUserIdWithIdResponse:
		return soap_in_PointerTotns__updateMediaAnnotationUserIdWithIdResponse(soap, NULL, NULL, "tns:updateMediaAnnotationUserIdWithIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__updateMediaAnnotationUserIdWithId:
		return soap_in_PointerTotns__updateMediaAnnotationUserIdWithId(soap, NULL, NULL, "tns:updateMediaAnnotationUserIdWithId");
	case SOAP_TYPE_Annot_PointerTotns__updateMediaAnnotationTextWithIdResponse:
		return soap_in_PointerTotns__updateMediaAnnotationTextWithIdResponse(soap, NULL, NULL, "tns:updateMediaAnnotationTextWithIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__updateMediaAnnotationTextWithId:
		return soap_in_PointerTotns__updateMediaAnnotationTextWithId(soap, NULL, NULL, "tns:updateMediaAnnotationTextWithId");
	case SOAP_TYPE_Annot_PointerTotns__updateMediaAnnotationLanguageWithIdResponse:
		return soap_in_PointerTotns__updateMediaAnnotationLanguageWithIdResponse(soap, NULL, NULL, "tns:updateMediaAnnotationLanguageWithIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__updateMediaAnnotationLanguageWithId:
		return soap_in_PointerTotns__updateMediaAnnotationLanguageWithId(soap, NULL, NULL, "tns:updateMediaAnnotationLanguageWithId");
	case SOAP_TYPE_Annot_PointerTotns__updateGameThreadResponse:
		return soap_in_PointerTotns__updateGameThreadResponse(soap, NULL, NULL, "tns:updateGameThreadResponse");
	case SOAP_TYPE_Annot_PointerTotns__updateGameThread:
		return soap_in_PointerTotns__updateGameThread(soap, NULL, NULL, "tns:updateGameThread");
	case SOAP_TYPE_Annot_PointerTotns__submitMediaTokenUrlResponse:
		return soap_in_PointerTotns__submitMediaTokenUrlResponse(soap, NULL, NULL, "tns:submitMediaTokenUrlResponse");
	case SOAP_TYPE_Annot_PointerTotns__submitMediaTokenUrl:
		return soap_in_PointerTotns__submitMediaTokenUrl(soap, NULL, NULL, "tns:submitMediaTokenUrl");
	case SOAP_TYPE_Annot_PointerTotns__submitMediaTokenDigestResponse:
		return soap_in_PointerTotns__submitMediaTokenDigestResponse(soap, NULL, NULL, "tns:submitMediaTokenDigestResponse");
	case SOAP_TYPE_Annot_PointerTotns__submitMediaTokenDigest:
		return soap_in_PointerTotns__submitMediaTokenDigest(soap, NULL, NULL, "tns:submitMediaTokenDigest");
	case SOAP_TYPE_Annot_PointerTotns__submitMediaTokenResponse:
		return soap_in_PointerTotns__submitMediaTokenResponse(soap, NULL, NULL, "tns:submitMediaTokenResponse");
	case SOAP_TYPE_Annot_PointerTotns__submitMediaToken:
		return soap_in_PointerTotns__submitMediaToken(soap, NULL, NULL, "tns:submitMediaToken");
	case SOAP_TYPE_Annot_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse:
		return soap_in_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse(soap, NULL, NULL, "tns:submitMediaAnnotationTextWithTokenIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__submitMediaAnnotationTextWithTokenId:
		return soap_in_PointerTotns__submitMediaAnnotationTextWithTokenId(soap, NULL, NULL, "tns:submitMediaAnnotationTextWithTokenId");
	case SOAP_TYPE_Annot_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse:
		return soap_in_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse(soap, NULL, NULL, "tns:submitMediaAnnotationTextAndTokenDigestResponse");
	case SOAP_TYPE_Annot_PointerTotns__submitMediaAnnotationTextAndTokenDigest:
		return soap_in_PointerTotns__submitMediaAnnotationTextAndTokenDigest(soap, NULL, NULL, "tns:submitMediaAnnotationTextAndTokenDigest");
	case SOAP_TYPE_Annot_PointerTotns__submitMediaAnnotationResponse:
		return soap_in_PointerTotns__submitMediaAnnotationResponse(soap, NULL, NULL, "tns:submitMediaAnnotationResponse");
	case SOAP_TYPE_Annot_PointerTotns__submitMediaAnnotation:
		return soap_in_PointerTotns__submitMediaAnnotation(soap, NULL, NULL, "tns:submitMediaAnnotation");
	case SOAP_TYPE_Annot_PointerTotns__submitMediaAliasTextWithTokenIdResponse:
		return soap_in_PointerTotns__submitMediaAliasTextWithTokenIdResponse(soap, NULL, NULL, "tns:submitMediaAliasTextWithTokenIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__submitMediaAliasTextWithTokenId:
		return soap_in_PointerTotns__submitMediaAliasTextWithTokenId(soap, NULL, NULL, "tns:submitMediaAliasTextWithTokenId");
	case SOAP_TYPE_Annot_PointerTotns__submitMediaAliasTextAndTokenDigestResponse:
		return soap_in_PointerTotns__submitMediaAliasTextAndTokenDigestResponse(soap, NULL, NULL, "tns:submitMediaAliasTextAndTokenDigestResponse");
	case SOAP_TYPE_Annot_PointerTotns__submitMediaAliasTextAndTokenDigest:
		return soap_in_PointerTotns__submitMediaAliasTextAndTokenDigest(soap, NULL, NULL, "tns:submitMediaAliasTextAndTokenDigest");
	case SOAP_TYPE_Annot_PointerTotns__submitMediaAliasResponse:
		return soap_in_PointerTotns__submitMediaAliasResponse(soap, NULL, NULL, "tns:submitMediaAliasResponse");
	case SOAP_TYPE_Annot_PointerTotns__submitMediaAlias:
		return soap_in_PointerTotns__submitMediaAlias(soap, NULL, NULL, "tns:submitMediaAlias");
	case SOAP_TYPE_Annot_PointerTotns__submitGameThreadResponse:
		return soap_in_PointerTotns__submitGameThreadResponse(soap, NULL, NULL, "tns:submitGameThreadResponse");
	case SOAP_TYPE_Annot_PointerTotns__submitGameThread:
		return soap_in_PointerTotns__submitGameThread(soap, NULL, NULL, "tns:submitGameThread");
	case SOAP_TYPE_Annot_PointerTotns__setUserLanguageResponse:
		return soap_in_PointerTotns__setUserLanguageResponse(soap, NULL, NULL, "tns:setUserLanguageResponse");
	case SOAP_TYPE_Annot_PointerTotns__setUserLanguage:
		return soap_in_PointerTotns__setUserLanguage(soap, NULL, NULL, "tns:setUserLanguage");
	case SOAP_TYPE_Annot_PointerTotns__setUserAnonymousResponse:
		return soap_in_PointerTotns__setUserAnonymousResponse(soap, NULL, NULL, "tns:setUserAnonymousResponse");
	case SOAP_TYPE_Annot_PointerTotns__setUserAnonymous:
		return soap_in_PointerTotns__setUserAnonymous(soap, NULL, NULL, "tns:setUserAnonymous");
	case SOAP_TYPE_Annot_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse:
		return soap_in_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse(soap, NULL, NULL, "tns:selectRelatedMediaAnnotationsWithTokenIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__selectRelatedMediaAnnotationsWithTokenId:
		return soap_in_PointerTotns__selectRelatedMediaAnnotationsWithTokenId(soap, NULL, NULL, "tns:selectRelatedMediaAnnotationsWithTokenId");
	case SOAP_TYPE_Annot_PointerTotns__selectRelatedMediaAliasesWithTokenIdResponse:
		return soap_in_PointerTotns__selectRelatedMediaAliasesWithTokenIdResponse(soap, NULL, NULL, "tns:selectRelatedMediaAliasesWithTokenIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__selectRelatedMediaAliasesWithTokenId:
		return soap_in_PointerTotns__selectRelatedMediaAliasesWithTokenId(soap, NULL, NULL, "tns:selectRelatedMediaAliasesWithTokenId");
	case SOAP_TYPE_Annot_PointerTotns__selectMediaTokenWithIdResponse:
		return soap_in_PointerTotns__selectMediaTokenWithIdResponse(soap, NULL, NULL, "tns:selectMediaTokenWithIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__selectMediaTokenWithId:
		return soap_in_PointerTotns__selectMediaTokenWithId(soap, NULL, NULL, "tns:selectMediaTokenWithId");
	case SOAP_TYPE_Annot_PointerTotns__selectMediaTokenWithDigestResponse:
		return soap_in_PointerTotns__selectMediaTokenWithDigestResponse(soap, NULL, NULL, "tns:selectMediaTokenWithDigestResponse");
	case SOAP_TYPE_Annot_PointerTotns__selectMediaTokenWithDigest:
		return soap_in_PointerTotns__selectMediaTokenWithDigest(soap, NULL, NULL, "tns:selectMediaTokenWithDigest");
	case SOAP_TYPE_Annot_PointerTotns__selectMediaTokenIdWithUrlResponse:
		return soap_in_PointerTotns__selectMediaTokenIdWithUrlResponse(soap, NULL, NULL, "tns:selectMediaTokenIdWithUrlResponse");
	case SOAP_TYPE_Annot_PointerTotns__selectMediaTokenIdWithUrl:
		return soap_in_PointerTotns__selectMediaTokenIdWithUrl(soap, NULL, NULL, "tns:selectMediaTokenIdWithUrl");
	case SOAP_TYPE_Annot_PointerTotns__selectMediaTokenIdWithDigestResponse:
		return soap_in_PointerTotns__selectMediaTokenIdWithDigestResponse(soap, NULL, NULL, "tns:selectMediaTokenIdWithDigestResponse");
	case SOAP_TYPE_Annot_PointerTotns__selectMediaTokenIdWithDigest:
		return soap_in_PointerTotns__selectMediaTokenIdWithDigest(soap, NULL, NULL, "tns:selectMediaTokenIdWithDigest");
	case SOAP_TYPE_Annot_PointerTotns__selectMediaAnnotationsWithTokenIdResponse:
		return soap_in_PointerTotns__selectMediaAnnotationsWithTokenIdResponse(soap, NULL, NULL, "tns:selectMediaAnnotationsWithTokenIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__selectMediaAnnotationsWithTokenId:
		return soap_in_PointerTotns__selectMediaAnnotationsWithTokenId(soap, NULL, NULL, "tns:selectMediaAnnotationsWithTokenId");
	case SOAP_TYPE_Annot_PointerTotns__selectMediaAliasesWithTokenIdResponse:
		return soap_in_PointerTotns__selectMediaAliasesWithTokenIdResponse(soap, NULL, NULL, "tns:selectMediaAliasesWithTokenIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__selectMediaAliasesWithTokenId:
		return soap_in_PointerTotns__selectMediaAliasesWithTokenId(soap, NULL, NULL, "tns:selectMediaAliasesWithTokenId");
	case SOAP_TYPE_Annot_PointerTotns__selectGameThreadWithTokenIdResponse:
		return soap_in_PointerTotns__selectGameThreadWithTokenIdResponse(soap, NULL, NULL, "tns:selectGameThreadWithTokenIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__selectGameThreadWithTokenId:
		return soap_in_PointerTotns__selectGameThreadWithTokenId(soap, NULL, NULL, "tns:selectGameThreadWithTokenId");
	case SOAP_TYPE_Annot_PointerTotns__selectGameThreadWithTokenDigestResponse:
		return soap_in_PointerTotns__selectGameThreadWithTokenDigestResponse(soap, NULL, NULL, "tns:selectGameThreadWithTokenDigestResponse");
	case SOAP_TYPE_Annot_PointerTotns__selectGameThreadWithTokenDigest:
		return soap_in_PointerTotns__selectGameThreadWithTokenDigest(soap, NULL, NULL, "tns:selectGameThreadWithTokenDigest");
	case SOAP_TYPE_Annot_PointerTotns__loginResponse:
		return soap_in_PointerTotns__loginResponse(soap, NULL, NULL, "tns:loginResponse");
	case SOAP_TYPE_Annot_PointerTotns__login:
		return soap_in_PointerTotns__login(soap, NULL, NULL, "tns:login");
	case SOAP_TYPE_Annot_PointerTotns__isLatestAppResponse:
		return soap_in_PointerTotns__isLatestAppResponse(soap, NULL, NULL, "tns:isLatestAppResponse");
	case SOAP_TYPE_Annot_PointerTotns__isLatestApp:
		return soap_in_PointerTotns__isLatestApp(soap, NULL, NULL, "tns:isLatestApp");
	case SOAP_TYPE_Annot_PointerTotns__isConnectedResponse:
		return soap_in_PointerTotns__isConnectedResponse(soap, NULL, NULL, "tns:isConnectedResponse");
	case SOAP_TYPE_Annot_PointerTotns__isConnected:
		return soap_in_PointerTotns__isConnected(soap, NULL, NULL, "tns:isConnected");
	case SOAP_TYPE_Annot_PointerTotns__isAuthorizedResponse:
		return soap_in_PointerTotns__isAuthorizedResponse(soap, NULL, NULL, "tns:isAuthorizedResponse");
	case SOAP_TYPE_Annot_PointerTotns__isAuthorized:
		return soap_in_PointerTotns__isAuthorized(soap, NULL, NULL, "tns:isAuthorized");
	case SOAP_TYPE_Annot_PointerTotns__getUserResponse:
		return soap_in_PointerTotns__getUserResponse(soap, NULL, NULL, "tns:getUserResponse");
	case SOAP_TYPE_Annot_PointerTotns__getUser:
		return soap_in_PointerTotns__getUser(soap, NULL, NULL, "tns:getUser");
	case SOAP_TYPE_Annot_PointerTotns__deleteMediaAnnotationWithIdResponse:
		return soap_in_PointerTotns__deleteMediaAnnotationWithIdResponse(soap, NULL, NULL, "tns:deleteMediaAnnotationWithIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__deleteMediaAnnotationWithId:
		return soap_in_PointerTotns__deleteMediaAnnotationWithId(soap, NULL, NULL, "tns:deleteMediaAnnotationWithId");
	case SOAP_TYPE_Annot_PointerTotns__deleteMediaAliasWithIdResponse:
		return soap_in_PointerTotns__deleteMediaAliasWithIdResponse(soap, NULL, NULL, "tns:deleteMediaAliasWithIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__deleteMediaAliasWithId:
		return soap_in_PointerTotns__deleteMediaAliasWithId(soap, NULL, NULL, "tns:deleteMediaAliasWithId");
	case SOAP_TYPE_Annot_PointerTotns__curseUserWithIdResponse:
		return soap_in_PointerTotns__curseUserWithIdResponse(soap, NULL, NULL, "tns:curseUserWithIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__curseUserWithId:
		return soap_in_PointerTotns__curseUserWithId(soap, NULL, NULL, "tns:curseUserWithId");
	case SOAP_TYPE_Annot_PointerTotns__curseMediaTokenWithIdResponse:
		return soap_in_PointerTotns__curseMediaTokenWithIdResponse(soap, NULL, NULL, "tns:curseMediaTokenWithIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__curseMediaTokenWithId:
		return soap_in_PointerTotns__curseMediaTokenWithId(soap, NULL, NULL, "tns:curseMediaTokenWithId");
	case SOAP_TYPE_Annot_PointerTotns__curseMediaAnnotationWithIdResponse:
		return soap_in_PointerTotns__curseMediaAnnotationWithIdResponse(soap, NULL, NULL, "tns:curseMediaAnnotationWithIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__curseMediaAnnotationWithId:
		return soap_in_PointerTotns__curseMediaAnnotationWithId(soap, NULL, NULL, "tns:curseMediaAnnotationWithId");
	case SOAP_TYPE_Annot_PointerTotns__curseMediaAliasWithIdResponse:
		return soap_in_PointerTotns__curseMediaAliasWithIdResponse(soap, NULL, NULL, "tns:curseMediaAliasWithIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__curseMediaAliasWithId:
		return soap_in_PointerTotns__curseMediaAliasWithId(soap, NULL, NULL, "tns:curseMediaAliasWithId");
	case SOAP_TYPE_Annot_PointerTotns__chatResponse:
		return soap_in_PointerTotns__chatResponse(soap, NULL, NULL, "tns:chatResponse");
	case SOAP_TYPE_Annot_PointerTotns__chat:
		return soap_in_PointerTotns__chat(soap, NULL, NULL, "tns:chat");
	case SOAP_TYPE_Annot_PointerTotns__blockUserWithIdResponse:
		return soap_in_PointerTotns__blockUserWithIdResponse(soap, NULL, NULL, "tns:blockUserWithIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__blockUserWithId:
		return soap_in_PointerTotns__blockUserWithId(soap, NULL, NULL, "tns:blockUserWithId");
	case SOAP_TYPE_Annot_PointerTotns__blockMediaAnnotationWithIdResponse:
		return soap_in_PointerTotns__blockMediaAnnotationWithIdResponse(soap, NULL, NULL, "tns:blockMediaAnnotationWithIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__blockMediaAnnotationWithId:
		return soap_in_PointerTotns__blockMediaAnnotationWithId(soap, NULL, NULL, "tns:blockMediaAnnotationWithId");
	case SOAP_TYPE_Annot_PointerTotns__blockMediaAliasWithIdResponse:
		return soap_in_PointerTotns__blockMediaAliasWithIdResponse(soap, NULL, NULL, "tns:blockMediaAliasWithIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__blockMediaAliasWithId:
		return soap_in_PointerTotns__blockMediaAliasWithId(soap, NULL, NULL, "tns:blockMediaAliasWithId");
	case SOAP_TYPE_Annot_PointerTotns__blessUserWithIdResponse:
		return soap_in_PointerTotns__blessUserWithIdResponse(soap, NULL, NULL, "tns:blessUserWithIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__blessUserWithId:
		return soap_in_PointerTotns__blessUserWithId(soap, NULL, NULL, "tns:blessUserWithId");
	case SOAP_TYPE_Annot_PointerTotns__blessMediaTokenWithIdResponse:
		return soap_in_PointerTotns__blessMediaTokenWithIdResponse(soap, NULL, NULL, "tns:blessMediaTokenWithIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__blessMediaTokenWithId:
		return soap_in_PointerTotns__blessMediaTokenWithId(soap, NULL, NULL, "tns:blessMediaTokenWithId");
	case SOAP_TYPE_Annot_PointerTotns__blessMediaAnnotationWithIdResponse:
		return soap_in_PointerTotns__blessMediaAnnotationWithIdResponse(soap, NULL, NULL, "tns:blessMediaAnnotationWithIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__blessMediaAnnotationWithId:
		return soap_in_PointerTotns__blessMediaAnnotationWithId(soap, NULL, NULL, "tns:blessMediaAnnotationWithId");
	case SOAP_TYPE_Annot_PointerTotns__blessMediaAliasWithIdResponse:
		return soap_in_PointerTotns__blessMediaAliasWithIdResponse(soap, NULL, NULL, "tns:blessMediaAliasWithIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__blessMediaAliasWithId:
		return soap_in_PointerTotns__blessMediaAliasWithId(soap, NULL, NULL, "tns:blessMediaAliasWithId");
	case SOAP_TYPE_Annot_PointerTotns__mediaToken:
		return soap_in_PointerTotns__mediaToken(soap, NULL, NULL, "tns:mediaToken");
	case SOAP_TYPE_Annot_PointerTotns__mediaAnnotation:
		return soap_in_PointerTotns__mediaAnnotation(soap, NULL, NULL, "tns:mediaAnnotation");
	case SOAP_TYPE_Annot_PointerTotns__mediaAlias:
		return soap_in_PointerTotns__mediaAlias(soap, NULL, NULL, "tns:mediaAlias");
	case SOAP_TYPE_Annot_PointerTotns__gameThread:
		return soap_in_PointerTotns__gameThread(soap, NULL, NULL, "tns:gameThread");
	case SOAP_TYPE_Annot_PointerTotns__user:
		return soap_in_PointerTotns__user(soap, NULL, NULL, "tns:user");
	case SOAP_TYPE_Annot_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_Annot__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_Annot_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_Annot_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:updateMediaAnnotationUserIdWithIdResponse"))
		{	*type = SOAP_TYPE_Annot_tns__updateMediaAnnotationUserIdWithIdResponse;
			return soap_in_tns__updateMediaAnnotationUserIdWithIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:updateMediaAnnotationUserIdWithId"))
		{	*type = SOAP_TYPE_Annot_tns__updateMediaAnnotationUserIdWithId;
			return soap_in_tns__updateMediaAnnotationUserIdWithId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:updateMediaAnnotationTextWithIdResponse"))
		{	*type = SOAP_TYPE_Annot_tns__updateMediaAnnotationTextWithIdResponse;
			return soap_in_tns__updateMediaAnnotationTextWithIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:updateMediaAnnotationTextWithId"))
		{	*type = SOAP_TYPE_Annot_tns__updateMediaAnnotationTextWithId;
			return soap_in_tns__updateMediaAnnotationTextWithId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:updateMediaAnnotationLanguageWithIdResponse"))
		{	*type = SOAP_TYPE_Annot_tns__updateMediaAnnotationLanguageWithIdResponse;
			return soap_in_tns__updateMediaAnnotationLanguageWithIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:updateMediaAnnotationLanguageWithId"))
		{	*type = SOAP_TYPE_Annot_tns__updateMediaAnnotationLanguageWithId;
			return soap_in_tns__updateMediaAnnotationLanguageWithId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:updateGameThreadResponse"))
		{	*type = SOAP_TYPE_Annot_tns__updateGameThreadResponse;
			return soap_in_tns__updateGameThreadResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:updateGameThread"))
		{	*type = SOAP_TYPE_Annot_tns__updateGameThread;
			return soap_in_tns__updateGameThread(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaTokenUrlResponse"))
		{	*type = SOAP_TYPE_Annot_tns__submitMediaTokenUrlResponse;
			return soap_in_tns__submitMediaTokenUrlResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaTokenUrl"))
		{	*type = SOAP_TYPE_Annot_tns__submitMediaTokenUrl;
			return soap_in_tns__submitMediaTokenUrl(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaTokenDigestResponse"))
		{	*type = SOAP_TYPE_Annot_tns__submitMediaTokenDigestResponse;
			return soap_in_tns__submitMediaTokenDigestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaTokenDigest"))
		{	*type = SOAP_TYPE_Annot_tns__submitMediaTokenDigest;
			return soap_in_tns__submitMediaTokenDigest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaTokenResponse"))
		{	*type = SOAP_TYPE_Annot_tns__submitMediaTokenResponse;
			return soap_in_tns__submitMediaTokenResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaToken"))
		{	*type = SOAP_TYPE_Annot_tns__submitMediaToken;
			return soap_in_tns__submitMediaToken(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaAnnotationTextWithTokenIdResponse"))
		{	*type = SOAP_TYPE_Annot_tns__submitMediaAnnotationTextWithTokenIdResponse;
			return soap_in_tns__submitMediaAnnotationTextWithTokenIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaAnnotationTextWithTokenId"))
		{	*type = SOAP_TYPE_Annot_tns__submitMediaAnnotationTextWithTokenId;
			return soap_in_tns__submitMediaAnnotationTextWithTokenId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaAnnotationTextAndTokenDigestResponse"))
		{	*type = SOAP_TYPE_Annot_tns__submitMediaAnnotationTextAndTokenDigestResponse;
			return soap_in_tns__submitMediaAnnotationTextAndTokenDigestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaAnnotationTextAndTokenDigest"))
		{	*type = SOAP_TYPE_Annot_tns__submitMediaAnnotationTextAndTokenDigest;
			return soap_in_tns__submitMediaAnnotationTextAndTokenDigest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaAnnotationResponse"))
		{	*type = SOAP_TYPE_Annot_tns__submitMediaAnnotationResponse;
			return soap_in_tns__submitMediaAnnotationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaAnnotation"))
		{	*type = SOAP_TYPE_Annot_tns__submitMediaAnnotation;
			return soap_in_tns__submitMediaAnnotation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaAliasTextWithTokenIdResponse"))
		{	*type = SOAP_TYPE_Annot_tns__submitMediaAliasTextWithTokenIdResponse;
			return soap_in_tns__submitMediaAliasTextWithTokenIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaAliasTextWithTokenId"))
		{	*type = SOAP_TYPE_Annot_tns__submitMediaAliasTextWithTokenId;
			return soap_in_tns__submitMediaAliasTextWithTokenId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaAliasTextAndTokenDigestResponse"))
		{	*type = SOAP_TYPE_Annot_tns__submitMediaAliasTextAndTokenDigestResponse;
			return soap_in_tns__submitMediaAliasTextAndTokenDigestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaAliasTextAndTokenDigest"))
		{	*type = SOAP_TYPE_Annot_tns__submitMediaAliasTextAndTokenDigest;
			return soap_in_tns__submitMediaAliasTextAndTokenDigest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaAliasResponse"))
		{	*type = SOAP_TYPE_Annot_tns__submitMediaAliasResponse;
			return soap_in_tns__submitMediaAliasResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaAlias"))
		{	*type = SOAP_TYPE_Annot_tns__submitMediaAlias;
			return soap_in_tns__submitMediaAlias(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitGameThreadResponse"))
		{	*type = SOAP_TYPE_Annot_tns__submitGameThreadResponse;
			return soap_in_tns__submitGameThreadResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitGameThread"))
		{	*type = SOAP_TYPE_Annot_tns__submitGameThread;
			return soap_in_tns__submitGameThread(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:setUserLanguageResponse"))
		{	*type = SOAP_TYPE_Annot_tns__setUserLanguageResponse;
			return soap_in_tns__setUserLanguageResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:setUserLanguage"))
		{	*type = SOAP_TYPE_Annot_tns__setUserLanguage;
			return soap_in_tns__setUserLanguage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:setUserAnonymousResponse"))
		{	*type = SOAP_TYPE_Annot_tns__setUserAnonymousResponse;
			return soap_in_tns__setUserAnonymousResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:setUserAnonymous"))
		{	*type = SOAP_TYPE_Annot_tns__setUserAnonymous;
			return soap_in_tns__setUserAnonymous(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectRelatedMediaAnnotationsWithTokenIdResponse"))
		{	*type = SOAP_TYPE_Annot_tns__selectRelatedMediaAnnotationsWithTokenIdResponse;
			return soap_in_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectRelatedMediaAnnotationsWithTokenId"))
		{	*type = SOAP_TYPE_Annot_tns__selectRelatedMediaAnnotationsWithTokenId;
			return soap_in_tns__selectRelatedMediaAnnotationsWithTokenId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectRelatedMediaAliasesWithTokenIdResponse"))
		{	*type = SOAP_TYPE_Annot_tns__selectRelatedMediaAliasesWithTokenIdResponse;
			return soap_in_tns__selectRelatedMediaAliasesWithTokenIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectRelatedMediaAliasesWithTokenId"))
		{	*type = SOAP_TYPE_Annot_tns__selectRelatedMediaAliasesWithTokenId;
			return soap_in_tns__selectRelatedMediaAliasesWithTokenId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectMediaTokenWithIdResponse"))
		{	*type = SOAP_TYPE_Annot_tns__selectMediaTokenWithIdResponse;
			return soap_in_tns__selectMediaTokenWithIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectMediaTokenWithId"))
		{	*type = SOAP_TYPE_Annot_tns__selectMediaTokenWithId;
			return soap_in_tns__selectMediaTokenWithId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectMediaTokenWithDigestResponse"))
		{	*type = SOAP_TYPE_Annot_tns__selectMediaTokenWithDigestResponse;
			return soap_in_tns__selectMediaTokenWithDigestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectMediaTokenWithDigest"))
		{	*type = SOAP_TYPE_Annot_tns__selectMediaTokenWithDigest;
			return soap_in_tns__selectMediaTokenWithDigest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectMediaTokenIdWithUrlResponse"))
		{	*type = SOAP_TYPE_Annot_tns__selectMediaTokenIdWithUrlResponse;
			return soap_in_tns__selectMediaTokenIdWithUrlResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectMediaTokenIdWithUrl"))
		{	*type = SOAP_TYPE_Annot_tns__selectMediaTokenIdWithUrl;
			return soap_in_tns__selectMediaTokenIdWithUrl(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectMediaTokenIdWithDigestResponse"))
		{	*type = SOAP_TYPE_Annot_tns__selectMediaTokenIdWithDigestResponse;
			return soap_in_tns__selectMediaTokenIdWithDigestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectMediaTokenIdWithDigest"))
		{	*type = SOAP_TYPE_Annot_tns__selectMediaTokenIdWithDigest;
			return soap_in_tns__selectMediaTokenIdWithDigest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectMediaAnnotationsWithTokenIdResponse"))
		{	*type = SOAP_TYPE_Annot_tns__selectMediaAnnotationsWithTokenIdResponse;
			return soap_in_tns__selectMediaAnnotationsWithTokenIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectMediaAnnotationsWithTokenId"))
		{	*type = SOAP_TYPE_Annot_tns__selectMediaAnnotationsWithTokenId;
			return soap_in_tns__selectMediaAnnotationsWithTokenId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectMediaAliasesWithTokenIdResponse"))
		{	*type = SOAP_TYPE_Annot_tns__selectMediaAliasesWithTokenIdResponse;
			return soap_in_tns__selectMediaAliasesWithTokenIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectMediaAliasesWithTokenId"))
		{	*type = SOAP_TYPE_Annot_tns__selectMediaAliasesWithTokenId;
			return soap_in_tns__selectMediaAliasesWithTokenId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectGameThreadWithTokenIdResponse"))
		{	*type = SOAP_TYPE_Annot_tns__selectGameThreadWithTokenIdResponse;
			return soap_in_tns__selectGameThreadWithTokenIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectGameThreadWithTokenId"))
		{	*type = SOAP_TYPE_Annot_tns__selectGameThreadWithTokenId;
			return soap_in_tns__selectGameThreadWithTokenId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectGameThreadWithTokenDigestResponse"))
		{	*type = SOAP_TYPE_Annot_tns__selectGameThreadWithTokenDigestResponse;
			return soap_in_tns__selectGameThreadWithTokenDigestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectGameThreadWithTokenDigest"))
		{	*type = SOAP_TYPE_Annot_tns__selectGameThreadWithTokenDigest;
			return soap_in_tns__selectGameThreadWithTokenDigest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:loginResponse"))
		{	*type = SOAP_TYPE_Annot_tns__loginResponse;
			return soap_in_tns__loginResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:login"))
		{	*type = SOAP_TYPE_Annot_tns__login;
			return soap_in_tns__login(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:isLatestAppResponse"))
		{	*type = SOAP_TYPE_Annot_tns__isLatestAppResponse;
			return soap_in_tns__isLatestAppResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:isLatestApp"))
		{	*type = SOAP_TYPE_Annot_tns__isLatestApp;
			return soap_in_tns__isLatestApp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:isConnectedResponse"))
		{	*type = SOAP_TYPE_Annot_tns__isConnectedResponse;
			return soap_in_tns__isConnectedResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:isConnected"))
		{	*type = SOAP_TYPE_Annot_tns__isConnected;
			return soap_in_tns__isConnected(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:isAuthorizedResponse"))
		{	*type = SOAP_TYPE_Annot_tns__isAuthorizedResponse;
			return soap_in_tns__isAuthorizedResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:isAuthorized"))
		{	*type = SOAP_TYPE_Annot_tns__isAuthorized;
			return soap_in_tns__isAuthorized(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:getUserResponse"))
		{	*type = SOAP_TYPE_Annot_tns__getUserResponse;
			return soap_in_tns__getUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:getUser"))
		{	*type = SOAP_TYPE_Annot_tns__getUser;
			return soap_in_tns__getUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:deleteMediaAnnotationWithIdResponse"))
		{	*type = SOAP_TYPE_Annot_tns__deleteMediaAnnotationWithIdResponse;
			return soap_in_tns__deleteMediaAnnotationWithIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:deleteMediaAnnotationWithId"))
		{	*type = SOAP_TYPE_Annot_tns__deleteMediaAnnotationWithId;
			return soap_in_tns__deleteMediaAnnotationWithId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:deleteMediaAliasWithIdResponse"))
		{	*type = SOAP_TYPE_Annot_tns__deleteMediaAliasWithIdResponse;
			return soap_in_tns__deleteMediaAliasWithIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:deleteMediaAliasWithId"))
		{	*type = SOAP_TYPE_Annot_tns__deleteMediaAliasWithId;
			return soap_in_tns__deleteMediaAliasWithId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:curseUserWithIdResponse"))
		{	*type = SOAP_TYPE_Annot_tns__curseUserWithIdResponse;
			return soap_in_tns__curseUserWithIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:curseUserWithId"))
		{	*type = SOAP_TYPE_Annot_tns__curseUserWithId;
			return soap_in_tns__curseUserWithId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:curseMediaTokenWithIdResponse"))
		{	*type = SOAP_TYPE_Annot_tns__curseMediaTokenWithIdResponse;
			return soap_in_tns__curseMediaTokenWithIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:curseMediaTokenWithId"))
		{	*type = SOAP_TYPE_Annot_tns__curseMediaTokenWithId;
			return soap_in_tns__curseMediaTokenWithId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:curseMediaAnnotationWithIdResponse"))
		{	*type = SOAP_TYPE_Annot_tns__curseMediaAnnotationWithIdResponse;
			return soap_in_tns__curseMediaAnnotationWithIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:curseMediaAnnotationWithId"))
		{	*type = SOAP_TYPE_Annot_tns__curseMediaAnnotationWithId;
			return soap_in_tns__curseMediaAnnotationWithId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:curseMediaAliasWithIdResponse"))
		{	*type = SOAP_TYPE_Annot_tns__curseMediaAliasWithIdResponse;
			return soap_in_tns__curseMediaAliasWithIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:curseMediaAliasWithId"))
		{	*type = SOAP_TYPE_Annot_tns__curseMediaAliasWithId;
			return soap_in_tns__curseMediaAliasWithId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:chatResponse"))
		{	*type = SOAP_TYPE_Annot_tns__chatResponse;
			return soap_in_tns__chatResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:chat"))
		{	*type = SOAP_TYPE_Annot_tns__chat;
			return soap_in_tns__chat(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:blockUserWithIdResponse"))
		{	*type = SOAP_TYPE_Annot_tns__blockUserWithIdResponse;
			return soap_in_tns__blockUserWithIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:blockUserWithId"))
		{	*type = SOAP_TYPE_Annot_tns__blockUserWithId;
			return soap_in_tns__blockUserWithId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:blockMediaAnnotationWithIdResponse"))
		{	*type = SOAP_TYPE_Annot_tns__blockMediaAnnotationWithIdResponse;
			return soap_in_tns__blockMediaAnnotationWithIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:blockMediaAnnotationWithId"))
		{	*type = SOAP_TYPE_Annot_tns__blockMediaAnnotationWithId;
			return soap_in_tns__blockMediaAnnotationWithId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:blockMediaAliasWithIdResponse"))
		{	*type = SOAP_TYPE_Annot_tns__blockMediaAliasWithIdResponse;
			return soap_in_tns__blockMediaAliasWithIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:blockMediaAliasWithId"))
		{	*type = SOAP_TYPE_Annot_tns__blockMediaAliasWithId;
			return soap_in_tns__blockMediaAliasWithId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:blessUserWithIdResponse"))
		{	*type = SOAP_TYPE_Annot_tns__blessUserWithIdResponse;
			return soap_in_tns__blessUserWithIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:blessUserWithId"))
		{	*type = SOAP_TYPE_Annot_tns__blessUserWithId;
			return soap_in_tns__blessUserWithId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:blessMediaTokenWithIdResponse"))
		{	*type = SOAP_TYPE_Annot_tns__blessMediaTokenWithIdResponse;
			return soap_in_tns__blessMediaTokenWithIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:blessMediaTokenWithId"))
		{	*type = SOAP_TYPE_Annot_tns__blessMediaTokenWithId;
			return soap_in_tns__blessMediaTokenWithId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:blessMediaAnnotationWithIdResponse"))
		{	*type = SOAP_TYPE_Annot_tns__blessMediaAnnotationWithIdResponse;
			return soap_in_tns__blessMediaAnnotationWithIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:blessMediaAnnotationWithId"))
		{	*type = SOAP_TYPE_Annot_tns__blessMediaAnnotationWithId;
			return soap_in_tns__blessMediaAnnotationWithId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:blessMediaAliasWithIdResponse"))
		{	*type = SOAP_TYPE_Annot_tns__blessMediaAliasWithIdResponse;
			return soap_in_tns__blessMediaAliasWithIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:blessMediaAliasWithId"))
		{	*type = SOAP_TYPE_Annot_tns__blessMediaAliasWithId;
			return soap_in_tns__blessMediaAliasWithId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:user"))
		{	*type = SOAP_TYPE_Annot_tns__user;
			return soap_in_tns__user(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:mediaAlias"))
		{	*type = SOAP_TYPE_Annot_tns__mediaAlias;
			return soap_in_tns__mediaAlias(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:mediaToken"))
		{	*type = SOAP_TYPE_Annot_tns__mediaToken;
			return soap_in_tns__mediaToken(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:mediaAnnotation"))
		{	*type = SOAP_TYPE_Annot_tns__mediaAnnotation;
			return soap_in_tns__mediaAnnotation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:gameThread"))
		{	*type = SOAP_TYPE_Annot_tns__gameThread;
			return soap_in_tns__gameThread(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_Annot_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_Annot_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_Annot_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_Annot_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE_Annot__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_Annot_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_Annot_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_Annot_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_Annot_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_Annot_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_Annot_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_Annot_tns__updateMediaAnnotationUserIdWithIdResponse:
		return ((tns__updateMediaAnnotationUserIdWithIdResponse *)ptr)->soap_out(soap, tag, id, "tns:updateMediaAnnotationUserIdWithIdResponse");
	case SOAP_TYPE_Annot_tns__updateMediaAnnotationUserIdWithId:
		return ((tns__updateMediaAnnotationUserIdWithId *)ptr)->soap_out(soap, tag, id, "tns:updateMediaAnnotationUserIdWithId");
	case SOAP_TYPE_Annot_tns__updateMediaAnnotationTextWithIdResponse:
		return ((tns__updateMediaAnnotationTextWithIdResponse *)ptr)->soap_out(soap, tag, id, "tns:updateMediaAnnotationTextWithIdResponse");
	case SOAP_TYPE_Annot_tns__updateMediaAnnotationTextWithId:
		return ((tns__updateMediaAnnotationTextWithId *)ptr)->soap_out(soap, tag, id, "tns:updateMediaAnnotationTextWithId");
	case SOAP_TYPE_Annot_tns__updateMediaAnnotationLanguageWithIdResponse:
		return ((tns__updateMediaAnnotationLanguageWithIdResponse *)ptr)->soap_out(soap, tag, id, "tns:updateMediaAnnotationLanguageWithIdResponse");
	case SOAP_TYPE_Annot_tns__updateMediaAnnotationLanguageWithId:
		return ((tns__updateMediaAnnotationLanguageWithId *)ptr)->soap_out(soap, tag, id, "tns:updateMediaAnnotationLanguageWithId");
	case SOAP_TYPE_Annot_tns__updateGameThreadResponse:
		return ((tns__updateGameThreadResponse *)ptr)->soap_out(soap, tag, id, "tns:updateGameThreadResponse");
	case SOAP_TYPE_Annot_tns__updateGameThread:
		return ((tns__updateGameThread *)ptr)->soap_out(soap, tag, id, "tns:updateGameThread");
	case SOAP_TYPE_Annot_tns__submitMediaTokenUrlResponse:
		return ((tns__submitMediaTokenUrlResponse *)ptr)->soap_out(soap, tag, id, "tns:submitMediaTokenUrlResponse");
	case SOAP_TYPE_Annot_tns__submitMediaTokenUrl:
		return ((tns__submitMediaTokenUrl *)ptr)->soap_out(soap, tag, id, "tns:submitMediaTokenUrl");
	case SOAP_TYPE_Annot_tns__submitMediaTokenDigestResponse:
		return ((tns__submitMediaTokenDigestResponse *)ptr)->soap_out(soap, tag, id, "tns:submitMediaTokenDigestResponse");
	case SOAP_TYPE_Annot_tns__submitMediaTokenDigest:
		return ((tns__submitMediaTokenDigest *)ptr)->soap_out(soap, tag, id, "tns:submitMediaTokenDigest");
	case SOAP_TYPE_Annot_tns__submitMediaTokenResponse:
		return ((tns__submitMediaTokenResponse *)ptr)->soap_out(soap, tag, id, "tns:submitMediaTokenResponse");
	case SOAP_TYPE_Annot_tns__submitMediaToken:
		return ((tns__submitMediaToken *)ptr)->soap_out(soap, tag, id, "tns:submitMediaToken");
	case SOAP_TYPE_Annot_tns__submitMediaAnnotationTextWithTokenIdResponse:
		return ((tns__submitMediaAnnotationTextWithTokenIdResponse *)ptr)->soap_out(soap, tag, id, "tns:submitMediaAnnotationTextWithTokenIdResponse");
	case SOAP_TYPE_Annot_tns__submitMediaAnnotationTextWithTokenId:
		return ((tns__submitMediaAnnotationTextWithTokenId *)ptr)->soap_out(soap, tag, id, "tns:submitMediaAnnotationTextWithTokenId");
	case SOAP_TYPE_Annot_tns__submitMediaAnnotationTextAndTokenDigestResponse:
		return ((tns__submitMediaAnnotationTextAndTokenDigestResponse *)ptr)->soap_out(soap, tag, id, "tns:submitMediaAnnotationTextAndTokenDigestResponse");
	case SOAP_TYPE_Annot_tns__submitMediaAnnotationTextAndTokenDigest:
		return ((tns__submitMediaAnnotationTextAndTokenDigest *)ptr)->soap_out(soap, tag, id, "tns:submitMediaAnnotationTextAndTokenDigest");
	case SOAP_TYPE_Annot_tns__submitMediaAnnotationResponse:
		return ((tns__submitMediaAnnotationResponse *)ptr)->soap_out(soap, tag, id, "tns:submitMediaAnnotationResponse");
	case SOAP_TYPE_Annot_tns__submitMediaAnnotation:
		return ((tns__submitMediaAnnotation *)ptr)->soap_out(soap, tag, id, "tns:submitMediaAnnotation");
	case SOAP_TYPE_Annot_tns__submitMediaAliasTextWithTokenIdResponse:
		return ((tns__submitMediaAliasTextWithTokenIdResponse *)ptr)->soap_out(soap, tag, id, "tns:submitMediaAliasTextWithTokenIdResponse");
	case SOAP_TYPE_Annot_tns__submitMediaAliasTextWithTokenId:
		return ((tns__submitMediaAliasTextWithTokenId *)ptr)->soap_out(soap, tag, id, "tns:submitMediaAliasTextWithTokenId");
	case SOAP_TYPE_Annot_tns__submitMediaAliasTextAndTokenDigestResponse:
		return ((tns__submitMediaAliasTextAndTokenDigestResponse *)ptr)->soap_out(soap, tag, id, "tns:submitMediaAliasTextAndTokenDigestResponse");
	case SOAP_TYPE_Annot_tns__submitMediaAliasTextAndTokenDigest:
		return ((tns__submitMediaAliasTextAndTokenDigest *)ptr)->soap_out(soap, tag, id, "tns:submitMediaAliasTextAndTokenDigest");
	case SOAP_TYPE_Annot_tns__submitMediaAliasResponse:
		return ((tns__submitMediaAliasResponse *)ptr)->soap_out(soap, tag, id, "tns:submitMediaAliasResponse");
	case SOAP_TYPE_Annot_tns__submitMediaAlias:
		return ((tns__submitMediaAlias *)ptr)->soap_out(soap, tag, id, "tns:submitMediaAlias");
	case SOAP_TYPE_Annot_tns__submitGameThreadResponse:
		return ((tns__submitGameThreadResponse *)ptr)->soap_out(soap, tag, id, "tns:submitGameThreadResponse");
	case SOAP_TYPE_Annot_tns__submitGameThread:
		return ((tns__submitGameThread *)ptr)->soap_out(soap, tag, id, "tns:submitGameThread");
	case SOAP_TYPE_Annot_tns__setUserLanguageResponse:
		return ((tns__setUserLanguageResponse *)ptr)->soap_out(soap, tag, id, "tns:setUserLanguageResponse");
	case SOAP_TYPE_Annot_tns__setUserLanguage:
		return ((tns__setUserLanguage *)ptr)->soap_out(soap, tag, id, "tns:setUserLanguage");
	case SOAP_TYPE_Annot_tns__setUserAnonymousResponse:
		return ((tns__setUserAnonymousResponse *)ptr)->soap_out(soap, tag, id, "tns:setUserAnonymousResponse");
	case SOAP_TYPE_Annot_tns__setUserAnonymous:
		return ((tns__setUserAnonymous *)ptr)->soap_out(soap, tag, id, "tns:setUserAnonymous");
	case SOAP_TYPE_Annot_tns__selectRelatedMediaAnnotationsWithTokenIdResponse:
		return ((tns__selectRelatedMediaAnnotationsWithTokenIdResponse *)ptr)->soap_out(soap, tag, id, "tns:selectRelatedMediaAnnotationsWithTokenIdResponse");
	case SOAP_TYPE_Annot_tns__selectRelatedMediaAnnotationsWithTokenId:
		return ((tns__selectRelatedMediaAnnotationsWithTokenId *)ptr)->soap_out(soap, tag, id, "tns:selectRelatedMediaAnnotationsWithTokenId");
	case SOAP_TYPE_Annot_tns__selectRelatedMediaAliasesWithTokenIdResponse:
		return ((tns__selectRelatedMediaAliasesWithTokenIdResponse *)ptr)->soap_out(soap, tag, id, "tns:selectRelatedMediaAliasesWithTokenIdResponse");
	case SOAP_TYPE_Annot_tns__selectRelatedMediaAliasesWithTokenId:
		return ((tns__selectRelatedMediaAliasesWithTokenId *)ptr)->soap_out(soap, tag, id, "tns:selectRelatedMediaAliasesWithTokenId");
	case SOAP_TYPE_Annot_tns__selectMediaTokenWithIdResponse:
		return ((tns__selectMediaTokenWithIdResponse *)ptr)->soap_out(soap, tag, id, "tns:selectMediaTokenWithIdResponse");
	case SOAP_TYPE_Annot_tns__selectMediaTokenWithId:
		return ((tns__selectMediaTokenWithId *)ptr)->soap_out(soap, tag, id, "tns:selectMediaTokenWithId");
	case SOAP_TYPE_Annot_tns__selectMediaTokenWithDigestResponse:
		return ((tns__selectMediaTokenWithDigestResponse *)ptr)->soap_out(soap, tag, id, "tns:selectMediaTokenWithDigestResponse");
	case SOAP_TYPE_Annot_tns__selectMediaTokenWithDigest:
		return ((tns__selectMediaTokenWithDigest *)ptr)->soap_out(soap, tag, id, "tns:selectMediaTokenWithDigest");
	case SOAP_TYPE_Annot_tns__selectMediaTokenIdWithUrlResponse:
		return ((tns__selectMediaTokenIdWithUrlResponse *)ptr)->soap_out(soap, tag, id, "tns:selectMediaTokenIdWithUrlResponse");
	case SOAP_TYPE_Annot_tns__selectMediaTokenIdWithUrl:
		return ((tns__selectMediaTokenIdWithUrl *)ptr)->soap_out(soap, tag, id, "tns:selectMediaTokenIdWithUrl");
	case SOAP_TYPE_Annot_tns__selectMediaTokenIdWithDigestResponse:
		return ((tns__selectMediaTokenIdWithDigestResponse *)ptr)->soap_out(soap, tag, id, "tns:selectMediaTokenIdWithDigestResponse");
	case SOAP_TYPE_Annot_tns__selectMediaTokenIdWithDigest:
		return ((tns__selectMediaTokenIdWithDigest *)ptr)->soap_out(soap, tag, id, "tns:selectMediaTokenIdWithDigest");
	case SOAP_TYPE_Annot_tns__selectMediaAnnotationsWithTokenIdResponse:
		return ((tns__selectMediaAnnotationsWithTokenIdResponse *)ptr)->soap_out(soap, tag, id, "tns:selectMediaAnnotationsWithTokenIdResponse");
	case SOAP_TYPE_Annot_tns__selectMediaAnnotationsWithTokenId:
		return ((tns__selectMediaAnnotationsWithTokenId *)ptr)->soap_out(soap, tag, id, "tns:selectMediaAnnotationsWithTokenId");
	case SOAP_TYPE_Annot_tns__selectMediaAliasesWithTokenIdResponse:
		return ((tns__selectMediaAliasesWithTokenIdResponse *)ptr)->soap_out(soap, tag, id, "tns:selectMediaAliasesWithTokenIdResponse");
	case SOAP_TYPE_Annot_tns__selectMediaAliasesWithTokenId:
		return ((tns__selectMediaAliasesWithTokenId *)ptr)->soap_out(soap, tag, id, "tns:selectMediaAliasesWithTokenId");
	case SOAP_TYPE_Annot_tns__selectGameThreadWithTokenIdResponse:
		return ((tns__selectGameThreadWithTokenIdResponse *)ptr)->soap_out(soap, tag, id, "tns:selectGameThreadWithTokenIdResponse");
	case SOAP_TYPE_Annot_tns__selectGameThreadWithTokenId:
		return ((tns__selectGameThreadWithTokenId *)ptr)->soap_out(soap, tag, id, "tns:selectGameThreadWithTokenId");
	case SOAP_TYPE_Annot_tns__selectGameThreadWithTokenDigestResponse:
		return ((tns__selectGameThreadWithTokenDigestResponse *)ptr)->soap_out(soap, tag, id, "tns:selectGameThreadWithTokenDigestResponse");
	case SOAP_TYPE_Annot_tns__selectGameThreadWithTokenDigest:
		return ((tns__selectGameThreadWithTokenDigest *)ptr)->soap_out(soap, tag, id, "tns:selectGameThreadWithTokenDigest");
	case SOAP_TYPE_Annot_tns__loginResponse:
		return ((tns__loginResponse *)ptr)->soap_out(soap, tag, id, "tns:loginResponse");
	case SOAP_TYPE_Annot_tns__login:
		return ((tns__login *)ptr)->soap_out(soap, tag, id, "tns:login");
	case SOAP_TYPE_Annot_tns__isLatestAppResponse:
		return ((tns__isLatestAppResponse *)ptr)->soap_out(soap, tag, id, "tns:isLatestAppResponse");
	case SOAP_TYPE_Annot_tns__isLatestApp:
		return ((tns__isLatestApp *)ptr)->soap_out(soap, tag, id, "tns:isLatestApp");
	case SOAP_TYPE_Annot_tns__isConnectedResponse:
		return ((tns__isConnectedResponse *)ptr)->soap_out(soap, tag, id, "tns:isConnectedResponse");
	case SOAP_TYPE_Annot_tns__isConnected:
		return ((tns__isConnected *)ptr)->soap_out(soap, tag, id, "tns:isConnected");
	case SOAP_TYPE_Annot_tns__isAuthorizedResponse:
		return ((tns__isAuthorizedResponse *)ptr)->soap_out(soap, tag, id, "tns:isAuthorizedResponse");
	case SOAP_TYPE_Annot_tns__isAuthorized:
		return ((tns__isAuthorized *)ptr)->soap_out(soap, tag, id, "tns:isAuthorized");
	case SOAP_TYPE_Annot_tns__getUserResponse:
		return ((tns__getUserResponse *)ptr)->soap_out(soap, tag, id, "tns:getUserResponse");
	case SOAP_TYPE_Annot_tns__getUser:
		return ((tns__getUser *)ptr)->soap_out(soap, tag, id, "tns:getUser");
	case SOAP_TYPE_Annot_tns__deleteMediaAnnotationWithIdResponse:
		return ((tns__deleteMediaAnnotationWithIdResponse *)ptr)->soap_out(soap, tag, id, "tns:deleteMediaAnnotationWithIdResponse");
	case SOAP_TYPE_Annot_tns__deleteMediaAnnotationWithId:
		return ((tns__deleteMediaAnnotationWithId *)ptr)->soap_out(soap, tag, id, "tns:deleteMediaAnnotationWithId");
	case SOAP_TYPE_Annot_tns__deleteMediaAliasWithIdResponse:
		return ((tns__deleteMediaAliasWithIdResponse *)ptr)->soap_out(soap, tag, id, "tns:deleteMediaAliasWithIdResponse");
	case SOAP_TYPE_Annot_tns__deleteMediaAliasWithId:
		return ((tns__deleteMediaAliasWithId *)ptr)->soap_out(soap, tag, id, "tns:deleteMediaAliasWithId");
	case SOAP_TYPE_Annot_tns__curseUserWithIdResponse:
		return ((tns__curseUserWithIdResponse *)ptr)->soap_out(soap, tag, id, "tns:curseUserWithIdResponse");
	case SOAP_TYPE_Annot_tns__curseUserWithId:
		return ((tns__curseUserWithId *)ptr)->soap_out(soap, tag, id, "tns:curseUserWithId");
	case SOAP_TYPE_Annot_tns__curseMediaTokenWithIdResponse:
		return ((tns__curseMediaTokenWithIdResponse *)ptr)->soap_out(soap, tag, id, "tns:curseMediaTokenWithIdResponse");
	case SOAP_TYPE_Annot_tns__curseMediaTokenWithId:
		return ((tns__curseMediaTokenWithId *)ptr)->soap_out(soap, tag, id, "tns:curseMediaTokenWithId");
	case SOAP_TYPE_Annot_tns__curseMediaAnnotationWithIdResponse:
		return ((tns__curseMediaAnnotationWithIdResponse *)ptr)->soap_out(soap, tag, id, "tns:curseMediaAnnotationWithIdResponse");
	case SOAP_TYPE_Annot_tns__curseMediaAnnotationWithId:
		return ((tns__curseMediaAnnotationWithId *)ptr)->soap_out(soap, tag, id, "tns:curseMediaAnnotationWithId");
	case SOAP_TYPE_Annot_tns__curseMediaAliasWithIdResponse:
		return ((tns__curseMediaAliasWithIdResponse *)ptr)->soap_out(soap, tag, id, "tns:curseMediaAliasWithIdResponse");
	case SOAP_TYPE_Annot_tns__curseMediaAliasWithId:
		return ((tns__curseMediaAliasWithId *)ptr)->soap_out(soap, tag, id, "tns:curseMediaAliasWithId");
	case SOAP_TYPE_Annot_tns__chatResponse:
		return ((tns__chatResponse *)ptr)->soap_out(soap, tag, id, "tns:chatResponse");
	case SOAP_TYPE_Annot_tns__chat:
		return ((tns__chat *)ptr)->soap_out(soap, tag, id, "tns:chat");
	case SOAP_TYPE_Annot_tns__blockUserWithIdResponse:
		return ((tns__blockUserWithIdResponse *)ptr)->soap_out(soap, tag, id, "tns:blockUserWithIdResponse");
	case SOAP_TYPE_Annot_tns__blockUserWithId:
		return ((tns__blockUserWithId *)ptr)->soap_out(soap, tag, id, "tns:blockUserWithId");
	case SOAP_TYPE_Annot_tns__blockMediaAnnotationWithIdResponse:
		return ((tns__blockMediaAnnotationWithIdResponse *)ptr)->soap_out(soap, tag, id, "tns:blockMediaAnnotationWithIdResponse");
	case SOAP_TYPE_Annot_tns__blockMediaAnnotationWithId:
		return ((tns__blockMediaAnnotationWithId *)ptr)->soap_out(soap, tag, id, "tns:blockMediaAnnotationWithId");
	case SOAP_TYPE_Annot_tns__blockMediaAliasWithIdResponse:
		return ((tns__blockMediaAliasWithIdResponse *)ptr)->soap_out(soap, tag, id, "tns:blockMediaAliasWithIdResponse");
	case SOAP_TYPE_Annot_tns__blockMediaAliasWithId:
		return ((tns__blockMediaAliasWithId *)ptr)->soap_out(soap, tag, id, "tns:blockMediaAliasWithId");
	case SOAP_TYPE_Annot_tns__blessUserWithIdResponse:
		return ((tns__blessUserWithIdResponse *)ptr)->soap_out(soap, tag, id, "tns:blessUserWithIdResponse");
	case SOAP_TYPE_Annot_tns__blessUserWithId:
		return ((tns__blessUserWithId *)ptr)->soap_out(soap, tag, id, "tns:blessUserWithId");
	case SOAP_TYPE_Annot_tns__blessMediaTokenWithIdResponse:
		return ((tns__blessMediaTokenWithIdResponse *)ptr)->soap_out(soap, tag, id, "tns:blessMediaTokenWithIdResponse");
	case SOAP_TYPE_Annot_tns__blessMediaTokenWithId:
		return ((tns__blessMediaTokenWithId *)ptr)->soap_out(soap, tag, id, "tns:blessMediaTokenWithId");
	case SOAP_TYPE_Annot_tns__blessMediaAnnotationWithIdResponse:
		return ((tns__blessMediaAnnotationWithIdResponse *)ptr)->soap_out(soap, tag, id, "tns:blessMediaAnnotationWithIdResponse");
	case SOAP_TYPE_Annot_tns__blessMediaAnnotationWithId:
		return ((tns__blessMediaAnnotationWithId *)ptr)->soap_out(soap, tag, id, "tns:blessMediaAnnotationWithId");
	case SOAP_TYPE_Annot_tns__blessMediaAliasWithIdResponse:
		return ((tns__blessMediaAliasWithIdResponse *)ptr)->soap_out(soap, tag, id, "tns:blessMediaAliasWithIdResponse");
	case SOAP_TYPE_Annot_tns__blessMediaAliasWithId:
		return ((tns__blessMediaAliasWithId *)ptr)->soap_out(soap, tag, id, "tns:blessMediaAliasWithId");
	case SOAP_TYPE_Annot_tns__user:
		return ((tns__user *)ptr)->soap_out(soap, tag, id, "tns:user");
	case SOAP_TYPE_Annot_tns__mediaAlias:
		return ((tns__mediaAlias *)ptr)->soap_out(soap, tag, id, "tns:mediaAlias");
	case SOAP_TYPE_Annot_tns__mediaToken:
		return ((tns__mediaToken *)ptr)->soap_out(soap, tag, id, "tns:mediaToken");
	case SOAP_TYPE_Annot_tns__mediaAnnotation:
		return ((tns__mediaAnnotation *)ptr)->soap_out(soap, tag, id, "tns:mediaAnnotation");
	case SOAP_TYPE_Annot_tns__gameThread:
		return ((tns__gameThread *)ptr)->soap_out(soap, tag, id, "tns:gameThread");
	case SOAP_TYPE_Annot_PointerTotns__updateMediaAnnotationUserIdWithIdResponse:
		return soap_out_PointerTotns__updateMediaAnnotationUserIdWithIdResponse(soap, tag, id, (tns__updateMediaAnnotationUserIdWithIdResponse *const*)ptr, "tns:updateMediaAnnotationUserIdWithIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__updateMediaAnnotationUserIdWithId:
		return soap_out_PointerTotns__updateMediaAnnotationUserIdWithId(soap, tag, id, (tns__updateMediaAnnotationUserIdWithId *const*)ptr, "tns:updateMediaAnnotationUserIdWithId");
	case SOAP_TYPE_Annot_PointerTotns__updateMediaAnnotationTextWithIdResponse:
		return soap_out_PointerTotns__updateMediaAnnotationTextWithIdResponse(soap, tag, id, (tns__updateMediaAnnotationTextWithIdResponse *const*)ptr, "tns:updateMediaAnnotationTextWithIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__updateMediaAnnotationTextWithId:
		return soap_out_PointerTotns__updateMediaAnnotationTextWithId(soap, tag, id, (tns__updateMediaAnnotationTextWithId *const*)ptr, "tns:updateMediaAnnotationTextWithId");
	case SOAP_TYPE_Annot_PointerTotns__updateMediaAnnotationLanguageWithIdResponse:
		return soap_out_PointerTotns__updateMediaAnnotationLanguageWithIdResponse(soap, tag, id, (tns__updateMediaAnnotationLanguageWithIdResponse *const*)ptr, "tns:updateMediaAnnotationLanguageWithIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__updateMediaAnnotationLanguageWithId:
		return soap_out_PointerTotns__updateMediaAnnotationLanguageWithId(soap, tag, id, (tns__updateMediaAnnotationLanguageWithId *const*)ptr, "tns:updateMediaAnnotationLanguageWithId");
	case SOAP_TYPE_Annot_PointerTotns__updateGameThreadResponse:
		return soap_out_PointerTotns__updateGameThreadResponse(soap, tag, id, (tns__updateGameThreadResponse *const*)ptr, "tns:updateGameThreadResponse");
	case SOAP_TYPE_Annot_PointerTotns__updateGameThread:
		return soap_out_PointerTotns__updateGameThread(soap, tag, id, (tns__updateGameThread *const*)ptr, "tns:updateGameThread");
	case SOAP_TYPE_Annot_PointerTotns__submitMediaTokenUrlResponse:
		return soap_out_PointerTotns__submitMediaTokenUrlResponse(soap, tag, id, (tns__submitMediaTokenUrlResponse *const*)ptr, "tns:submitMediaTokenUrlResponse");
	case SOAP_TYPE_Annot_PointerTotns__submitMediaTokenUrl:
		return soap_out_PointerTotns__submitMediaTokenUrl(soap, tag, id, (tns__submitMediaTokenUrl *const*)ptr, "tns:submitMediaTokenUrl");
	case SOAP_TYPE_Annot_PointerTotns__submitMediaTokenDigestResponse:
		return soap_out_PointerTotns__submitMediaTokenDigestResponse(soap, tag, id, (tns__submitMediaTokenDigestResponse *const*)ptr, "tns:submitMediaTokenDigestResponse");
	case SOAP_TYPE_Annot_PointerTotns__submitMediaTokenDigest:
		return soap_out_PointerTotns__submitMediaTokenDigest(soap, tag, id, (tns__submitMediaTokenDigest *const*)ptr, "tns:submitMediaTokenDigest");
	case SOAP_TYPE_Annot_PointerTotns__submitMediaTokenResponse:
		return soap_out_PointerTotns__submitMediaTokenResponse(soap, tag, id, (tns__submitMediaTokenResponse *const*)ptr, "tns:submitMediaTokenResponse");
	case SOAP_TYPE_Annot_PointerTotns__submitMediaToken:
		return soap_out_PointerTotns__submitMediaToken(soap, tag, id, (tns__submitMediaToken *const*)ptr, "tns:submitMediaToken");
	case SOAP_TYPE_Annot_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse:
		return soap_out_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse(soap, tag, id, (tns__submitMediaAnnotationTextWithTokenIdResponse *const*)ptr, "tns:submitMediaAnnotationTextWithTokenIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__submitMediaAnnotationTextWithTokenId:
		return soap_out_PointerTotns__submitMediaAnnotationTextWithTokenId(soap, tag, id, (tns__submitMediaAnnotationTextWithTokenId *const*)ptr, "tns:submitMediaAnnotationTextWithTokenId");
	case SOAP_TYPE_Annot_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse:
		return soap_out_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse(soap, tag, id, (tns__submitMediaAnnotationTextAndTokenDigestResponse *const*)ptr, "tns:submitMediaAnnotationTextAndTokenDigestResponse");
	case SOAP_TYPE_Annot_PointerTotns__submitMediaAnnotationTextAndTokenDigest:
		return soap_out_PointerTotns__submitMediaAnnotationTextAndTokenDigest(soap, tag, id, (tns__submitMediaAnnotationTextAndTokenDigest *const*)ptr, "tns:submitMediaAnnotationTextAndTokenDigest");
	case SOAP_TYPE_Annot_PointerTotns__submitMediaAnnotationResponse:
		return soap_out_PointerTotns__submitMediaAnnotationResponse(soap, tag, id, (tns__submitMediaAnnotationResponse *const*)ptr, "tns:submitMediaAnnotationResponse");
	case SOAP_TYPE_Annot_PointerTotns__submitMediaAnnotation:
		return soap_out_PointerTotns__submitMediaAnnotation(soap, tag, id, (tns__submitMediaAnnotation *const*)ptr, "tns:submitMediaAnnotation");
	case SOAP_TYPE_Annot_PointerTotns__submitMediaAliasTextWithTokenIdResponse:
		return soap_out_PointerTotns__submitMediaAliasTextWithTokenIdResponse(soap, tag, id, (tns__submitMediaAliasTextWithTokenIdResponse *const*)ptr, "tns:submitMediaAliasTextWithTokenIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__submitMediaAliasTextWithTokenId:
		return soap_out_PointerTotns__submitMediaAliasTextWithTokenId(soap, tag, id, (tns__submitMediaAliasTextWithTokenId *const*)ptr, "tns:submitMediaAliasTextWithTokenId");
	case SOAP_TYPE_Annot_PointerTotns__submitMediaAliasTextAndTokenDigestResponse:
		return soap_out_PointerTotns__submitMediaAliasTextAndTokenDigestResponse(soap, tag, id, (tns__submitMediaAliasTextAndTokenDigestResponse *const*)ptr, "tns:submitMediaAliasTextAndTokenDigestResponse");
	case SOAP_TYPE_Annot_PointerTotns__submitMediaAliasTextAndTokenDigest:
		return soap_out_PointerTotns__submitMediaAliasTextAndTokenDigest(soap, tag, id, (tns__submitMediaAliasTextAndTokenDigest *const*)ptr, "tns:submitMediaAliasTextAndTokenDigest");
	case SOAP_TYPE_Annot_PointerTotns__submitMediaAliasResponse:
		return soap_out_PointerTotns__submitMediaAliasResponse(soap, tag, id, (tns__submitMediaAliasResponse *const*)ptr, "tns:submitMediaAliasResponse");
	case SOAP_TYPE_Annot_PointerTotns__submitMediaAlias:
		return soap_out_PointerTotns__submitMediaAlias(soap, tag, id, (tns__submitMediaAlias *const*)ptr, "tns:submitMediaAlias");
	case SOAP_TYPE_Annot_PointerTotns__submitGameThreadResponse:
		return soap_out_PointerTotns__submitGameThreadResponse(soap, tag, id, (tns__submitGameThreadResponse *const*)ptr, "tns:submitGameThreadResponse");
	case SOAP_TYPE_Annot_PointerTotns__submitGameThread:
		return soap_out_PointerTotns__submitGameThread(soap, tag, id, (tns__submitGameThread *const*)ptr, "tns:submitGameThread");
	case SOAP_TYPE_Annot_PointerTotns__setUserLanguageResponse:
		return soap_out_PointerTotns__setUserLanguageResponse(soap, tag, id, (tns__setUserLanguageResponse *const*)ptr, "tns:setUserLanguageResponse");
	case SOAP_TYPE_Annot_PointerTotns__setUserLanguage:
		return soap_out_PointerTotns__setUserLanguage(soap, tag, id, (tns__setUserLanguage *const*)ptr, "tns:setUserLanguage");
	case SOAP_TYPE_Annot_PointerTotns__setUserAnonymousResponse:
		return soap_out_PointerTotns__setUserAnonymousResponse(soap, tag, id, (tns__setUserAnonymousResponse *const*)ptr, "tns:setUserAnonymousResponse");
	case SOAP_TYPE_Annot_PointerTotns__setUserAnonymous:
		return soap_out_PointerTotns__setUserAnonymous(soap, tag, id, (tns__setUserAnonymous *const*)ptr, "tns:setUserAnonymous");
	case SOAP_TYPE_Annot_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse:
		return soap_out_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse(soap, tag, id, (tns__selectRelatedMediaAnnotationsWithTokenIdResponse *const*)ptr, "tns:selectRelatedMediaAnnotationsWithTokenIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__selectRelatedMediaAnnotationsWithTokenId:
		return soap_out_PointerTotns__selectRelatedMediaAnnotationsWithTokenId(soap, tag, id, (tns__selectRelatedMediaAnnotationsWithTokenId *const*)ptr, "tns:selectRelatedMediaAnnotationsWithTokenId");
	case SOAP_TYPE_Annot_PointerTotns__selectRelatedMediaAliasesWithTokenIdResponse:
		return soap_out_PointerTotns__selectRelatedMediaAliasesWithTokenIdResponse(soap, tag, id, (tns__selectRelatedMediaAliasesWithTokenIdResponse *const*)ptr, "tns:selectRelatedMediaAliasesWithTokenIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__selectRelatedMediaAliasesWithTokenId:
		return soap_out_PointerTotns__selectRelatedMediaAliasesWithTokenId(soap, tag, id, (tns__selectRelatedMediaAliasesWithTokenId *const*)ptr, "tns:selectRelatedMediaAliasesWithTokenId");
	case SOAP_TYPE_Annot_PointerTotns__selectMediaTokenWithIdResponse:
		return soap_out_PointerTotns__selectMediaTokenWithIdResponse(soap, tag, id, (tns__selectMediaTokenWithIdResponse *const*)ptr, "tns:selectMediaTokenWithIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__selectMediaTokenWithId:
		return soap_out_PointerTotns__selectMediaTokenWithId(soap, tag, id, (tns__selectMediaTokenWithId *const*)ptr, "tns:selectMediaTokenWithId");
	case SOAP_TYPE_Annot_PointerTotns__selectMediaTokenWithDigestResponse:
		return soap_out_PointerTotns__selectMediaTokenWithDigestResponse(soap, tag, id, (tns__selectMediaTokenWithDigestResponse *const*)ptr, "tns:selectMediaTokenWithDigestResponse");
	case SOAP_TYPE_Annot_PointerTotns__selectMediaTokenWithDigest:
		return soap_out_PointerTotns__selectMediaTokenWithDigest(soap, tag, id, (tns__selectMediaTokenWithDigest *const*)ptr, "tns:selectMediaTokenWithDigest");
	case SOAP_TYPE_Annot_PointerTotns__selectMediaTokenIdWithUrlResponse:
		return soap_out_PointerTotns__selectMediaTokenIdWithUrlResponse(soap, tag, id, (tns__selectMediaTokenIdWithUrlResponse *const*)ptr, "tns:selectMediaTokenIdWithUrlResponse");
	case SOAP_TYPE_Annot_PointerTotns__selectMediaTokenIdWithUrl:
		return soap_out_PointerTotns__selectMediaTokenIdWithUrl(soap, tag, id, (tns__selectMediaTokenIdWithUrl *const*)ptr, "tns:selectMediaTokenIdWithUrl");
	case SOAP_TYPE_Annot_PointerTotns__selectMediaTokenIdWithDigestResponse:
		return soap_out_PointerTotns__selectMediaTokenIdWithDigestResponse(soap, tag, id, (tns__selectMediaTokenIdWithDigestResponse *const*)ptr, "tns:selectMediaTokenIdWithDigestResponse");
	case SOAP_TYPE_Annot_PointerTotns__selectMediaTokenIdWithDigest:
		return soap_out_PointerTotns__selectMediaTokenIdWithDigest(soap, tag, id, (tns__selectMediaTokenIdWithDigest *const*)ptr, "tns:selectMediaTokenIdWithDigest");
	case SOAP_TYPE_Annot_PointerTotns__selectMediaAnnotationsWithTokenIdResponse:
		return soap_out_PointerTotns__selectMediaAnnotationsWithTokenIdResponse(soap, tag, id, (tns__selectMediaAnnotationsWithTokenIdResponse *const*)ptr, "tns:selectMediaAnnotationsWithTokenIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__selectMediaAnnotationsWithTokenId:
		return soap_out_PointerTotns__selectMediaAnnotationsWithTokenId(soap, tag, id, (tns__selectMediaAnnotationsWithTokenId *const*)ptr, "tns:selectMediaAnnotationsWithTokenId");
	case SOAP_TYPE_Annot_PointerTotns__selectMediaAliasesWithTokenIdResponse:
		return soap_out_PointerTotns__selectMediaAliasesWithTokenIdResponse(soap, tag, id, (tns__selectMediaAliasesWithTokenIdResponse *const*)ptr, "tns:selectMediaAliasesWithTokenIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__selectMediaAliasesWithTokenId:
		return soap_out_PointerTotns__selectMediaAliasesWithTokenId(soap, tag, id, (tns__selectMediaAliasesWithTokenId *const*)ptr, "tns:selectMediaAliasesWithTokenId");
	case SOAP_TYPE_Annot_PointerTotns__selectGameThreadWithTokenIdResponse:
		return soap_out_PointerTotns__selectGameThreadWithTokenIdResponse(soap, tag, id, (tns__selectGameThreadWithTokenIdResponse *const*)ptr, "tns:selectGameThreadWithTokenIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__selectGameThreadWithTokenId:
		return soap_out_PointerTotns__selectGameThreadWithTokenId(soap, tag, id, (tns__selectGameThreadWithTokenId *const*)ptr, "tns:selectGameThreadWithTokenId");
	case SOAP_TYPE_Annot_PointerTotns__selectGameThreadWithTokenDigestResponse:
		return soap_out_PointerTotns__selectGameThreadWithTokenDigestResponse(soap, tag, id, (tns__selectGameThreadWithTokenDigestResponse *const*)ptr, "tns:selectGameThreadWithTokenDigestResponse");
	case SOAP_TYPE_Annot_PointerTotns__selectGameThreadWithTokenDigest:
		return soap_out_PointerTotns__selectGameThreadWithTokenDigest(soap, tag, id, (tns__selectGameThreadWithTokenDigest *const*)ptr, "tns:selectGameThreadWithTokenDigest");
	case SOAP_TYPE_Annot_PointerTotns__loginResponse:
		return soap_out_PointerTotns__loginResponse(soap, tag, id, (tns__loginResponse *const*)ptr, "tns:loginResponse");
	case SOAP_TYPE_Annot_PointerTotns__login:
		return soap_out_PointerTotns__login(soap, tag, id, (tns__login *const*)ptr, "tns:login");
	case SOAP_TYPE_Annot_PointerTotns__isLatestAppResponse:
		return soap_out_PointerTotns__isLatestAppResponse(soap, tag, id, (tns__isLatestAppResponse *const*)ptr, "tns:isLatestAppResponse");
	case SOAP_TYPE_Annot_PointerTotns__isLatestApp:
		return soap_out_PointerTotns__isLatestApp(soap, tag, id, (tns__isLatestApp *const*)ptr, "tns:isLatestApp");
	case SOAP_TYPE_Annot_PointerTotns__isConnectedResponse:
		return soap_out_PointerTotns__isConnectedResponse(soap, tag, id, (tns__isConnectedResponse *const*)ptr, "tns:isConnectedResponse");
	case SOAP_TYPE_Annot_PointerTotns__isConnected:
		return soap_out_PointerTotns__isConnected(soap, tag, id, (tns__isConnected *const*)ptr, "tns:isConnected");
	case SOAP_TYPE_Annot_PointerTotns__isAuthorizedResponse:
		return soap_out_PointerTotns__isAuthorizedResponse(soap, tag, id, (tns__isAuthorizedResponse *const*)ptr, "tns:isAuthorizedResponse");
	case SOAP_TYPE_Annot_PointerTotns__isAuthorized:
		return soap_out_PointerTotns__isAuthorized(soap, tag, id, (tns__isAuthorized *const*)ptr, "tns:isAuthorized");
	case SOAP_TYPE_Annot_PointerTotns__getUserResponse:
		return soap_out_PointerTotns__getUserResponse(soap, tag, id, (tns__getUserResponse *const*)ptr, "tns:getUserResponse");
	case SOAP_TYPE_Annot_PointerTotns__getUser:
		return soap_out_PointerTotns__getUser(soap, tag, id, (tns__getUser *const*)ptr, "tns:getUser");
	case SOAP_TYPE_Annot_PointerTotns__deleteMediaAnnotationWithIdResponse:
		return soap_out_PointerTotns__deleteMediaAnnotationWithIdResponse(soap, tag, id, (tns__deleteMediaAnnotationWithIdResponse *const*)ptr, "tns:deleteMediaAnnotationWithIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__deleteMediaAnnotationWithId:
		return soap_out_PointerTotns__deleteMediaAnnotationWithId(soap, tag, id, (tns__deleteMediaAnnotationWithId *const*)ptr, "tns:deleteMediaAnnotationWithId");
	case SOAP_TYPE_Annot_PointerTotns__deleteMediaAliasWithIdResponse:
		return soap_out_PointerTotns__deleteMediaAliasWithIdResponse(soap, tag, id, (tns__deleteMediaAliasWithIdResponse *const*)ptr, "tns:deleteMediaAliasWithIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__deleteMediaAliasWithId:
		return soap_out_PointerTotns__deleteMediaAliasWithId(soap, tag, id, (tns__deleteMediaAliasWithId *const*)ptr, "tns:deleteMediaAliasWithId");
	case SOAP_TYPE_Annot_PointerTotns__curseUserWithIdResponse:
		return soap_out_PointerTotns__curseUserWithIdResponse(soap, tag, id, (tns__curseUserWithIdResponse *const*)ptr, "tns:curseUserWithIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__curseUserWithId:
		return soap_out_PointerTotns__curseUserWithId(soap, tag, id, (tns__curseUserWithId *const*)ptr, "tns:curseUserWithId");
	case SOAP_TYPE_Annot_PointerTotns__curseMediaTokenWithIdResponse:
		return soap_out_PointerTotns__curseMediaTokenWithIdResponse(soap, tag, id, (tns__curseMediaTokenWithIdResponse *const*)ptr, "tns:curseMediaTokenWithIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__curseMediaTokenWithId:
		return soap_out_PointerTotns__curseMediaTokenWithId(soap, tag, id, (tns__curseMediaTokenWithId *const*)ptr, "tns:curseMediaTokenWithId");
	case SOAP_TYPE_Annot_PointerTotns__curseMediaAnnotationWithIdResponse:
		return soap_out_PointerTotns__curseMediaAnnotationWithIdResponse(soap, tag, id, (tns__curseMediaAnnotationWithIdResponse *const*)ptr, "tns:curseMediaAnnotationWithIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__curseMediaAnnotationWithId:
		return soap_out_PointerTotns__curseMediaAnnotationWithId(soap, tag, id, (tns__curseMediaAnnotationWithId *const*)ptr, "tns:curseMediaAnnotationWithId");
	case SOAP_TYPE_Annot_PointerTotns__curseMediaAliasWithIdResponse:
		return soap_out_PointerTotns__curseMediaAliasWithIdResponse(soap, tag, id, (tns__curseMediaAliasWithIdResponse *const*)ptr, "tns:curseMediaAliasWithIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__curseMediaAliasWithId:
		return soap_out_PointerTotns__curseMediaAliasWithId(soap, tag, id, (tns__curseMediaAliasWithId *const*)ptr, "tns:curseMediaAliasWithId");
	case SOAP_TYPE_Annot_PointerTotns__chatResponse:
		return soap_out_PointerTotns__chatResponse(soap, tag, id, (tns__chatResponse *const*)ptr, "tns:chatResponse");
	case SOAP_TYPE_Annot_PointerTotns__chat:
		return soap_out_PointerTotns__chat(soap, tag, id, (tns__chat *const*)ptr, "tns:chat");
	case SOAP_TYPE_Annot_PointerTotns__blockUserWithIdResponse:
		return soap_out_PointerTotns__blockUserWithIdResponse(soap, tag, id, (tns__blockUserWithIdResponse *const*)ptr, "tns:blockUserWithIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__blockUserWithId:
		return soap_out_PointerTotns__blockUserWithId(soap, tag, id, (tns__blockUserWithId *const*)ptr, "tns:blockUserWithId");
	case SOAP_TYPE_Annot_PointerTotns__blockMediaAnnotationWithIdResponse:
		return soap_out_PointerTotns__blockMediaAnnotationWithIdResponse(soap, tag, id, (tns__blockMediaAnnotationWithIdResponse *const*)ptr, "tns:blockMediaAnnotationWithIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__blockMediaAnnotationWithId:
		return soap_out_PointerTotns__blockMediaAnnotationWithId(soap, tag, id, (tns__blockMediaAnnotationWithId *const*)ptr, "tns:blockMediaAnnotationWithId");
	case SOAP_TYPE_Annot_PointerTotns__blockMediaAliasWithIdResponse:
		return soap_out_PointerTotns__blockMediaAliasWithIdResponse(soap, tag, id, (tns__blockMediaAliasWithIdResponse *const*)ptr, "tns:blockMediaAliasWithIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__blockMediaAliasWithId:
		return soap_out_PointerTotns__blockMediaAliasWithId(soap, tag, id, (tns__blockMediaAliasWithId *const*)ptr, "tns:blockMediaAliasWithId");
	case SOAP_TYPE_Annot_PointerTotns__blessUserWithIdResponse:
		return soap_out_PointerTotns__blessUserWithIdResponse(soap, tag, id, (tns__blessUserWithIdResponse *const*)ptr, "tns:blessUserWithIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__blessUserWithId:
		return soap_out_PointerTotns__blessUserWithId(soap, tag, id, (tns__blessUserWithId *const*)ptr, "tns:blessUserWithId");
	case SOAP_TYPE_Annot_PointerTotns__blessMediaTokenWithIdResponse:
		return soap_out_PointerTotns__blessMediaTokenWithIdResponse(soap, tag, id, (tns__blessMediaTokenWithIdResponse *const*)ptr, "tns:blessMediaTokenWithIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__blessMediaTokenWithId:
		return soap_out_PointerTotns__blessMediaTokenWithId(soap, tag, id, (tns__blessMediaTokenWithId *const*)ptr, "tns:blessMediaTokenWithId");
	case SOAP_TYPE_Annot_PointerTotns__blessMediaAnnotationWithIdResponse:
		return soap_out_PointerTotns__blessMediaAnnotationWithIdResponse(soap, tag, id, (tns__blessMediaAnnotationWithIdResponse *const*)ptr, "tns:blessMediaAnnotationWithIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__blessMediaAnnotationWithId:
		return soap_out_PointerTotns__blessMediaAnnotationWithId(soap, tag, id, (tns__blessMediaAnnotationWithId *const*)ptr, "tns:blessMediaAnnotationWithId");
	case SOAP_TYPE_Annot_PointerTotns__blessMediaAliasWithIdResponse:
		return soap_out_PointerTotns__blessMediaAliasWithIdResponse(soap, tag, id, (tns__blessMediaAliasWithIdResponse *const*)ptr, "tns:blessMediaAliasWithIdResponse");
	case SOAP_TYPE_Annot_PointerTotns__blessMediaAliasWithId:
		return soap_out_PointerTotns__blessMediaAliasWithId(soap, tag, id, (tns__blessMediaAliasWithId *const*)ptr, "tns:blessMediaAliasWithId");
	case SOAP_TYPE_Annot_PointerTotns__mediaToken:
		return soap_out_PointerTotns__mediaToken(soap, tag, id, (tns__mediaToken *const*)ptr, "tns:mediaToken");
	case SOAP_TYPE_Annot_PointerTotns__mediaAnnotation:
		return soap_out_PointerTotns__mediaAnnotation(soap, tag, id, (tns__mediaAnnotation *const*)ptr, "tns:mediaAnnotation");
	case SOAP_TYPE_Annot_PointerTotns__mediaAlias:
		return soap_out_PointerTotns__mediaAlias(soap, tag, id, (tns__mediaAlias *const*)ptr, "tns:mediaAlias");
	case SOAP_TYPE_Annot_PointerTotns__gameThread:
		return soap_out_PointerTotns__gameThread(soap, tag, id, (tns__gameThread *const*)ptr, "tns:gameThread");
	case SOAP_TYPE_Annot_PointerTotns__user:
		return soap_out_PointerTotns__user(soap, tag, id, (tns__user *const*)ptr, "tns:user");
	case SOAP_TYPE_Annot_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_Annot__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_Annot_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_Annot_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_Annot_tns__updateMediaAnnotationUserIdWithIdResponse:
		((tns__updateMediaAnnotationUserIdWithIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__updateMediaAnnotationUserIdWithId:
		((tns__updateMediaAnnotationUserIdWithId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__updateMediaAnnotationTextWithIdResponse:
		((tns__updateMediaAnnotationTextWithIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__updateMediaAnnotationTextWithId:
		((tns__updateMediaAnnotationTextWithId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__updateMediaAnnotationLanguageWithIdResponse:
		((tns__updateMediaAnnotationLanguageWithIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__updateMediaAnnotationLanguageWithId:
		((tns__updateMediaAnnotationLanguageWithId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__updateGameThreadResponse:
		((tns__updateGameThreadResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__updateGameThread:
		((tns__updateGameThread *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__submitMediaTokenUrlResponse:
		((tns__submitMediaTokenUrlResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__submitMediaTokenUrl:
		((tns__submitMediaTokenUrl *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__submitMediaTokenDigestResponse:
		((tns__submitMediaTokenDigestResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__submitMediaTokenDigest:
		((tns__submitMediaTokenDigest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__submitMediaTokenResponse:
		((tns__submitMediaTokenResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__submitMediaToken:
		((tns__submitMediaToken *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__submitMediaAnnotationTextWithTokenIdResponse:
		((tns__submitMediaAnnotationTextWithTokenIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__submitMediaAnnotationTextWithTokenId:
		((tns__submitMediaAnnotationTextWithTokenId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__submitMediaAnnotationTextAndTokenDigestResponse:
		((tns__submitMediaAnnotationTextAndTokenDigestResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__submitMediaAnnotationTextAndTokenDigest:
		((tns__submitMediaAnnotationTextAndTokenDigest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__submitMediaAnnotationResponse:
		((tns__submitMediaAnnotationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__submitMediaAnnotation:
		((tns__submitMediaAnnotation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__submitMediaAliasTextWithTokenIdResponse:
		((tns__submitMediaAliasTextWithTokenIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__submitMediaAliasTextWithTokenId:
		((tns__submitMediaAliasTextWithTokenId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__submitMediaAliasTextAndTokenDigestResponse:
		((tns__submitMediaAliasTextAndTokenDigestResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__submitMediaAliasTextAndTokenDigest:
		((tns__submitMediaAliasTextAndTokenDigest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__submitMediaAliasResponse:
		((tns__submitMediaAliasResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__submitMediaAlias:
		((tns__submitMediaAlias *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__submitGameThreadResponse:
		((tns__submitGameThreadResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__submitGameThread:
		((tns__submitGameThread *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__setUserLanguageResponse:
		((tns__setUserLanguageResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__setUserLanguage:
		((tns__setUserLanguage *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__setUserAnonymousResponse:
		((tns__setUserAnonymousResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__setUserAnonymous:
		((tns__setUserAnonymous *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__selectRelatedMediaAnnotationsWithTokenIdResponse:
		((tns__selectRelatedMediaAnnotationsWithTokenIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__selectRelatedMediaAnnotationsWithTokenId:
		((tns__selectRelatedMediaAnnotationsWithTokenId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__selectRelatedMediaAliasesWithTokenIdResponse:
		((tns__selectRelatedMediaAliasesWithTokenIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__selectRelatedMediaAliasesWithTokenId:
		((tns__selectRelatedMediaAliasesWithTokenId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__selectMediaTokenWithIdResponse:
		((tns__selectMediaTokenWithIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__selectMediaTokenWithId:
		((tns__selectMediaTokenWithId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__selectMediaTokenWithDigestResponse:
		((tns__selectMediaTokenWithDigestResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__selectMediaTokenWithDigest:
		((tns__selectMediaTokenWithDigest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__selectMediaTokenIdWithUrlResponse:
		((tns__selectMediaTokenIdWithUrlResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__selectMediaTokenIdWithUrl:
		((tns__selectMediaTokenIdWithUrl *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__selectMediaTokenIdWithDigestResponse:
		((tns__selectMediaTokenIdWithDigestResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__selectMediaTokenIdWithDigest:
		((tns__selectMediaTokenIdWithDigest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__selectMediaAnnotationsWithTokenIdResponse:
		((tns__selectMediaAnnotationsWithTokenIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__selectMediaAnnotationsWithTokenId:
		((tns__selectMediaAnnotationsWithTokenId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__selectMediaAliasesWithTokenIdResponse:
		((tns__selectMediaAliasesWithTokenIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__selectMediaAliasesWithTokenId:
		((tns__selectMediaAliasesWithTokenId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__selectGameThreadWithTokenIdResponse:
		((tns__selectGameThreadWithTokenIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__selectGameThreadWithTokenId:
		((tns__selectGameThreadWithTokenId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__selectGameThreadWithTokenDigestResponse:
		((tns__selectGameThreadWithTokenDigestResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__selectGameThreadWithTokenDigest:
		((tns__selectGameThreadWithTokenDigest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__loginResponse:
		((tns__loginResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__login:
		((tns__login *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__isLatestAppResponse:
		((tns__isLatestAppResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__isLatestApp:
		((tns__isLatestApp *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__isConnectedResponse:
		((tns__isConnectedResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__isConnected:
		((tns__isConnected *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__isAuthorizedResponse:
		((tns__isAuthorizedResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__isAuthorized:
		((tns__isAuthorized *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__getUserResponse:
		((tns__getUserResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__getUser:
		((tns__getUser *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__deleteMediaAnnotationWithIdResponse:
		((tns__deleteMediaAnnotationWithIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__deleteMediaAnnotationWithId:
		((tns__deleteMediaAnnotationWithId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__deleteMediaAliasWithIdResponse:
		((tns__deleteMediaAliasWithIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__deleteMediaAliasWithId:
		((tns__deleteMediaAliasWithId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__curseUserWithIdResponse:
		((tns__curseUserWithIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__curseUserWithId:
		((tns__curseUserWithId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__curseMediaTokenWithIdResponse:
		((tns__curseMediaTokenWithIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__curseMediaTokenWithId:
		((tns__curseMediaTokenWithId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__curseMediaAnnotationWithIdResponse:
		((tns__curseMediaAnnotationWithIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__curseMediaAnnotationWithId:
		((tns__curseMediaAnnotationWithId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__curseMediaAliasWithIdResponse:
		((tns__curseMediaAliasWithIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__curseMediaAliasWithId:
		((tns__curseMediaAliasWithId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__chatResponse:
		((tns__chatResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__chat:
		((tns__chat *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__blockUserWithIdResponse:
		((tns__blockUserWithIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__blockUserWithId:
		((tns__blockUserWithId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__blockMediaAnnotationWithIdResponse:
		((tns__blockMediaAnnotationWithIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__blockMediaAnnotationWithId:
		((tns__blockMediaAnnotationWithId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__blockMediaAliasWithIdResponse:
		((tns__blockMediaAliasWithIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__blockMediaAliasWithId:
		((tns__blockMediaAliasWithId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__blessUserWithIdResponse:
		((tns__blessUserWithIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__blessUserWithId:
		((tns__blessUserWithId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__blessMediaTokenWithIdResponse:
		((tns__blessMediaTokenWithIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__blessMediaTokenWithId:
		((tns__blessMediaTokenWithId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__blessMediaAnnotationWithIdResponse:
		((tns__blessMediaAnnotationWithIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__blessMediaAnnotationWithId:
		((tns__blessMediaAnnotationWithId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__blessMediaAliasWithIdResponse:
		((tns__blessMediaAliasWithIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__blessMediaAliasWithId:
		((tns__blessMediaAliasWithId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__user:
		((tns__user *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__mediaAlias:
		((tns__mediaAlias *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__mediaToken:
		((tns__mediaToken *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__mediaAnnotation:
		((tns__mediaAnnotation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot_tns__gameThread:
		((tns__gameThread *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Annot___tns__updateMediaAnnotationUserIdWithId:
		soap_serialize___tns__updateMediaAnnotationUserIdWithId(soap, (const struct __tns__updateMediaAnnotationUserIdWithId *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__updateMediaAnnotationTextWithId:
		soap_serialize___tns__updateMediaAnnotationTextWithId(soap, (const struct __tns__updateMediaAnnotationTextWithId *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__updateMediaAnnotationLanguageWithId:
		soap_serialize___tns__updateMediaAnnotationLanguageWithId(soap, (const struct __tns__updateMediaAnnotationLanguageWithId *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__updateGameThread:
		soap_serialize___tns__updateGameThread(soap, (const struct __tns__updateGameThread *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__submitMediaTokenUrl:
		soap_serialize___tns__submitMediaTokenUrl(soap, (const struct __tns__submitMediaTokenUrl *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__submitMediaTokenDigest:
		soap_serialize___tns__submitMediaTokenDigest(soap, (const struct __tns__submitMediaTokenDigest *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__submitMediaToken:
		soap_serialize___tns__submitMediaToken(soap, (const struct __tns__submitMediaToken *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__submitMediaAnnotationTextWithTokenId:
		soap_serialize___tns__submitMediaAnnotationTextWithTokenId(soap, (const struct __tns__submitMediaAnnotationTextWithTokenId *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__submitMediaAnnotationTextAndTokenDigest:
		soap_serialize___tns__submitMediaAnnotationTextAndTokenDigest(soap, (const struct __tns__submitMediaAnnotationTextAndTokenDigest *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__submitMediaAnnotation:
		soap_serialize___tns__submitMediaAnnotation(soap, (const struct __tns__submitMediaAnnotation *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__submitMediaAliasTextWithTokenId:
		soap_serialize___tns__submitMediaAliasTextWithTokenId(soap, (const struct __tns__submitMediaAliasTextWithTokenId *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__submitMediaAliasTextAndTokenDigest:
		soap_serialize___tns__submitMediaAliasTextAndTokenDigest(soap, (const struct __tns__submitMediaAliasTextAndTokenDigest *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__submitMediaAlias:
		soap_serialize___tns__submitMediaAlias(soap, (const struct __tns__submitMediaAlias *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__submitGameThread:
		soap_serialize___tns__submitGameThread(soap, (const struct __tns__submitGameThread *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__setUserLanguage:
		soap_serialize___tns__setUserLanguage(soap, (const struct __tns__setUserLanguage *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__setUserAnonymous:
		soap_serialize___tns__setUserAnonymous(soap, (const struct __tns__setUserAnonymous *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__selectRelatedMediaAnnotationsWithTokenId:
		soap_serialize___tns__selectRelatedMediaAnnotationsWithTokenId(soap, (const struct __tns__selectRelatedMediaAnnotationsWithTokenId *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__selectRelatedMediaAliasesWithTokenId:
		soap_serialize___tns__selectRelatedMediaAliasesWithTokenId(soap, (const struct __tns__selectRelatedMediaAliasesWithTokenId *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__selectMediaTokenWithId:
		soap_serialize___tns__selectMediaTokenWithId(soap, (const struct __tns__selectMediaTokenWithId *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__selectMediaTokenWithDigest:
		soap_serialize___tns__selectMediaTokenWithDigest(soap, (const struct __tns__selectMediaTokenWithDigest *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__selectMediaTokenIdWithUrl:
		soap_serialize___tns__selectMediaTokenIdWithUrl(soap, (const struct __tns__selectMediaTokenIdWithUrl *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__selectMediaTokenIdWithDigest:
		soap_serialize___tns__selectMediaTokenIdWithDigest(soap, (const struct __tns__selectMediaTokenIdWithDigest *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__selectMediaAnnotationsWithTokenId:
		soap_serialize___tns__selectMediaAnnotationsWithTokenId(soap, (const struct __tns__selectMediaAnnotationsWithTokenId *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__selectMediaAliasesWithTokenId:
		soap_serialize___tns__selectMediaAliasesWithTokenId(soap, (const struct __tns__selectMediaAliasesWithTokenId *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__selectGameThreadWithTokenId:
		soap_serialize___tns__selectGameThreadWithTokenId(soap, (const struct __tns__selectGameThreadWithTokenId *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__selectGameThreadWithTokenDigest:
		soap_serialize___tns__selectGameThreadWithTokenDigest(soap, (const struct __tns__selectGameThreadWithTokenDigest *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__login:
		soap_serialize___tns__login(soap, (const struct __tns__login *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__isLatestApp:
		soap_serialize___tns__isLatestApp(soap, (const struct __tns__isLatestApp *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__isConnected:
		soap_serialize___tns__isConnected(soap, (const struct __tns__isConnected *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__isAuthorized:
		soap_serialize___tns__isAuthorized(soap, (const struct __tns__isAuthorized *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__getUser:
		soap_serialize___tns__getUser(soap, (const struct __tns__getUser *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__deleteMediaAnnotationWithId:
		soap_serialize___tns__deleteMediaAnnotationWithId(soap, (const struct __tns__deleteMediaAnnotationWithId *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__deleteMediaAliasWithId:
		soap_serialize___tns__deleteMediaAliasWithId(soap, (const struct __tns__deleteMediaAliasWithId *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__curseUserWithId:
		soap_serialize___tns__curseUserWithId(soap, (const struct __tns__curseUserWithId *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__curseMediaTokenWithId:
		soap_serialize___tns__curseMediaTokenWithId(soap, (const struct __tns__curseMediaTokenWithId *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__curseMediaAnnotationWithId:
		soap_serialize___tns__curseMediaAnnotationWithId(soap, (const struct __tns__curseMediaAnnotationWithId *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__curseMediaAliasWithId:
		soap_serialize___tns__curseMediaAliasWithId(soap, (const struct __tns__curseMediaAliasWithId *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__chat:
		soap_serialize___tns__chat(soap, (const struct __tns__chat *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__blockUserWithId:
		soap_serialize___tns__blockUserWithId(soap, (const struct __tns__blockUserWithId *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__blockMediaAnnotationWithId:
		soap_serialize___tns__blockMediaAnnotationWithId(soap, (const struct __tns__blockMediaAnnotationWithId *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__blockMediaAliasWithId:
		soap_serialize___tns__blockMediaAliasWithId(soap, (const struct __tns__blockMediaAliasWithId *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__blessUserWithId:
		soap_serialize___tns__blessUserWithId(soap, (const struct __tns__blessUserWithId *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__blessMediaTokenWithId:
		soap_serialize___tns__blessMediaTokenWithId(soap, (const struct __tns__blessMediaTokenWithId *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__blessMediaAnnotationWithId:
		soap_serialize___tns__blessMediaAnnotationWithId(soap, (const struct __tns__blessMediaAnnotationWithId *)ptr);
		break;
	case SOAP_TYPE_Annot___tns__blessMediaAliasWithId:
		soap_serialize___tns__blessMediaAliasWithId(soap, (const struct __tns__blessMediaAliasWithId *)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__updateMediaAnnotationUserIdWithIdResponse:
		soap_serialize_PointerTotns__updateMediaAnnotationUserIdWithIdResponse(soap, (tns__updateMediaAnnotationUserIdWithIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__updateMediaAnnotationUserIdWithId:
		soap_serialize_PointerTotns__updateMediaAnnotationUserIdWithId(soap, (tns__updateMediaAnnotationUserIdWithId *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__updateMediaAnnotationTextWithIdResponse:
		soap_serialize_PointerTotns__updateMediaAnnotationTextWithIdResponse(soap, (tns__updateMediaAnnotationTextWithIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__updateMediaAnnotationTextWithId:
		soap_serialize_PointerTotns__updateMediaAnnotationTextWithId(soap, (tns__updateMediaAnnotationTextWithId *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__updateMediaAnnotationLanguageWithIdResponse:
		soap_serialize_PointerTotns__updateMediaAnnotationLanguageWithIdResponse(soap, (tns__updateMediaAnnotationLanguageWithIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__updateMediaAnnotationLanguageWithId:
		soap_serialize_PointerTotns__updateMediaAnnotationLanguageWithId(soap, (tns__updateMediaAnnotationLanguageWithId *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__updateGameThreadResponse:
		soap_serialize_PointerTotns__updateGameThreadResponse(soap, (tns__updateGameThreadResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__updateGameThread:
		soap_serialize_PointerTotns__updateGameThread(soap, (tns__updateGameThread *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__submitMediaTokenUrlResponse:
		soap_serialize_PointerTotns__submitMediaTokenUrlResponse(soap, (tns__submitMediaTokenUrlResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__submitMediaTokenUrl:
		soap_serialize_PointerTotns__submitMediaTokenUrl(soap, (tns__submitMediaTokenUrl *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__submitMediaTokenDigestResponse:
		soap_serialize_PointerTotns__submitMediaTokenDigestResponse(soap, (tns__submitMediaTokenDigestResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__submitMediaTokenDigest:
		soap_serialize_PointerTotns__submitMediaTokenDigest(soap, (tns__submitMediaTokenDigest *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__submitMediaTokenResponse:
		soap_serialize_PointerTotns__submitMediaTokenResponse(soap, (tns__submitMediaTokenResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__submitMediaToken:
		soap_serialize_PointerTotns__submitMediaToken(soap, (tns__submitMediaToken *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse:
		soap_serialize_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse(soap, (tns__submitMediaAnnotationTextWithTokenIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__submitMediaAnnotationTextWithTokenId:
		soap_serialize_PointerTotns__submitMediaAnnotationTextWithTokenId(soap, (tns__submitMediaAnnotationTextWithTokenId *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse:
		soap_serialize_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse(soap, (tns__submitMediaAnnotationTextAndTokenDigestResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__submitMediaAnnotationTextAndTokenDigest:
		soap_serialize_PointerTotns__submitMediaAnnotationTextAndTokenDigest(soap, (tns__submitMediaAnnotationTextAndTokenDigest *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__submitMediaAnnotationResponse:
		soap_serialize_PointerTotns__submitMediaAnnotationResponse(soap, (tns__submitMediaAnnotationResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__submitMediaAnnotation:
		soap_serialize_PointerTotns__submitMediaAnnotation(soap, (tns__submitMediaAnnotation *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__submitMediaAliasTextWithTokenIdResponse:
		soap_serialize_PointerTotns__submitMediaAliasTextWithTokenIdResponse(soap, (tns__submitMediaAliasTextWithTokenIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__submitMediaAliasTextWithTokenId:
		soap_serialize_PointerTotns__submitMediaAliasTextWithTokenId(soap, (tns__submitMediaAliasTextWithTokenId *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__submitMediaAliasTextAndTokenDigestResponse:
		soap_serialize_PointerTotns__submitMediaAliasTextAndTokenDigestResponse(soap, (tns__submitMediaAliasTextAndTokenDigestResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__submitMediaAliasTextAndTokenDigest:
		soap_serialize_PointerTotns__submitMediaAliasTextAndTokenDigest(soap, (tns__submitMediaAliasTextAndTokenDigest *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__submitMediaAliasResponse:
		soap_serialize_PointerTotns__submitMediaAliasResponse(soap, (tns__submitMediaAliasResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__submitMediaAlias:
		soap_serialize_PointerTotns__submitMediaAlias(soap, (tns__submitMediaAlias *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__submitGameThreadResponse:
		soap_serialize_PointerTotns__submitGameThreadResponse(soap, (tns__submitGameThreadResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__submitGameThread:
		soap_serialize_PointerTotns__submitGameThread(soap, (tns__submitGameThread *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__setUserLanguageResponse:
		soap_serialize_PointerTotns__setUserLanguageResponse(soap, (tns__setUserLanguageResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__setUserLanguage:
		soap_serialize_PointerTotns__setUserLanguage(soap, (tns__setUserLanguage *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__setUserAnonymousResponse:
		soap_serialize_PointerTotns__setUserAnonymousResponse(soap, (tns__setUserAnonymousResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__setUserAnonymous:
		soap_serialize_PointerTotns__setUserAnonymous(soap, (tns__setUserAnonymous *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse:
		soap_serialize_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse(soap, (tns__selectRelatedMediaAnnotationsWithTokenIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__selectRelatedMediaAnnotationsWithTokenId:
		soap_serialize_PointerTotns__selectRelatedMediaAnnotationsWithTokenId(soap, (tns__selectRelatedMediaAnnotationsWithTokenId *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__selectRelatedMediaAliasesWithTokenIdResponse:
		soap_serialize_PointerTotns__selectRelatedMediaAliasesWithTokenIdResponse(soap, (tns__selectRelatedMediaAliasesWithTokenIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__selectRelatedMediaAliasesWithTokenId:
		soap_serialize_PointerTotns__selectRelatedMediaAliasesWithTokenId(soap, (tns__selectRelatedMediaAliasesWithTokenId *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__selectMediaTokenWithIdResponse:
		soap_serialize_PointerTotns__selectMediaTokenWithIdResponse(soap, (tns__selectMediaTokenWithIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__selectMediaTokenWithId:
		soap_serialize_PointerTotns__selectMediaTokenWithId(soap, (tns__selectMediaTokenWithId *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__selectMediaTokenWithDigestResponse:
		soap_serialize_PointerTotns__selectMediaTokenWithDigestResponse(soap, (tns__selectMediaTokenWithDigestResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__selectMediaTokenWithDigest:
		soap_serialize_PointerTotns__selectMediaTokenWithDigest(soap, (tns__selectMediaTokenWithDigest *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__selectMediaTokenIdWithUrlResponse:
		soap_serialize_PointerTotns__selectMediaTokenIdWithUrlResponse(soap, (tns__selectMediaTokenIdWithUrlResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__selectMediaTokenIdWithUrl:
		soap_serialize_PointerTotns__selectMediaTokenIdWithUrl(soap, (tns__selectMediaTokenIdWithUrl *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__selectMediaTokenIdWithDigestResponse:
		soap_serialize_PointerTotns__selectMediaTokenIdWithDigestResponse(soap, (tns__selectMediaTokenIdWithDigestResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__selectMediaTokenIdWithDigest:
		soap_serialize_PointerTotns__selectMediaTokenIdWithDigest(soap, (tns__selectMediaTokenIdWithDigest *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__selectMediaAnnotationsWithTokenIdResponse:
		soap_serialize_PointerTotns__selectMediaAnnotationsWithTokenIdResponse(soap, (tns__selectMediaAnnotationsWithTokenIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__selectMediaAnnotationsWithTokenId:
		soap_serialize_PointerTotns__selectMediaAnnotationsWithTokenId(soap, (tns__selectMediaAnnotationsWithTokenId *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__selectMediaAliasesWithTokenIdResponse:
		soap_serialize_PointerTotns__selectMediaAliasesWithTokenIdResponse(soap, (tns__selectMediaAliasesWithTokenIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__selectMediaAliasesWithTokenId:
		soap_serialize_PointerTotns__selectMediaAliasesWithTokenId(soap, (tns__selectMediaAliasesWithTokenId *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__selectGameThreadWithTokenIdResponse:
		soap_serialize_PointerTotns__selectGameThreadWithTokenIdResponse(soap, (tns__selectGameThreadWithTokenIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__selectGameThreadWithTokenId:
		soap_serialize_PointerTotns__selectGameThreadWithTokenId(soap, (tns__selectGameThreadWithTokenId *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__selectGameThreadWithTokenDigestResponse:
		soap_serialize_PointerTotns__selectGameThreadWithTokenDigestResponse(soap, (tns__selectGameThreadWithTokenDigestResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__selectGameThreadWithTokenDigest:
		soap_serialize_PointerTotns__selectGameThreadWithTokenDigest(soap, (tns__selectGameThreadWithTokenDigest *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__loginResponse:
		soap_serialize_PointerTotns__loginResponse(soap, (tns__loginResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__login:
		soap_serialize_PointerTotns__login(soap, (tns__login *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__isLatestAppResponse:
		soap_serialize_PointerTotns__isLatestAppResponse(soap, (tns__isLatestAppResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__isLatestApp:
		soap_serialize_PointerTotns__isLatestApp(soap, (tns__isLatestApp *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__isConnectedResponse:
		soap_serialize_PointerTotns__isConnectedResponse(soap, (tns__isConnectedResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__isConnected:
		soap_serialize_PointerTotns__isConnected(soap, (tns__isConnected *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__isAuthorizedResponse:
		soap_serialize_PointerTotns__isAuthorizedResponse(soap, (tns__isAuthorizedResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__isAuthorized:
		soap_serialize_PointerTotns__isAuthorized(soap, (tns__isAuthorized *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__getUserResponse:
		soap_serialize_PointerTotns__getUserResponse(soap, (tns__getUserResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__getUser:
		soap_serialize_PointerTotns__getUser(soap, (tns__getUser *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__deleteMediaAnnotationWithIdResponse:
		soap_serialize_PointerTotns__deleteMediaAnnotationWithIdResponse(soap, (tns__deleteMediaAnnotationWithIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__deleteMediaAnnotationWithId:
		soap_serialize_PointerTotns__deleteMediaAnnotationWithId(soap, (tns__deleteMediaAnnotationWithId *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__deleteMediaAliasWithIdResponse:
		soap_serialize_PointerTotns__deleteMediaAliasWithIdResponse(soap, (tns__deleteMediaAliasWithIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__deleteMediaAliasWithId:
		soap_serialize_PointerTotns__deleteMediaAliasWithId(soap, (tns__deleteMediaAliasWithId *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__curseUserWithIdResponse:
		soap_serialize_PointerTotns__curseUserWithIdResponse(soap, (tns__curseUserWithIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__curseUserWithId:
		soap_serialize_PointerTotns__curseUserWithId(soap, (tns__curseUserWithId *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__curseMediaTokenWithIdResponse:
		soap_serialize_PointerTotns__curseMediaTokenWithIdResponse(soap, (tns__curseMediaTokenWithIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__curseMediaTokenWithId:
		soap_serialize_PointerTotns__curseMediaTokenWithId(soap, (tns__curseMediaTokenWithId *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__curseMediaAnnotationWithIdResponse:
		soap_serialize_PointerTotns__curseMediaAnnotationWithIdResponse(soap, (tns__curseMediaAnnotationWithIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__curseMediaAnnotationWithId:
		soap_serialize_PointerTotns__curseMediaAnnotationWithId(soap, (tns__curseMediaAnnotationWithId *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__curseMediaAliasWithIdResponse:
		soap_serialize_PointerTotns__curseMediaAliasWithIdResponse(soap, (tns__curseMediaAliasWithIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__curseMediaAliasWithId:
		soap_serialize_PointerTotns__curseMediaAliasWithId(soap, (tns__curseMediaAliasWithId *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__chatResponse:
		soap_serialize_PointerTotns__chatResponse(soap, (tns__chatResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__chat:
		soap_serialize_PointerTotns__chat(soap, (tns__chat *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__blockUserWithIdResponse:
		soap_serialize_PointerTotns__blockUserWithIdResponse(soap, (tns__blockUserWithIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__blockUserWithId:
		soap_serialize_PointerTotns__blockUserWithId(soap, (tns__blockUserWithId *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__blockMediaAnnotationWithIdResponse:
		soap_serialize_PointerTotns__blockMediaAnnotationWithIdResponse(soap, (tns__blockMediaAnnotationWithIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__blockMediaAnnotationWithId:
		soap_serialize_PointerTotns__blockMediaAnnotationWithId(soap, (tns__blockMediaAnnotationWithId *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__blockMediaAliasWithIdResponse:
		soap_serialize_PointerTotns__blockMediaAliasWithIdResponse(soap, (tns__blockMediaAliasWithIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__blockMediaAliasWithId:
		soap_serialize_PointerTotns__blockMediaAliasWithId(soap, (tns__blockMediaAliasWithId *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__blessUserWithIdResponse:
		soap_serialize_PointerTotns__blessUserWithIdResponse(soap, (tns__blessUserWithIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__blessUserWithId:
		soap_serialize_PointerTotns__blessUserWithId(soap, (tns__blessUserWithId *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__blessMediaTokenWithIdResponse:
		soap_serialize_PointerTotns__blessMediaTokenWithIdResponse(soap, (tns__blessMediaTokenWithIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__blessMediaTokenWithId:
		soap_serialize_PointerTotns__blessMediaTokenWithId(soap, (tns__blessMediaTokenWithId *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__blessMediaAnnotationWithIdResponse:
		soap_serialize_PointerTotns__blessMediaAnnotationWithIdResponse(soap, (tns__blessMediaAnnotationWithIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__blessMediaAnnotationWithId:
		soap_serialize_PointerTotns__blessMediaAnnotationWithId(soap, (tns__blessMediaAnnotationWithId *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__blessMediaAliasWithIdResponse:
		soap_serialize_PointerTotns__blessMediaAliasWithIdResponse(soap, (tns__blessMediaAliasWithIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__blessMediaAliasWithId:
		soap_serialize_PointerTotns__blessMediaAliasWithId(soap, (tns__blessMediaAliasWithId *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__mediaToken:
		soap_serialize_PointerTotns__mediaToken(soap, (tns__mediaToken *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__mediaAnnotation:
		soap_serialize_PointerTotns__mediaAnnotation(soap, (tns__mediaAnnotation *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__mediaAlias:
		soap_serialize_PointerTotns__mediaAlias(soap, (tns__mediaAlias *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__gameThread:
		soap_serialize_PointerTotns__gameThread(soap, (tns__gameThread *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTotns__user:
		soap_serialize_PointerTotns__user(soap, (tns__user *const*)ptr);
		break;
	case SOAP_TYPE_Annot_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_Annot__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_Annot_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 Annot_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_Annot_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__gameThread:
		return (void*)soap_instantiate_tns__gameThread(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__mediaAnnotation:
		return (void*)soap_instantiate_tns__mediaAnnotation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__mediaToken:
		return (void*)soap_instantiate_tns__mediaToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__mediaAlias:
		return (void*)soap_instantiate_tns__mediaAlias(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__user:
		return (void*)soap_instantiate_tns__user(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__blessMediaAliasWithId:
		return (void*)soap_instantiate_tns__blessMediaAliasWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__blessMediaAliasWithIdResponse:
		return (void*)soap_instantiate_tns__blessMediaAliasWithIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__blessMediaAnnotationWithId:
		return (void*)soap_instantiate_tns__blessMediaAnnotationWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__blessMediaAnnotationWithIdResponse:
		return (void*)soap_instantiate_tns__blessMediaAnnotationWithIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__blessMediaTokenWithId:
		return (void*)soap_instantiate_tns__blessMediaTokenWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__blessMediaTokenWithIdResponse:
		return (void*)soap_instantiate_tns__blessMediaTokenWithIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__blessUserWithId:
		return (void*)soap_instantiate_tns__blessUserWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__blessUserWithIdResponse:
		return (void*)soap_instantiate_tns__blessUserWithIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__blockMediaAliasWithId:
		return (void*)soap_instantiate_tns__blockMediaAliasWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__blockMediaAliasWithIdResponse:
		return (void*)soap_instantiate_tns__blockMediaAliasWithIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__blockMediaAnnotationWithId:
		return (void*)soap_instantiate_tns__blockMediaAnnotationWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__blockMediaAnnotationWithIdResponse:
		return (void*)soap_instantiate_tns__blockMediaAnnotationWithIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__blockUserWithId:
		return (void*)soap_instantiate_tns__blockUserWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__blockUserWithIdResponse:
		return (void*)soap_instantiate_tns__blockUserWithIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__chat:
		return (void*)soap_instantiate_tns__chat(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__chatResponse:
		return (void*)soap_instantiate_tns__chatResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__curseMediaAliasWithId:
		return (void*)soap_instantiate_tns__curseMediaAliasWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__curseMediaAliasWithIdResponse:
		return (void*)soap_instantiate_tns__curseMediaAliasWithIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__curseMediaAnnotationWithId:
		return (void*)soap_instantiate_tns__curseMediaAnnotationWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__curseMediaAnnotationWithIdResponse:
		return (void*)soap_instantiate_tns__curseMediaAnnotationWithIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__curseMediaTokenWithId:
		return (void*)soap_instantiate_tns__curseMediaTokenWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__curseMediaTokenWithIdResponse:
		return (void*)soap_instantiate_tns__curseMediaTokenWithIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__curseUserWithId:
		return (void*)soap_instantiate_tns__curseUserWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__curseUserWithIdResponse:
		return (void*)soap_instantiate_tns__curseUserWithIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__deleteMediaAliasWithId:
		return (void*)soap_instantiate_tns__deleteMediaAliasWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__deleteMediaAliasWithIdResponse:
		return (void*)soap_instantiate_tns__deleteMediaAliasWithIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__deleteMediaAnnotationWithId:
		return (void*)soap_instantiate_tns__deleteMediaAnnotationWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__deleteMediaAnnotationWithIdResponse:
		return (void*)soap_instantiate_tns__deleteMediaAnnotationWithIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__getUser:
		return (void*)soap_instantiate_tns__getUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__getUserResponse:
		return (void*)soap_instantiate_tns__getUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__isAuthorized:
		return (void*)soap_instantiate_tns__isAuthorized(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__isAuthorizedResponse:
		return (void*)soap_instantiate_tns__isAuthorizedResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__isConnected:
		return (void*)soap_instantiate_tns__isConnected(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__isConnectedResponse:
		return (void*)soap_instantiate_tns__isConnectedResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__isLatestApp:
		return (void*)soap_instantiate_tns__isLatestApp(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__isLatestAppResponse:
		return (void*)soap_instantiate_tns__isLatestAppResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__login:
		return (void*)soap_instantiate_tns__login(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__loginResponse:
		return (void*)soap_instantiate_tns__loginResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__selectGameThreadWithTokenDigest:
		return (void*)soap_instantiate_tns__selectGameThreadWithTokenDigest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__selectGameThreadWithTokenDigestResponse:
		return (void*)soap_instantiate_tns__selectGameThreadWithTokenDigestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__selectGameThreadWithTokenId:
		return (void*)soap_instantiate_tns__selectGameThreadWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__selectGameThreadWithTokenIdResponse:
		return (void*)soap_instantiate_tns__selectGameThreadWithTokenIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__selectMediaAliasesWithTokenId:
		return (void*)soap_instantiate_tns__selectMediaAliasesWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__selectMediaAliasesWithTokenIdResponse:
		return (void*)soap_instantiate_tns__selectMediaAliasesWithTokenIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__selectMediaAnnotationsWithTokenId:
		return (void*)soap_instantiate_tns__selectMediaAnnotationsWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__selectMediaAnnotationsWithTokenIdResponse:
		return (void*)soap_instantiate_tns__selectMediaAnnotationsWithTokenIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__selectMediaTokenIdWithDigest:
		return (void*)soap_instantiate_tns__selectMediaTokenIdWithDigest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__selectMediaTokenIdWithDigestResponse:
		return (void*)soap_instantiate_tns__selectMediaTokenIdWithDigestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__selectMediaTokenIdWithUrl:
		return (void*)soap_instantiate_tns__selectMediaTokenIdWithUrl(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__selectMediaTokenIdWithUrlResponse:
		return (void*)soap_instantiate_tns__selectMediaTokenIdWithUrlResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__selectMediaTokenWithDigest:
		return (void*)soap_instantiate_tns__selectMediaTokenWithDigest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__selectMediaTokenWithDigestResponse:
		return (void*)soap_instantiate_tns__selectMediaTokenWithDigestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__selectMediaTokenWithId:
		return (void*)soap_instantiate_tns__selectMediaTokenWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__selectMediaTokenWithIdResponse:
		return (void*)soap_instantiate_tns__selectMediaTokenWithIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__selectRelatedMediaAliasesWithTokenId:
		return (void*)soap_instantiate_tns__selectRelatedMediaAliasesWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__selectRelatedMediaAliasesWithTokenIdResponse:
		return (void*)soap_instantiate_tns__selectRelatedMediaAliasesWithTokenIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__selectRelatedMediaAnnotationsWithTokenId:
		return (void*)soap_instantiate_tns__selectRelatedMediaAnnotationsWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__selectRelatedMediaAnnotationsWithTokenIdResponse:
		return (void*)soap_instantiate_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__setUserAnonymous:
		return (void*)soap_instantiate_tns__setUserAnonymous(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__setUserAnonymousResponse:
		return (void*)soap_instantiate_tns__setUserAnonymousResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__setUserLanguage:
		return (void*)soap_instantiate_tns__setUserLanguage(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__setUserLanguageResponse:
		return (void*)soap_instantiate_tns__setUserLanguageResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__submitGameThread:
		return (void*)soap_instantiate_tns__submitGameThread(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__submitGameThreadResponse:
		return (void*)soap_instantiate_tns__submitGameThreadResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__submitMediaAlias:
		return (void*)soap_instantiate_tns__submitMediaAlias(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__submitMediaAliasResponse:
		return (void*)soap_instantiate_tns__submitMediaAliasResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__submitMediaAliasTextAndTokenDigest:
		return (void*)soap_instantiate_tns__submitMediaAliasTextAndTokenDigest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__submitMediaAliasTextAndTokenDigestResponse:
		return (void*)soap_instantiate_tns__submitMediaAliasTextAndTokenDigestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__submitMediaAliasTextWithTokenId:
		return (void*)soap_instantiate_tns__submitMediaAliasTextWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__submitMediaAliasTextWithTokenIdResponse:
		return (void*)soap_instantiate_tns__submitMediaAliasTextWithTokenIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__submitMediaAnnotation:
		return (void*)soap_instantiate_tns__submitMediaAnnotation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__submitMediaAnnotationResponse:
		return (void*)soap_instantiate_tns__submitMediaAnnotationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__submitMediaAnnotationTextAndTokenDigest:
		return (void*)soap_instantiate_tns__submitMediaAnnotationTextAndTokenDigest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__submitMediaAnnotationTextAndTokenDigestResponse:
		return (void*)soap_instantiate_tns__submitMediaAnnotationTextAndTokenDigestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__submitMediaAnnotationTextWithTokenId:
		return (void*)soap_instantiate_tns__submitMediaAnnotationTextWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__submitMediaAnnotationTextWithTokenIdResponse:
		return (void*)soap_instantiate_tns__submitMediaAnnotationTextWithTokenIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__submitMediaToken:
		return (void*)soap_instantiate_tns__submitMediaToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__submitMediaTokenResponse:
		return (void*)soap_instantiate_tns__submitMediaTokenResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__submitMediaTokenDigest:
		return (void*)soap_instantiate_tns__submitMediaTokenDigest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__submitMediaTokenDigestResponse:
		return (void*)soap_instantiate_tns__submitMediaTokenDigestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__submitMediaTokenUrl:
		return (void*)soap_instantiate_tns__submitMediaTokenUrl(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__submitMediaTokenUrlResponse:
		return (void*)soap_instantiate_tns__submitMediaTokenUrlResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__updateGameThread:
		return (void*)soap_instantiate_tns__updateGameThread(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__updateGameThreadResponse:
		return (void*)soap_instantiate_tns__updateGameThreadResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__updateMediaAnnotationLanguageWithId:
		return (void*)soap_instantiate_tns__updateMediaAnnotationLanguageWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__updateMediaAnnotationLanguageWithIdResponse:
		return (void*)soap_instantiate_tns__updateMediaAnnotationLanguageWithIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__updateMediaAnnotationTextWithId:
		return (void*)soap_instantiate_tns__updateMediaAnnotationTextWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__updateMediaAnnotationTextWithIdResponse:
		return (void*)soap_instantiate_tns__updateMediaAnnotationTextWithIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__updateMediaAnnotationUserIdWithId:
		return (void*)soap_instantiate_tns__updateMediaAnnotationUserIdWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_tns__updateMediaAnnotationUserIdWithIdResponse:
		return (void*)soap_instantiate_tns__updateMediaAnnotationUserIdWithIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__blessMediaAliasWithId:
		return (void*)soap_instantiate___tns__blessMediaAliasWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__blessMediaAnnotationWithId:
		return (void*)soap_instantiate___tns__blessMediaAnnotationWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__blessMediaTokenWithId:
		return (void*)soap_instantiate___tns__blessMediaTokenWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__blessUserWithId:
		return (void*)soap_instantiate___tns__blessUserWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__blockMediaAliasWithId:
		return (void*)soap_instantiate___tns__blockMediaAliasWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__blockMediaAnnotationWithId:
		return (void*)soap_instantiate___tns__blockMediaAnnotationWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__blockUserWithId:
		return (void*)soap_instantiate___tns__blockUserWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__chat:
		return (void*)soap_instantiate___tns__chat(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__curseMediaAliasWithId:
		return (void*)soap_instantiate___tns__curseMediaAliasWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__curseMediaAnnotationWithId:
		return (void*)soap_instantiate___tns__curseMediaAnnotationWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__curseMediaTokenWithId:
		return (void*)soap_instantiate___tns__curseMediaTokenWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__curseUserWithId:
		return (void*)soap_instantiate___tns__curseUserWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__deleteMediaAliasWithId:
		return (void*)soap_instantiate___tns__deleteMediaAliasWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__deleteMediaAnnotationWithId:
		return (void*)soap_instantiate___tns__deleteMediaAnnotationWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__getUser:
		return (void*)soap_instantiate___tns__getUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__isAuthorized:
		return (void*)soap_instantiate___tns__isAuthorized(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__isConnected:
		return (void*)soap_instantiate___tns__isConnected(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__isLatestApp:
		return (void*)soap_instantiate___tns__isLatestApp(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__login:
		return (void*)soap_instantiate___tns__login(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__selectGameThreadWithTokenDigest:
		return (void*)soap_instantiate___tns__selectGameThreadWithTokenDigest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__selectGameThreadWithTokenId:
		return (void*)soap_instantiate___tns__selectGameThreadWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__selectMediaAliasesWithTokenId:
		return (void*)soap_instantiate___tns__selectMediaAliasesWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__selectMediaAnnotationsWithTokenId:
		return (void*)soap_instantiate___tns__selectMediaAnnotationsWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__selectMediaTokenIdWithDigest:
		return (void*)soap_instantiate___tns__selectMediaTokenIdWithDigest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__selectMediaTokenIdWithUrl:
		return (void*)soap_instantiate___tns__selectMediaTokenIdWithUrl(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__selectMediaTokenWithDigest:
		return (void*)soap_instantiate___tns__selectMediaTokenWithDigest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__selectMediaTokenWithId:
		return (void*)soap_instantiate___tns__selectMediaTokenWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__selectRelatedMediaAliasesWithTokenId:
		return (void*)soap_instantiate___tns__selectRelatedMediaAliasesWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__selectRelatedMediaAnnotationsWithTokenId:
		return (void*)soap_instantiate___tns__selectRelatedMediaAnnotationsWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__setUserAnonymous:
		return (void*)soap_instantiate___tns__setUserAnonymous(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__setUserLanguage:
		return (void*)soap_instantiate___tns__setUserLanguage(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__submitGameThread:
		return (void*)soap_instantiate___tns__submitGameThread(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__submitMediaAlias:
		return (void*)soap_instantiate___tns__submitMediaAlias(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__submitMediaAliasTextAndTokenDigest:
		return (void*)soap_instantiate___tns__submitMediaAliasTextAndTokenDigest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__submitMediaAliasTextWithTokenId:
		return (void*)soap_instantiate___tns__submitMediaAliasTextWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__submitMediaAnnotation:
		return (void*)soap_instantiate___tns__submitMediaAnnotation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__submitMediaAnnotationTextAndTokenDigest:
		return (void*)soap_instantiate___tns__submitMediaAnnotationTextAndTokenDigest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__submitMediaAnnotationTextWithTokenId:
		return (void*)soap_instantiate___tns__submitMediaAnnotationTextWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__submitMediaToken:
		return (void*)soap_instantiate___tns__submitMediaToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__submitMediaTokenDigest:
		return (void*)soap_instantiate___tns__submitMediaTokenDigest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__submitMediaTokenUrl:
		return (void*)soap_instantiate___tns__submitMediaTokenUrl(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__updateGameThread:
		return (void*)soap_instantiate___tns__updateGameThread(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__updateMediaAnnotationLanguageWithId:
		return (void*)soap_instantiate___tns__updateMediaAnnotationLanguageWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__updateMediaAnnotationTextWithId:
		return (void*)soap_instantiate___tns__updateMediaAnnotationTextWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot___tns__updateMediaAnnotationUserIdWithId:
		return (void*)soap_instantiate___tns__updateMediaAnnotationUserIdWithId(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_Annot_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_Annot_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_Annot_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_Annot_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_Annot_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_Annot_std__vectorTemplateOfPointerTotns__mediaAnnotation:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTotns__mediaAnnotation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Annot_std__vectorTemplateOfPointerTotns__mediaAlias:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTotns__mediaAlias(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 Annot_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_Annot_std__string:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__gameThread:
		if (p->size < 0)
			SOAP_DELETE((tns__gameThread*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__gameThread*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__mediaAnnotation:
		if (p->size < 0)
			SOAP_DELETE((tns__mediaAnnotation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__mediaAnnotation*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__mediaToken:
		if (p->size < 0)
			SOAP_DELETE((tns__mediaToken*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__mediaToken*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__mediaAlias:
		if (p->size < 0)
			SOAP_DELETE((tns__mediaAlias*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__mediaAlias*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__user:
		if (p->size < 0)
			SOAP_DELETE((tns__user*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__user*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__blessMediaAliasWithId:
		if (p->size < 0)
			SOAP_DELETE((tns__blessMediaAliasWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__blessMediaAliasWithId*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__blessMediaAliasWithIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__blessMediaAliasWithIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__blessMediaAliasWithIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__blessMediaAnnotationWithId:
		if (p->size < 0)
			SOAP_DELETE((tns__blessMediaAnnotationWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__blessMediaAnnotationWithId*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__blessMediaAnnotationWithIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__blessMediaAnnotationWithIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__blessMediaAnnotationWithIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__blessMediaTokenWithId:
		if (p->size < 0)
			SOAP_DELETE((tns__blessMediaTokenWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__blessMediaTokenWithId*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__blessMediaTokenWithIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__blessMediaTokenWithIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__blessMediaTokenWithIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__blessUserWithId:
		if (p->size < 0)
			SOAP_DELETE((tns__blessUserWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__blessUserWithId*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__blessUserWithIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__blessUserWithIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__blessUserWithIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__blockMediaAliasWithId:
		if (p->size < 0)
			SOAP_DELETE((tns__blockMediaAliasWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__blockMediaAliasWithId*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__blockMediaAliasWithIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__blockMediaAliasWithIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__blockMediaAliasWithIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__blockMediaAnnotationWithId:
		if (p->size < 0)
			SOAP_DELETE((tns__blockMediaAnnotationWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__blockMediaAnnotationWithId*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__blockMediaAnnotationWithIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__blockMediaAnnotationWithIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__blockMediaAnnotationWithIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__blockUserWithId:
		if (p->size < 0)
			SOAP_DELETE((tns__blockUserWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__blockUserWithId*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__blockUserWithIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__blockUserWithIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__blockUserWithIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__chat:
		if (p->size < 0)
			SOAP_DELETE((tns__chat*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__chat*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__chatResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__chatResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__chatResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__curseMediaAliasWithId:
		if (p->size < 0)
			SOAP_DELETE((tns__curseMediaAliasWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__curseMediaAliasWithId*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__curseMediaAliasWithIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__curseMediaAliasWithIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__curseMediaAliasWithIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__curseMediaAnnotationWithId:
		if (p->size < 0)
			SOAP_DELETE((tns__curseMediaAnnotationWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__curseMediaAnnotationWithId*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__curseMediaAnnotationWithIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__curseMediaAnnotationWithIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__curseMediaAnnotationWithIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__curseMediaTokenWithId:
		if (p->size < 0)
			SOAP_DELETE((tns__curseMediaTokenWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__curseMediaTokenWithId*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__curseMediaTokenWithIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__curseMediaTokenWithIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__curseMediaTokenWithIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__curseUserWithId:
		if (p->size < 0)
			SOAP_DELETE((tns__curseUserWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__curseUserWithId*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__curseUserWithIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__curseUserWithIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__curseUserWithIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__deleteMediaAliasWithId:
		if (p->size < 0)
			SOAP_DELETE((tns__deleteMediaAliasWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__deleteMediaAliasWithId*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__deleteMediaAliasWithIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__deleteMediaAliasWithIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__deleteMediaAliasWithIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__deleteMediaAnnotationWithId:
		if (p->size < 0)
			SOAP_DELETE((tns__deleteMediaAnnotationWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__deleteMediaAnnotationWithId*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__deleteMediaAnnotationWithIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__deleteMediaAnnotationWithIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__deleteMediaAnnotationWithIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__getUser:
		if (p->size < 0)
			SOAP_DELETE((tns__getUser*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__getUser*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__getUserResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__getUserResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__getUserResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__isAuthorized:
		if (p->size < 0)
			SOAP_DELETE((tns__isAuthorized*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__isAuthorized*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__isAuthorizedResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__isAuthorizedResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__isAuthorizedResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__isConnected:
		if (p->size < 0)
			SOAP_DELETE((tns__isConnected*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__isConnected*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__isConnectedResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__isConnectedResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__isConnectedResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__isLatestApp:
		if (p->size < 0)
			SOAP_DELETE((tns__isLatestApp*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__isLatestApp*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__isLatestAppResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__isLatestAppResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__isLatestAppResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__login:
		if (p->size < 0)
			SOAP_DELETE((tns__login*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__login*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__loginResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__loginResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__loginResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__selectGameThreadWithTokenDigest:
		if (p->size < 0)
			SOAP_DELETE((tns__selectGameThreadWithTokenDigest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectGameThreadWithTokenDigest*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__selectGameThreadWithTokenDigestResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__selectGameThreadWithTokenDigestResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectGameThreadWithTokenDigestResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__selectGameThreadWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((tns__selectGameThreadWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectGameThreadWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__selectGameThreadWithTokenIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__selectGameThreadWithTokenIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectGameThreadWithTokenIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__selectMediaAliasesWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((tns__selectMediaAliasesWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectMediaAliasesWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__selectMediaAliasesWithTokenIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__selectMediaAliasesWithTokenIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectMediaAliasesWithTokenIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__selectMediaAnnotationsWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((tns__selectMediaAnnotationsWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectMediaAnnotationsWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__selectMediaAnnotationsWithTokenIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__selectMediaAnnotationsWithTokenIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectMediaAnnotationsWithTokenIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__selectMediaTokenIdWithDigest:
		if (p->size < 0)
			SOAP_DELETE((tns__selectMediaTokenIdWithDigest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectMediaTokenIdWithDigest*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__selectMediaTokenIdWithDigestResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__selectMediaTokenIdWithDigestResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectMediaTokenIdWithDigestResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__selectMediaTokenIdWithUrl:
		if (p->size < 0)
			SOAP_DELETE((tns__selectMediaTokenIdWithUrl*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectMediaTokenIdWithUrl*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__selectMediaTokenIdWithUrlResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__selectMediaTokenIdWithUrlResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectMediaTokenIdWithUrlResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__selectMediaTokenWithDigest:
		if (p->size < 0)
			SOAP_DELETE((tns__selectMediaTokenWithDigest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectMediaTokenWithDigest*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__selectMediaTokenWithDigestResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__selectMediaTokenWithDigestResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectMediaTokenWithDigestResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__selectMediaTokenWithId:
		if (p->size < 0)
			SOAP_DELETE((tns__selectMediaTokenWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectMediaTokenWithId*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__selectMediaTokenWithIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__selectMediaTokenWithIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectMediaTokenWithIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__selectRelatedMediaAliasesWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((tns__selectRelatedMediaAliasesWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectRelatedMediaAliasesWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__selectRelatedMediaAliasesWithTokenIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__selectRelatedMediaAliasesWithTokenIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectRelatedMediaAliasesWithTokenIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__selectRelatedMediaAnnotationsWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((tns__selectRelatedMediaAnnotationsWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectRelatedMediaAnnotationsWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__selectRelatedMediaAnnotationsWithTokenIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__selectRelatedMediaAnnotationsWithTokenIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectRelatedMediaAnnotationsWithTokenIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__setUserAnonymous:
		if (p->size < 0)
			SOAP_DELETE((tns__setUserAnonymous*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__setUserAnonymous*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__setUserAnonymousResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__setUserAnonymousResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__setUserAnonymousResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__setUserLanguage:
		if (p->size < 0)
			SOAP_DELETE((tns__setUserLanguage*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__setUserLanguage*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__setUserLanguageResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__setUserLanguageResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__setUserLanguageResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__submitGameThread:
		if (p->size < 0)
			SOAP_DELETE((tns__submitGameThread*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitGameThread*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__submitGameThreadResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__submitGameThreadResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitGameThreadResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__submitMediaAlias:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaAlias*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaAlias*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__submitMediaAliasResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaAliasResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaAliasResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__submitMediaAliasTextAndTokenDigest:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaAliasTextAndTokenDigest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaAliasTextAndTokenDigest*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__submitMediaAliasTextAndTokenDigestResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaAliasTextAndTokenDigestResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaAliasTextAndTokenDigestResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__submitMediaAliasTextWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaAliasTextWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaAliasTextWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__submitMediaAliasTextWithTokenIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaAliasTextWithTokenIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaAliasTextWithTokenIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__submitMediaAnnotation:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaAnnotation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaAnnotation*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__submitMediaAnnotationResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaAnnotationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaAnnotationResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__submitMediaAnnotationTextAndTokenDigest:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaAnnotationTextAndTokenDigest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaAnnotationTextAndTokenDigest*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__submitMediaAnnotationTextAndTokenDigestResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaAnnotationTextAndTokenDigestResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaAnnotationTextAndTokenDigestResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__submitMediaAnnotationTextWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaAnnotationTextWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaAnnotationTextWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__submitMediaAnnotationTextWithTokenIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaAnnotationTextWithTokenIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaAnnotationTextWithTokenIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__submitMediaToken:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaToken*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaToken*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__submitMediaTokenResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaTokenResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaTokenResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__submitMediaTokenDigest:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaTokenDigest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaTokenDigest*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__submitMediaTokenDigestResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaTokenDigestResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaTokenDigestResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__submitMediaTokenUrl:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaTokenUrl*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaTokenUrl*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__submitMediaTokenUrlResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaTokenUrlResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaTokenUrlResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__updateGameThread:
		if (p->size < 0)
			SOAP_DELETE((tns__updateGameThread*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__updateGameThread*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__updateGameThreadResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__updateGameThreadResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__updateGameThreadResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__updateMediaAnnotationLanguageWithId:
		if (p->size < 0)
			SOAP_DELETE((tns__updateMediaAnnotationLanguageWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__updateMediaAnnotationLanguageWithId*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__updateMediaAnnotationLanguageWithIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__updateMediaAnnotationLanguageWithIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__updateMediaAnnotationLanguageWithIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__updateMediaAnnotationTextWithId:
		if (p->size < 0)
			SOAP_DELETE((tns__updateMediaAnnotationTextWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__updateMediaAnnotationTextWithId*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__updateMediaAnnotationTextWithIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__updateMediaAnnotationTextWithIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__updateMediaAnnotationTextWithIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__updateMediaAnnotationUserIdWithId:
		if (p->size < 0)
			SOAP_DELETE((tns__updateMediaAnnotationUserIdWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__updateMediaAnnotationUserIdWithId*)p->ptr);
		break;
	case SOAP_TYPE_Annot_tns__updateMediaAnnotationUserIdWithIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__updateMediaAnnotationUserIdWithIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__updateMediaAnnotationUserIdWithIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__blessMediaAliasWithId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__blessMediaAliasWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__blessMediaAliasWithId*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__blessMediaAnnotationWithId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__blessMediaAnnotationWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__blessMediaAnnotationWithId*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__blessMediaTokenWithId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__blessMediaTokenWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__blessMediaTokenWithId*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__blessUserWithId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__blessUserWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__blessUserWithId*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__blockMediaAliasWithId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__blockMediaAliasWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__blockMediaAliasWithId*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__blockMediaAnnotationWithId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__blockMediaAnnotationWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__blockMediaAnnotationWithId*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__blockUserWithId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__blockUserWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__blockUserWithId*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__chat:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__chat*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__chat*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__curseMediaAliasWithId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__curseMediaAliasWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__curseMediaAliasWithId*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__curseMediaAnnotationWithId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__curseMediaAnnotationWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__curseMediaAnnotationWithId*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__curseMediaTokenWithId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__curseMediaTokenWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__curseMediaTokenWithId*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__curseUserWithId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__curseUserWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__curseUserWithId*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__deleteMediaAliasWithId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__deleteMediaAliasWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__deleteMediaAliasWithId*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__deleteMediaAnnotationWithId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__deleteMediaAnnotationWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__deleteMediaAnnotationWithId*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__getUser:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__getUser*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__getUser*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__isAuthorized:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__isAuthorized*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__isAuthorized*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__isConnected:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__isConnected*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__isConnected*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__isLatestApp:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__isLatestApp*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__isLatestApp*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__login:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__login*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__login*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__selectGameThreadWithTokenDigest:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__selectGameThreadWithTokenDigest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__selectGameThreadWithTokenDigest*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__selectGameThreadWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__selectGameThreadWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__selectGameThreadWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__selectMediaAliasesWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__selectMediaAliasesWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__selectMediaAliasesWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__selectMediaAnnotationsWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__selectMediaAnnotationsWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__selectMediaAnnotationsWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__selectMediaTokenIdWithDigest:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__selectMediaTokenIdWithDigest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__selectMediaTokenIdWithDigest*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__selectMediaTokenIdWithUrl:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__selectMediaTokenIdWithUrl*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__selectMediaTokenIdWithUrl*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__selectMediaTokenWithDigest:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__selectMediaTokenWithDigest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__selectMediaTokenWithDigest*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__selectMediaTokenWithId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__selectMediaTokenWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__selectMediaTokenWithId*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__selectRelatedMediaAliasesWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__selectRelatedMediaAliasesWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__selectRelatedMediaAliasesWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__selectRelatedMediaAnnotationsWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__selectRelatedMediaAnnotationsWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__selectRelatedMediaAnnotationsWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__setUserAnonymous:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__setUserAnonymous*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__setUserAnonymous*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__setUserLanguage:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__setUserLanguage*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__setUserLanguage*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__submitGameThread:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__submitGameThread*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__submitGameThread*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__submitMediaAlias:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__submitMediaAlias*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__submitMediaAlias*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__submitMediaAliasTextAndTokenDigest:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__submitMediaAliasTextAndTokenDigest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__submitMediaAliasTextAndTokenDigest*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__submitMediaAliasTextWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__submitMediaAliasTextWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__submitMediaAliasTextWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__submitMediaAnnotation:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__submitMediaAnnotation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__submitMediaAnnotation*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__submitMediaAnnotationTextAndTokenDigest:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__submitMediaAnnotationTextAndTokenDigest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__submitMediaAnnotationTextAndTokenDigest*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__submitMediaAnnotationTextWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__submitMediaAnnotationTextWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__submitMediaAnnotationTextWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__submitMediaToken:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__submitMediaToken*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__submitMediaToken*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__submitMediaTokenDigest:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__submitMediaTokenDigest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__submitMediaTokenDigest*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__submitMediaTokenUrl:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__submitMediaTokenUrl*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__submitMediaTokenUrl*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__updateGameThread:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__updateGameThread*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__updateGameThread*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__updateMediaAnnotationLanguageWithId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__updateMediaAnnotationLanguageWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__updateMediaAnnotationLanguageWithId*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__updateMediaAnnotationTextWithId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__updateMediaAnnotationTextWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__updateMediaAnnotationTextWithId*)p->ptr);
		break;
	case SOAP_TYPE_Annot___tns__updateMediaAnnotationUserIdWithId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__updateMediaAnnotationUserIdWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__updateMediaAnnotationUserIdWithId*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_Annot_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_Annot_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_Annot_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_Annot_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_Annot_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	case SOAP_TYPE_Annot_std__vectorTemplateOfPointerTotns__mediaAnnotation:
		if (p->size < 0)
			SOAP_DELETE((std::vector<tns__mediaAnnotation * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<tns__mediaAnnotation * >*)p->ptr);
		break;
	case SOAP_TYPE_Annot_std__vectorTemplateOfPointerTotns__mediaAlias:
		if (p->size < 0)
			SOAP_DELETE((std::vector<tns__mediaAlias * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<tns__mediaAlias * >*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, Annot_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, Annot_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 Annot_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_Annot_std__vectorTemplateOfPointerTotns__mediaAnnotation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container Annot_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<tns__mediaAnnotation * >*)p)[len] = *(tns__mediaAnnotation **)q;
		break;
	case SOAP_TYPE_Annot_std__vectorTemplateOfPointerTotns__mediaAlias:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container Annot_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<tns__mediaAlias * >*)p)[len] = *(tns__mediaAlias **)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_Annot_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_Annot_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_Annot_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_Annot_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_Annot_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{	LONG64 *p;
	p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_Annot_LONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_LONG64);
	if (soap_out_LONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_Annot_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_Annot_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_Annot_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_Annot_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_std__string, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::string[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void tns__updateMediaAnnotationUserIdWithIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__updateMediaAnnotationUserIdWithIdResponse::return_);
	/* transient soap skipped */
}

void tns__updateMediaAnnotationUserIdWithIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__updateMediaAnnotationUserIdWithIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__updateMediaAnnotationUserIdWithIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__updateMediaAnnotationUserIdWithIdResponse(struct soap *soap, const char *tag, int id, const tns__updateMediaAnnotationUserIdWithIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__updateMediaAnnotationUserIdWithIdResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__updateMediaAnnotationUserIdWithIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__updateMediaAnnotationUserIdWithIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__updateMediaAnnotationUserIdWithIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__updateMediaAnnotationUserIdWithIdResponse * SOAP_FMAC4 soap_in_tns__updateMediaAnnotationUserIdWithIdResponse(struct soap *soap, const char *tag, tns__updateMediaAnnotationUserIdWithIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__updateMediaAnnotationUserIdWithIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__updateMediaAnnotationUserIdWithIdResponse, sizeof(tns__updateMediaAnnotationUserIdWithIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__updateMediaAnnotationUserIdWithIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__updateMediaAnnotationUserIdWithIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__updateMediaAnnotationUserIdWithIdResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__updateMediaAnnotationUserIdWithIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__updateMediaAnnotationUserIdWithIdResponse, 0, sizeof(tns__updateMediaAnnotationUserIdWithIdResponse), 0, soap_copy_tns__updateMediaAnnotationUserIdWithIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__updateMediaAnnotationUserIdWithIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__updateMediaAnnotationUserIdWithIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:updateMediaAnnotationUserIdWithIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__updateMediaAnnotationUserIdWithIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__updateMediaAnnotationUserIdWithIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__updateMediaAnnotationUserIdWithIdResponse * SOAP_FMAC4 soap_get_tns__updateMediaAnnotationUserIdWithIdResponse(struct soap *soap, tns__updateMediaAnnotationUserIdWithIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__updateMediaAnnotationUserIdWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__updateMediaAnnotationUserIdWithIdResponse * SOAP_FMAC2 soap_instantiate_tns__updateMediaAnnotationUserIdWithIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__updateMediaAnnotationUserIdWithIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__updateMediaAnnotationUserIdWithIdResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__updateMediaAnnotationUserIdWithIdResponse);
		if (size)
			*size = sizeof(tns__updateMediaAnnotationUserIdWithIdResponse);
		((tns__updateMediaAnnotationUserIdWithIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__updateMediaAnnotationUserIdWithIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__updateMediaAnnotationUserIdWithIdResponse);
		for (int i = 0; i < n; i++)
			((tns__updateMediaAnnotationUserIdWithIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__updateMediaAnnotationUserIdWithIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__updateMediaAnnotationUserIdWithIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__updateMediaAnnotationUserIdWithIdResponse %p -> %p\n", q, p));
	*(tns__updateMediaAnnotationUserIdWithIdResponse*)p = *(tns__updateMediaAnnotationUserIdWithIdResponse*)q;
}

void tns__updateMediaAnnotationUserIdWithId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__updateMediaAnnotationUserIdWithId::userId);
	soap_default_LONG64(soap, &this->tns__updateMediaAnnotationUserIdWithId::id);
	/* transient soap skipped */
}

void tns__updateMediaAnnotationUserIdWithId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__updateMediaAnnotationUserIdWithId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__updateMediaAnnotationUserIdWithId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__updateMediaAnnotationUserIdWithId(struct soap *soap, const char *tag, int id, const tns__updateMediaAnnotationUserIdWithId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__updateMediaAnnotationUserIdWithId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "userId", -1, &(a->tns__updateMediaAnnotationUserIdWithId::userId), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "id", -1, &(a->tns__updateMediaAnnotationUserIdWithId::id), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__updateMediaAnnotationUserIdWithId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__updateMediaAnnotationUserIdWithId(soap, tag, this, type);
}

SOAP_FMAC3 tns__updateMediaAnnotationUserIdWithId * SOAP_FMAC4 soap_in_tns__updateMediaAnnotationUserIdWithId(struct soap *soap, const char *tag, tns__updateMediaAnnotationUserIdWithId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__updateMediaAnnotationUserIdWithId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__updateMediaAnnotationUserIdWithId, sizeof(tns__updateMediaAnnotationUserIdWithId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__updateMediaAnnotationUserIdWithId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__updateMediaAnnotationUserIdWithId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "userId", &(a->tns__updateMediaAnnotationUserIdWithId::userId), "xsd:long"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "id", &(a->tns__updateMediaAnnotationUserIdWithId::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__updateMediaAnnotationUserIdWithId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__updateMediaAnnotationUserIdWithId, 0, sizeof(tns__updateMediaAnnotationUserIdWithId), 0, soap_copy_tns__updateMediaAnnotationUserIdWithId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_userId1 > 0 || soap_flag_id1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__updateMediaAnnotationUserIdWithId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__updateMediaAnnotationUserIdWithId);
	if (this->soap_out(soap, tag?tag:"tns:updateMediaAnnotationUserIdWithId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__updateMediaAnnotationUserIdWithId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__updateMediaAnnotationUserIdWithId(soap, this, tag, type);
}

SOAP_FMAC3 tns__updateMediaAnnotationUserIdWithId * SOAP_FMAC4 soap_get_tns__updateMediaAnnotationUserIdWithId(struct soap *soap, tns__updateMediaAnnotationUserIdWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__updateMediaAnnotationUserIdWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__updateMediaAnnotationUserIdWithId * SOAP_FMAC2 soap_instantiate_tns__updateMediaAnnotationUserIdWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__updateMediaAnnotationUserIdWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__updateMediaAnnotationUserIdWithId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__updateMediaAnnotationUserIdWithId);
		if (size)
			*size = sizeof(tns__updateMediaAnnotationUserIdWithId);
		((tns__updateMediaAnnotationUserIdWithId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__updateMediaAnnotationUserIdWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__updateMediaAnnotationUserIdWithId);
		for (int i = 0; i < n; i++)
			((tns__updateMediaAnnotationUserIdWithId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__updateMediaAnnotationUserIdWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__updateMediaAnnotationUserIdWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__updateMediaAnnotationUserIdWithId %p -> %p\n", q, p));
	*(tns__updateMediaAnnotationUserIdWithId*)p = *(tns__updateMediaAnnotationUserIdWithId*)q;
}

void tns__updateMediaAnnotationTextWithIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__updateMediaAnnotationTextWithIdResponse::return_);
	/* transient soap skipped */
}

void tns__updateMediaAnnotationTextWithIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__updateMediaAnnotationTextWithIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__updateMediaAnnotationTextWithIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__updateMediaAnnotationTextWithIdResponse(struct soap *soap, const char *tag, int id, const tns__updateMediaAnnotationTextWithIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__updateMediaAnnotationTextWithIdResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__updateMediaAnnotationTextWithIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__updateMediaAnnotationTextWithIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__updateMediaAnnotationTextWithIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__updateMediaAnnotationTextWithIdResponse * SOAP_FMAC4 soap_in_tns__updateMediaAnnotationTextWithIdResponse(struct soap *soap, const char *tag, tns__updateMediaAnnotationTextWithIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__updateMediaAnnotationTextWithIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__updateMediaAnnotationTextWithIdResponse, sizeof(tns__updateMediaAnnotationTextWithIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__updateMediaAnnotationTextWithIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__updateMediaAnnotationTextWithIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__updateMediaAnnotationTextWithIdResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__updateMediaAnnotationTextWithIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__updateMediaAnnotationTextWithIdResponse, 0, sizeof(tns__updateMediaAnnotationTextWithIdResponse), 0, soap_copy_tns__updateMediaAnnotationTextWithIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__updateMediaAnnotationTextWithIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__updateMediaAnnotationTextWithIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:updateMediaAnnotationTextWithIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__updateMediaAnnotationTextWithIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__updateMediaAnnotationTextWithIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__updateMediaAnnotationTextWithIdResponse * SOAP_FMAC4 soap_get_tns__updateMediaAnnotationTextWithIdResponse(struct soap *soap, tns__updateMediaAnnotationTextWithIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__updateMediaAnnotationTextWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__updateMediaAnnotationTextWithIdResponse * SOAP_FMAC2 soap_instantiate_tns__updateMediaAnnotationTextWithIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__updateMediaAnnotationTextWithIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__updateMediaAnnotationTextWithIdResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__updateMediaAnnotationTextWithIdResponse);
		if (size)
			*size = sizeof(tns__updateMediaAnnotationTextWithIdResponse);
		((tns__updateMediaAnnotationTextWithIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__updateMediaAnnotationTextWithIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__updateMediaAnnotationTextWithIdResponse);
		for (int i = 0; i < n; i++)
			((tns__updateMediaAnnotationTextWithIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__updateMediaAnnotationTextWithIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__updateMediaAnnotationTextWithIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__updateMediaAnnotationTextWithIdResponse %p -> %p\n", q, p));
	*(tns__updateMediaAnnotationTextWithIdResponse*)p = *(tns__updateMediaAnnotationTextWithIdResponse*)q;
}

void tns__updateMediaAnnotationTextWithId::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__updateMediaAnnotationTextWithId::text = NULL;
	soap_default_LONG64(soap, &this->tns__updateMediaAnnotationTextWithId::id);
	/* transient soap skipped */
}

void tns__updateMediaAnnotationTextWithId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__updateMediaAnnotationTextWithId::text);
	/* transient soap skipped */
}

int tns__updateMediaAnnotationTextWithId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__updateMediaAnnotationTextWithId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__updateMediaAnnotationTextWithId(struct soap *soap, const char *tag, int id, const tns__updateMediaAnnotationTextWithId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__updateMediaAnnotationTextWithId), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "text", -1, &(a->tns__updateMediaAnnotationTextWithId::text), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "id", -1, &(a->tns__updateMediaAnnotationTextWithId::id), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__updateMediaAnnotationTextWithId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__updateMediaAnnotationTextWithId(soap, tag, this, type);
}

SOAP_FMAC3 tns__updateMediaAnnotationTextWithId * SOAP_FMAC4 soap_in_tns__updateMediaAnnotationTextWithId(struct soap *soap, const char *tag, tns__updateMediaAnnotationTextWithId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__updateMediaAnnotationTextWithId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__updateMediaAnnotationTextWithId, sizeof(tns__updateMediaAnnotationTextWithId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__updateMediaAnnotationTextWithId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__updateMediaAnnotationTextWithId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_text1 = 1;
	size_t soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_text1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "text", &(a->tns__updateMediaAnnotationTextWithId::text), "xsd:string"))
				{	soap_flag_text1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "id", &(a->tns__updateMediaAnnotationTextWithId::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__updateMediaAnnotationTextWithId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__updateMediaAnnotationTextWithId, 0, sizeof(tns__updateMediaAnnotationTextWithId), 0, soap_copy_tns__updateMediaAnnotationTextWithId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__updateMediaAnnotationTextWithId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__updateMediaAnnotationTextWithId);
	if (this->soap_out(soap, tag?tag:"tns:updateMediaAnnotationTextWithId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__updateMediaAnnotationTextWithId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__updateMediaAnnotationTextWithId(soap, this, tag, type);
}

SOAP_FMAC3 tns__updateMediaAnnotationTextWithId * SOAP_FMAC4 soap_get_tns__updateMediaAnnotationTextWithId(struct soap *soap, tns__updateMediaAnnotationTextWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__updateMediaAnnotationTextWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__updateMediaAnnotationTextWithId * SOAP_FMAC2 soap_instantiate_tns__updateMediaAnnotationTextWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__updateMediaAnnotationTextWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__updateMediaAnnotationTextWithId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__updateMediaAnnotationTextWithId);
		if (size)
			*size = sizeof(tns__updateMediaAnnotationTextWithId);
		((tns__updateMediaAnnotationTextWithId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__updateMediaAnnotationTextWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__updateMediaAnnotationTextWithId);
		for (int i = 0; i < n; i++)
			((tns__updateMediaAnnotationTextWithId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__updateMediaAnnotationTextWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__updateMediaAnnotationTextWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__updateMediaAnnotationTextWithId %p -> %p\n", q, p));
	*(tns__updateMediaAnnotationTextWithId*)p = *(tns__updateMediaAnnotationTextWithId*)q;
}

void tns__updateMediaAnnotationLanguageWithIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__updateMediaAnnotationLanguageWithIdResponse::return_);
	/* transient soap skipped */
}

void tns__updateMediaAnnotationLanguageWithIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__updateMediaAnnotationLanguageWithIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__updateMediaAnnotationLanguageWithIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__updateMediaAnnotationLanguageWithIdResponse(struct soap *soap, const char *tag, int id, const tns__updateMediaAnnotationLanguageWithIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__updateMediaAnnotationLanguageWithIdResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__updateMediaAnnotationLanguageWithIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__updateMediaAnnotationLanguageWithIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__updateMediaAnnotationLanguageWithIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__updateMediaAnnotationLanguageWithIdResponse * SOAP_FMAC4 soap_in_tns__updateMediaAnnotationLanguageWithIdResponse(struct soap *soap, const char *tag, tns__updateMediaAnnotationLanguageWithIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__updateMediaAnnotationLanguageWithIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__updateMediaAnnotationLanguageWithIdResponse, sizeof(tns__updateMediaAnnotationLanguageWithIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__updateMediaAnnotationLanguageWithIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__updateMediaAnnotationLanguageWithIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__updateMediaAnnotationLanguageWithIdResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__updateMediaAnnotationLanguageWithIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__updateMediaAnnotationLanguageWithIdResponse, 0, sizeof(tns__updateMediaAnnotationLanguageWithIdResponse), 0, soap_copy_tns__updateMediaAnnotationLanguageWithIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__updateMediaAnnotationLanguageWithIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__updateMediaAnnotationLanguageWithIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:updateMediaAnnotationLanguageWithIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__updateMediaAnnotationLanguageWithIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__updateMediaAnnotationLanguageWithIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__updateMediaAnnotationLanguageWithIdResponse * SOAP_FMAC4 soap_get_tns__updateMediaAnnotationLanguageWithIdResponse(struct soap *soap, tns__updateMediaAnnotationLanguageWithIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__updateMediaAnnotationLanguageWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__updateMediaAnnotationLanguageWithIdResponse * SOAP_FMAC2 soap_instantiate_tns__updateMediaAnnotationLanguageWithIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__updateMediaAnnotationLanguageWithIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__updateMediaAnnotationLanguageWithIdResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__updateMediaAnnotationLanguageWithIdResponse);
		if (size)
			*size = sizeof(tns__updateMediaAnnotationLanguageWithIdResponse);
		((tns__updateMediaAnnotationLanguageWithIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__updateMediaAnnotationLanguageWithIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__updateMediaAnnotationLanguageWithIdResponse);
		for (int i = 0; i < n; i++)
			((tns__updateMediaAnnotationLanguageWithIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__updateMediaAnnotationLanguageWithIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__updateMediaAnnotationLanguageWithIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__updateMediaAnnotationLanguageWithIdResponse %p -> %p\n", q, p));
	*(tns__updateMediaAnnotationLanguageWithIdResponse*)p = *(tns__updateMediaAnnotationLanguageWithIdResponse*)q;
}

void tns__updateMediaAnnotationLanguageWithId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->tns__updateMediaAnnotationLanguageWithId::language);
	soap_default_LONG64(soap, &this->tns__updateMediaAnnotationLanguageWithId::id);
	/* transient soap skipped */
}

void tns__updateMediaAnnotationLanguageWithId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__updateMediaAnnotationLanguageWithId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__updateMediaAnnotationLanguageWithId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__updateMediaAnnotationLanguageWithId(struct soap *soap, const char *tag, int id, const tns__updateMediaAnnotationLanguageWithId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__updateMediaAnnotationLanguageWithId), type))
		return soap->error;
	if (soap_out_int(soap, "language", -1, &(a->tns__updateMediaAnnotationLanguageWithId::language), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "id", -1, &(a->tns__updateMediaAnnotationLanguageWithId::id), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__updateMediaAnnotationLanguageWithId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__updateMediaAnnotationLanguageWithId(soap, tag, this, type);
}

SOAP_FMAC3 tns__updateMediaAnnotationLanguageWithId * SOAP_FMAC4 soap_in_tns__updateMediaAnnotationLanguageWithId(struct soap *soap, const char *tag, tns__updateMediaAnnotationLanguageWithId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__updateMediaAnnotationLanguageWithId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__updateMediaAnnotationLanguageWithId, sizeof(tns__updateMediaAnnotationLanguageWithId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__updateMediaAnnotationLanguageWithId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__updateMediaAnnotationLanguageWithId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_language1 = 1;
	size_t soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_language1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "language", &(a->tns__updateMediaAnnotationLanguageWithId::language), "xsd:int"))
				{	soap_flag_language1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "id", &(a->tns__updateMediaAnnotationLanguageWithId::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__updateMediaAnnotationLanguageWithId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__updateMediaAnnotationLanguageWithId, 0, sizeof(tns__updateMediaAnnotationLanguageWithId), 0, soap_copy_tns__updateMediaAnnotationLanguageWithId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_language1 > 0 || soap_flag_id1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__updateMediaAnnotationLanguageWithId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__updateMediaAnnotationLanguageWithId);
	if (this->soap_out(soap, tag?tag:"tns:updateMediaAnnotationLanguageWithId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__updateMediaAnnotationLanguageWithId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__updateMediaAnnotationLanguageWithId(soap, this, tag, type);
}

SOAP_FMAC3 tns__updateMediaAnnotationLanguageWithId * SOAP_FMAC4 soap_get_tns__updateMediaAnnotationLanguageWithId(struct soap *soap, tns__updateMediaAnnotationLanguageWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__updateMediaAnnotationLanguageWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__updateMediaAnnotationLanguageWithId * SOAP_FMAC2 soap_instantiate_tns__updateMediaAnnotationLanguageWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__updateMediaAnnotationLanguageWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__updateMediaAnnotationLanguageWithId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__updateMediaAnnotationLanguageWithId);
		if (size)
			*size = sizeof(tns__updateMediaAnnotationLanguageWithId);
		((tns__updateMediaAnnotationLanguageWithId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__updateMediaAnnotationLanguageWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__updateMediaAnnotationLanguageWithId);
		for (int i = 0; i < n; i++)
			((tns__updateMediaAnnotationLanguageWithId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__updateMediaAnnotationLanguageWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__updateMediaAnnotationLanguageWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__updateMediaAnnotationLanguageWithId %p -> %p\n", q, p));
	*(tns__updateMediaAnnotationLanguageWithId*)p = *(tns__updateMediaAnnotationLanguageWithId*)q;
}

void tns__updateGameThreadResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__updateGameThreadResponse::return_);
	/* transient soap skipped */
}

void tns__updateGameThreadResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__updateGameThreadResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__updateGameThreadResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__updateGameThreadResponse(struct soap *soap, const char *tag, int id, const tns__updateGameThreadResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__updateGameThreadResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__updateGameThreadResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__updateGameThreadResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__updateGameThreadResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__updateGameThreadResponse * SOAP_FMAC4 soap_in_tns__updateGameThreadResponse(struct soap *soap, const char *tag, tns__updateGameThreadResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__updateGameThreadResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__updateGameThreadResponse, sizeof(tns__updateGameThreadResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__updateGameThreadResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__updateGameThreadResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__updateGameThreadResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__updateGameThreadResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__updateGameThreadResponse, 0, sizeof(tns__updateGameThreadResponse), 0, soap_copy_tns__updateGameThreadResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__updateGameThreadResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__updateGameThreadResponse);
	if (this->soap_out(soap, tag?tag:"tns:updateGameThreadResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__updateGameThreadResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__updateGameThreadResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__updateGameThreadResponse * SOAP_FMAC4 soap_get_tns__updateGameThreadResponse(struct soap *soap, tns__updateGameThreadResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__updateGameThreadResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__updateGameThreadResponse * SOAP_FMAC2 soap_instantiate_tns__updateGameThreadResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__updateGameThreadResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__updateGameThreadResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__updateGameThreadResponse);
		if (size)
			*size = sizeof(tns__updateGameThreadResponse);
		((tns__updateGameThreadResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__updateGameThreadResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__updateGameThreadResponse);
		for (int i = 0; i < n; i++)
			((tns__updateGameThreadResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__updateGameThreadResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__updateGameThreadResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__updateGameThreadResponse %p -> %p\n", q, p));
	*(tns__updateGameThreadResponse*)p = *(tns__updateGameThreadResponse*)q;
}

void tns__updateGameThread::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__updateGameThread::thread = NULL;
	/* transient soap skipped */
}

void tns__updateGameThread::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__gameThread(soap, &this->tns__updateGameThread::thread);
	/* transient soap skipped */
}

int tns__updateGameThread::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__updateGameThread(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__updateGameThread(struct soap *soap, const char *tag, int id, const tns__updateGameThread *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__updateGameThread), type))
		return soap->error;
	if (soap_out_PointerTotns__gameThread(soap, "thread", -1, &(a->tns__updateGameThread::thread), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__updateGameThread::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__updateGameThread(soap, tag, this, type);
}

SOAP_FMAC3 tns__updateGameThread * SOAP_FMAC4 soap_in_tns__updateGameThread(struct soap *soap, const char *tag, tns__updateGameThread *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__updateGameThread *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__updateGameThread, sizeof(tns__updateGameThread), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__updateGameThread)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__updateGameThread *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_thread1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_thread1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__gameThread(soap, "thread", &(a->tns__updateGameThread::thread), "tns:gameThread"))
				{	soap_flag_thread1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__updateGameThread *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__updateGameThread, 0, sizeof(tns__updateGameThread), 0, soap_copy_tns__updateGameThread);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__updateGameThread::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__updateGameThread);
	if (this->soap_out(soap, tag?tag:"tns:updateGameThread", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__updateGameThread::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__updateGameThread(soap, this, tag, type);
}

SOAP_FMAC3 tns__updateGameThread * SOAP_FMAC4 soap_get_tns__updateGameThread(struct soap *soap, tns__updateGameThread *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__updateGameThread(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__updateGameThread * SOAP_FMAC2 soap_instantiate_tns__updateGameThread(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__updateGameThread(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__updateGameThread, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__updateGameThread);
		if (size)
			*size = sizeof(tns__updateGameThread);
		((tns__updateGameThread*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__updateGameThread[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__updateGameThread);
		for (int i = 0; i < n; i++)
			((tns__updateGameThread*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__updateGameThread*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__updateGameThread(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__updateGameThread %p -> %p\n", q, p));
	*(tns__updateGameThread*)p = *(tns__updateGameThread*)q;
}

void tns__submitMediaTokenUrlResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__submitMediaTokenUrlResponse::return_);
	/* transient soap skipped */
}

void tns__submitMediaTokenUrlResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__submitMediaTokenUrlResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaTokenUrlResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaTokenUrlResponse(struct soap *soap, const char *tag, int id, const tns__submitMediaTokenUrlResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__submitMediaTokenUrlResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "return", -1, &(a->tns__submitMediaTokenUrlResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaTokenUrlResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaTokenUrlResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaTokenUrlResponse * SOAP_FMAC4 soap_in_tns__submitMediaTokenUrlResponse(struct soap *soap, const char *tag, tns__submitMediaTokenUrlResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaTokenUrlResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__submitMediaTokenUrlResponse, sizeof(tns__submitMediaTokenUrlResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__submitMediaTokenUrlResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaTokenUrlResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "return", &(a->tns__submitMediaTokenUrlResponse::return_), "xsd:long"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaTokenUrlResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__submitMediaTokenUrlResponse, 0, sizeof(tns__submitMediaTokenUrlResponse), 0, soap_copy_tns__submitMediaTokenUrlResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitMediaTokenUrlResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__submitMediaTokenUrlResponse);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaTokenUrlResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaTokenUrlResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaTokenUrlResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaTokenUrlResponse * SOAP_FMAC4 soap_get_tns__submitMediaTokenUrlResponse(struct soap *soap, tns__submitMediaTokenUrlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaTokenUrlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaTokenUrlResponse * SOAP_FMAC2 soap_instantiate_tns__submitMediaTokenUrlResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaTokenUrlResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__submitMediaTokenUrlResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaTokenUrlResponse);
		if (size)
			*size = sizeof(tns__submitMediaTokenUrlResponse);
		((tns__submitMediaTokenUrlResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaTokenUrlResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaTokenUrlResponse);
		for (int i = 0; i < n; i++)
			((tns__submitMediaTokenUrlResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaTokenUrlResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaTokenUrlResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaTokenUrlResponse %p -> %p\n", q, p));
	*(tns__submitMediaTokenUrlResponse*)p = *(tns__submitMediaTokenUrlResponse*)q;
}

void tns__submitMediaTokenUrl::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__submitMediaTokenUrl::url = NULL;
	soap_default_int(soap, &this->tns__submitMediaTokenUrl::section);
	soap_default_int(soap, &this->tns__submitMediaTokenUrl::type);
	/* transient soap skipped */
}

void tns__submitMediaTokenUrl::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaTokenUrl::url);
	/* transient soap skipped */
}

int tns__submitMediaTokenUrl::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaTokenUrl(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaTokenUrl(struct soap *soap, const char *tag, int id, const tns__submitMediaTokenUrl *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__submitMediaTokenUrl), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "url", -1, &(a->tns__submitMediaTokenUrl::url), ""))
		return soap->error;
	if (soap_out_int(soap, "section", -1, &(a->tns__submitMediaTokenUrl::section), ""))
		return soap->error;
	if (soap_out_int(soap, "type", -1, &(a->tns__submitMediaTokenUrl::type), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaTokenUrl::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaTokenUrl(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaTokenUrl * SOAP_FMAC4 soap_in_tns__submitMediaTokenUrl(struct soap *soap, const char *tag, tns__submitMediaTokenUrl *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaTokenUrl *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__submitMediaTokenUrl, sizeof(tns__submitMediaTokenUrl), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__submitMediaTokenUrl)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaTokenUrl *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_url1 = 1;
	size_t soap_flag_section1 = 1;
	size_t soap_flag_type1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_url1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "url", &(a->tns__submitMediaTokenUrl::url), "xsd:string"))
				{	soap_flag_url1--;
					continue;
				}
			if (soap_flag_section1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "section", &(a->tns__submitMediaTokenUrl::section), "xsd:int"))
				{	soap_flag_section1--;
					continue;
				}
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "type", &(a->tns__submitMediaTokenUrl::type), "xsd:int"))
				{	soap_flag_type1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaTokenUrl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__submitMediaTokenUrl, 0, sizeof(tns__submitMediaTokenUrl), 0, soap_copy_tns__submitMediaTokenUrl);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_section1 > 0 || soap_flag_type1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitMediaTokenUrl::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__submitMediaTokenUrl);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaTokenUrl", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaTokenUrl::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaTokenUrl(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaTokenUrl * SOAP_FMAC4 soap_get_tns__submitMediaTokenUrl(struct soap *soap, tns__submitMediaTokenUrl *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaTokenUrl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaTokenUrl * SOAP_FMAC2 soap_instantiate_tns__submitMediaTokenUrl(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaTokenUrl(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__submitMediaTokenUrl, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaTokenUrl);
		if (size)
			*size = sizeof(tns__submitMediaTokenUrl);
		((tns__submitMediaTokenUrl*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaTokenUrl[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaTokenUrl);
		for (int i = 0; i < n; i++)
			((tns__submitMediaTokenUrl*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaTokenUrl*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaTokenUrl(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaTokenUrl %p -> %p\n", q, p));
	*(tns__submitMediaTokenUrl*)p = *(tns__submitMediaTokenUrl*)q;
}

void tns__submitMediaTokenDigestResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__submitMediaTokenDigestResponse::return_);
	/* transient soap skipped */
}

void tns__submitMediaTokenDigestResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__submitMediaTokenDigestResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaTokenDigestResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaTokenDigestResponse(struct soap *soap, const char *tag, int id, const tns__submitMediaTokenDigestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__submitMediaTokenDigestResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "return", -1, &(a->tns__submitMediaTokenDigestResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaTokenDigestResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaTokenDigestResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaTokenDigestResponse * SOAP_FMAC4 soap_in_tns__submitMediaTokenDigestResponse(struct soap *soap, const char *tag, tns__submitMediaTokenDigestResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaTokenDigestResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__submitMediaTokenDigestResponse, sizeof(tns__submitMediaTokenDigestResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__submitMediaTokenDigestResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaTokenDigestResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "return", &(a->tns__submitMediaTokenDigestResponse::return_), "xsd:long"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaTokenDigestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__submitMediaTokenDigestResponse, 0, sizeof(tns__submitMediaTokenDigestResponse), 0, soap_copy_tns__submitMediaTokenDigestResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitMediaTokenDigestResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__submitMediaTokenDigestResponse);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaTokenDigestResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaTokenDigestResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaTokenDigestResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaTokenDigestResponse * SOAP_FMAC4 soap_get_tns__submitMediaTokenDigestResponse(struct soap *soap, tns__submitMediaTokenDigestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaTokenDigestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaTokenDigestResponse * SOAP_FMAC2 soap_instantiate_tns__submitMediaTokenDigestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaTokenDigestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__submitMediaTokenDigestResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaTokenDigestResponse);
		if (size)
			*size = sizeof(tns__submitMediaTokenDigestResponse);
		((tns__submitMediaTokenDigestResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaTokenDigestResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaTokenDigestResponse);
		for (int i = 0; i < n; i++)
			((tns__submitMediaTokenDigestResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaTokenDigestResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaTokenDigestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaTokenDigestResponse %p -> %p\n", q, p));
	*(tns__submitMediaTokenDigestResponse*)p = *(tns__submitMediaTokenDigestResponse*)q;
}

void tns__submitMediaTokenDigest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__submitMediaTokenDigest::digest = NULL;
	soap_default_int(soap, &this->tns__submitMediaTokenDigest::section);
	soap_default_int(soap, &this->tns__submitMediaTokenDigest::type);
	/* transient soap skipped */
}

void tns__submitMediaTokenDigest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaTokenDigest::digest);
	/* transient soap skipped */
}

int tns__submitMediaTokenDigest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaTokenDigest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaTokenDigest(struct soap *soap, const char *tag, int id, const tns__submitMediaTokenDigest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__submitMediaTokenDigest), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "digest", -1, &(a->tns__submitMediaTokenDigest::digest), ""))
		return soap->error;
	if (soap_out_int(soap, "section", -1, &(a->tns__submitMediaTokenDigest::section), ""))
		return soap->error;
	if (soap_out_int(soap, "type", -1, &(a->tns__submitMediaTokenDigest::type), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaTokenDigest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaTokenDigest(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaTokenDigest * SOAP_FMAC4 soap_in_tns__submitMediaTokenDigest(struct soap *soap, const char *tag, tns__submitMediaTokenDigest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaTokenDigest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__submitMediaTokenDigest, sizeof(tns__submitMediaTokenDigest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__submitMediaTokenDigest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaTokenDigest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_digest1 = 1;
	size_t soap_flag_section1 = 1;
	size_t soap_flag_type1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_digest1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "digest", &(a->tns__submitMediaTokenDigest::digest), "xsd:string"))
				{	soap_flag_digest1--;
					continue;
				}
			if (soap_flag_section1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "section", &(a->tns__submitMediaTokenDigest::section), "xsd:int"))
				{	soap_flag_section1--;
					continue;
				}
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "type", &(a->tns__submitMediaTokenDigest::type), "xsd:int"))
				{	soap_flag_type1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaTokenDigest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__submitMediaTokenDigest, 0, sizeof(tns__submitMediaTokenDigest), 0, soap_copy_tns__submitMediaTokenDigest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_section1 > 0 || soap_flag_type1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitMediaTokenDigest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__submitMediaTokenDigest);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaTokenDigest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaTokenDigest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaTokenDigest(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaTokenDigest * SOAP_FMAC4 soap_get_tns__submitMediaTokenDigest(struct soap *soap, tns__submitMediaTokenDigest *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaTokenDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaTokenDigest * SOAP_FMAC2 soap_instantiate_tns__submitMediaTokenDigest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaTokenDigest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__submitMediaTokenDigest, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaTokenDigest);
		if (size)
			*size = sizeof(tns__submitMediaTokenDigest);
		((tns__submitMediaTokenDigest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaTokenDigest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaTokenDigest);
		for (int i = 0; i < n; i++)
			((tns__submitMediaTokenDigest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaTokenDigest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaTokenDigest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaTokenDigest %p -> %p\n", q, p));
	*(tns__submitMediaTokenDigest*)p = *(tns__submitMediaTokenDigest*)q;
}

void tns__submitMediaTokenResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__submitMediaTokenResponse::return_);
	/* transient soap skipped */
}

void tns__submitMediaTokenResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__submitMediaTokenResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaTokenResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaTokenResponse(struct soap *soap, const char *tag, int id, const tns__submitMediaTokenResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__submitMediaTokenResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "return", -1, &(a->tns__submitMediaTokenResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaTokenResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaTokenResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaTokenResponse * SOAP_FMAC4 soap_in_tns__submitMediaTokenResponse(struct soap *soap, const char *tag, tns__submitMediaTokenResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaTokenResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__submitMediaTokenResponse, sizeof(tns__submitMediaTokenResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__submitMediaTokenResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaTokenResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "return", &(a->tns__submitMediaTokenResponse::return_), "xsd:long"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaTokenResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__submitMediaTokenResponse, 0, sizeof(tns__submitMediaTokenResponse), 0, soap_copy_tns__submitMediaTokenResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitMediaTokenResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__submitMediaTokenResponse);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaTokenResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaTokenResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaTokenResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaTokenResponse * SOAP_FMAC4 soap_get_tns__submitMediaTokenResponse(struct soap *soap, tns__submitMediaTokenResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaTokenResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaTokenResponse * SOAP_FMAC2 soap_instantiate_tns__submitMediaTokenResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaTokenResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__submitMediaTokenResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaTokenResponse);
		if (size)
			*size = sizeof(tns__submitMediaTokenResponse);
		((tns__submitMediaTokenResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaTokenResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaTokenResponse);
		for (int i = 0; i < n; i++)
			((tns__submitMediaTokenResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaTokenResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaTokenResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaTokenResponse %p -> %p\n", q, p));
	*(tns__submitMediaTokenResponse*)p = *(tns__submitMediaTokenResponse*)q;
}

void tns__submitMediaToken::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__submitMediaToken::token = NULL;
	/* transient soap skipped */
}

void tns__submitMediaToken::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__mediaToken(soap, &this->tns__submitMediaToken::token);
	/* transient soap skipped */
}

int tns__submitMediaToken::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaToken(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaToken(struct soap *soap, const char *tag, int id, const tns__submitMediaToken *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__submitMediaToken), type))
		return soap->error;
	if (soap_out_PointerTotns__mediaToken(soap, "token", -1, &(a->tns__submitMediaToken::token), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaToken::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaToken(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaToken * SOAP_FMAC4 soap_in_tns__submitMediaToken(struct soap *soap, const char *tag, tns__submitMediaToken *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaToken *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__submitMediaToken, sizeof(tns__submitMediaToken), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__submitMediaToken)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaToken *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_token1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_token1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__mediaToken(soap, "token", &(a->tns__submitMediaToken::token), "tns:mediaToken"))
				{	soap_flag_token1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaToken *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__submitMediaToken, 0, sizeof(tns__submitMediaToken), 0, soap_copy_tns__submitMediaToken);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__submitMediaToken::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__submitMediaToken);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaToken", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaToken::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaToken(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaToken * SOAP_FMAC4 soap_get_tns__submitMediaToken(struct soap *soap, tns__submitMediaToken *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaToken * SOAP_FMAC2 soap_instantiate_tns__submitMediaToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaToken(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__submitMediaToken, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaToken);
		if (size)
			*size = sizeof(tns__submitMediaToken);
		((tns__submitMediaToken*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaToken[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaToken);
		for (int i = 0; i < n; i++)
			((tns__submitMediaToken*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaToken*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaToken(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaToken %p -> %p\n", q, p));
	*(tns__submitMediaToken*)p = *(tns__submitMediaToken*)q;
}

void tns__submitMediaAnnotationTextWithTokenIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__submitMediaAnnotationTextWithTokenIdResponse::return_);
	/* transient soap skipped */
}

void tns__submitMediaAnnotationTextWithTokenIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__submitMediaAnnotationTextWithTokenIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaAnnotationTextWithTokenIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaAnnotationTextWithTokenIdResponse(struct soap *soap, const char *tag, int id, const tns__submitMediaAnnotationTextWithTokenIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__submitMediaAnnotationTextWithTokenIdResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "return", -1, &(a->tns__submitMediaAnnotationTextWithTokenIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaAnnotationTextWithTokenIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaAnnotationTextWithTokenIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextWithTokenIdResponse * SOAP_FMAC4 soap_in_tns__submitMediaAnnotationTextWithTokenIdResponse(struct soap *soap, const char *tag, tns__submitMediaAnnotationTextWithTokenIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaAnnotationTextWithTokenIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__submitMediaAnnotationTextWithTokenIdResponse, sizeof(tns__submitMediaAnnotationTextWithTokenIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__submitMediaAnnotationTextWithTokenIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaAnnotationTextWithTokenIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "return", &(a->tns__submitMediaAnnotationTextWithTokenIdResponse::return_), "xsd:long"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaAnnotationTextWithTokenIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__submitMediaAnnotationTextWithTokenIdResponse, 0, sizeof(tns__submitMediaAnnotationTextWithTokenIdResponse), 0, soap_copy_tns__submitMediaAnnotationTextWithTokenIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitMediaAnnotationTextWithTokenIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__submitMediaAnnotationTextWithTokenIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaAnnotationTextWithTokenIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaAnnotationTextWithTokenIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaAnnotationTextWithTokenIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextWithTokenIdResponse * SOAP_FMAC4 soap_get_tns__submitMediaAnnotationTextWithTokenIdResponse(struct soap *soap, tns__submitMediaAnnotationTextWithTokenIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaAnnotationTextWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaAnnotationTextWithTokenIdResponse * SOAP_FMAC2 soap_instantiate_tns__submitMediaAnnotationTextWithTokenIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaAnnotationTextWithTokenIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__submitMediaAnnotationTextWithTokenIdResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAnnotationTextWithTokenIdResponse);
		if (size)
			*size = sizeof(tns__submitMediaAnnotationTextWithTokenIdResponse);
		((tns__submitMediaAnnotationTextWithTokenIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAnnotationTextWithTokenIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaAnnotationTextWithTokenIdResponse);
		for (int i = 0; i < n; i++)
			((tns__submitMediaAnnotationTextWithTokenIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaAnnotationTextWithTokenIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaAnnotationTextWithTokenIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaAnnotationTextWithTokenIdResponse %p -> %p\n", q, p));
	*(tns__submitMediaAnnotationTextWithTokenIdResponse*)p = *(tns__submitMediaAnnotationTextWithTokenIdResponse*)q;
}

void tns__submitMediaAnnotationTextWithTokenId::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__submitMediaAnnotationTextWithTokenId::text = NULL;
	soap_default_LONG64(soap, &this->tns__submitMediaAnnotationTextWithTokenId::pos);
	soap_default_int(soap, &this->tns__submitMediaAnnotationTextWithTokenId::posType);
	soap_default_LONG64(soap, &this->tns__submitMediaAnnotationTextWithTokenId::tokenId);
	/* transient soap skipped */
}

void tns__submitMediaAnnotationTextWithTokenId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAnnotationTextWithTokenId::text);
	/* transient soap skipped */
}

int tns__submitMediaAnnotationTextWithTokenId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaAnnotationTextWithTokenId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaAnnotationTextWithTokenId(struct soap *soap, const char *tag, int id, const tns__submitMediaAnnotationTextWithTokenId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__submitMediaAnnotationTextWithTokenId), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "text", -1, &(a->tns__submitMediaAnnotationTextWithTokenId::text), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "pos", -1, &(a->tns__submitMediaAnnotationTextWithTokenId::pos), ""))
		return soap->error;
	if (soap_out_int(soap, "posType", -1, &(a->tns__submitMediaAnnotationTextWithTokenId::posType), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "tokenId", -1, &(a->tns__submitMediaAnnotationTextWithTokenId::tokenId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaAnnotationTextWithTokenId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaAnnotationTextWithTokenId(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextWithTokenId * SOAP_FMAC4 soap_in_tns__submitMediaAnnotationTextWithTokenId(struct soap *soap, const char *tag, tns__submitMediaAnnotationTextWithTokenId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaAnnotationTextWithTokenId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__submitMediaAnnotationTextWithTokenId, sizeof(tns__submitMediaAnnotationTextWithTokenId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__submitMediaAnnotationTextWithTokenId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaAnnotationTextWithTokenId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_text1 = 1;
	size_t soap_flag_pos1 = 1;
	size_t soap_flag_posType1 = 1;
	size_t soap_flag_tokenId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_text1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "text", &(a->tns__submitMediaAnnotationTextWithTokenId::text), "xsd:string"))
				{	soap_flag_text1--;
					continue;
				}
			if (soap_flag_pos1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "pos", &(a->tns__submitMediaAnnotationTextWithTokenId::pos), "xsd:long"))
				{	soap_flag_pos1--;
					continue;
				}
			if (soap_flag_posType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "posType", &(a->tns__submitMediaAnnotationTextWithTokenId::posType), "xsd:int"))
				{	soap_flag_posType1--;
					continue;
				}
			if (soap_flag_tokenId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "tokenId", &(a->tns__submitMediaAnnotationTextWithTokenId::tokenId), "xsd:long"))
				{	soap_flag_tokenId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaAnnotationTextWithTokenId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__submitMediaAnnotationTextWithTokenId, 0, sizeof(tns__submitMediaAnnotationTextWithTokenId), 0, soap_copy_tns__submitMediaAnnotationTextWithTokenId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pos1 > 0 || soap_flag_posType1 > 0 || soap_flag_tokenId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitMediaAnnotationTextWithTokenId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__submitMediaAnnotationTextWithTokenId);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaAnnotationTextWithTokenId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaAnnotationTextWithTokenId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaAnnotationTextWithTokenId(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextWithTokenId * SOAP_FMAC4 soap_get_tns__submitMediaAnnotationTextWithTokenId(struct soap *soap, tns__submitMediaAnnotationTextWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaAnnotationTextWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaAnnotationTextWithTokenId * SOAP_FMAC2 soap_instantiate_tns__submitMediaAnnotationTextWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaAnnotationTextWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__submitMediaAnnotationTextWithTokenId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAnnotationTextWithTokenId);
		if (size)
			*size = sizeof(tns__submitMediaAnnotationTextWithTokenId);
		((tns__submitMediaAnnotationTextWithTokenId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAnnotationTextWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaAnnotationTextWithTokenId);
		for (int i = 0; i < n; i++)
			((tns__submitMediaAnnotationTextWithTokenId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaAnnotationTextWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaAnnotationTextWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaAnnotationTextWithTokenId %p -> %p\n", q, p));
	*(tns__submitMediaAnnotationTextWithTokenId*)p = *(tns__submitMediaAnnotationTextWithTokenId*)q;
}

void tns__submitMediaAnnotationTextAndTokenDigestResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__submitMediaAnnotationTextAndTokenDigestResponse::return_);
	/* transient soap skipped */
}

void tns__submitMediaAnnotationTextAndTokenDigestResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__submitMediaAnnotationTextAndTokenDigestResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaAnnotationTextAndTokenDigestResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaAnnotationTextAndTokenDigestResponse(struct soap *soap, const char *tag, int id, const tns__submitMediaAnnotationTextAndTokenDigestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__submitMediaAnnotationTextAndTokenDigestResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "return", -1, &(a->tns__submitMediaAnnotationTextAndTokenDigestResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaAnnotationTextAndTokenDigestResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaAnnotationTextAndTokenDigestResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextAndTokenDigestResponse * SOAP_FMAC4 soap_in_tns__submitMediaAnnotationTextAndTokenDigestResponse(struct soap *soap, const char *tag, tns__submitMediaAnnotationTextAndTokenDigestResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaAnnotationTextAndTokenDigestResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__submitMediaAnnotationTextAndTokenDigestResponse, sizeof(tns__submitMediaAnnotationTextAndTokenDigestResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__submitMediaAnnotationTextAndTokenDigestResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaAnnotationTextAndTokenDigestResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "return", &(a->tns__submitMediaAnnotationTextAndTokenDigestResponse::return_), "xsd:long"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaAnnotationTextAndTokenDigestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__submitMediaAnnotationTextAndTokenDigestResponse, 0, sizeof(tns__submitMediaAnnotationTextAndTokenDigestResponse), 0, soap_copy_tns__submitMediaAnnotationTextAndTokenDigestResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitMediaAnnotationTextAndTokenDigestResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__submitMediaAnnotationTextAndTokenDigestResponse);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaAnnotationTextAndTokenDigestResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaAnnotationTextAndTokenDigestResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaAnnotationTextAndTokenDigestResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextAndTokenDigestResponse * SOAP_FMAC4 soap_get_tns__submitMediaAnnotationTextAndTokenDigestResponse(struct soap *soap, tns__submitMediaAnnotationTextAndTokenDigestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaAnnotationTextAndTokenDigestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaAnnotationTextAndTokenDigestResponse * SOAP_FMAC2 soap_instantiate_tns__submitMediaAnnotationTextAndTokenDigestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaAnnotationTextAndTokenDigestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__submitMediaAnnotationTextAndTokenDigestResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAnnotationTextAndTokenDigestResponse);
		if (size)
			*size = sizeof(tns__submitMediaAnnotationTextAndTokenDigestResponse);
		((tns__submitMediaAnnotationTextAndTokenDigestResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAnnotationTextAndTokenDigestResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaAnnotationTextAndTokenDigestResponse);
		for (int i = 0; i < n; i++)
			((tns__submitMediaAnnotationTextAndTokenDigestResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaAnnotationTextAndTokenDigestResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaAnnotationTextAndTokenDigestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaAnnotationTextAndTokenDigestResponse %p -> %p\n", q, p));
	*(tns__submitMediaAnnotationTextAndTokenDigestResponse*)p = *(tns__submitMediaAnnotationTextAndTokenDigestResponse*)q;
}

void tns__submitMediaAnnotationTextAndTokenDigest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__submitMediaAnnotationTextAndTokenDigest::text = NULL;
	soap_default_LONG64(soap, &this->tns__submitMediaAnnotationTextAndTokenDigest::pos);
	soap_default_int(soap, &this->tns__submitMediaAnnotationTextAndTokenDigest::posType);
	this->tns__submitMediaAnnotationTextAndTokenDigest::tokenDigest = NULL;
	soap_default_int(soap, &this->tns__submitMediaAnnotationTextAndTokenDigest::tokenSection);
	/* transient soap skipped */
}

void tns__submitMediaAnnotationTextAndTokenDigest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAnnotationTextAndTokenDigest::text);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAnnotationTextAndTokenDigest::tokenDigest);
	/* transient soap skipped */
}

int tns__submitMediaAnnotationTextAndTokenDigest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaAnnotationTextAndTokenDigest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, const char *tag, int id, const tns__submitMediaAnnotationTextAndTokenDigest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__submitMediaAnnotationTextAndTokenDigest), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "text", -1, &(a->tns__submitMediaAnnotationTextAndTokenDigest::text), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "pos", -1, &(a->tns__submitMediaAnnotationTextAndTokenDigest::pos), ""))
		return soap->error;
	if (soap_out_int(soap, "posType", -1, &(a->tns__submitMediaAnnotationTextAndTokenDigest::posType), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tokenDigest", -1, &(a->tns__submitMediaAnnotationTextAndTokenDigest::tokenDigest), ""))
		return soap->error;
	if (soap_out_int(soap, "tokenSection", -1, &(a->tns__submitMediaAnnotationTextAndTokenDigest::tokenSection), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaAnnotationTextAndTokenDigest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaAnnotationTextAndTokenDigest(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextAndTokenDigest * SOAP_FMAC4 soap_in_tns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, const char *tag, tns__submitMediaAnnotationTextAndTokenDigest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaAnnotationTextAndTokenDigest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__submitMediaAnnotationTextAndTokenDigest, sizeof(tns__submitMediaAnnotationTextAndTokenDigest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__submitMediaAnnotationTextAndTokenDigest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaAnnotationTextAndTokenDigest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_text1 = 1;
	size_t soap_flag_pos1 = 1;
	size_t soap_flag_posType1 = 1;
	size_t soap_flag_tokenDigest1 = 1;
	size_t soap_flag_tokenSection1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_text1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "text", &(a->tns__submitMediaAnnotationTextAndTokenDigest::text), "xsd:string"))
				{	soap_flag_text1--;
					continue;
				}
			if (soap_flag_pos1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "pos", &(a->tns__submitMediaAnnotationTextAndTokenDigest::pos), "xsd:long"))
				{	soap_flag_pos1--;
					continue;
				}
			if (soap_flag_posType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "posType", &(a->tns__submitMediaAnnotationTextAndTokenDigest::posType), "xsd:int"))
				{	soap_flag_posType1--;
					continue;
				}
			if (soap_flag_tokenDigest1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "tokenDigest", &(a->tns__submitMediaAnnotationTextAndTokenDigest::tokenDigest), "xsd:string"))
				{	soap_flag_tokenDigest1--;
					continue;
				}
			if (soap_flag_tokenSection1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tokenSection", &(a->tns__submitMediaAnnotationTextAndTokenDigest::tokenSection), "xsd:int"))
				{	soap_flag_tokenSection1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaAnnotationTextAndTokenDigest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__submitMediaAnnotationTextAndTokenDigest, 0, sizeof(tns__submitMediaAnnotationTextAndTokenDigest), 0, soap_copy_tns__submitMediaAnnotationTextAndTokenDigest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pos1 > 0 || soap_flag_posType1 > 0 || soap_flag_tokenSection1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitMediaAnnotationTextAndTokenDigest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__submitMediaAnnotationTextAndTokenDigest);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaAnnotationTextAndTokenDigest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaAnnotationTextAndTokenDigest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaAnnotationTextAndTokenDigest(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextAndTokenDigest * SOAP_FMAC4 soap_get_tns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, tns__submitMediaAnnotationTextAndTokenDigest *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaAnnotationTextAndTokenDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaAnnotationTextAndTokenDigest * SOAP_FMAC2 soap_instantiate_tns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaAnnotationTextAndTokenDigest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__submitMediaAnnotationTextAndTokenDigest, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAnnotationTextAndTokenDigest);
		if (size)
			*size = sizeof(tns__submitMediaAnnotationTextAndTokenDigest);
		((tns__submitMediaAnnotationTextAndTokenDigest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAnnotationTextAndTokenDigest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaAnnotationTextAndTokenDigest);
		for (int i = 0; i < n; i++)
			((tns__submitMediaAnnotationTextAndTokenDigest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaAnnotationTextAndTokenDigest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaAnnotationTextAndTokenDigest %p -> %p\n", q, p));
	*(tns__submitMediaAnnotationTextAndTokenDigest*)p = *(tns__submitMediaAnnotationTextAndTokenDigest*)q;
}

void tns__submitMediaAnnotationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__submitMediaAnnotationResponse::return_);
	/* transient soap skipped */
}

void tns__submitMediaAnnotationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__submitMediaAnnotationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaAnnotationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaAnnotationResponse(struct soap *soap, const char *tag, int id, const tns__submitMediaAnnotationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__submitMediaAnnotationResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "return", -1, &(a->tns__submitMediaAnnotationResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaAnnotationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaAnnotationResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationResponse * SOAP_FMAC4 soap_in_tns__submitMediaAnnotationResponse(struct soap *soap, const char *tag, tns__submitMediaAnnotationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaAnnotationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__submitMediaAnnotationResponse, sizeof(tns__submitMediaAnnotationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__submitMediaAnnotationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaAnnotationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "return", &(a->tns__submitMediaAnnotationResponse::return_), "xsd:long"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaAnnotationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__submitMediaAnnotationResponse, 0, sizeof(tns__submitMediaAnnotationResponse), 0, soap_copy_tns__submitMediaAnnotationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitMediaAnnotationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__submitMediaAnnotationResponse);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaAnnotationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaAnnotationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaAnnotationResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationResponse * SOAP_FMAC4 soap_get_tns__submitMediaAnnotationResponse(struct soap *soap, tns__submitMediaAnnotationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaAnnotationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaAnnotationResponse * SOAP_FMAC2 soap_instantiate_tns__submitMediaAnnotationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaAnnotationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__submitMediaAnnotationResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAnnotationResponse);
		if (size)
			*size = sizeof(tns__submitMediaAnnotationResponse);
		((tns__submitMediaAnnotationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAnnotationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaAnnotationResponse);
		for (int i = 0; i < n; i++)
			((tns__submitMediaAnnotationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaAnnotationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaAnnotationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaAnnotationResponse %p -> %p\n", q, p));
	*(tns__submitMediaAnnotationResponse*)p = *(tns__submitMediaAnnotationResponse*)q;
}

void tns__submitMediaAnnotation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__submitMediaAnnotation::annot = NULL;
	/* transient soap skipped */
}

void tns__submitMediaAnnotation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__mediaAnnotation(soap, &this->tns__submitMediaAnnotation::annot);
	/* transient soap skipped */
}

int tns__submitMediaAnnotation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaAnnotation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaAnnotation(struct soap *soap, const char *tag, int id, const tns__submitMediaAnnotation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__submitMediaAnnotation), type))
		return soap->error;
	if (soap_out_PointerTotns__mediaAnnotation(soap, "annot", -1, &(a->tns__submitMediaAnnotation::annot), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaAnnotation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaAnnotation(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaAnnotation * SOAP_FMAC4 soap_in_tns__submitMediaAnnotation(struct soap *soap, const char *tag, tns__submitMediaAnnotation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaAnnotation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__submitMediaAnnotation, sizeof(tns__submitMediaAnnotation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__submitMediaAnnotation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaAnnotation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_annot1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_annot1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__mediaAnnotation(soap, "annot", &(a->tns__submitMediaAnnotation::annot), "tns:mediaAnnotation"))
				{	soap_flag_annot1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaAnnotation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__submitMediaAnnotation, 0, sizeof(tns__submitMediaAnnotation), 0, soap_copy_tns__submitMediaAnnotation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__submitMediaAnnotation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__submitMediaAnnotation);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaAnnotation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaAnnotation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaAnnotation(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaAnnotation * SOAP_FMAC4 soap_get_tns__submitMediaAnnotation(struct soap *soap, tns__submitMediaAnnotation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaAnnotation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaAnnotation * SOAP_FMAC2 soap_instantiate_tns__submitMediaAnnotation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaAnnotation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__submitMediaAnnotation, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAnnotation);
		if (size)
			*size = sizeof(tns__submitMediaAnnotation);
		((tns__submitMediaAnnotation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAnnotation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaAnnotation);
		for (int i = 0; i < n; i++)
			((tns__submitMediaAnnotation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaAnnotation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaAnnotation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaAnnotation %p -> %p\n", q, p));
	*(tns__submitMediaAnnotation*)p = *(tns__submitMediaAnnotation*)q;
}

void tns__submitMediaAliasTextWithTokenIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__submitMediaAliasTextWithTokenIdResponse::return_);
	/* transient soap skipped */
}

void tns__submitMediaAliasTextWithTokenIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__submitMediaAliasTextWithTokenIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaAliasTextWithTokenIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaAliasTextWithTokenIdResponse(struct soap *soap, const char *tag, int id, const tns__submitMediaAliasTextWithTokenIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__submitMediaAliasTextWithTokenIdResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "return", -1, &(a->tns__submitMediaAliasTextWithTokenIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaAliasTextWithTokenIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaAliasTextWithTokenIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaAliasTextWithTokenIdResponse * SOAP_FMAC4 soap_in_tns__submitMediaAliasTextWithTokenIdResponse(struct soap *soap, const char *tag, tns__submitMediaAliasTextWithTokenIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaAliasTextWithTokenIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__submitMediaAliasTextWithTokenIdResponse, sizeof(tns__submitMediaAliasTextWithTokenIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__submitMediaAliasTextWithTokenIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaAliasTextWithTokenIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "return", &(a->tns__submitMediaAliasTextWithTokenIdResponse::return_), "xsd:long"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaAliasTextWithTokenIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__submitMediaAliasTextWithTokenIdResponse, 0, sizeof(tns__submitMediaAliasTextWithTokenIdResponse), 0, soap_copy_tns__submitMediaAliasTextWithTokenIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitMediaAliasTextWithTokenIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__submitMediaAliasTextWithTokenIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaAliasTextWithTokenIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaAliasTextWithTokenIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaAliasTextWithTokenIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaAliasTextWithTokenIdResponse * SOAP_FMAC4 soap_get_tns__submitMediaAliasTextWithTokenIdResponse(struct soap *soap, tns__submitMediaAliasTextWithTokenIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaAliasTextWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaAliasTextWithTokenIdResponse * SOAP_FMAC2 soap_instantiate_tns__submitMediaAliasTextWithTokenIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaAliasTextWithTokenIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__submitMediaAliasTextWithTokenIdResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAliasTextWithTokenIdResponse);
		if (size)
			*size = sizeof(tns__submitMediaAliasTextWithTokenIdResponse);
		((tns__submitMediaAliasTextWithTokenIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAliasTextWithTokenIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaAliasTextWithTokenIdResponse);
		for (int i = 0; i < n; i++)
			((tns__submitMediaAliasTextWithTokenIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaAliasTextWithTokenIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaAliasTextWithTokenIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaAliasTextWithTokenIdResponse %p -> %p\n", q, p));
	*(tns__submitMediaAliasTextWithTokenIdResponse*)p = *(tns__submitMediaAliasTextWithTokenIdResponse*)q;
}

void tns__submitMediaAliasTextWithTokenId::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__submitMediaAliasTextWithTokenId::text = NULL;
	soap_default_int(soap, &this->tns__submitMediaAliasTextWithTokenId::type);
	soap_default_LONG64(soap, &this->tns__submitMediaAliasTextWithTokenId::tokenId);
	/* transient soap skipped */
}

void tns__submitMediaAliasTextWithTokenId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAliasTextWithTokenId::text);
	/* transient soap skipped */
}

int tns__submitMediaAliasTextWithTokenId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaAliasTextWithTokenId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaAliasTextWithTokenId(struct soap *soap, const char *tag, int id, const tns__submitMediaAliasTextWithTokenId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__submitMediaAliasTextWithTokenId), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "text", -1, &(a->tns__submitMediaAliasTextWithTokenId::text), ""))
		return soap->error;
	if (soap_out_int(soap, "type", -1, &(a->tns__submitMediaAliasTextWithTokenId::type), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "tokenId", -1, &(a->tns__submitMediaAliasTextWithTokenId::tokenId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaAliasTextWithTokenId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaAliasTextWithTokenId(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaAliasTextWithTokenId * SOAP_FMAC4 soap_in_tns__submitMediaAliasTextWithTokenId(struct soap *soap, const char *tag, tns__submitMediaAliasTextWithTokenId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaAliasTextWithTokenId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__submitMediaAliasTextWithTokenId, sizeof(tns__submitMediaAliasTextWithTokenId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__submitMediaAliasTextWithTokenId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaAliasTextWithTokenId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_text1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_tokenId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_text1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "text", &(a->tns__submitMediaAliasTextWithTokenId::text), "xsd:string"))
				{	soap_flag_text1--;
					continue;
				}
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "type", &(a->tns__submitMediaAliasTextWithTokenId::type), "xsd:int"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_tokenId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "tokenId", &(a->tns__submitMediaAliasTextWithTokenId::tokenId), "xsd:long"))
				{	soap_flag_tokenId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaAliasTextWithTokenId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__submitMediaAliasTextWithTokenId, 0, sizeof(tns__submitMediaAliasTextWithTokenId), 0, soap_copy_tns__submitMediaAliasTextWithTokenId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_type1 > 0 || soap_flag_tokenId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitMediaAliasTextWithTokenId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__submitMediaAliasTextWithTokenId);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaAliasTextWithTokenId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaAliasTextWithTokenId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaAliasTextWithTokenId(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaAliasTextWithTokenId * SOAP_FMAC4 soap_get_tns__submitMediaAliasTextWithTokenId(struct soap *soap, tns__submitMediaAliasTextWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaAliasTextWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaAliasTextWithTokenId * SOAP_FMAC2 soap_instantiate_tns__submitMediaAliasTextWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaAliasTextWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__submitMediaAliasTextWithTokenId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAliasTextWithTokenId);
		if (size)
			*size = sizeof(tns__submitMediaAliasTextWithTokenId);
		((tns__submitMediaAliasTextWithTokenId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAliasTextWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaAliasTextWithTokenId);
		for (int i = 0; i < n; i++)
			((tns__submitMediaAliasTextWithTokenId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaAliasTextWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaAliasTextWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaAliasTextWithTokenId %p -> %p\n", q, p));
	*(tns__submitMediaAliasTextWithTokenId*)p = *(tns__submitMediaAliasTextWithTokenId*)q;
}

void tns__submitMediaAliasTextAndTokenDigestResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__submitMediaAliasTextAndTokenDigestResponse::return_);
	/* transient soap skipped */
}

void tns__submitMediaAliasTextAndTokenDigestResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__submitMediaAliasTextAndTokenDigestResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaAliasTextAndTokenDigestResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaAliasTextAndTokenDigestResponse(struct soap *soap, const char *tag, int id, const tns__submitMediaAliasTextAndTokenDigestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__submitMediaAliasTextAndTokenDigestResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "return", -1, &(a->tns__submitMediaAliasTextAndTokenDigestResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaAliasTextAndTokenDigestResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaAliasTextAndTokenDigestResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaAliasTextAndTokenDigestResponse * SOAP_FMAC4 soap_in_tns__submitMediaAliasTextAndTokenDigestResponse(struct soap *soap, const char *tag, tns__submitMediaAliasTextAndTokenDigestResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaAliasTextAndTokenDigestResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__submitMediaAliasTextAndTokenDigestResponse, sizeof(tns__submitMediaAliasTextAndTokenDigestResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__submitMediaAliasTextAndTokenDigestResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaAliasTextAndTokenDigestResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "return", &(a->tns__submitMediaAliasTextAndTokenDigestResponse::return_), "xsd:long"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaAliasTextAndTokenDigestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__submitMediaAliasTextAndTokenDigestResponse, 0, sizeof(tns__submitMediaAliasTextAndTokenDigestResponse), 0, soap_copy_tns__submitMediaAliasTextAndTokenDigestResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitMediaAliasTextAndTokenDigestResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__submitMediaAliasTextAndTokenDigestResponse);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaAliasTextAndTokenDigestResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaAliasTextAndTokenDigestResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaAliasTextAndTokenDigestResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaAliasTextAndTokenDigestResponse * SOAP_FMAC4 soap_get_tns__submitMediaAliasTextAndTokenDigestResponse(struct soap *soap, tns__submitMediaAliasTextAndTokenDigestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaAliasTextAndTokenDigestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaAliasTextAndTokenDigestResponse * SOAP_FMAC2 soap_instantiate_tns__submitMediaAliasTextAndTokenDigestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaAliasTextAndTokenDigestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__submitMediaAliasTextAndTokenDigestResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAliasTextAndTokenDigestResponse);
		if (size)
			*size = sizeof(tns__submitMediaAliasTextAndTokenDigestResponse);
		((tns__submitMediaAliasTextAndTokenDigestResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAliasTextAndTokenDigestResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaAliasTextAndTokenDigestResponse);
		for (int i = 0; i < n; i++)
			((tns__submitMediaAliasTextAndTokenDigestResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaAliasTextAndTokenDigestResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaAliasTextAndTokenDigestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaAliasTextAndTokenDigestResponse %p -> %p\n", q, p));
	*(tns__submitMediaAliasTextAndTokenDigestResponse*)p = *(tns__submitMediaAliasTextAndTokenDigestResponse*)q;
}

void tns__submitMediaAliasTextAndTokenDigest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__submitMediaAliasTextAndTokenDigest::text = NULL;
	soap_default_int(soap, &this->tns__submitMediaAliasTextAndTokenDigest::type);
	this->tns__submitMediaAliasTextAndTokenDigest::tokenDigest = NULL;
	soap_default_int(soap, &this->tns__submitMediaAliasTextAndTokenDigest::tokenSection);
	/* transient soap skipped */
}

void tns__submitMediaAliasTextAndTokenDigest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAliasTextAndTokenDigest::text);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAliasTextAndTokenDigest::tokenDigest);
	/* transient soap skipped */
}

int tns__submitMediaAliasTextAndTokenDigest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaAliasTextAndTokenDigest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaAliasTextAndTokenDigest(struct soap *soap, const char *tag, int id, const tns__submitMediaAliasTextAndTokenDigest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__submitMediaAliasTextAndTokenDigest), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "text", -1, &(a->tns__submitMediaAliasTextAndTokenDigest::text), ""))
		return soap->error;
	if (soap_out_int(soap, "type", -1, &(a->tns__submitMediaAliasTextAndTokenDigest::type), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tokenDigest", -1, &(a->tns__submitMediaAliasTextAndTokenDigest::tokenDigest), ""))
		return soap->error;
	if (soap_out_int(soap, "tokenSection", -1, &(a->tns__submitMediaAliasTextAndTokenDigest::tokenSection), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaAliasTextAndTokenDigest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaAliasTextAndTokenDigest(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaAliasTextAndTokenDigest * SOAP_FMAC4 soap_in_tns__submitMediaAliasTextAndTokenDigest(struct soap *soap, const char *tag, tns__submitMediaAliasTextAndTokenDigest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaAliasTextAndTokenDigest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__submitMediaAliasTextAndTokenDigest, sizeof(tns__submitMediaAliasTextAndTokenDigest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__submitMediaAliasTextAndTokenDigest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaAliasTextAndTokenDigest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_text1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_tokenDigest1 = 1;
	size_t soap_flag_tokenSection1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_text1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "text", &(a->tns__submitMediaAliasTextAndTokenDigest::text), "xsd:string"))
				{	soap_flag_text1--;
					continue;
				}
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "type", &(a->tns__submitMediaAliasTextAndTokenDigest::type), "xsd:int"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_tokenDigest1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "tokenDigest", &(a->tns__submitMediaAliasTextAndTokenDigest::tokenDigest), "xsd:string"))
				{	soap_flag_tokenDigest1--;
					continue;
				}
			if (soap_flag_tokenSection1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tokenSection", &(a->tns__submitMediaAliasTextAndTokenDigest::tokenSection), "xsd:int"))
				{	soap_flag_tokenSection1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaAliasTextAndTokenDigest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__submitMediaAliasTextAndTokenDigest, 0, sizeof(tns__submitMediaAliasTextAndTokenDigest), 0, soap_copy_tns__submitMediaAliasTextAndTokenDigest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_type1 > 0 || soap_flag_tokenSection1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitMediaAliasTextAndTokenDigest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__submitMediaAliasTextAndTokenDigest);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaAliasTextAndTokenDigest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaAliasTextAndTokenDigest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaAliasTextAndTokenDigest(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaAliasTextAndTokenDigest * SOAP_FMAC4 soap_get_tns__submitMediaAliasTextAndTokenDigest(struct soap *soap, tns__submitMediaAliasTextAndTokenDigest *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaAliasTextAndTokenDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaAliasTextAndTokenDigest * SOAP_FMAC2 soap_instantiate_tns__submitMediaAliasTextAndTokenDigest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaAliasTextAndTokenDigest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__submitMediaAliasTextAndTokenDigest, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAliasTextAndTokenDigest);
		if (size)
			*size = sizeof(tns__submitMediaAliasTextAndTokenDigest);
		((tns__submitMediaAliasTextAndTokenDigest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAliasTextAndTokenDigest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaAliasTextAndTokenDigest);
		for (int i = 0; i < n; i++)
			((tns__submitMediaAliasTextAndTokenDigest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaAliasTextAndTokenDigest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaAliasTextAndTokenDigest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaAliasTextAndTokenDigest %p -> %p\n", q, p));
	*(tns__submitMediaAliasTextAndTokenDigest*)p = *(tns__submitMediaAliasTextAndTokenDigest*)q;
}

void tns__submitMediaAliasResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__submitMediaAliasResponse::return_);
	/* transient soap skipped */
}

void tns__submitMediaAliasResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__submitMediaAliasResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaAliasResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaAliasResponse(struct soap *soap, const char *tag, int id, const tns__submitMediaAliasResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__submitMediaAliasResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "return", -1, &(a->tns__submitMediaAliasResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaAliasResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaAliasResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaAliasResponse * SOAP_FMAC4 soap_in_tns__submitMediaAliasResponse(struct soap *soap, const char *tag, tns__submitMediaAliasResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaAliasResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__submitMediaAliasResponse, sizeof(tns__submitMediaAliasResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__submitMediaAliasResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaAliasResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "return", &(a->tns__submitMediaAliasResponse::return_), "xsd:long"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaAliasResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__submitMediaAliasResponse, 0, sizeof(tns__submitMediaAliasResponse), 0, soap_copy_tns__submitMediaAliasResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitMediaAliasResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__submitMediaAliasResponse);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaAliasResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaAliasResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaAliasResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaAliasResponse * SOAP_FMAC4 soap_get_tns__submitMediaAliasResponse(struct soap *soap, tns__submitMediaAliasResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaAliasResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaAliasResponse * SOAP_FMAC2 soap_instantiate_tns__submitMediaAliasResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaAliasResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__submitMediaAliasResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAliasResponse);
		if (size)
			*size = sizeof(tns__submitMediaAliasResponse);
		((tns__submitMediaAliasResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAliasResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaAliasResponse);
		for (int i = 0; i < n; i++)
			((tns__submitMediaAliasResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaAliasResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaAliasResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaAliasResponse %p -> %p\n", q, p));
	*(tns__submitMediaAliasResponse*)p = *(tns__submitMediaAliasResponse*)q;
}

void tns__submitMediaAlias::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__submitMediaAlias::alias = NULL;
	/* transient soap skipped */
}

void tns__submitMediaAlias::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__mediaAlias(soap, &this->tns__submitMediaAlias::alias);
	/* transient soap skipped */
}

int tns__submitMediaAlias::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaAlias(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaAlias(struct soap *soap, const char *tag, int id, const tns__submitMediaAlias *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__submitMediaAlias), type))
		return soap->error;
	if (soap_out_PointerTotns__mediaAlias(soap, "alias", -1, &(a->tns__submitMediaAlias::alias), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaAlias::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaAlias(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaAlias * SOAP_FMAC4 soap_in_tns__submitMediaAlias(struct soap *soap, const char *tag, tns__submitMediaAlias *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaAlias *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__submitMediaAlias, sizeof(tns__submitMediaAlias), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__submitMediaAlias)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaAlias *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_alias1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_alias1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__mediaAlias(soap, "alias", &(a->tns__submitMediaAlias::alias), "tns:mediaAlias"))
				{	soap_flag_alias1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaAlias *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__submitMediaAlias, 0, sizeof(tns__submitMediaAlias), 0, soap_copy_tns__submitMediaAlias);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__submitMediaAlias::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__submitMediaAlias);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaAlias", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaAlias::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaAlias(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaAlias * SOAP_FMAC4 soap_get_tns__submitMediaAlias(struct soap *soap, tns__submitMediaAlias *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaAlias(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaAlias * SOAP_FMAC2 soap_instantiate_tns__submitMediaAlias(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaAlias(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__submitMediaAlias, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAlias);
		if (size)
			*size = sizeof(tns__submitMediaAlias);
		((tns__submitMediaAlias*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAlias[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaAlias);
		for (int i = 0; i < n; i++)
			((tns__submitMediaAlias*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaAlias*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaAlias(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaAlias %p -> %p\n", q, p));
	*(tns__submitMediaAlias*)p = *(tns__submitMediaAlias*)q;
}

void tns__submitGameThreadResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__submitGameThreadResponse::return_);
	/* transient soap skipped */
}

void tns__submitGameThreadResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__submitGameThreadResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitGameThreadResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitGameThreadResponse(struct soap *soap, const char *tag, int id, const tns__submitGameThreadResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__submitGameThreadResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "return", -1, &(a->tns__submitGameThreadResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitGameThreadResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitGameThreadResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitGameThreadResponse * SOAP_FMAC4 soap_in_tns__submitGameThreadResponse(struct soap *soap, const char *tag, tns__submitGameThreadResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitGameThreadResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__submitGameThreadResponse, sizeof(tns__submitGameThreadResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__submitGameThreadResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitGameThreadResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "return", &(a->tns__submitGameThreadResponse::return_), "xsd:long"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitGameThreadResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__submitGameThreadResponse, 0, sizeof(tns__submitGameThreadResponse), 0, soap_copy_tns__submitGameThreadResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitGameThreadResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__submitGameThreadResponse);
	if (this->soap_out(soap, tag?tag:"tns:submitGameThreadResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitGameThreadResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitGameThreadResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitGameThreadResponse * SOAP_FMAC4 soap_get_tns__submitGameThreadResponse(struct soap *soap, tns__submitGameThreadResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitGameThreadResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitGameThreadResponse * SOAP_FMAC2 soap_instantiate_tns__submitGameThreadResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitGameThreadResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__submitGameThreadResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitGameThreadResponse);
		if (size)
			*size = sizeof(tns__submitGameThreadResponse);
		((tns__submitGameThreadResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitGameThreadResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitGameThreadResponse);
		for (int i = 0; i < n; i++)
			((tns__submitGameThreadResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitGameThreadResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitGameThreadResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitGameThreadResponse %p -> %p\n", q, p));
	*(tns__submitGameThreadResponse*)p = *(tns__submitGameThreadResponse*)q;
}

void tns__submitGameThread::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__submitGameThread::thread = NULL;
	/* transient soap skipped */
}

void tns__submitGameThread::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__gameThread(soap, &this->tns__submitGameThread::thread);
	/* transient soap skipped */
}

int tns__submitGameThread::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitGameThread(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitGameThread(struct soap *soap, const char *tag, int id, const tns__submitGameThread *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__submitGameThread), type))
		return soap->error;
	if (soap_out_PointerTotns__gameThread(soap, "thread", -1, &(a->tns__submitGameThread::thread), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitGameThread::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitGameThread(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitGameThread * SOAP_FMAC4 soap_in_tns__submitGameThread(struct soap *soap, const char *tag, tns__submitGameThread *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitGameThread *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__submitGameThread, sizeof(tns__submitGameThread), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__submitGameThread)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitGameThread *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_thread1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_thread1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__gameThread(soap, "thread", &(a->tns__submitGameThread::thread), "tns:gameThread"))
				{	soap_flag_thread1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitGameThread *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__submitGameThread, 0, sizeof(tns__submitGameThread), 0, soap_copy_tns__submitGameThread);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__submitGameThread::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__submitGameThread);
	if (this->soap_out(soap, tag?tag:"tns:submitGameThread", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitGameThread::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitGameThread(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitGameThread * SOAP_FMAC4 soap_get_tns__submitGameThread(struct soap *soap, tns__submitGameThread *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitGameThread(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitGameThread * SOAP_FMAC2 soap_instantiate_tns__submitGameThread(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitGameThread(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__submitGameThread, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitGameThread);
		if (size)
			*size = sizeof(tns__submitGameThread);
		((tns__submitGameThread*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitGameThread[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitGameThread);
		for (int i = 0; i < n; i++)
			((tns__submitGameThread*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitGameThread*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitGameThread(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitGameThread %p -> %p\n", q, p));
	*(tns__submitGameThread*)p = *(tns__submitGameThread*)q;
}

void tns__setUserLanguageResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__setUserLanguageResponse::return_);
	/* transient soap skipped */
}

void tns__setUserLanguageResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__setUserLanguageResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__setUserLanguageResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__setUserLanguageResponse(struct soap *soap, const char *tag, int id, const tns__setUserLanguageResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__setUserLanguageResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__setUserLanguageResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__setUserLanguageResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__setUserLanguageResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__setUserLanguageResponse * SOAP_FMAC4 soap_in_tns__setUserLanguageResponse(struct soap *soap, const char *tag, tns__setUserLanguageResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__setUserLanguageResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__setUserLanguageResponse, sizeof(tns__setUserLanguageResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__setUserLanguageResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__setUserLanguageResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__setUserLanguageResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__setUserLanguageResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__setUserLanguageResponse, 0, sizeof(tns__setUserLanguageResponse), 0, soap_copy_tns__setUserLanguageResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__setUserLanguageResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__setUserLanguageResponse);
	if (this->soap_out(soap, tag?tag:"tns:setUserLanguageResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__setUserLanguageResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__setUserLanguageResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__setUserLanguageResponse * SOAP_FMAC4 soap_get_tns__setUserLanguageResponse(struct soap *soap, tns__setUserLanguageResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__setUserLanguageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__setUserLanguageResponse * SOAP_FMAC2 soap_instantiate_tns__setUserLanguageResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__setUserLanguageResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__setUserLanguageResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__setUserLanguageResponse);
		if (size)
			*size = sizeof(tns__setUserLanguageResponse);
		((tns__setUserLanguageResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__setUserLanguageResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__setUserLanguageResponse);
		for (int i = 0; i < n; i++)
			((tns__setUserLanguageResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__setUserLanguageResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__setUserLanguageResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__setUserLanguageResponse %p -> %p\n", q, p));
	*(tns__setUserLanguageResponse*)p = *(tns__setUserLanguageResponse*)q;
}

void tns__setUserLanguage::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->tns__setUserLanguage::value);
	/* transient soap skipped */
}

void tns__setUserLanguage::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__setUserLanguage::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__setUserLanguage(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__setUserLanguage(struct soap *soap, const char *tag, int id, const tns__setUserLanguage *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__setUserLanguage), type))
		return soap->error;
	if (soap_out_int(soap, "value", -1, &(a->tns__setUserLanguage::value), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__setUserLanguage::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__setUserLanguage(soap, tag, this, type);
}

SOAP_FMAC3 tns__setUserLanguage * SOAP_FMAC4 soap_in_tns__setUserLanguage(struct soap *soap, const char *tag, tns__setUserLanguage *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__setUserLanguage *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__setUserLanguage, sizeof(tns__setUserLanguage), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__setUserLanguage)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__setUserLanguage *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_value1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "value", &(a->tns__setUserLanguage::value), "xsd:int"))
				{	soap_flag_value1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__setUserLanguage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__setUserLanguage, 0, sizeof(tns__setUserLanguage), 0, soap_copy_tns__setUserLanguage);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_value1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__setUserLanguage::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__setUserLanguage);
	if (this->soap_out(soap, tag?tag:"tns:setUserLanguage", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__setUserLanguage::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__setUserLanguage(soap, this, tag, type);
}

SOAP_FMAC3 tns__setUserLanguage * SOAP_FMAC4 soap_get_tns__setUserLanguage(struct soap *soap, tns__setUserLanguage *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__setUserLanguage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__setUserLanguage * SOAP_FMAC2 soap_instantiate_tns__setUserLanguage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__setUserLanguage(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__setUserLanguage, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__setUserLanguage);
		if (size)
			*size = sizeof(tns__setUserLanguage);
		((tns__setUserLanguage*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__setUserLanguage[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__setUserLanguage);
		for (int i = 0; i < n; i++)
			((tns__setUserLanguage*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__setUserLanguage*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__setUserLanguage(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__setUserLanguage %p -> %p\n", q, p));
	*(tns__setUserLanguage*)p = *(tns__setUserLanguage*)q;
}

void tns__setUserAnonymousResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__setUserAnonymousResponse::return_);
	/* transient soap skipped */
}

void tns__setUserAnonymousResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__setUserAnonymousResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__setUserAnonymousResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__setUserAnonymousResponse(struct soap *soap, const char *tag, int id, const tns__setUserAnonymousResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__setUserAnonymousResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__setUserAnonymousResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__setUserAnonymousResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__setUserAnonymousResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__setUserAnonymousResponse * SOAP_FMAC4 soap_in_tns__setUserAnonymousResponse(struct soap *soap, const char *tag, tns__setUserAnonymousResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__setUserAnonymousResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__setUserAnonymousResponse, sizeof(tns__setUserAnonymousResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__setUserAnonymousResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__setUserAnonymousResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__setUserAnonymousResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__setUserAnonymousResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__setUserAnonymousResponse, 0, sizeof(tns__setUserAnonymousResponse), 0, soap_copy_tns__setUserAnonymousResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__setUserAnonymousResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__setUserAnonymousResponse);
	if (this->soap_out(soap, tag?tag:"tns:setUserAnonymousResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__setUserAnonymousResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__setUserAnonymousResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__setUserAnonymousResponse * SOAP_FMAC4 soap_get_tns__setUserAnonymousResponse(struct soap *soap, tns__setUserAnonymousResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__setUserAnonymousResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__setUserAnonymousResponse * SOAP_FMAC2 soap_instantiate_tns__setUserAnonymousResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__setUserAnonymousResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__setUserAnonymousResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__setUserAnonymousResponse);
		if (size)
			*size = sizeof(tns__setUserAnonymousResponse);
		((tns__setUserAnonymousResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__setUserAnonymousResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__setUserAnonymousResponse);
		for (int i = 0; i < n; i++)
			((tns__setUserAnonymousResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__setUserAnonymousResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__setUserAnonymousResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__setUserAnonymousResponse %p -> %p\n", q, p));
	*(tns__setUserAnonymousResponse*)p = *(tns__setUserAnonymousResponse*)q;
}

void tns__setUserAnonymous::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__setUserAnonymous::value);
	/* transient soap skipped */
}

void tns__setUserAnonymous::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__setUserAnonymous::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__setUserAnonymous(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__setUserAnonymous(struct soap *soap, const char *tag, int id, const tns__setUserAnonymous *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__setUserAnonymous), type))
		return soap->error;
	if (soap_out_bool(soap, "value", -1, &(a->tns__setUserAnonymous::value), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__setUserAnonymous::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__setUserAnonymous(soap, tag, this, type);
}

SOAP_FMAC3 tns__setUserAnonymous * SOAP_FMAC4 soap_in_tns__setUserAnonymous(struct soap *soap, const char *tag, tns__setUserAnonymous *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__setUserAnonymous *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__setUserAnonymous, sizeof(tns__setUserAnonymous), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__setUserAnonymous)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__setUserAnonymous *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_value1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "value", &(a->tns__setUserAnonymous::value), "xsd:boolean"))
				{	soap_flag_value1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__setUserAnonymous *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__setUserAnonymous, 0, sizeof(tns__setUserAnonymous), 0, soap_copy_tns__setUserAnonymous);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_value1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__setUserAnonymous::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__setUserAnonymous);
	if (this->soap_out(soap, tag?tag:"tns:setUserAnonymous", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__setUserAnonymous::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__setUserAnonymous(soap, this, tag, type);
}

SOAP_FMAC3 tns__setUserAnonymous * SOAP_FMAC4 soap_get_tns__setUserAnonymous(struct soap *soap, tns__setUserAnonymous *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__setUserAnonymous(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__setUserAnonymous * SOAP_FMAC2 soap_instantiate_tns__setUserAnonymous(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__setUserAnonymous(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__setUserAnonymous, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__setUserAnonymous);
		if (size)
			*size = sizeof(tns__setUserAnonymous);
		((tns__setUserAnonymous*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__setUserAnonymous[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__setUserAnonymous);
		for (int i = 0; i < n; i++)
			((tns__setUserAnonymous*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__setUserAnonymous*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__setUserAnonymous(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__setUserAnonymous %p -> %p\n", q, p));
	*(tns__setUserAnonymous*)p = *(tns__setUserAnonymous*)q;
}

void tns__selectRelatedMediaAnnotationsWithTokenIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTotns__mediaAnnotation(soap, &this->tns__selectRelatedMediaAnnotationsWithTokenIdResponse::return_);
	/* transient soap skipped */
}

void tns__selectRelatedMediaAnnotationsWithTokenIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTotns__mediaAnnotation(soap, &this->tns__selectRelatedMediaAnnotationsWithTokenIdResponse::return_);
	/* transient soap skipped */
}

int tns__selectRelatedMediaAnnotationsWithTokenIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(struct soap *soap, const char *tag, int id, const tns__selectRelatedMediaAnnotationsWithTokenIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__selectRelatedMediaAnnotationsWithTokenIdResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTotns__mediaAnnotation(soap, "return", -1, &(a->tns__selectRelatedMediaAnnotationsWithTokenIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectRelatedMediaAnnotationsWithTokenIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectRelatedMediaAnnotationsWithTokenIdResponse * SOAP_FMAC4 soap_in_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(struct soap *soap, const char *tag, tns__selectRelatedMediaAnnotationsWithTokenIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectRelatedMediaAnnotationsWithTokenIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__selectRelatedMediaAnnotationsWithTokenIdResponse, sizeof(tns__selectRelatedMediaAnnotationsWithTokenIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__selectRelatedMediaAnnotationsWithTokenIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectRelatedMediaAnnotationsWithTokenIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTotns__mediaAnnotation(soap, "return", &(a->tns__selectRelatedMediaAnnotationsWithTokenIdResponse::return_), "tns:mediaAnnotation"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectRelatedMediaAnnotationsWithTokenIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__selectRelatedMediaAnnotationsWithTokenIdResponse, 0, sizeof(tns__selectRelatedMediaAnnotationsWithTokenIdResponse), 0, soap_copy_tns__selectRelatedMediaAnnotationsWithTokenIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__selectRelatedMediaAnnotationsWithTokenIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__selectRelatedMediaAnnotationsWithTokenIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:selectRelatedMediaAnnotationsWithTokenIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectRelatedMediaAnnotationsWithTokenIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectRelatedMediaAnnotationsWithTokenIdResponse * SOAP_FMAC4 soap_get_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(struct soap *soap, tns__selectRelatedMediaAnnotationsWithTokenIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectRelatedMediaAnnotationsWithTokenIdResponse * SOAP_FMAC2 soap_instantiate_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__selectRelatedMediaAnnotationsWithTokenIdResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectRelatedMediaAnnotationsWithTokenIdResponse);
		if (size)
			*size = sizeof(tns__selectRelatedMediaAnnotationsWithTokenIdResponse);
		((tns__selectRelatedMediaAnnotationsWithTokenIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectRelatedMediaAnnotationsWithTokenIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectRelatedMediaAnnotationsWithTokenIdResponse);
		for (int i = 0; i < n; i++)
			((tns__selectRelatedMediaAnnotationsWithTokenIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectRelatedMediaAnnotationsWithTokenIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectRelatedMediaAnnotationsWithTokenIdResponse %p -> %p\n", q, p));
	*(tns__selectRelatedMediaAnnotationsWithTokenIdResponse*)p = *(tns__selectRelatedMediaAnnotationsWithTokenIdResponse*)q;
}

void tns__selectRelatedMediaAnnotationsWithTokenId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__selectRelatedMediaAnnotationsWithTokenId::tokenId);
	/* transient soap skipped */
}

void tns__selectRelatedMediaAnnotationsWithTokenId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__selectRelatedMediaAnnotationsWithTokenId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectRelatedMediaAnnotationsWithTokenId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, const char *tag, int id, const tns__selectRelatedMediaAnnotationsWithTokenId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__selectRelatedMediaAnnotationsWithTokenId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "tokenId", -1, &(a->tns__selectRelatedMediaAnnotationsWithTokenId::tokenId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectRelatedMediaAnnotationsWithTokenId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectRelatedMediaAnnotationsWithTokenId(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectRelatedMediaAnnotationsWithTokenId * SOAP_FMAC4 soap_in_tns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, const char *tag, tns__selectRelatedMediaAnnotationsWithTokenId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectRelatedMediaAnnotationsWithTokenId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__selectRelatedMediaAnnotationsWithTokenId, sizeof(tns__selectRelatedMediaAnnotationsWithTokenId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__selectRelatedMediaAnnotationsWithTokenId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectRelatedMediaAnnotationsWithTokenId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_tokenId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tokenId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "tokenId", &(a->tns__selectRelatedMediaAnnotationsWithTokenId::tokenId), "xsd:long"))
				{	soap_flag_tokenId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectRelatedMediaAnnotationsWithTokenId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__selectRelatedMediaAnnotationsWithTokenId, 0, sizeof(tns__selectRelatedMediaAnnotationsWithTokenId), 0, soap_copy_tns__selectRelatedMediaAnnotationsWithTokenId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_tokenId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__selectRelatedMediaAnnotationsWithTokenId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__selectRelatedMediaAnnotationsWithTokenId);
	if (this->soap_out(soap, tag?tag:"tns:selectRelatedMediaAnnotationsWithTokenId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectRelatedMediaAnnotationsWithTokenId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectRelatedMediaAnnotationsWithTokenId(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectRelatedMediaAnnotationsWithTokenId * SOAP_FMAC4 soap_get_tns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, tns__selectRelatedMediaAnnotationsWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectRelatedMediaAnnotationsWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectRelatedMediaAnnotationsWithTokenId * SOAP_FMAC2 soap_instantiate_tns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectRelatedMediaAnnotationsWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__selectRelatedMediaAnnotationsWithTokenId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectRelatedMediaAnnotationsWithTokenId);
		if (size)
			*size = sizeof(tns__selectRelatedMediaAnnotationsWithTokenId);
		((tns__selectRelatedMediaAnnotationsWithTokenId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectRelatedMediaAnnotationsWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectRelatedMediaAnnotationsWithTokenId);
		for (int i = 0; i < n; i++)
			((tns__selectRelatedMediaAnnotationsWithTokenId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectRelatedMediaAnnotationsWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectRelatedMediaAnnotationsWithTokenId %p -> %p\n", q, p));
	*(tns__selectRelatedMediaAnnotationsWithTokenId*)p = *(tns__selectRelatedMediaAnnotationsWithTokenId*)q;
}

void tns__selectRelatedMediaAliasesWithTokenIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTotns__mediaAlias(soap, &this->tns__selectRelatedMediaAliasesWithTokenIdResponse::return_);
	/* transient soap skipped */
}

void tns__selectRelatedMediaAliasesWithTokenIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTotns__mediaAlias(soap, &this->tns__selectRelatedMediaAliasesWithTokenIdResponse::return_);
	/* transient soap skipped */
}

int tns__selectRelatedMediaAliasesWithTokenIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectRelatedMediaAliasesWithTokenIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectRelatedMediaAliasesWithTokenIdResponse(struct soap *soap, const char *tag, int id, const tns__selectRelatedMediaAliasesWithTokenIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__selectRelatedMediaAliasesWithTokenIdResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTotns__mediaAlias(soap, "return", -1, &(a->tns__selectRelatedMediaAliasesWithTokenIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectRelatedMediaAliasesWithTokenIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectRelatedMediaAliasesWithTokenIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectRelatedMediaAliasesWithTokenIdResponse * SOAP_FMAC4 soap_in_tns__selectRelatedMediaAliasesWithTokenIdResponse(struct soap *soap, const char *tag, tns__selectRelatedMediaAliasesWithTokenIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectRelatedMediaAliasesWithTokenIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__selectRelatedMediaAliasesWithTokenIdResponse, sizeof(tns__selectRelatedMediaAliasesWithTokenIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__selectRelatedMediaAliasesWithTokenIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectRelatedMediaAliasesWithTokenIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTotns__mediaAlias(soap, "return", &(a->tns__selectRelatedMediaAliasesWithTokenIdResponse::return_), "tns:mediaAlias"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectRelatedMediaAliasesWithTokenIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__selectRelatedMediaAliasesWithTokenIdResponse, 0, sizeof(tns__selectRelatedMediaAliasesWithTokenIdResponse), 0, soap_copy_tns__selectRelatedMediaAliasesWithTokenIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__selectRelatedMediaAliasesWithTokenIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__selectRelatedMediaAliasesWithTokenIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:selectRelatedMediaAliasesWithTokenIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectRelatedMediaAliasesWithTokenIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectRelatedMediaAliasesWithTokenIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectRelatedMediaAliasesWithTokenIdResponse * SOAP_FMAC4 soap_get_tns__selectRelatedMediaAliasesWithTokenIdResponse(struct soap *soap, tns__selectRelatedMediaAliasesWithTokenIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectRelatedMediaAliasesWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectRelatedMediaAliasesWithTokenIdResponse * SOAP_FMAC2 soap_instantiate_tns__selectRelatedMediaAliasesWithTokenIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectRelatedMediaAliasesWithTokenIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__selectRelatedMediaAliasesWithTokenIdResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectRelatedMediaAliasesWithTokenIdResponse);
		if (size)
			*size = sizeof(tns__selectRelatedMediaAliasesWithTokenIdResponse);
		((tns__selectRelatedMediaAliasesWithTokenIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectRelatedMediaAliasesWithTokenIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectRelatedMediaAliasesWithTokenIdResponse);
		for (int i = 0; i < n; i++)
			((tns__selectRelatedMediaAliasesWithTokenIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectRelatedMediaAliasesWithTokenIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectRelatedMediaAliasesWithTokenIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectRelatedMediaAliasesWithTokenIdResponse %p -> %p\n", q, p));
	*(tns__selectRelatedMediaAliasesWithTokenIdResponse*)p = *(tns__selectRelatedMediaAliasesWithTokenIdResponse*)q;
}

void tns__selectRelatedMediaAliasesWithTokenId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__selectRelatedMediaAliasesWithTokenId::tokenId);
	/* transient soap skipped */
}

void tns__selectRelatedMediaAliasesWithTokenId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__selectRelatedMediaAliasesWithTokenId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectRelatedMediaAliasesWithTokenId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectRelatedMediaAliasesWithTokenId(struct soap *soap, const char *tag, int id, const tns__selectRelatedMediaAliasesWithTokenId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__selectRelatedMediaAliasesWithTokenId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "tokenId", -1, &(a->tns__selectRelatedMediaAliasesWithTokenId::tokenId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectRelatedMediaAliasesWithTokenId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectRelatedMediaAliasesWithTokenId(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectRelatedMediaAliasesWithTokenId * SOAP_FMAC4 soap_in_tns__selectRelatedMediaAliasesWithTokenId(struct soap *soap, const char *tag, tns__selectRelatedMediaAliasesWithTokenId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectRelatedMediaAliasesWithTokenId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__selectRelatedMediaAliasesWithTokenId, sizeof(tns__selectRelatedMediaAliasesWithTokenId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__selectRelatedMediaAliasesWithTokenId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectRelatedMediaAliasesWithTokenId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_tokenId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tokenId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "tokenId", &(a->tns__selectRelatedMediaAliasesWithTokenId::tokenId), "xsd:long"))
				{	soap_flag_tokenId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectRelatedMediaAliasesWithTokenId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__selectRelatedMediaAliasesWithTokenId, 0, sizeof(tns__selectRelatedMediaAliasesWithTokenId), 0, soap_copy_tns__selectRelatedMediaAliasesWithTokenId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_tokenId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__selectRelatedMediaAliasesWithTokenId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__selectRelatedMediaAliasesWithTokenId);
	if (this->soap_out(soap, tag?tag:"tns:selectRelatedMediaAliasesWithTokenId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectRelatedMediaAliasesWithTokenId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectRelatedMediaAliasesWithTokenId(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectRelatedMediaAliasesWithTokenId * SOAP_FMAC4 soap_get_tns__selectRelatedMediaAliasesWithTokenId(struct soap *soap, tns__selectRelatedMediaAliasesWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectRelatedMediaAliasesWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectRelatedMediaAliasesWithTokenId * SOAP_FMAC2 soap_instantiate_tns__selectRelatedMediaAliasesWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectRelatedMediaAliasesWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__selectRelatedMediaAliasesWithTokenId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectRelatedMediaAliasesWithTokenId);
		if (size)
			*size = sizeof(tns__selectRelatedMediaAliasesWithTokenId);
		((tns__selectRelatedMediaAliasesWithTokenId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectRelatedMediaAliasesWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectRelatedMediaAliasesWithTokenId);
		for (int i = 0; i < n; i++)
			((tns__selectRelatedMediaAliasesWithTokenId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectRelatedMediaAliasesWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectRelatedMediaAliasesWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectRelatedMediaAliasesWithTokenId %p -> %p\n", q, p));
	*(tns__selectRelatedMediaAliasesWithTokenId*)p = *(tns__selectRelatedMediaAliasesWithTokenId*)q;
}

void tns__selectMediaTokenWithIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__selectMediaTokenWithIdResponse::return_ = NULL;
	/* transient soap skipped */
}

void tns__selectMediaTokenWithIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__mediaToken(soap, &this->tns__selectMediaTokenWithIdResponse::return_);
	/* transient soap skipped */
}

int tns__selectMediaTokenWithIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectMediaTokenWithIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectMediaTokenWithIdResponse(struct soap *soap, const char *tag, int id, const tns__selectMediaTokenWithIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__selectMediaTokenWithIdResponse), type))
		return soap->error;
	if (soap_out_PointerTotns__mediaToken(soap, "return", -1, &(a->tns__selectMediaTokenWithIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectMediaTokenWithIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectMediaTokenWithIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectMediaTokenWithIdResponse * SOAP_FMAC4 soap_in_tns__selectMediaTokenWithIdResponse(struct soap *soap, const char *tag, tns__selectMediaTokenWithIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectMediaTokenWithIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__selectMediaTokenWithIdResponse, sizeof(tns__selectMediaTokenWithIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__selectMediaTokenWithIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectMediaTokenWithIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__mediaToken(soap, "return", &(a->tns__selectMediaTokenWithIdResponse::return_), "tns:mediaToken"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectMediaTokenWithIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__selectMediaTokenWithIdResponse, 0, sizeof(tns__selectMediaTokenWithIdResponse), 0, soap_copy_tns__selectMediaTokenWithIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__selectMediaTokenWithIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__selectMediaTokenWithIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:selectMediaTokenWithIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectMediaTokenWithIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectMediaTokenWithIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectMediaTokenWithIdResponse * SOAP_FMAC4 soap_get_tns__selectMediaTokenWithIdResponse(struct soap *soap, tns__selectMediaTokenWithIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectMediaTokenWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectMediaTokenWithIdResponse * SOAP_FMAC2 soap_instantiate_tns__selectMediaTokenWithIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectMediaTokenWithIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__selectMediaTokenWithIdResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaTokenWithIdResponse);
		if (size)
			*size = sizeof(tns__selectMediaTokenWithIdResponse);
		((tns__selectMediaTokenWithIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaTokenWithIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectMediaTokenWithIdResponse);
		for (int i = 0; i < n; i++)
			((tns__selectMediaTokenWithIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectMediaTokenWithIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectMediaTokenWithIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectMediaTokenWithIdResponse %p -> %p\n", q, p));
	*(tns__selectMediaTokenWithIdResponse*)p = *(tns__selectMediaTokenWithIdResponse*)q;
}

void tns__selectMediaTokenWithId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__selectMediaTokenWithId::id);
	/* transient soap skipped */
}

void tns__selectMediaTokenWithId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__selectMediaTokenWithId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectMediaTokenWithId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectMediaTokenWithId(struct soap *soap, const char *tag, int id, const tns__selectMediaTokenWithId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__selectMediaTokenWithId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "id", -1, &(a->tns__selectMediaTokenWithId::id), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectMediaTokenWithId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectMediaTokenWithId(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectMediaTokenWithId * SOAP_FMAC4 soap_in_tns__selectMediaTokenWithId(struct soap *soap, const char *tag, tns__selectMediaTokenWithId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectMediaTokenWithId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__selectMediaTokenWithId, sizeof(tns__selectMediaTokenWithId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__selectMediaTokenWithId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectMediaTokenWithId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "id", &(a->tns__selectMediaTokenWithId::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectMediaTokenWithId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__selectMediaTokenWithId, 0, sizeof(tns__selectMediaTokenWithId), 0, soap_copy_tns__selectMediaTokenWithId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__selectMediaTokenWithId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__selectMediaTokenWithId);
	if (this->soap_out(soap, tag?tag:"tns:selectMediaTokenWithId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectMediaTokenWithId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectMediaTokenWithId(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectMediaTokenWithId * SOAP_FMAC4 soap_get_tns__selectMediaTokenWithId(struct soap *soap, tns__selectMediaTokenWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectMediaTokenWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectMediaTokenWithId * SOAP_FMAC2 soap_instantiate_tns__selectMediaTokenWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectMediaTokenWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__selectMediaTokenWithId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaTokenWithId);
		if (size)
			*size = sizeof(tns__selectMediaTokenWithId);
		((tns__selectMediaTokenWithId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaTokenWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectMediaTokenWithId);
		for (int i = 0; i < n; i++)
			((tns__selectMediaTokenWithId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectMediaTokenWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectMediaTokenWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectMediaTokenWithId %p -> %p\n", q, p));
	*(tns__selectMediaTokenWithId*)p = *(tns__selectMediaTokenWithId*)q;
}

void tns__selectMediaTokenWithDigestResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__selectMediaTokenWithDigestResponse::return_ = NULL;
	/* transient soap skipped */
}

void tns__selectMediaTokenWithDigestResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__mediaToken(soap, &this->tns__selectMediaTokenWithDigestResponse::return_);
	/* transient soap skipped */
}

int tns__selectMediaTokenWithDigestResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectMediaTokenWithDigestResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectMediaTokenWithDigestResponse(struct soap *soap, const char *tag, int id, const tns__selectMediaTokenWithDigestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__selectMediaTokenWithDigestResponse), type))
		return soap->error;
	if (soap_out_PointerTotns__mediaToken(soap, "return", -1, &(a->tns__selectMediaTokenWithDigestResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectMediaTokenWithDigestResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectMediaTokenWithDigestResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectMediaTokenWithDigestResponse * SOAP_FMAC4 soap_in_tns__selectMediaTokenWithDigestResponse(struct soap *soap, const char *tag, tns__selectMediaTokenWithDigestResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectMediaTokenWithDigestResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__selectMediaTokenWithDigestResponse, sizeof(tns__selectMediaTokenWithDigestResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__selectMediaTokenWithDigestResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectMediaTokenWithDigestResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__mediaToken(soap, "return", &(a->tns__selectMediaTokenWithDigestResponse::return_), "tns:mediaToken"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectMediaTokenWithDigestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__selectMediaTokenWithDigestResponse, 0, sizeof(tns__selectMediaTokenWithDigestResponse), 0, soap_copy_tns__selectMediaTokenWithDigestResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__selectMediaTokenWithDigestResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__selectMediaTokenWithDigestResponse);
	if (this->soap_out(soap, tag?tag:"tns:selectMediaTokenWithDigestResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectMediaTokenWithDigestResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectMediaTokenWithDigestResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectMediaTokenWithDigestResponse * SOAP_FMAC4 soap_get_tns__selectMediaTokenWithDigestResponse(struct soap *soap, tns__selectMediaTokenWithDigestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectMediaTokenWithDigestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectMediaTokenWithDigestResponse * SOAP_FMAC2 soap_instantiate_tns__selectMediaTokenWithDigestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectMediaTokenWithDigestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__selectMediaTokenWithDigestResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaTokenWithDigestResponse);
		if (size)
			*size = sizeof(tns__selectMediaTokenWithDigestResponse);
		((tns__selectMediaTokenWithDigestResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaTokenWithDigestResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectMediaTokenWithDigestResponse);
		for (int i = 0; i < n; i++)
			((tns__selectMediaTokenWithDigestResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectMediaTokenWithDigestResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectMediaTokenWithDigestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectMediaTokenWithDigestResponse %p -> %p\n", q, p));
	*(tns__selectMediaTokenWithDigestResponse*)p = *(tns__selectMediaTokenWithDigestResponse*)q;
}

void tns__selectMediaTokenWithDigest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__selectMediaTokenWithDigest::digest = NULL;
	soap_default_int(soap, &this->tns__selectMediaTokenWithDigest::section);
	/* transient soap skipped */
}

void tns__selectMediaTokenWithDigest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__selectMediaTokenWithDigest::digest);
	/* transient soap skipped */
}

int tns__selectMediaTokenWithDigest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectMediaTokenWithDigest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectMediaTokenWithDigest(struct soap *soap, const char *tag, int id, const tns__selectMediaTokenWithDigest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__selectMediaTokenWithDigest), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "digest", -1, &(a->tns__selectMediaTokenWithDigest::digest), ""))
		return soap->error;
	if (soap_out_int(soap, "section", -1, &(a->tns__selectMediaTokenWithDigest::section), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectMediaTokenWithDigest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectMediaTokenWithDigest(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectMediaTokenWithDigest * SOAP_FMAC4 soap_in_tns__selectMediaTokenWithDigest(struct soap *soap, const char *tag, tns__selectMediaTokenWithDigest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectMediaTokenWithDigest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__selectMediaTokenWithDigest, sizeof(tns__selectMediaTokenWithDigest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__selectMediaTokenWithDigest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectMediaTokenWithDigest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_digest1 = 1;
	size_t soap_flag_section1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_digest1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "digest", &(a->tns__selectMediaTokenWithDigest::digest), "xsd:string"))
				{	soap_flag_digest1--;
					continue;
				}
			if (soap_flag_section1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "section", &(a->tns__selectMediaTokenWithDigest::section), "xsd:int"))
				{	soap_flag_section1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectMediaTokenWithDigest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__selectMediaTokenWithDigest, 0, sizeof(tns__selectMediaTokenWithDigest), 0, soap_copy_tns__selectMediaTokenWithDigest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_section1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__selectMediaTokenWithDigest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__selectMediaTokenWithDigest);
	if (this->soap_out(soap, tag?tag:"tns:selectMediaTokenWithDigest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectMediaTokenWithDigest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectMediaTokenWithDigest(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectMediaTokenWithDigest * SOAP_FMAC4 soap_get_tns__selectMediaTokenWithDigest(struct soap *soap, tns__selectMediaTokenWithDigest *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectMediaTokenWithDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectMediaTokenWithDigest * SOAP_FMAC2 soap_instantiate_tns__selectMediaTokenWithDigest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectMediaTokenWithDigest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__selectMediaTokenWithDigest, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaTokenWithDigest);
		if (size)
			*size = sizeof(tns__selectMediaTokenWithDigest);
		((tns__selectMediaTokenWithDigest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaTokenWithDigest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectMediaTokenWithDigest);
		for (int i = 0; i < n; i++)
			((tns__selectMediaTokenWithDigest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectMediaTokenWithDigest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectMediaTokenWithDigest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectMediaTokenWithDigest %p -> %p\n", q, p));
	*(tns__selectMediaTokenWithDigest*)p = *(tns__selectMediaTokenWithDigest*)q;
}

void tns__selectMediaTokenIdWithUrlResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__selectMediaTokenIdWithUrlResponse::return_);
	/* transient soap skipped */
}

void tns__selectMediaTokenIdWithUrlResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__selectMediaTokenIdWithUrlResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectMediaTokenIdWithUrlResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectMediaTokenIdWithUrlResponse(struct soap *soap, const char *tag, int id, const tns__selectMediaTokenIdWithUrlResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__selectMediaTokenIdWithUrlResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "return", -1, &(a->tns__selectMediaTokenIdWithUrlResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectMediaTokenIdWithUrlResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectMediaTokenIdWithUrlResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectMediaTokenIdWithUrlResponse * SOAP_FMAC4 soap_in_tns__selectMediaTokenIdWithUrlResponse(struct soap *soap, const char *tag, tns__selectMediaTokenIdWithUrlResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectMediaTokenIdWithUrlResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__selectMediaTokenIdWithUrlResponse, sizeof(tns__selectMediaTokenIdWithUrlResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__selectMediaTokenIdWithUrlResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectMediaTokenIdWithUrlResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "return", &(a->tns__selectMediaTokenIdWithUrlResponse::return_), "xsd:long"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectMediaTokenIdWithUrlResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__selectMediaTokenIdWithUrlResponse, 0, sizeof(tns__selectMediaTokenIdWithUrlResponse), 0, soap_copy_tns__selectMediaTokenIdWithUrlResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__selectMediaTokenIdWithUrlResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__selectMediaTokenIdWithUrlResponse);
	if (this->soap_out(soap, tag?tag:"tns:selectMediaTokenIdWithUrlResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectMediaTokenIdWithUrlResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectMediaTokenIdWithUrlResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectMediaTokenIdWithUrlResponse * SOAP_FMAC4 soap_get_tns__selectMediaTokenIdWithUrlResponse(struct soap *soap, tns__selectMediaTokenIdWithUrlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectMediaTokenIdWithUrlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectMediaTokenIdWithUrlResponse * SOAP_FMAC2 soap_instantiate_tns__selectMediaTokenIdWithUrlResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectMediaTokenIdWithUrlResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__selectMediaTokenIdWithUrlResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaTokenIdWithUrlResponse);
		if (size)
			*size = sizeof(tns__selectMediaTokenIdWithUrlResponse);
		((tns__selectMediaTokenIdWithUrlResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaTokenIdWithUrlResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectMediaTokenIdWithUrlResponse);
		for (int i = 0; i < n; i++)
			((tns__selectMediaTokenIdWithUrlResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectMediaTokenIdWithUrlResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectMediaTokenIdWithUrlResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectMediaTokenIdWithUrlResponse %p -> %p\n", q, p));
	*(tns__selectMediaTokenIdWithUrlResponse*)p = *(tns__selectMediaTokenIdWithUrlResponse*)q;
}

void tns__selectMediaTokenIdWithUrl::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__selectMediaTokenIdWithUrl::url = NULL;
	soap_default_int(soap, &this->tns__selectMediaTokenIdWithUrl::section);
	/* transient soap skipped */
}

void tns__selectMediaTokenIdWithUrl::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__selectMediaTokenIdWithUrl::url);
	/* transient soap skipped */
}

int tns__selectMediaTokenIdWithUrl::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectMediaTokenIdWithUrl(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectMediaTokenIdWithUrl(struct soap *soap, const char *tag, int id, const tns__selectMediaTokenIdWithUrl *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__selectMediaTokenIdWithUrl), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "url", -1, &(a->tns__selectMediaTokenIdWithUrl::url), ""))
		return soap->error;
	if (soap_out_int(soap, "section", -1, &(a->tns__selectMediaTokenIdWithUrl::section), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectMediaTokenIdWithUrl::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectMediaTokenIdWithUrl(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectMediaTokenIdWithUrl * SOAP_FMAC4 soap_in_tns__selectMediaTokenIdWithUrl(struct soap *soap, const char *tag, tns__selectMediaTokenIdWithUrl *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectMediaTokenIdWithUrl *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__selectMediaTokenIdWithUrl, sizeof(tns__selectMediaTokenIdWithUrl), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__selectMediaTokenIdWithUrl)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectMediaTokenIdWithUrl *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_url1 = 1;
	size_t soap_flag_section1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_url1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "url", &(a->tns__selectMediaTokenIdWithUrl::url), "xsd:string"))
				{	soap_flag_url1--;
					continue;
				}
			if (soap_flag_section1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "section", &(a->tns__selectMediaTokenIdWithUrl::section), "xsd:int"))
				{	soap_flag_section1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectMediaTokenIdWithUrl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__selectMediaTokenIdWithUrl, 0, sizeof(tns__selectMediaTokenIdWithUrl), 0, soap_copy_tns__selectMediaTokenIdWithUrl);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_section1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__selectMediaTokenIdWithUrl::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__selectMediaTokenIdWithUrl);
	if (this->soap_out(soap, tag?tag:"tns:selectMediaTokenIdWithUrl", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectMediaTokenIdWithUrl::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectMediaTokenIdWithUrl(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectMediaTokenIdWithUrl * SOAP_FMAC4 soap_get_tns__selectMediaTokenIdWithUrl(struct soap *soap, tns__selectMediaTokenIdWithUrl *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectMediaTokenIdWithUrl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectMediaTokenIdWithUrl * SOAP_FMAC2 soap_instantiate_tns__selectMediaTokenIdWithUrl(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectMediaTokenIdWithUrl(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__selectMediaTokenIdWithUrl, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaTokenIdWithUrl);
		if (size)
			*size = sizeof(tns__selectMediaTokenIdWithUrl);
		((tns__selectMediaTokenIdWithUrl*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaTokenIdWithUrl[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectMediaTokenIdWithUrl);
		for (int i = 0; i < n; i++)
			((tns__selectMediaTokenIdWithUrl*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectMediaTokenIdWithUrl*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectMediaTokenIdWithUrl(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectMediaTokenIdWithUrl %p -> %p\n", q, p));
	*(tns__selectMediaTokenIdWithUrl*)p = *(tns__selectMediaTokenIdWithUrl*)q;
}

void tns__selectMediaTokenIdWithDigestResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__selectMediaTokenIdWithDigestResponse::return_);
	/* transient soap skipped */
}

void tns__selectMediaTokenIdWithDigestResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__selectMediaTokenIdWithDigestResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectMediaTokenIdWithDigestResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectMediaTokenIdWithDigestResponse(struct soap *soap, const char *tag, int id, const tns__selectMediaTokenIdWithDigestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__selectMediaTokenIdWithDigestResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "return", -1, &(a->tns__selectMediaTokenIdWithDigestResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectMediaTokenIdWithDigestResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectMediaTokenIdWithDigestResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectMediaTokenIdWithDigestResponse * SOAP_FMAC4 soap_in_tns__selectMediaTokenIdWithDigestResponse(struct soap *soap, const char *tag, tns__selectMediaTokenIdWithDigestResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectMediaTokenIdWithDigestResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__selectMediaTokenIdWithDigestResponse, sizeof(tns__selectMediaTokenIdWithDigestResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__selectMediaTokenIdWithDigestResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectMediaTokenIdWithDigestResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "return", &(a->tns__selectMediaTokenIdWithDigestResponse::return_), "xsd:long"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectMediaTokenIdWithDigestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__selectMediaTokenIdWithDigestResponse, 0, sizeof(tns__selectMediaTokenIdWithDigestResponse), 0, soap_copy_tns__selectMediaTokenIdWithDigestResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__selectMediaTokenIdWithDigestResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__selectMediaTokenIdWithDigestResponse);
	if (this->soap_out(soap, tag?tag:"tns:selectMediaTokenIdWithDigestResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectMediaTokenIdWithDigestResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectMediaTokenIdWithDigestResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectMediaTokenIdWithDigestResponse * SOAP_FMAC4 soap_get_tns__selectMediaTokenIdWithDigestResponse(struct soap *soap, tns__selectMediaTokenIdWithDigestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectMediaTokenIdWithDigestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectMediaTokenIdWithDigestResponse * SOAP_FMAC2 soap_instantiate_tns__selectMediaTokenIdWithDigestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectMediaTokenIdWithDigestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__selectMediaTokenIdWithDigestResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaTokenIdWithDigestResponse);
		if (size)
			*size = sizeof(tns__selectMediaTokenIdWithDigestResponse);
		((tns__selectMediaTokenIdWithDigestResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaTokenIdWithDigestResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectMediaTokenIdWithDigestResponse);
		for (int i = 0; i < n; i++)
			((tns__selectMediaTokenIdWithDigestResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectMediaTokenIdWithDigestResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectMediaTokenIdWithDigestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectMediaTokenIdWithDigestResponse %p -> %p\n", q, p));
	*(tns__selectMediaTokenIdWithDigestResponse*)p = *(tns__selectMediaTokenIdWithDigestResponse*)q;
}

void tns__selectMediaTokenIdWithDigest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__selectMediaTokenIdWithDigest::digest = NULL;
	soap_default_int(soap, &this->tns__selectMediaTokenIdWithDigest::section);
	/* transient soap skipped */
}

void tns__selectMediaTokenIdWithDigest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__selectMediaTokenIdWithDigest::digest);
	/* transient soap skipped */
}

int tns__selectMediaTokenIdWithDigest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectMediaTokenIdWithDigest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectMediaTokenIdWithDigest(struct soap *soap, const char *tag, int id, const tns__selectMediaTokenIdWithDigest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__selectMediaTokenIdWithDigest), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "digest", -1, &(a->tns__selectMediaTokenIdWithDigest::digest), ""))
		return soap->error;
	if (soap_out_int(soap, "section", -1, &(a->tns__selectMediaTokenIdWithDigest::section), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectMediaTokenIdWithDigest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectMediaTokenIdWithDigest(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectMediaTokenIdWithDigest * SOAP_FMAC4 soap_in_tns__selectMediaTokenIdWithDigest(struct soap *soap, const char *tag, tns__selectMediaTokenIdWithDigest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectMediaTokenIdWithDigest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__selectMediaTokenIdWithDigest, sizeof(tns__selectMediaTokenIdWithDigest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__selectMediaTokenIdWithDigest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectMediaTokenIdWithDigest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_digest1 = 1;
	size_t soap_flag_section1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_digest1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "digest", &(a->tns__selectMediaTokenIdWithDigest::digest), "xsd:string"))
				{	soap_flag_digest1--;
					continue;
				}
			if (soap_flag_section1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "section", &(a->tns__selectMediaTokenIdWithDigest::section), "xsd:int"))
				{	soap_flag_section1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectMediaTokenIdWithDigest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__selectMediaTokenIdWithDigest, 0, sizeof(tns__selectMediaTokenIdWithDigest), 0, soap_copy_tns__selectMediaTokenIdWithDigest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_section1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__selectMediaTokenIdWithDigest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__selectMediaTokenIdWithDigest);
	if (this->soap_out(soap, tag?tag:"tns:selectMediaTokenIdWithDigest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectMediaTokenIdWithDigest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectMediaTokenIdWithDigest(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectMediaTokenIdWithDigest * SOAP_FMAC4 soap_get_tns__selectMediaTokenIdWithDigest(struct soap *soap, tns__selectMediaTokenIdWithDigest *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectMediaTokenIdWithDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectMediaTokenIdWithDigest * SOAP_FMAC2 soap_instantiate_tns__selectMediaTokenIdWithDigest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectMediaTokenIdWithDigest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__selectMediaTokenIdWithDigest, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaTokenIdWithDigest);
		if (size)
			*size = sizeof(tns__selectMediaTokenIdWithDigest);
		((tns__selectMediaTokenIdWithDigest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaTokenIdWithDigest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectMediaTokenIdWithDigest);
		for (int i = 0; i < n; i++)
			((tns__selectMediaTokenIdWithDigest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectMediaTokenIdWithDigest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectMediaTokenIdWithDigest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectMediaTokenIdWithDigest %p -> %p\n", q, p));
	*(tns__selectMediaTokenIdWithDigest*)p = *(tns__selectMediaTokenIdWithDigest*)q;
}

void tns__selectMediaAnnotationsWithTokenIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTotns__mediaAnnotation(soap, &this->tns__selectMediaAnnotationsWithTokenIdResponse::return_);
	/* transient soap skipped */
}

void tns__selectMediaAnnotationsWithTokenIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTotns__mediaAnnotation(soap, &this->tns__selectMediaAnnotationsWithTokenIdResponse::return_);
	/* transient soap skipped */
}

int tns__selectMediaAnnotationsWithTokenIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectMediaAnnotationsWithTokenIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectMediaAnnotationsWithTokenIdResponse(struct soap *soap, const char *tag, int id, const tns__selectMediaAnnotationsWithTokenIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__selectMediaAnnotationsWithTokenIdResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTotns__mediaAnnotation(soap, "return", -1, &(a->tns__selectMediaAnnotationsWithTokenIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectMediaAnnotationsWithTokenIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectMediaAnnotationsWithTokenIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectMediaAnnotationsWithTokenIdResponse * SOAP_FMAC4 soap_in_tns__selectMediaAnnotationsWithTokenIdResponse(struct soap *soap, const char *tag, tns__selectMediaAnnotationsWithTokenIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectMediaAnnotationsWithTokenIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__selectMediaAnnotationsWithTokenIdResponse, sizeof(tns__selectMediaAnnotationsWithTokenIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__selectMediaAnnotationsWithTokenIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectMediaAnnotationsWithTokenIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTotns__mediaAnnotation(soap, "return", &(a->tns__selectMediaAnnotationsWithTokenIdResponse::return_), "tns:mediaAnnotation"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectMediaAnnotationsWithTokenIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__selectMediaAnnotationsWithTokenIdResponse, 0, sizeof(tns__selectMediaAnnotationsWithTokenIdResponse), 0, soap_copy_tns__selectMediaAnnotationsWithTokenIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__selectMediaAnnotationsWithTokenIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__selectMediaAnnotationsWithTokenIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:selectMediaAnnotationsWithTokenIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectMediaAnnotationsWithTokenIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectMediaAnnotationsWithTokenIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectMediaAnnotationsWithTokenIdResponse * SOAP_FMAC4 soap_get_tns__selectMediaAnnotationsWithTokenIdResponse(struct soap *soap, tns__selectMediaAnnotationsWithTokenIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectMediaAnnotationsWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectMediaAnnotationsWithTokenIdResponse * SOAP_FMAC2 soap_instantiate_tns__selectMediaAnnotationsWithTokenIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectMediaAnnotationsWithTokenIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__selectMediaAnnotationsWithTokenIdResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaAnnotationsWithTokenIdResponse);
		if (size)
			*size = sizeof(tns__selectMediaAnnotationsWithTokenIdResponse);
		((tns__selectMediaAnnotationsWithTokenIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaAnnotationsWithTokenIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectMediaAnnotationsWithTokenIdResponse);
		for (int i = 0; i < n; i++)
			((tns__selectMediaAnnotationsWithTokenIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectMediaAnnotationsWithTokenIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectMediaAnnotationsWithTokenIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectMediaAnnotationsWithTokenIdResponse %p -> %p\n", q, p));
	*(tns__selectMediaAnnotationsWithTokenIdResponse*)p = *(tns__selectMediaAnnotationsWithTokenIdResponse*)q;
}

void tns__selectMediaAnnotationsWithTokenId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__selectMediaAnnotationsWithTokenId::tokenId);
	/* transient soap skipped */
}

void tns__selectMediaAnnotationsWithTokenId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__selectMediaAnnotationsWithTokenId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectMediaAnnotationsWithTokenId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectMediaAnnotationsWithTokenId(struct soap *soap, const char *tag, int id, const tns__selectMediaAnnotationsWithTokenId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__selectMediaAnnotationsWithTokenId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "tokenId", -1, &(a->tns__selectMediaAnnotationsWithTokenId::tokenId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectMediaAnnotationsWithTokenId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectMediaAnnotationsWithTokenId(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectMediaAnnotationsWithTokenId * SOAP_FMAC4 soap_in_tns__selectMediaAnnotationsWithTokenId(struct soap *soap, const char *tag, tns__selectMediaAnnotationsWithTokenId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectMediaAnnotationsWithTokenId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__selectMediaAnnotationsWithTokenId, sizeof(tns__selectMediaAnnotationsWithTokenId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__selectMediaAnnotationsWithTokenId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectMediaAnnotationsWithTokenId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_tokenId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tokenId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "tokenId", &(a->tns__selectMediaAnnotationsWithTokenId::tokenId), "xsd:long"))
				{	soap_flag_tokenId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectMediaAnnotationsWithTokenId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__selectMediaAnnotationsWithTokenId, 0, sizeof(tns__selectMediaAnnotationsWithTokenId), 0, soap_copy_tns__selectMediaAnnotationsWithTokenId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_tokenId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__selectMediaAnnotationsWithTokenId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__selectMediaAnnotationsWithTokenId);
	if (this->soap_out(soap, tag?tag:"tns:selectMediaAnnotationsWithTokenId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectMediaAnnotationsWithTokenId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectMediaAnnotationsWithTokenId(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectMediaAnnotationsWithTokenId * SOAP_FMAC4 soap_get_tns__selectMediaAnnotationsWithTokenId(struct soap *soap, tns__selectMediaAnnotationsWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectMediaAnnotationsWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectMediaAnnotationsWithTokenId * SOAP_FMAC2 soap_instantiate_tns__selectMediaAnnotationsWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectMediaAnnotationsWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__selectMediaAnnotationsWithTokenId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaAnnotationsWithTokenId);
		if (size)
			*size = sizeof(tns__selectMediaAnnotationsWithTokenId);
		((tns__selectMediaAnnotationsWithTokenId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaAnnotationsWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectMediaAnnotationsWithTokenId);
		for (int i = 0; i < n; i++)
			((tns__selectMediaAnnotationsWithTokenId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectMediaAnnotationsWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectMediaAnnotationsWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectMediaAnnotationsWithTokenId %p -> %p\n", q, p));
	*(tns__selectMediaAnnotationsWithTokenId*)p = *(tns__selectMediaAnnotationsWithTokenId*)q;
}

void tns__selectMediaAliasesWithTokenIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTotns__mediaAlias(soap, &this->tns__selectMediaAliasesWithTokenIdResponse::return_);
	/* transient soap skipped */
}

void tns__selectMediaAliasesWithTokenIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTotns__mediaAlias(soap, &this->tns__selectMediaAliasesWithTokenIdResponse::return_);
	/* transient soap skipped */
}

int tns__selectMediaAliasesWithTokenIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectMediaAliasesWithTokenIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectMediaAliasesWithTokenIdResponse(struct soap *soap, const char *tag, int id, const tns__selectMediaAliasesWithTokenIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__selectMediaAliasesWithTokenIdResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTotns__mediaAlias(soap, "return", -1, &(a->tns__selectMediaAliasesWithTokenIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectMediaAliasesWithTokenIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectMediaAliasesWithTokenIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectMediaAliasesWithTokenIdResponse * SOAP_FMAC4 soap_in_tns__selectMediaAliasesWithTokenIdResponse(struct soap *soap, const char *tag, tns__selectMediaAliasesWithTokenIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectMediaAliasesWithTokenIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__selectMediaAliasesWithTokenIdResponse, sizeof(tns__selectMediaAliasesWithTokenIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__selectMediaAliasesWithTokenIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectMediaAliasesWithTokenIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTotns__mediaAlias(soap, "return", &(a->tns__selectMediaAliasesWithTokenIdResponse::return_), "tns:mediaAlias"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectMediaAliasesWithTokenIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__selectMediaAliasesWithTokenIdResponse, 0, sizeof(tns__selectMediaAliasesWithTokenIdResponse), 0, soap_copy_tns__selectMediaAliasesWithTokenIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__selectMediaAliasesWithTokenIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__selectMediaAliasesWithTokenIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:selectMediaAliasesWithTokenIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectMediaAliasesWithTokenIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectMediaAliasesWithTokenIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectMediaAliasesWithTokenIdResponse * SOAP_FMAC4 soap_get_tns__selectMediaAliasesWithTokenIdResponse(struct soap *soap, tns__selectMediaAliasesWithTokenIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectMediaAliasesWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectMediaAliasesWithTokenIdResponse * SOAP_FMAC2 soap_instantiate_tns__selectMediaAliasesWithTokenIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectMediaAliasesWithTokenIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__selectMediaAliasesWithTokenIdResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaAliasesWithTokenIdResponse);
		if (size)
			*size = sizeof(tns__selectMediaAliasesWithTokenIdResponse);
		((tns__selectMediaAliasesWithTokenIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaAliasesWithTokenIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectMediaAliasesWithTokenIdResponse);
		for (int i = 0; i < n; i++)
			((tns__selectMediaAliasesWithTokenIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectMediaAliasesWithTokenIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectMediaAliasesWithTokenIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectMediaAliasesWithTokenIdResponse %p -> %p\n", q, p));
	*(tns__selectMediaAliasesWithTokenIdResponse*)p = *(tns__selectMediaAliasesWithTokenIdResponse*)q;
}

void tns__selectMediaAliasesWithTokenId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__selectMediaAliasesWithTokenId::tokenId);
	/* transient soap skipped */
}

void tns__selectMediaAliasesWithTokenId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__selectMediaAliasesWithTokenId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectMediaAliasesWithTokenId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectMediaAliasesWithTokenId(struct soap *soap, const char *tag, int id, const tns__selectMediaAliasesWithTokenId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__selectMediaAliasesWithTokenId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "tokenId", -1, &(a->tns__selectMediaAliasesWithTokenId::tokenId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectMediaAliasesWithTokenId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectMediaAliasesWithTokenId(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectMediaAliasesWithTokenId * SOAP_FMAC4 soap_in_tns__selectMediaAliasesWithTokenId(struct soap *soap, const char *tag, tns__selectMediaAliasesWithTokenId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectMediaAliasesWithTokenId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__selectMediaAliasesWithTokenId, sizeof(tns__selectMediaAliasesWithTokenId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__selectMediaAliasesWithTokenId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectMediaAliasesWithTokenId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_tokenId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tokenId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "tokenId", &(a->tns__selectMediaAliasesWithTokenId::tokenId), "xsd:long"))
				{	soap_flag_tokenId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectMediaAliasesWithTokenId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__selectMediaAliasesWithTokenId, 0, sizeof(tns__selectMediaAliasesWithTokenId), 0, soap_copy_tns__selectMediaAliasesWithTokenId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_tokenId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__selectMediaAliasesWithTokenId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__selectMediaAliasesWithTokenId);
	if (this->soap_out(soap, tag?tag:"tns:selectMediaAliasesWithTokenId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectMediaAliasesWithTokenId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectMediaAliasesWithTokenId(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectMediaAliasesWithTokenId * SOAP_FMAC4 soap_get_tns__selectMediaAliasesWithTokenId(struct soap *soap, tns__selectMediaAliasesWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectMediaAliasesWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectMediaAliasesWithTokenId * SOAP_FMAC2 soap_instantiate_tns__selectMediaAliasesWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectMediaAliasesWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__selectMediaAliasesWithTokenId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaAliasesWithTokenId);
		if (size)
			*size = sizeof(tns__selectMediaAliasesWithTokenId);
		((tns__selectMediaAliasesWithTokenId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaAliasesWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectMediaAliasesWithTokenId);
		for (int i = 0; i < n; i++)
			((tns__selectMediaAliasesWithTokenId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectMediaAliasesWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectMediaAliasesWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectMediaAliasesWithTokenId %p -> %p\n", q, p));
	*(tns__selectMediaAliasesWithTokenId*)p = *(tns__selectMediaAliasesWithTokenId*)q;
}

void tns__selectGameThreadWithTokenIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__selectGameThreadWithTokenIdResponse::return_ = NULL;
	/* transient soap skipped */
}

void tns__selectGameThreadWithTokenIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__gameThread(soap, &this->tns__selectGameThreadWithTokenIdResponse::return_);
	/* transient soap skipped */
}

int tns__selectGameThreadWithTokenIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectGameThreadWithTokenIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectGameThreadWithTokenIdResponse(struct soap *soap, const char *tag, int id, const tns__selectGameThreadWithTokenIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__selectGameThreadWithTokenIdResponse), type))
		return soap->error;
	if (soap_out_PointerTotns__gameThread(soap, "return", -1, &(a->tns__selectGameThreadWithTokenIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectGameThreadWithTokenIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectGameThreadWithTokenIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectGameThreadWithTokenIdResponse * SOAP_FMAC4 soap_in_tns__selectGameThreadWithTokenIdResponse(struct soap *soap, const char *tag, tns__selectGameThreadWithTokenIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectGameThreadWithTokenIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__selectGameThreadWithTokenIdResponse, sizeof(tns__selectGameThreadWithTokenIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__selectGameThreadWithTokenIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectGameThreadWithTokenIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__gameThread(soap, "return", &(a->tns__selectGameThreadWithTokenIdResponse::return_), "tns:gameThread"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectGameThreadWithTokenIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__selectGameThreadWithTokenIdResponse, 0, sizeof(tns__selectGameThreadWithTokenIdResponse), 0, soap_copy_tns__selectGameThreadWithTokenIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__selectGameThreadWithTokenIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__selectGameThreadWithTokenIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:selectGameThreadWithTokenIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectGameThreadWithTokenIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectGameThreadWithTokenIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectGameThreadWithTokenIdResponse * SOAP_FMAC4 soap_get_tns__selectGameThreadWithTokenIdResponse(struct soap *soap, tns__selectGameThreadWithTokenIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectGameThreadWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectGameThreadWithTokenIdResponse * SOAP_FMAC2 soap_instantiate_tns__selectGameThreadWithTokenIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectGameThreadWithTokenIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__selectGameThreadWithTokenIdResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectGameThreadWithTokenIdResponse);
		if (size)
			*size = sizeof(tns__selectGameThreadWithTokenIdResponse);
		((tns__selectGameThreadWithTokenIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectGameThreadWithTokenIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectGameThreadWithTokenIdResponse);
		for (int i = 0; i < n; i++)
			((tns__selectGameThreadWithTokenIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectGameThreadWithTokenIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectGameThreadWithTokenIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectGameThreadWithTokenIdResponse %p -> %p\n", q, p));
	*(tns__selectGameThreadWithTokenIdResponse*)p = *(tns__selectGameThreadWithTokenIdResponse*)q;
}

void tns__selectGameThreadWithTokenId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__selectGameThreadWithTokenId::tokenId);
	/* transient soap skipped */
}

void tns__selectGameThreadWithTokenId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__selectGameThreadWithTokenId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectGameThreadWithTokenId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectGameThreadWithTokenId(struct soap *soap, const char *tag, int id, const tns__selectGameThreadWithTokenId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__selectGameThreadWithTokenId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "tokenId", -1, &(a->tns__selectGameThreadWithTokenId::tokenId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectGameThreadWithTokenId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectGameThreadWithTokenId(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectGameThreadWithTokenId * SOAP_FMAC4 soap_in_tns__selectGameThreadWithTokenId(struct soap *soap, const char *tag, tns__selectGameThreadWithTokenId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectGameThreadWithTokenId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__selectGameThreadWithTokenId, sizeof(tns__selectGameThreadWithTokenId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__selectGameThreadWithTokenId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectGameThreadWithTokenId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_tokenId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tokenId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "tokenId", &(a->tns__selectGameThreadWithTokenId::tokenId), "xsd:long"))
				{	soap_flag_tokenId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectGameThreadWithTokenId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__selectGameThreadWithTokenId, 0, sizeof(tns__selectGameThreadWithTokenId), 0, soap_copy_tns__selectGameThreadWithTokenId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_tokenId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__selectGameThreadWithTokenId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__selectGameThreadWithTokenId);
	if (this->soap_out(soap, tag?tag:"tns:selectGameThreadWithTokenId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectGameThreadWithTokenId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectGameThreadWithTokenId(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectGameThreadWithTokenId * SOAP_FMAC4 soap_get_tns__selectGameThreadWithTokenId(struct soap *soap, tns__selectGameThreadWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectGameThreadWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectGameThreadWithTokenId * SOAP_FMAC2 soap_instantiate_tns__selectGameThreadWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectGameThreadWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__selectGameThreadWithTokenId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectGameThreadWithTokenId);
		if (size)
			*size = sizeof(tns__selectGameThreadWithTokenId);
		((tns__selectGameThreadWithTokenId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectGameThreadWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectGameThreadWithTokenId);
		for (int i = 0; i < n; i++)
			((tns__selectGameThreadWithTokenId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectGameThreadWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectGameThreadWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectGameThreadWithTokenId %p -> %p\n", q, p));
	*(tns__selectGameThreadWithTokenId*)p = *(tns__selectGameThreadWithTokenId*)q;
}

void tns__selectGameThreadWithTokenDigestResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__selectGameThreadWithTokenDigestResponse::return_ = NULL;
	/* transient soap skipped */
}

void tns__selectGameThreadWithTokenDigestResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__gameThread(soap, &this->tns__selectGameThreadWithTokenDigestResponse::return_);
	/* transient soap skipped */
}

int tns__selectGameThreadWithTokenDigestResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectGameThreadWithTokenDigestResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectGameThreadWithTokenDigestResponse(struct soap *soap, const char *tag, int id, const tns__selectGameThreadWithTokenDigestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__selectGameThreadWithTokenDigestResponse), type))
		return soap->error;
	if (soap_out_PointerTotns__gameThread(soap, "return", -1, &(a->tns__selectGameThreadWithTokenDigestResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectGameThreadWithTokenDigestResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectGameThreadWithTokenDigestResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectGameThreadWithTokenDigestResponse * SOAP_FMAC4 soap_in_tns__selectGameThreadWithTokenDigestResponse(struct soap *soap, const char *tag, tns__selectGameThreadWithTokenDigestResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectGameThreadWithTokenDigestResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__selectGameThreadWithTokenDigestResponse, sizeof(tns__selectGameThreadWithTokenDigestResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__selectGameThreadWithTokenDigestResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectGameThreadWithTokenDigestResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__gameThread(soap, "return", &(a->tns__selectGameThreadWithTokenDigestResponse::return_), "tns:gameThread"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectGameThreadWithTokenDigestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__selectGameThreadWithTokenDigestResponse, 0, sizeof(tns__selectGameThreadWithTokenDigestResponse), 0, soap_copy_tns__selectGameThreadWithTokenDigestResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__selectGameThreadWithTokenDigestResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__selectGameThreadWithTokenDigestResponse);
	if (this->soap_out(soap, tag?tag:"tns:selectGameThreadWithTokenDigestResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectGameThreadWithTokenDigestResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectGameThreadWithTokenDigestResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectGameThreadWithTokenDigestResponse * SOAP_FMAC4 soap_get_tns__selectGameThreadWithTokenDigestResponse(struct soap *soap, tns__selectGameThreadWithTokenDigestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectGameThreadWithTokenDigestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectGameThreadWithTokenDigestResponse * SOAP_FMAC2 soap_instantiate_tns__selectGameThreadWithTokenDigestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectGameThreadWithTokenDigestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__selectGameThreadWithTokenDigestResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectGameThreadWithTokenDigestResponse);
		if (size)
			*size = sizeof(tns__selectGameThreadWithTokenDigestResponse);
		((tns__selectGameThreadWithTokenDigestResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectGameThreadWithTokenDigestResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectGameThreadWithTokenDigestResponse);
		for (int i = 0; i < n; i++)
			((tns__selectGameThreadWithTokenDigestResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectGameThreadWithTokenDigestResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectGameThreadWithTokenDigestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectGameThreadWithTokenDigestResponse %p -> %p\n", q, p));
	*(tns__selectGameThreadWithTokenDigestResponse*)p = *(tns__selectGameThreadWithTokenDigestResponse*)q;
}

void tns__selectGameThreadWithTokenDigest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__selectGameThreadWithTokenDigest::tokenDigest = NULL;
	/* transient soap skipped */
}

void tns__selectGameThreadWithTokenDigest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__selectGameThreadWithTokenDigest::tokenDigest);
	/* transient soap skipped */
}

int tns__selectGameThreadWithTokenDigest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectGameThreadWithTokenDigest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectGameThreadWithTokenDigest(struct soap *soap, const char *tag, int id, const tns__selectGameThreadWithTokenDigest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__selectGameThreadWithTokenDigest), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tokenDigest", -1, &(a->tns__selectGameThreadWithTokenDigest::tokenDigest), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectGameThreadWithTokenDigest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectGameThreadWithTokenDigest(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectGameThreadWithTokenDigest * SOAP_FMAC4 soap_in_tns__selectGameThreadWithTokenDigest(struct soap *soap, const char *tag, tns__selectGameThreadWithTokenDigest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectGameThreadWithTokenDigest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__selectGameThreadWithTokenDigest, sizeof(tns__selectGameThreadWithTokenDigest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__selectGameThreadWithTokenDigest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectGameThreadWithTokenDigest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_tokenDigest1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tokenDigest1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "tokenDigest", &(a->tns__selectGameThreadWithTokenDigest::tokenDigest), "xsd:string"))
				{	soap_flag_tokenDigest1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectGameThreadWithTokenDigest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__selectGameThreadWithTokenDigest, 0, sizeof(tns__selectGameThreadWithTokenDigest), 0, soap_copy_tns__selectGameThreadWithTokenDigest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__selectGameThreadWithTokenDigest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__selectGameThreadWithTokenDigest);
	if (this->soap_out(soap, tag?tag:"tns:selectGameThreadWithTokenDigest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectGameThreadWithTokenDigest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectGameThreadWithTokenDigest(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectGameThreadWithTokenDigest * SOAP_FMAC4 soap_get_tns__selectGameThreadWithTokenDigest(struct soap *soap, tns__selectGameThreadWithTokenDigest *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectGameThreadWithTokenDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectGameThreadWithTokenDigest * SOAP_FMAC2 soap_instantiate_tns__selectGameThreadWithTokenDigest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectGameThreadWithTokenDigest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__selectGameThreadWithTokenDigest, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectGameThreadWithTokenDigest);
		if (size)
			*size = sizeof(tns__selectGameThreadWithTokenDigest);
		((tns__selectGameThreadWithTokenDigest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectGameThreadWithTokenDigest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectGameThreadWithTokenDigest);
		for (int i = 0; i < n; i++)
			((tns__selectGameThreadWithTokenDigest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectGameThreadWithTokenDigest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectGameThreadWithTokenDigest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectGameThreadWithTokenDigest %p -> %p\n", q, p));
	*(tns__selectGameThreadWithTokenDigest*)p = *(tns__selectGameThreadWithTokenDigest*)q;
}

void tns__loginResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__loginResponse::return_);
	/* transient soap skipped */
}

void tns__loginResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__loginResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__loginResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__loginResponse(struct soap *soap, const char *tag, int id, const tns__loginResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__loginResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__loginResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__loginResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__loginResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__loginResponse * SOAP_FMAC4 soap_in_tns__loginResponse(struct soap *soap, const char *tag, tns__loginResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__loginResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__loginResponse, sizeof(tns__loginResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__loginResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__loginResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__loginResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__loginResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__loginResponse, 0, sizeof(tns__loginResponse), 0, soap_copy_tns__loginResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__loginResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__loginResponse);
	if (this->soap_out(soap, tag?tag:"tns:loginResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__loginResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__loginResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__loginResponse * SOAP_FMAC4 soap_get_tns__loginResponse(struct soap *soap, tns__loginResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__loginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__loginResponse * SOAP_FMAC2 soap_instantiate_tns__loginResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__loginResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__loginResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__loginResponse);
		if (size)
			*size = sizeof(tns__loginResponse);
		((tns__loginResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__loginResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__loginResponse);
		for (int i = 0; i < n; i++)
			((tns__loginResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__loginResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__loginResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__loginResponse %p -> %p\n", q, p));
	*(tns__loginResponse*)p = *(tns__loginResponse*)q;
}

void tns__login::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__login::userName = NULL;
	this->tns__login::password = NULL;
	/* transient soap skipped */
}

void tns__login::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__login::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__login::password);
	/* transient soap skipped */
}

int tns__login::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__login(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__login(struct soap *soap, const char *tag, int id, const tns__login *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__login), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__login::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__login::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__login::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__login(soap, tag, this, type);
}

SOAP_FMAC3 tns__login * SOAP_FMAC4 soap_in_tns__login(struct soap *soap, const char *tag, tns__login *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__login *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__login, sizeof(tns__login), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__login)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__login *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__login::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__login::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__login *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__login, 0, sizeof(tns__login), 0, soap_copy_tns__login);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__login::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__login);
	if (this->soap_out(soap, tag?tag:"tns:login", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__login::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__login(soap, this, tag, type);
}

SOAP_FMAC3 tns__login * SOAP_FMAC4 soap_get_tns__login(struct soap *soap, tns__login *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__login * SOAP_FMAC2 soap_instantiate_tns__login(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__login(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__login, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__login);
		if (size)
			*size = sizeof(tns__login);
		((tns__login*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__login[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__login);
		for (int i = 0; i < n; i++)
			((tns__login*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__login*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__login(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__login %p -> %p\n", q, p));
	*(tns__login*)p = *(tns__login*)q;
}

void tns__isLatestAppResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__isLatestAppResponse::return_);
	/* transient soap skipped */
}

void tns__isLatestAppResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__isLatestAppResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__isLatestAppResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__isLatestAppResponse(struct soap *soap, const char *tag, int id, const tns__isLatestAppResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__isLatestAppResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__isLatestAppResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__isLatestAppResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__isLatestAppResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__isLatestAppResponse * SOAP_FMAC4 soap_in_tns__isLatestAppResponse(struct soap *soap, const char *tag, tns__isLatestAppResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__isLatestAppResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__isLatestAppResponse, sizeof(tns__isLatestAppResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__isLatestAppResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__isLatestAppResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__isLatestAppResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__isLatestAppResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__isLatestAppResponse, 0, sizeof(tns__isLatestAppResponse), 0, soap_copy_tns__isLatestAppResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__isLatestAppResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__isLatestAppResponse);
	if (this->soap_out(soap, tag?tag:"tns:isLatestAppResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__isLatestAppResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__isLatestAppResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__isLatestAppResponse * SOAP_FMAC4 soap_get_tns__isLatestAppResponse(struct soap *soap, tns__isLatestAppResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__isLatestAppResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__isLatestAppResponse * SOAP_FMAC2 soap_instantiate_tns__isLatestAppResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__isLatestAppResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__isLatestAppResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__isLatestAppResponse);
		if (size)
			*size = sizeof(tns__isLatestAppResponse);
		((tns__isLatestAppResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__isLatestAppResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__isLatestAppResponse);
		for (int i = 0; i < n; i++)
			((tns__isLatestAppResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__isLatestAppResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__isLatestAppResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__isLatestAppResponse %p -> %p\n", q, p));
	*(tns__isLatestAppResponse*)p = *(tns__isLatestAppResponse*)q;
}

void tns__isLatestApp::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__isLatestApp::version = NULL;
	/* transient soap skipped */
}

void tns__isLatestApp::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__isLatestApp::version);
	/* transient soap skipped */
}

int tns__isLatestApp::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__isLatestApp(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__isLatestApp(struct soap *soap, const char *tag, int id, const tns__isLatestApp *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__isLatestApp), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "version", -1, &(a->tns__isLatestApp::version), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__isLatestApp::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__isLatestApp(soap, tag, this, type);
}

SOAP_FMAC3 tns__isLatestApp * SOAP_FMAC4 soap_in_tns__isLatestApp(struct soap *soap, const char *tag, tns__isLatestApp *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__isLatestApp *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__isLatestApp, sizeof(tns__isLatestApp), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__isLatestApp)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__isLatestApp *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_version1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "version", &(a->tns__isLatestApp::version), "xsd:string"))
				{	soap_flag_version1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__isLatestApp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__isLatestApp, 0, sizeof(tns__isLatestApp), 0, soap_copy_tns__isLatestApp);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__isLatestApp::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__isLatestApp);
	if (this->soap_out(soap, tag?tag:"tns:isLatestApp", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__isLatestApp::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__isLatestApp(soap, this, tag, type);
}

SOAP_FMAC3 tns__isLatestApp * SOAP_FMAC4 soap_get_tns__isLatestApp(struct soap *soap, tns__isLatestApp *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__isLatestApp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__isLatestApp * SOAP_FMAC2 soap_instantiate_tns__isLatestApp(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__isLatestApp(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__isLatestApp, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__isLatestApp);
		if (size)
			*size = sizeof(tns__isLatestApp);
		((tns__isLatestApp*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__isLatestApp[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__isLatestApp);
		for (int i = 0; i < n; i++)
			((tns__isLatestApp*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__isLatestApp*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__isLatestApp(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__isLatestApp %p -> %p\n", q, p));
	*(tns__isLatestApp*)p = *(tns__isLatestApp*)q;
}

void tns__isConnectedResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__isConnectedResponse::return_);
	/* transient soap skipped */
}

void tns__isConnectedResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__isConnectedResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__isConnectedResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__isConnectedResponse(struct soap *soap, const char *tag, int id, const tns__isConnectedResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__isConnectedResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__isConnectedResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__isConnectedResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__isConnectedResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__isConnectedResponse * SOAP_FMAC4 soap_in_tns__isConnectedResponse(struct soap *soap, const char *tag, tns__isConnectedResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__isConnectedResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__isConnectedResponse, sizeof(tns__isConnectedResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__isConnectedResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__isConnectedResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__isConnectedResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__isConnectedResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__isConnectedResponse, 0, sizeof(tns__isConnectedResponse), 0, soap_copy_tns__isConnectedResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__isConnectedResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__isConnectedResponse);
	if (this->soap_out(soap, tag?tag:"tns:isConnectedResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__isConnectedResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__isConnectedResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__isConnectedResponse * SOAP_FMAC4 soap_get_tns__isConnectedResponse(struct soap *soap, tns__isConnectedResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__isConnectedResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__isConnectedResponse * SOAP_FMAC2 soap_instantiate_tns__isConnectedResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__isConnectedResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__isConnectedResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__isConnectedResponse);
		if (size)
			*size = sizeof(tns__isConnectedResponse);
		((tns__isConnectedResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__isConnectedResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__isConnectedResponse);
		for (int i = 0; i < n; i++)
			((tns__isConnectedResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__isConnectedResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__isConnectedResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__isConnectedResponse %p -> %p\n", q, p));
	*(tns__isConnectedResponse*)p = *(tns__isConnectedResponse*)q;
}

void tns__isConnected::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void tns__isConnected::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__isConnected::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__isConnected(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__isConnected(struct soap *soap, const char *tag, int id, const tns__isConnected *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__isConnected), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__isConnected::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__isConnected(soap, tag, this, type);
}

SOAP_FMAC3 tns__isConnected * SOAP_FMAC4 soap_in_tns__isConnected(struct soap *soap, const char *tag, tns__isConnected *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__isConnected *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__isConnected, sizeof(tns__isConnected), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__isConnected)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__isConnected *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__isConnected *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__isConnected, 0, sizeof(tns__isConnected), 0, soap_copy_tns__isConnected);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__isConnected::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__isConnected);
	if (this->soap_out(soap, tag?tag:"tns:isConnected", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__isConnected::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__isConnected(soap, this, tag, type);
}

SOAP_FMAC3 tns__isConnected * SOAP_FMAC4 soap_get_tns__isConnected(struct soap *soap, tns__isConnected *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__isConnected(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__isConnected * SOAP_FMAC2 soap_instantiate_tns__isConnected(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__isConnected(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__isConnected, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__isConnected);
		if (size)
			*size = sizeof(tns__isConnected);
		((tns__isConnected*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__isConnected[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__isConnected);
		for (int i = 0; i < n; i++)
			((tns__isConnected*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__isConnected*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__isConnected(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__isConnected %p -> %p\n", q, p));
	*(tns__isConnected*)p = *(tns__isConnected*)q;
}

void tns__isAuthorizedResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__isAuthorizedResponse::return_);
	/* transient soap skipped */
}

void tns__isAuthorizedResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__isAuthorizedResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__isAuthorizedResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__isAuthorizedResponse(struct soap *soap, const char *tag, int id, const tns__isAuthorizedResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__isAuthorizedResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__isAuthorizedResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__isAuthorizedResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__isAuthorizedResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__isAuthorizedResponse * SOAP_FMAC4 soap_in_tns__isAuthorizedResponse(struct soap *soap, const char *tag, tns__isAuthorizedResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__isAuthorizedResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__isAuthorizedResponse, sizeof(tns__isAuthorizedResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__isAuthorizedResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__isAuthorizedResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__isAuthorizedResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__isAuthorizedResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__isAuthorizedResponse, 0, sizeof(tns__isAuthorizedResponse), 0, soap_copy_tns__isAuthorizedResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__isAuthorizedResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__isAuthorizedResponse);
	if (this->soap_out(soap, tag?tag:"tns:isAuthorizedResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__isAuthorizedResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__isAuthorizedResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__isAuthorizedResponse * SOAP_FMAC4 soap_get_tns__isAuthorizedResponse(struct soap *soap, tns__isAuthorizedResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__isAuthorizedResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__isAuthorizedResponse * SOAP_FMAC2 soap_instantiate_tns__isAuthorizedResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__isAuthorizedResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__isAuthorizedResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__isAuthorizedResponse);
		if (size)
			*size = sizeof(tns__isAuthorizedResponse);
		((tns__isAuthorizedResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__isAuthorizedResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__isAuthorizedResponse);
		for (int i = 0; i < n; i++)
			((tns__isAuthorizedResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__isAuthorizedResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__isAuthorizedResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__isAuthorizedResponse %p -> %p\n", q, p));
	*(tns__isAuthorizedResponse*)p = *(tns__isAuthorizedResponse*)q;
}

void tns__isAuthorized::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void tns__isAuthorized::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__isAuthorized::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__isAuthorized(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__isAuthorized(struct soap *soap, const char *tag, int id, const tns__isAuthorized *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__isAuthorized), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__isAuthorized::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__isAuthorized(soap, tag, this, type);
}

SOAP_FMAC3 tns__isAuthorized * SOAP_FMAC4 soap_in_tns__isAuthorized(struct soap *soap, const char *tag, tns__isAuthorized *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__isAuthorized *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__isAuthorized, sizeof(tns__isAuthorized), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__isAuthorized)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__isAuthorized *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__isAuthorized *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__isAuthorized, 0, sizeof(tns__isAuthorized), 0, soap_copy_tns__isAuthorized);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__isAuthorized::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__isAuthorized);
	if (this->soap_out(soap, tag?tag:"tns:isAuthorized", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__isAuthorized::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__isAuthorized(soap, this, tag, type);
}

SOAP_FMAC3 tns__isAuthorized * SOAP_FMAC4 soap_get_tns__isAuthorized(struct soap *soap, tns__isAuthorized *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__isAuthorized(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__isAuthorized * SOAP_FMAC2 soap_instantiate_tns__isAuthorized(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__isAuthorized(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__isAuthorized, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__isAuthorized);
		if (size)
			*size = sizeof(tns__isAuthorized);
		((tns__isAuthorized*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__isAuthorized[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__isAuthorized);
		for (int i = 0; i < n; i++)
			((tns__isAuthorized*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__isAuthorized*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__isAuthorized(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__isAuthorized %p -> %p\n", q, p));
	*(tns__isAuthorized*)p = *(tns__isAuthorized*)q;
}

void tns__getUserResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__getUserResponse::return_ = NULL;
	/* transient soap skipped */
}

void tns__getUserResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__user(soap, &this->tns__getUserResponse::return_);
	/* transient soap skipped */
}

int tns__getUserResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__getUserResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__getUserResponse(struct soap *soap, const char *tag, int id, const tns__getUserResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__getUserResponse), type))
		return soap->error;
	if (soap_out_PointerTotns__user(soap, "return", -1, &(a->tns__getUserResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__getUserResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__getUserResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__getUserResponse * SOAP_FMAC4 soap_in_tns__getUserResponse(struct soap *soap, const char *tag, tns__getUserResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__getUserResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__getUserResponse, sizeof(tns__getUserResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__getUserResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__getUserResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__user(soap, "return", &(a->tns__getUserResponse::return_), "tns:user"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__getUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__getUserResponse, 0, sizeof(tns__getUserResponse), 0, soap_copy_tns__getUserResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__getUserResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__getUserResponse);
	if (this->soap_out(soap, tag?tag:"tns:getUserResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__getUserResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__getUserResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__getUserResponse * SOAP_FMAC4 soap_get_tns__getUserResponse(struct soap *soap, tns__getUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__getUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__getUserResponse * SOAP_FMAC2 soap_instantiate_tns__getUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__getUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__getUserResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__getUserResponse);
		if (size)
			*size = sizeof(tns__getUserResponse);
		((tns__getUserResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__getUserResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__getUserResponse);
		for (int i = 0; i < n; i++)
			((tns__getUserResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__getUserResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__getUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__getUserResponse %p -> %p\n", q, p));
	*(tns__getUserResponse*)p = *(tns__getUserResponse*)q;
}

void tns__getUser::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void tns__getUser::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__getUser::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__getUser(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__getUser(struct soap *soap, const char *tag, int id, const tns__getUser *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__getUser), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__getUser::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__getUser(soap, tag, this, type);
}

SOAP_FMAC3 tns__getUser * SOAP_FMAC4 soap_in_tns__getUser(struct soap *soap, const char *tag, tns__getUser *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__getUser *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__getUser, sizeof(tns__getUser), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__getUser)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__getUser *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__getUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__getUser, 0, sizeof(tns__getUser), 0, soap_copy_tns__getUser);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__getUser::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__getUser);
	if (this->soap_out(soap, tag?tag:"tns:getUser", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__getUser::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__getUser(soap, this, tag, type);
}

SOAP_FMAC3 tns__getUser * SOAP_FMAC4 soap_get_tns__getUser(struct soap *soap, tns__getUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__getUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__getUser * SOAP_FMAC2 soap_instantiate_tns__getUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__getUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__getUser, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__getUser);
		if (size)
			*size = sizeof(tns__getUser);
		((tns__getUser*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__getUser[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__getUser);
		for (int i = 0; i < n; i++)
			((tns__getUser*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__getUser*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__getUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__getUser %p -> %p\n", q, p));
	*(tns__getUser*)p = *(tns__getUser*)q;
}

void tns__deleteMediaAnnotationWithIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__deleteMediaAnnotationWithIdResponse::return_);
	/* transient soap skipped */
}

void tns__deleteMediaAnnotationWithIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__deleteMediaAnnotationWithIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__deleteMediaAnnotationWithIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__deleteMediaAnnotationWithIdResponse(struct soap *soap, const char *tag, int id, const tns__deleteMediaAnnotationWithIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__deleteMediaAnnotationWithIdResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__deleteMediaAnnotationWithIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__deleteMediaAnnotationWithIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__deleteMediaAnnotationWithIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__deleteMediaAnnotationWithIdResponse * SOAP_FMAC4 soap_in_tns__deleteMediaAnnotationWithIdResponse(struct soap *soap, const char *tag, tns__deleteMediaAnnotationWithIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__deleteMediaAnnotationWithIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__deleteMediaAnnotationWithIdResponse, sizeof(tns__deleteMediaAnnotationWithIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__deleteMediaAnnotationWithIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__deleteMediaAnnotationWithIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__deleteMediaAnnotationWithIdResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__deleteMediaAnnotationWithIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__deleteMediaAnnotationWithIdResponse, 0, sizeof(tns__deleteMediaAnnotationWithIdResponse), 0, soap_copy_tns__deleteMediaAnnotationWithIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__deleteMediaAnnotationWithIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__deleteMediaAnnotationWithIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:deleteMediaAnnotationWithIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__deleteMediaAnnotationWithIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__deleteMediaAnnotationWithIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__deleteMediaAnnotationWithIdResponse * SOAP_FMAC4 soap_get_tns__deleteMediaAnnotationWithIdResponse(struct soap *soap, tns__deleteMediaAnnotationWithIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__deleteMediaAnnotationWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__deleteMediaAnnotationWithIdResponse * SOAP_FMAC2 soap_instantiate_tns__deleteMediaAnnotationWithIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__deleteMediaAnnotationWithIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__deleteMediaAnnotationWithIdResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__deleteMediaAnnotationWithIdResponse);
		if (size)
			*size = sizeof(tns__deleteMediaAnnotationWithIdResponse);
		((tns__deleteMediaAnnotationWithIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__deleteMediaAnnotationWithIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__deleteMediaAnnotationWithIdResponse);
		for (int i = 0; i < n; i++)
			((tns__deleteMediaAnnotationWithIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__deleteMediaAnnotationWithIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__deleteMediaAnnotationWithIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__deleteMediaAnnotationWithIdResponse %p -> %p\n", q, p));
	*(tns__deleteMediaAnnotationWithIdResponse*)p = *(tns__deleteMediaAnnotationWithIdResponse*)q;
}

void tns__deleteMediaAnnotationWithId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__deleteMediaAnnotationWithId::id);
	/* transient soap skipped */
}

void tns__deleteMediaAnnotationWithId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__deleteMediaAnnotationWithId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__deleteMediaAnnotationWithId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__deleteMediaAnnotationWithId(struct soap *soap, const char *tag, int id, const tns__deleteMediaAnnotationWithId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__deleteMediaAnnotationWithId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "id", -1, &(a->tns__deleteMediaAnnotationWithId::id), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__deleteMediaAnnotationWithId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__deleteMediaAnnotationWithId(soap, tag, this, type);
}

SOAP_FMAC3 tns__deleteMediaAnnotationWithId * SOAP_FMAC4 soap_in_tns__deleteMediaAnnotationWithId(struct soap *soap, const char *tag, tns__deleteMediaAnnotationWithId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__deleteMediaAnnotationWithId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__deleteMediaAnnotationWithId, sizeof(tns__deleteMediaAnnotationWithId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__deleteMediaAnnotationWithId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__deleteMediaAnnotationWithId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "id", &(a->tns__deleteMediaAnnotationWithId::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__deleteMediaAnnotationWithId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__deleteMediaAnnotationWithId, 0, sizeof(tns__deleteMediaAnnotationWithId), 0, soap_copy_tns__deleteMediaAnnotationWithId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__deleteMediaAnnotationWithId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__deleteMediaAnnotationWithId);
	if (this->soap_out(soap, tag?tag:"tns:deleteMediaAnnotationWithId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__deleteMediaAnnotationWithId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__deleteMediaAnnotationWithId(soap, this, tag, type);
}

SOAP_FMAC3 tns__deleteMediaAnnotationWithId * SOAP_FMAC4 soap_get_tns__deleteMediaAnnotationWithId(struct soap *soap, tns__deleteMediaAnnotationWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__deleteMediaAnnotationWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__deleteMediaAnnotationWithId * SOAP_FMAC2 soap_instantiate_tns__deleteMediaAnnotationWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__deleteMediaAnnotationWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__deleteMediaAnnotationWithId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__deleteMediaAnnotationWithId);
		if (size)
			*size = sizeof(tns__deleteMediaAnnotationWithId);
		((tns__deleteMediaAnnotationWithId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__deleteMediaAnnotationWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__deleteMediaAnnotationWithId);
		for (int i = 0; i < n; i++)
			((tns__deleteMediaAnnotationWithId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__deleteMediaAnnotationWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__deleteMediaAnnotationWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__deleteMediaAnnotationWithId %p -> %p\n", q, p));
	*(tns__deleteMediaAnnotationWithId*)p = *(tns__deleteMediaAnnotationWithId*)q;
}

void tns__deleteMediaAliasWithIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__deleteMediaAliasWithIdResponse::return_);
	/* transient soap skipped */
}

void tns__deleteMediaAliasWithIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__deleteMediaAliasWithIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__deleteMediaAliasWithIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__deleteMediaAliasWithIdResponse(struct soap *soap, const char *tag, int id, const tns__deleteMediaAliasWithIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__deleteMediaAliasWithIdResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__deleteMediaAliasWithIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__deleteMediaAliasWithIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__deleteMediaAliasWithIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__deleteMediaAliasWithIdResponse * SOAP_FMAC4 soap_in_tns__deleteMediaAliasWithIdResponse(struct soap *soap, const char *tag, tns__deleteMediaAliasWithIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__deleteMediaAliasWithIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__deleteMediaAliasWithIdResponse, sizeof(tns__deleteMediaAliasWithIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__deleteMediaAliasWithIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__deleteMediaAliasWithIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__deleteMediaAliasWithIdResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__deleteMediaAliasWithIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__deleteMediaAliasWithIdResponse, 0, sizeof(tns__deleteMediaAliasWithIdResponse), 0, soap_copy_tns__deleteMediaAliasWithIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__deleteMediaAliasWithIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__deleteMediaAliasWithIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:deleteMediaAliasWithIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__deleteMediaAliasWithIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__deleteMediaAliasWithIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__deleteMediaAliasWithIdResponse * SOAP_FMAC4 soap_get_tns__deleteMediaAliasWithIdResponse(struct soap *soap, tns__deleteMediaAliasWithIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__deleteMediaAliasWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__deleteMediaAliasWithIdResponse * SOAP_FMAC2 soap_instantiate_tns__deleteMediaAliasWithIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__deleteMediaAliasWithIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__deleteMediaAliasWithIdResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__deleteMediaAliasWithIdResponse);
		if (size)
			*size = sizeof(tns__deleteMediaAliasWithIdResponse);
		((tns__deleteMediaAliasWithIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__deleteMediaAliasWithIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__deleteMediaAliasWithIdResponse);
		for (int i = 0; i < n; i++)
			((tns__deleteMediaAliasWithIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__deleteMediaAliasWithIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__deleteMediaAliasWithIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__deleteMediaAliasWithIdResponse %p -> %p\n", q, p));
	*(tns__deleteMediaAliasWithIdResponse*)p = *(tns__deleteMediaAliasWithIdResponse*)q;
}

void tns__deleteMediaAliasWithId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__deleteMediaAliasWithId::id);
	/* transient soap skipped */
}

void tns__deleteMediaAliasWithId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__deleteMediaAliasWithId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__deleteMediaAliasWithId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__deleteMediaAliasWithId(struct soap *soap, const char *tag, int id, const tns__deleteMediaAliasWithId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__deleteMediaAliasWithId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "id", -1, &(a->tns__deleteMediaAliasWithId::id), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__deleteMediaAliasWithId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__deleteMediaAliasWithId(soap, tag, this, type);
}

SOAP_FMAC3 tns__deleteMediaAliasWithId * SOAP_FMAC4 soap_in_tns__deleteMediaAliasWithId(struct soap *soap, const char *tag, tns__deleteMediaAliasWithId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__deleteMediaAliasWithId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__deleteMediaAliasWithId, sizeof(tns__deleteMediaAliasWithId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__deleteMediaAliasWithId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__deleteMediaAliasWithId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "id", &(a->tns__deleteMediaAliasWithId::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__deleteMediaAliasWithId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__deleteMediaAliasWithId, 0, sizeof(tns__deleteMediaAliasWithId), 0, soap_copy_tns__deleteMediaAliasWithId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__deleteMediaAliasWithId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__deleteMediaAliasWithId);
	if (this->soap_out(soap, tag?tag:"tns:deleteMediaAliasWithId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__deleteMediaAliasWithId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__deleteMediaAliasWithId(soap, this, tag, type);
}

SOAP_FMAC3 tns__deleteMediaAliasWithId * SOAP_FMAC4 soap_get_tns__deleteMediaAliasWithId(struct soap *soap, tns__deleteMediaAliasWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__deleteMediaAliasWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__deleteMediaAliasWithId * SOAP_FMAC2 soap_instantiate_tns__deleteMediaAliasWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__deleteMediaAliasWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__deleteMediaAliasWithId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__deleteMediaAliasWithId);
		if (size)
			*size = sizeof(tns__deleteMediaAliasWithId);
		((tns__deleteMediaAliasWithId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__deleteMediaAliasWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__deleteMediaAliasWithId);
		for (int i = 0; i < n; i++)
			((tns__deleteMediaAliasWithId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__deleteMediaAliasWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__deleteMediaAliasWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__deleteMediaAliasWithId %p -> %p\n", q, p));
	*(tns__deleteMediaAliasWithId*)p = *(tns__deleteMediaAliasWithId*)q;
}

void tns__curseUserWithIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__curseUserWithIdResponse::return_);
	/* transient soap skipped */
}

void tns__curseUserWithIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__curseUserWithIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__curseUserWithIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__curseUserWithIdResponse(struct soap *soap, const char *tag, int id, const tns__curseUserWithIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__curseUserWithIdResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__curseUserWithIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__curseUserWithIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__curseUserWithIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__curseUserWithIdResponse * SOAP_FMAC4 soap_in_tns__curseUserWithIdResponse(struct soap *soap, const char *tag, tns__curseUserWithIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__curseUserWithIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__curseUserWithIdResponse, sizeof(tns__curseUserWithIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__curseUserWithIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__curseUserWithIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__curseUserWithIdResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__curseUserWithIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__curseUserWithIdResponse, 0, sizeof(tns__curseUserWithIdResponse), 0, soap_copy_tns__curseUserWithIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__curseUserWithIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__curseUserWithIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:curseUserWithIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__curseUserWithIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__curseUserWithIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__curseUserWithIdResponse * SOAP_FMAC4 soap_get_tns__curseUserWithIdResponse(struct soap *soap, tns__curseUserWithIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__curseUserWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__curseUserWithIdResponse * SOAP_FMAC2 soap_instantiate_tns__curseUserWithIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__curseUserWithIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__curseUserWithIdResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__curseUserWithIdResponse);
		if (size)
			*size = sizeof(tns__curseUserWithIdResponse);
		((tns__curseUserWithIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__curseUserWithIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__curseUserWithIdResponse);
		for (int i = 0; i < n; i++)
			((tns__curseUserWithIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__curseUserWithIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__curseUserWithIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__curseUserWithIdResponse %p -> %p\n", q, p));
	*(tns__curseUserWithIdResponse*)p = *(tns__curseUserWithIdResponse*)q;
}

void tns__curseUserWithId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__curseUserWithId::id);
	/* transient soap skipped */
}

void tns__curseUserWithId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__curseUserWithId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__curseUserWithId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__curseUserWithId(struct soap *soap, const char *tag, int id, const tns__curseUserWithId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__curseUserWithId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "id", -1, &(a->tns__curseUserWithId::id), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__curseUserWithId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__curseUserWithId(soap, tag, this, type);
}

SOAP_FMAC3 tns__curseUserWithId * SOAP_FMAC4 soap_in_tns__curseUserWithId(struct soap *soap, const char *tag, tns__curseUserWithId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__curseUserWithId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__curseUserWithId, sizeof(tns__curseUserWithId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__curseUserWithId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__curseUserWithId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "id", &(a->tns__curseUserWithId::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__curseUserWithId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__curseUserWithId, 0, sizeof(tns__curseUserWithId), 0, soap_copy_tns__curseUserWithId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__curseUserWithId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__curseUserWithId);
	if (this->soap_out(soap, tag?tag:"tns:curseUserWithId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__curseUserWithId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__curseUserWithId(soap, this, tag, type);
}

SOAP_FMAC3 tns__curseUserWithId * SOAP_FMAC4 soap_get_tns__curseUserWithId(struct soap *soap, tns__curseUserWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__curseUserWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__curseUserWithId * SOAP_FMAC2 soap_instantiate_tns__curseUserWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__curseUserWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__curseUserWithId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__curseUserWithId);
		if (size)
			*size = sizeof(tns__curseUserWithId);
		((tns__curseUserWithId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__curseUserWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__curseUserWithId);
		for (int i = 0; i < n; i++)
			((tns__curseUserWithId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__curseUserWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__curseUserWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__curseUserWithId %p -> %p\n", q, p));
	*(tns__curseUserWithId*)p = *(tns__curseUserWithId*)q;
}

void tns__curseMediaTokenWithIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__curseMediaTokenWithIdResponse::return_);
	/* transient soap skipped */
}

void tns__curseMediaTokenWithIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__curseMediaTokenWithIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__curseMediaTokenWithIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__curseMediaTokenWithIdResponse(struct soap *soap, const char *tag, int id, const tns__curseMediaTokenWithIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__curseMediaTokenWithIdResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__curseMediaTokenWithIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__curseMediaTokenWithIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__curseMediaTokenWithIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__curseMediaTokenWithIdResponse * SOAP_FMAC4 soap_in_tns__curseMediaTokenWithIdResponse(struct soap *soap, const char *tag, tns__curseMediaTokenWithIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__curseMediaTokenWithIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__curseMediaTokenWithIdResponse, sizeof(tns__curseMediaTokenWithIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__curseMediaTokenWithIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__curseMediaTokenWithIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__curseMediaTokenWithIdResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__curseMediaTokenWithIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__curseMediaTokenWithIdResponse, 0, sizeof(tns__curseMediaTokenWithIdResponse), 0, soap_copy_tns__curseMediaTokenWithIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__curseMediaTokenWithIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__curseMediaTokenWithIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:curseMediaTokenWithIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__curseMediaTokenWithIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__curseMediaTokenWithIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__curseMediaTokenWithIdResponse * SOAP_FMAC4 soap_get_tns__curseMediaTokenWithIdResponse(struct soap *soap, tns__curseMediaTokenWithIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__curseMediaTokenWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__curseMediaTokenWithIdResponse * SOAP_FMAC2 soap_instantiate_tns__curseMediaTokenWithIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__curseMediaTokenWithIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__curseMediaTokenWithIdResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__curseMediaTokenWithIdResponse);
		if (size)
			*size = sizeof(tns__curseMediaTokenWithIdResponse);
		((tns__curseMediaTokenWithIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__curseMediaTokenWithIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__curseMediaTokenWithIdResponse);
		for (int i = 0; i < n; i++)
			((tns__curseMediaTokenWithIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__curseMediaTokenWithIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__curseMediaTokenWithIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__curseMediaTokenWithIdResponse %p -> %p\n", q, p));
	*(tns__curseMediaTokenWithIdResponse*)p = *(tns__curseMediaTokenWithIdResponse*)q;
}

void tns__curseMediaTokenWithId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__curseMediaTokenWithId::id);
	/* transient soap skipped */
}

void tns__curseMediaTokenWithId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__curseMediaTokenWithId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__curseMediaTokenWithId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__curseMediaTokenWithId(struct soap *soap, const char *tag, int id, const tns__curseMediaTokenWithId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__curseMediaTokenWithId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "id", -1, &(a->tns__curseMediaTokenWithId::id), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__curseMediaTokenWithId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__curseMediaTokenWithId(soap, tag, this, type);
}

SOAP_FMAC3 tns__curseMediaTokenWithId * SOAP_FMAC4 soap_in_tns__curseMediaTokenWithId(struct soap *soap, const char *tag, tns__curseMediaTokenWithId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__curseMediaTokenWithId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__curseMediaTokenWithId, sizeof(tns__curseMediaTokenWithId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__curseMediaTokenWithId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__curseMediaTokenWithId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "id", &(a->tns__curseMediaTokenWithId::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__curseMediaTokenWithId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__curseMediaTokenWithId, 0, sizeof(tns__curseMediaTokenWithId), 0, soap_copy_tns__curseMediaTokenWithId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__curseMediaTokenWithId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__curseMediaTokenWithId);
	if (this->soap_out(soap, tag?tag:"tns:curseMediaTokenWithId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__curseMediaTokenWithId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__curseMediaTokenWithId(soap, this, tag, type);
}

SOAP_FMAC3 tns__curseMediaTokenWithId * SOAP_FMAC4 soap_get_tns__curseMediaTokenWithId(struct soap *soap, tns__curseMediaTokenWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__curseMediaTokenWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__curseMediaTokenWithId * SOAP_FMAC2 soap_instantiate_tns__curseMediaTokenWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__curseMediaTokenWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__curseMediaTokenWithId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__curseMediaTokenWithId);
		if (size)
			*size = sizeof(tns__curseMediaTokenWithId);
		((tns__curseMediaTokenWithId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__curseMediaTokenWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__curseMediaTokenWithId);
		for (int i = 0; i < n; i++)
			((tns__curseMediaTokenWithId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__curseMediaTokenWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__curseMediaTokenWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__curseMediaTokenWithId %p -> %p\n", q, p));
	*(tns__curseMediaTokenWithId*)p = *(tns__curseMediaTokenWithId*)q;
}

void tns__curseMediaAnnotationWithIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__curseMediaAnnotationWithIdResponse::return_);
	/* transient soap skipped */
}

void tns__curseMediaAnnotationWithIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__curseMediaAnnotationWithIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__curseMediaAnnotationWithIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__curseMediaAnnotationWithIdResponse(struct soap *soap, const char *tag, int id, const tns__curseMediaAnnotationWithIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__curseMediaAnnotationWithIdResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__curseMediaAnnotationWithIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__curseMediaAnnotationWithIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__curseMediaAnnotationWithIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__curseMediaAnnotationWithIdResponse * SOAP_FMAC4 soap_in_tns__curseMediaAnnotationWithIdResponse(struct soap *soap, const char *tag, tns__curseMediaAnnotationWithIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__curseMediaAnnotationWithIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__curseMediaAnnotationWithIdResponse, sizeof(tns__curseMediaAnnotationWithIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__curseMediaAnnotationWithIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__curseMediaAnnotationWithIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__curseMediaAnnotationWithIdResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__curseMediaAnnotationWithIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__curseMediaAnnotationWithIdResponse, 0, sizeof(tns__curseMediaAnnotationWithIdResponse), 0, soap_copy_tns__curseMediaAnnotationWithIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__curseMediaAnnotationWithIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__curseMediaAnnotationWithIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:curseMediaAnnotationWithIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__curseMediaAnnotationWithIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__curseMediaAnnotationWithIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__curseMediaAnnotationWithIdResponse * SOAP_FMAC4 soap_get_tns__curseMediaAnnotationWithIdResponse(struct soap *soap, tns__curseMediaAnnotationWithIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__curseMediaAnnotationWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__curseMediaAnnotationWithIdResponse * SOAP_FMAC2 soap_instantiate_tns__curseMediaAnnotationWithIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__curseMediaAnnotationWithIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__curseMediaAnnotationWithIdResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__curseMediaAnnotationWithIdResponse);
		if (size)
			*size = sizeof(tns__curseMediaAnnotationWithIdResponse);
		((tns__curseMediaAnnotationWithIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__curseMediaAnnotationWithIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__curseMediaAnnotationWithIdResponse);
		for (int i = 0; i < n; i++)
			((tns__curseMediaAnnotationWithIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__curseMediaAnnotationWithIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__curseMediaAnnotationWithIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__curseMediaAnnotationWithIdResponse %p -> %p\n", q, p));
	*(tns__curseMediaAnnotationWithIdResponse*)p = *(tns__curseMediaAnnotationWithIdResponse*)q;
}

void tns__curseMediaAnnotationWithId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__curseMediaAnnotationWithId::id);
	/* transient soap skipped */
}

void tns__curseMediaAnnotationWithId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__curseMediaAnnotationWithId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__curseMediaAnnotationWithId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__curseMediaAnnotationWithId(struct soap *soap, const char *tag, int id, const tns__curseMediaAnnotationWithId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__curseMediaAnnotationWithId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "id", -1, &(a->tns__curseMediaAnnotationWithId::id), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__curseMediaAnnotationWithId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__curseMediaAnnotationWithId(soap, tag, this, type);
}

SOAP_FMAC3 tns__curseMediaAnnotationWithId * SOAP_FMAC4 soap_in_tns__curseMediaAnnotationWithId(struct soap *soap, const char *tag, tns__curseMediaAnnotationWithId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__curseMediaAnnotationWithId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__curseMediaAnnotationWithId, sizeof(tns__curseMediaAnnotationWithId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__curseMediaAnnotationWithId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__curseMediaAnnotationWithId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "id", &(a->tns__curseMediaAnnotationWithId::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__curseMediaAnnotationWithId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__curseMediaAnnotationWithId, 0, sizeof(tns__curseMediaAnnotationWithId), 0, soap_copy_tns__curseMediaAnnotationWithId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__curseMediaAnnotationWithId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__curseMediaAnnotationWithId);
	if (this->soap_out(soap, tag?tag:"tns:curseMediaAnnotationWithId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__curseMediaAnnotationWithId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__curseMediaAnnotationWithId(soap, this, tag, type);
}

SOAP_FMAC3 tns__curseMediaAnnotationWithId * SOAP_FMAC4 soap_get_tns__curseMediaAnnotationWithId(struct soap *soap, tns__curseMediaAnnotationWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__curseMediaAnnotationWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__curseMediaAnnotationWithId * SOAP_FMAC2 soap_instantiate_tns__curseMediaAnnotationWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__curseMediaAnnotationWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__curseMediaAnnotationWithId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__curseMediaAnnotationWithId);
		if (size)
			*size = sizeof(tns__curseMediaAnnotationWithId);
		((tns__curseMediaAnnotationWithId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__curseMediaAnnotationWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__curseMediaAnnotationWithId);
		for (int i = 0; i < n; i++)
			((tns__curseMediaAnnotationWithId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__curseMediaAnnotationWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__curseMediaAnnotationWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__curseMediaAnnotationWithId %p -> %p\n", q, p));
	*(tns__curseMediaAnnotationWithId*)p = *(tns__curseMediaAnnotationWithId*)q;
}

void tns__curseMediaAliasWithIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__curseMediaAliasWithIdResponse::return_);
	/* transient soap skipped */
}

void tns__curseMediaAliasWithIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__curseMediaAliasWithIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__curseMediaAliasWithIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__curseMediaAliasWithIdResponse(struct soap *soap, const char *tag, int id, const tns__curseMediaAliasWithIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__curseMediaAliasWithIdResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__curseMediaAliasWithIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__curseMediaAliasWithIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__curseMediaAliasWithIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__curseMediaAliasWithIdResponse * SOAP_FMAC4 soap_in_tns__curseMediaAliasWithIdResponse(struct soap *soap, const char *tag, tns__curseMediaAliasWithIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__curseMediaAliasWithIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__curseMediaAliasWithIdResponse, sizeof(tns__curseMediaAliasWithIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__curseMediaAliasWithIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__curseMediaAliasWithIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__curseMediaAliasWithIdResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__curseMediaAliasWithIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__curseMediaAliasWithIdResponse, 0, sizeof(tns__curseMediaAliasWithIdResponse), 0, soap_copy_tns__curseMediaAliasWithIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__curseMediaAliasWithIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__curseMediaAliasWithIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:curseMediaAliasWithIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__curseMediaAliasWithIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__curseMediaAliasWithIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__curseMediaAliasWithIdResponse * SOAP_FMAC4 soap_get_tns__curseMediaAliasWithIdResponse(struct soap *soap, tns__curseMediaAliasWithIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__curseMediaAliasWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__curseMediaAliasWithIdResponse * SOAP_FMAC2 soap_instantiate_tns__curseMediaAliasWithIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__curseMediaAliasWithIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__curseMediaAliasWithIdResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__curseMediaAliasWithIdResponse);
		if (size)
			*size = sizeof(tns__curseMediaAliasWithIdResponse);
		((tns__curseMediaAliasWithIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__curseMediaAliasWithIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__curseMediaAliasWithIdResponse);
		for (int i = 0; i < n; i++)
			((tns__curseMediaAliasWithIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__curseMediaAliasWithIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__curseMediaAliasWithIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__curseMediaAliasWithIdResponse %p -> %p\n", q, p));
	*(tns__curseMediaAliasWithIdResponse*)p = *(tns__curseMediaAliasWithIdResponse*)q;
}

void tns__curseMediaAliasWithId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__curseMediaAliasWithId::id);
	/* transient soap skipped */
}

void tns__curseMediaAliasWithId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__curseMediaAliasWithId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__curseMediaAliasWithId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__curseMediaAliasWithId(struct soap *soap, const char *tag, int id, const tns__curseMediaAliasWithId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__curseMediaAliasWithId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "id", -1, &(a->tns__curseMediaAliasWithId::id), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__curseMediaAliasWithId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__curseMediaAliasWithId(soap, tag, this, type);
}

SOAP_FMAC3 tns__curseMediaAliasWithId * SOAP_FMAC4 soap_in_tns__curseMediaAliasWithId(struct soap *soap, const char *tag, tns__curseMediaAliasWithId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__curseMediaAliasWithId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__curseMediaAliasWithId, sizeof(tns__curseMediaAliasWithId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__curseMediaAliasWithId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__curseMediaAliasWithId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "id", &(a->tns__curseMediaAliasWithId::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__curseMediaAliasWithId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__curseMediaAliasWithId, 0, sizeof(tns__curseMediaAliasWithId), 0, soap_copy_tns__curseMediaAliasWithId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__curseMediaAliasWithId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__curseMediaAliasWithId);
	if (this->soap_out(soap, tag?tag:"tns:curseMediaAliasWithId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__curseMediaAliasWithId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__curseMediaAliasWithId(soap, this, tag, type);
}

SOAP_FMAC3 tns__curseMediaAliasWithId * SOAP_FMAC4 soap_get_tns__curseMediaAliasWithId(struct soap *soap, tns__curseMediaAliasWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__curseMediaAliasWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__curseMediaAliasWithId * SOAP_FMAC2 soap_instantiate_tns__curseMediaAliasWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__curseMediaAliasWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__curseMediaAliasWithId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__curseMediaAliasWithId);
		if (size)
			*size = sizeof(tns__curseMediaAliasWithId);
		((tns__curseMediaAliasWithId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__curseMediaAliasWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__curseMediaAliasWithId);
		for (int i = 0; i < n; i++)
			((tns__curseMediaAliasWithId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__curseMediaAliasWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__curseMediaAliasWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__curseMediaAliasWithId %p -> %p\n", q, p));
	*(tns__curseMediaAliasWithId*)p = *(tns__curseMediaAliasWithId*)q;
}

void tns__chatResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__chatResponse::return_ = NULL;
	/* transient soap skipped */
}

void tns__chatResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__chatResponse::return_);
	/* transient soap skipped */
}

int tns__chatResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__chatResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__chatResponse(struct soap *soap, const char *tag, int id, const tns__chatResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__chatResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &(a->tns__chatResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__chatResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__chatResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__chatResponse * SOAP_FMAC4 soap_in_tns__chatResponse(struct soap *soap, const char *tag, tns__chatResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__chatResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__chatResponse, sizeof(tns__chatResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__chatResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__chatResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "return", &(a->tns__chatResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__chatResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__chatResponse, 0, sizeof(tns__chatResponse), 0, soap_copy_tns__chatResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__chatResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__chatResponse);
	if (this->soap_out(soap, tag?tag:"tns:chatResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__chatResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__chatResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__chatResponse * SOAP_FMAC4 soap_get_tns__chatResponse(struct soap *soap, tns__chatResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__chatResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__chatResponse * SOAP_FMAC2 soap_instantiate_tns__chatResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__chatResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__chatResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__chatResponse);
		if (size)
			*size = sizeof(tns__chatResponse);
		((tns__chatResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__chatResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__chatResponse);
		for (int i = 0; i < n; i++)
			((tns__chatResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__chatResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__chatResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__chatResponse %p -> %p\n", q, p));
	*(tns__chatResponse*)p = *(tns__chatResponse*)q;
}

void tns__chat::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__chat::text = NULL;
	/* transient soap skipped */
}

void tns__chat::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__chat::text);
	/* transient soap skipped */
}

int tns__chat::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__chat(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__chat(struct soap *soap, const char *tag, int id, const tns__chat *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__chat), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "text", -1, &(a->tns__chat::text), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__chat::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__chat(soap, tag, this, type);
}

SOAP_FMAC3 tns__chat * SOAP_FMAC4 soap_in_tns__chat(struct soap *soap, const char *tag, tns__chat *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__chat *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__chat, sizeof(tns__chat), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__chat)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__chat *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_text1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_text1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "text", &(a->tns__chat::text), "xsd:string"))
				{	soap_flag_text1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__chat *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__chat, 0, sizeof(tns__chat), 0, soap_copy_tns__chat);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__chat::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__chat);
	if (this->soap_out(soap, tag?tag:"tns:chat", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__chat::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__chat(soap, this, tag, type);
}

SOAP_FMAC3 tns__chat * SOAP_FMAC4 soap_get_tns__chat(struct soap *soap, tns__chat *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__chat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__chat * SOAP_FMAC2 soap_instantiate_tns__chat(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__chat(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__chat, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__chat);
		if (size)
			*size = sizeof(tns__chat);
		((tns__chat*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__chat[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__chat);
		for (int i = 0; i < n; i++)
			((tns__chat*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__chat*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__chat(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__chat %p -> %p\n", q, p));
	*(tns__chat*)p = *(tns__chat*)q;
}

void tns__blockUserWithIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__blockUserWithIdResponse::return_);
	/* transient soap skipped */
}

void tns__blockUserWithIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__blockUserWithIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__blockUserWithIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__blockUserWithIdResponse(struct soap *soap, const char *tag, int id, const tns__blockUserWithIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__blockUserWithIdResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__blockUserWithIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__blockUserWithIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__blockUserWithIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__blockUserWithIdResponse * SOAP_FMAC4 soap_in_tns__blockUserWithIdResponse(struct soap *soap, const char *tag, tns__blockUserWithIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__blockUserWithIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__blockUserWithIdResponse, sizeof(tns__blockUserWithIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__blockUserWithIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__blockUserWithIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__blockUserWithIdResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__blockUserWithIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__blockUserWithIdResponse, 0, sizeof(tns__blockUserWithIdResponse), 0, soap_copy_tns__blockUserWithIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__blockUserWithIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__blockUserWithIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:blockUserWithIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__blockUserWithIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__blockUserWithIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__blockUserWithIdResponse * SOAP_FMAC4 soap_get_tns__blockUserWithIdResponse(struct soap *soap, tns__blockUserWithIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__blockUserWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__blockUserWithIdResponse * SOAP_FMAC2 soap_instantiate_tns__blockUserWithIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__blockUserWithIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__blockUserWithIdResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__blockUserWithIdResponse);
		if (size)
			*size = sizeof(tns__blockUserWithIdResponse);
		((tns__blockUserWithIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__blockUserWithIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__blockUserWithIdResponse);
		for (int i = 0; i < n; i++)
			((tns__blockUserWithIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__blockUserWithIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__blockUserWithIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__blockUserWithIdResponse %p -> %p\n", q, p));
	*(tns__blockUserWithIdResponse*)p = *(tns__blockUserWithIdResponse*)q;
}

void tns__blockUserWithId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__blockUserWithId::id);
	/* transient soap skipped */
}

void tns__blockUserWithId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__blockUserWithId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__blockUserWithId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__blockUserWithId(struct soap *soap, const char *tag, int id, const tns__blockUserWithId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__blockUserWithId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "id", -1, &(a->tns__blockUserWithId::id), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__blockUserWithId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__blockUserWithId(soap, tag, this, type);
}

SOAP_FMAC3 tns__blockUserWithId * SOAP_FMAC4 soap_in_tns__blockUserWithId(struct soap *soap, const char *tag, tns__blockUserWithId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__blockUserWithId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__blockUserWithId, sizeof(tns__blockUserWithId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__blockUserWithId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__blockUserWithId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "id", &(a->tns__blockUserWithId::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__blockUserWithId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__blockUserWithId, 0, sizeof(tns__blockUserWithId), 0, soap_copy_tns__blockUserWithId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__blockUserWithId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__blockUserWithId);
	if (this->soap_out(soap, tag?tag:"tns:blockUserWithId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__blockUserWithId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__blockUserWithId(soap, this, tag, type);
}

SOAP_FMAC3 tns__blockUserWithId * SOAP_FMAC4 soap_get_tns__blockUserWithId(struct soap *soap, tns__blockUserWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__blockUserWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__blockUserWithId * SOAP_FMAC2 soap_instantiate_tns__blockUserWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__blockUserWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__blockUserWithId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__blockUserWithId);
		if (size)
			*size = sizeof(tns__blockUserWithId);
		((tns__blockUserWithId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__blockUserWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__blockUserWithId);
		for (int i = 0; i < n; i++)
			((tns__blockUserWithId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__blockUserWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__blockUserWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__blockUserWithId %p -> %p\n", q, p));
	*(tns__blockUserWithId*)p = *(tns__blockUserWithId*)q;
}

void tns__blockMediaAnnotationWithIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__blockMediaAnnotationWithIdResponse::return_);
	/* transient soap skipped */
}

void tns__blockMediaAnnotationWithIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__blockMediaAnnotationWithIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__blockMediaAnnotationWithIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__blockMediaAnnotationWithIdResponse(struct soap *soap, const char *tag, int id, const tns__blockMediaAnnotationWithIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__blockMediaAnnotationWithIdResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__blockMediaAnnotationWithIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__blockMediaAnnotationWithIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__blockMediaAnnotationWithIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__blockMediaAnnotationWithIdResponse * SOAP_FMAC4 soap_in_tns__blockMediaAnnotationWithIdResponse(struct soap *soap, const char *tag, tns__blockMediaAnnotationWithIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__blockMediaAnnotationWithIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__blockMediaAnnotationWithIdResponse, sizeof(tns__blockMediaAnnotationWithIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__blockMediaAnnotationWithIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__blockMediaAnnotationWithIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__blockMediaAnnotationWithIdResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__blockMediaAnnotationWithIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__blockMediaAnnotationWithIdResponse, 0, sizeof(tns__blockMediaAnnotationWithIdResponse), 0, soap_copy_tns__blockMediaAnnotationWithIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__blockMediaAnnotationWithIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__blockMediaAnnotationWithIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:blockMediaAnnotationWithIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__blockMediaAnnotationWithIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__blockMediaAnnotationWithIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__blockMediaAnnotationWithIdResponse * SOAP_FMAC4 soap_get_tns__blockMediaAnnotationWithIdResponse(struct soap *soap, tns__blockMediaAnnotationWithIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__blockMediaAnnotationWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__blockMediaAnnotationWithIdResponse * SOAP_FMAC2 soap_instantiate_tns__blockMediaAnnotationWithIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__blockMediaAnnotationWithIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__blockMediaAnnotationWithIdResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__blockMediaAnnotationWithIdResponse);
		if (size)
			*size = sizeof(tns__blockMediaAnnotationWithIdResponse);
		((tns__blockMediaAnnotationWithIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__blockMediaAnnotationWithIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__blockMediaAnnotationWithIdResponse);
		for (int i = 0; i < n; i++)
			((tns__blockMediaAnnotationWithIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__blockMediaAnnotationWithIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__blockMediaAnnotationWithIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__blockMediaAnnotationWithIdResponse %p -> %p\n", q, p));
	*(tns__blockMediaAnnotationWithIdResponse*)p = *(tns__blockMediaAnnotationWithIdResponse*)q;
}

void tns__blockMediaAnnotationWithId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__blockMediaAnnotationWithId::id);
	/* transient soap skipped */
}

void tns__blockMediaAnnotationWithId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__blockMediaAnnotationWithId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__blockMediaAnnotationWithId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__blockMediaAnnotationWithId(struct soap *soap, const char *tag, int id, const tns__blockMediaAnnotationWithId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__blockMediaAnnotationWithId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "id", -1, &(a->tns__blockMediaAnnotationWithId::id), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__blockMediaAnnotationWithId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__blockMediaAnnotationWithId(soap, tag, this, type);
}

SOAP_FMAC3 tns__blockMediaAnnotationWithId * SOAP_FMAC4 soap_in_tns__blockMediaAnnotationWithId(struct soap *soap, const char *tag, tns__blockMediaAnnotationWithId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__blockMediaAnnotationWithId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__blockMediaAnnotationWithId, sizeof(tns__blockMediaAnnotationWithId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__blockMediaAnnotationWithId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__blockMediaAnnotationWithId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "id", &(a->tns__blockMediaAnnotationWithId::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__blockMediaAnnotationWithId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__blockMediaAnnotationWithId, 0, sizeof(tns__blockMediaAnnotationWithId), 0, soap_copy_tns__blockMediaAnnotationWithId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__blockMediaAnnotationWithId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__blockMediaAnnotationWithId);
	if (this->soap_out(soap, tag?tag:"tns:blockMediaAnnotationWithId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__blockMediaAnnotationWithId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__blockMediaAnnotationWithId(soap, this, tag, type);
}

SOAP_FMAC3 tns__blockMediaAnnotationWithId * SOAP_FMAC4 soap_get_tns__blockMediaAnnotationWithId(struct soap *soap, tns__blockMediaAnnotationWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__blockMediaAnnotationWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__blockMediaAnnotationWithId * SOAP_FMAC2 soap_instantiate_tns__blockMediaAnnotationWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__blockMediaAnnotationWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__blockMediaAnnotationWithId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__blockMediaAnnotationWithId);
		if (size)
			*size = sizeof(tns__blockMediaAnnotationWithId);
		((tns__blockMediaAnnotationWithId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__blockMediaAnnotationWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__blockMediaAnnotationWithId);
		for (int i = 0; i < n; i++)
			((tns__blockMediaAnnotationWithId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__blockMediaAnnotationWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__blockMediaAnnotationWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__blockMediaAnnotationWithId %p -> %p\n", q, p));
	*(tns__blockMediaAnnotationWithId*)p = *(tns__blockMediaAnnotationWithId*)q;
}

void tns__blockMediaAliasWithIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__blockMediaAliasWithIdResponse::return_);
	/* transient soap skipped */
}

void tns__blockMediaAliasWithIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__blockMediaAliasWithIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__blockMediaAliasWithIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__blockMediaAliasWithIdResponse(struct soap *soap, const char *tag, int id, const tns__blockMediaAliasWithIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__blockMediaAliasWithIdResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__blockMediaAliasWithIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__blockMediaAliasWithIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__blockMediaAliasWithIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__blockMediaAliasWithIdResponse * SOAP_FMAC4 soap_in_tns__blockMediaAliasWithIdResponse(struct soap *soap, const char *tag, tns__blockMediaAliasWithIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__blockMediaAliasWithIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__blockMediaAliasWithIdResponse, sizeof(tns__blockMediaAliasWithIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__blockMediaAliasWithIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__blockMediaAliasWithIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__blockMediaAliasWithIdResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__blockMediaAliasWithIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__blockMediaAliasWithIdResponse, 0, sizeof(tns__blockMediaAliasWithIdResponse), 0, soap_copy_tns__blockMediaAliasWithIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__blockMediaAliasWithIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__blockMediaAliasWithIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:blockMediaAliasWithIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__blockMediaAliasWithIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__blockMediaAliasWithIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__blockMediaAliasWithIdResponse * SOAP_FMAC4 soap_get_tns__blockMediaAliasWithIdResponse(struct soap *soap, tns__blockMediaAliasWithIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__blockMediaAliasWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__blockMediaAliasWithIdResponse * SOAP_FMAC2 soap_instantiate_tns__blockMediaAliasWithIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__blockMediaAliasWithIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__blockMediaAliasWithIdResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__blockMediaAliasWithIdResponse);
		if (size)
			*size = sizeof(tns__blockMediaAliasWithIdResponse);
		((tns__blockMediaAliasWithIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__blockMediaAliasWithIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__blockMediaAliasWithIdResponse);
		for (int i = 0; i < n; i++)
			((tns__blockMediaAliasWithIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__blockMediaAliasWithIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__blockMediaAliasWithIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__blockMediaAliasWithIdResponse %p -> %p\n", q, p));
	*(tns__blockMediaAliasWithIdResponse*)p = *(tns__blockMediaAliasWithIdResponse*)q;
}

void tns__blockMediaAliasWithId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__blockMediaAliasWithId::id);
	/* transient soap skipped */
}

void tns__blockMediaAliasWithId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__blockMediaAliasWithId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__blockMediaAliasWithId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__blockMediaAliasWithId(struct soap *soap, const char *tag, int id, const tns__blockMediaAliasWithId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__blockMediaAliasWithId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "id", -1, &(a->tns__blockMediaAliasWithId::id), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__blockMediaAliasWithId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__blockMediaAliasWithId(soap, tag, this, type);
}

SOAP_FMAC3 tns__blockMediaAliasWithId * SOAP_FMAC4 soap_in_tns__blockMediaAliasWithId(struct soap *soap, const char *tag, tns__blockMediaAliasWithId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__blockMediaAliasWithId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__blockMediaAliasWithId, sizeof(tns__blockMediaAliasWithId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__blockMediaAliasWithId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__blockMediaAliasWithId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "id", &(a->tns__blockMediaAliasWithId::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__blockMediaAliasWithId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__blockMediaAliasWithId, 0, sizeof(tns__blockMediaAliasWithId), 0, soap_copy_tns__blockMediaAliasWithId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__blockMediaAliasWithId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__blockMediaAliasWithId);
	if (this->soap_out(soap, tag?tag:"tns:blockMediaAliasWithId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__blockMediaAliasWithId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__blockMediaAliasWithId(soap, this, tag, type);
}

SOAP_FMAC3 tns__blockMediaAliasWithId * SOAP_FMAC4 soap_get_tns__blockMediaAliasWithId(struct soap *soap, tns__blockMediaAliasWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__blockMediaAliasWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__blockMediaAliasWithId * SOAP_FMAC2 soap_instantiate_tns__blockMediaAliasWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__blockMediaAliasWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__blockMediaAliasWithId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__blockMediaAliasWithId);
		if (size)
			*size = sizeof(tns__blockMediaAliasWithId);
		((tns__blockMediaAliasWithId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__blockMediaAliasWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__blockMediaAliasWithId);
		for (int i = 0; i < n; i++)
			((tns__blockMediaAliasWithId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__blockMediaAliasWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__blockMediaAliasWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__blockMediaAliasWithId %p -> %p\n", q, p));
	*(tns__blockMediaAliasWithId*)p = *(tns__blockMediaAliasWithId*)q;
}

void tns__blessUserWithIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__blessUserWithIdResponse::return_);
	/* transient soap skipped */
}

void tns__blessUserWithIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__blessUserWithIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__blessUserWithIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__blessUserWithIdResponse(struct soap *soap, const char *tag, int id, const tns__blessUserWithIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__blessUserWithIdResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__blessUserWithIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__blessUserWithIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__blessUserWithIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__blessUserWithIdResponse * SOAP_FMAC4 soap_in_tns__blessUserWithIdResponse(struct soap *soap, const char *tag, tns__blessUserWithIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__blessUserWithIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__blessUserWithIdResponse, sizeof(tns__blessUserWithIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__blessUserWithIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__blessUserWithIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__blessUserWithIdResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__blessUserWithIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__blessUserWithIdResponse, 0, sizeof(tns__blessUserWithIdResponse), 0, soap_copy_tns__blessUserWithIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__blessUserWithIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__blessUserWithIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:blessUserWithIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__blessUserWithIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__blessUserWithIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__blessUserWithIdResponse * SOAP_FMAC4 soap_get_tns__blessUserWithIdResponse(struct soap *soap, tns__blessUserWithIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__blessUserWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__blessUserWithIdResponse * SOAP_FMAC2 soap_instantiate_tns__blessUserWithIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__blessUserWithIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__blessUserWithIdResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__blessUserWithIdResponse);
		if (size)
			*size = sizeof(tns__blessUserWithIdResponse);
		((tns__blessUserWithIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__blessUserWithIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__blessUserWithIdResponse);
		for (int i = 0; i < n; i++)
			((tns__blessUserWithIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__blessUserWithIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__blessUserWithIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__blessUserWithIdResponse %p -> %p\n", q, p));
	*(tns__blessUserWithIdResponse*)p = *(tns__blessUserWithIdResponse*)q;
}

void tns__blessUserWithId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__blessUserWithId::id);
	/* transient soap skipped */
}

void tns__blessUserWithId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__blessUserWithId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__blessUserWithId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__blessUserWithId(struct soap *soap, const char *tag, int id, const tns__blessUserWithId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__blessUserWithId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "id", -1, &(a->tns__blessUserWithId::id), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__blessUserWithId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__blessUserWithId(soap, tag, this, type);
}

SOAP_FMAC3 tns__blessUserWithId * SOAP_FMAC4 soap_in_tns__blessUserWithId(struct soap *soap, const char *tag, tns__blessUserWithId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__blessUserWithId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__blessUserWithId, sizeof(tns__blessUserWithId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__blessUserWithId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__blessUserWithId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "id", &(a->tns__blessUserWithId::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__blessUserWithId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__blessUserWithId, 0, sizeof(tns__blessUserWithId), 0, soap_copy_tns__blessUserWithId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__blessUserWithId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__blessUserWithId);
	if (this->soap_out(soap, tag?tag:"tns:blessUserWithId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__blessUserWithId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__blessUserWithId(soap, this, tag, type);
}

SOAP_FMAC3 tns__blessUserWithId * SOAP_FMAC4 soap_get_tns__blessUserWithId(struct soap *soap, tns__blessUserWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__blessUserWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__blessUserWithId * SOAP_FMAC2 soap_instantiate_tns__blessUserWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__blessUserWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__blessUserWithId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__blessUserWithId);
		if (size)
			*size = sizeof(tns__blessUserWithId);
		((tns__blessUserWithId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__blessUserWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__blessUserWithId);
		for (int i = 0; i < n; i++)
			((tns__blessUserWithId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__blessUserWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__blessUserWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__blessUserWithId %p -> %p\n", q, p));
	*(tns__blessUserWithId*)p = *(tns__blessUserWithId*)q;
}

void tns__blessMediaTokenWithIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__blessMediaTokenWithIdResponse::return_);
	/* transient soap skipped */
}

void tns__blessMediaTokenWithIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__blessMediaTokenWithIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__blessMediaTokenWithIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__blessMediaTokenWithIdResponse(struct soap *soap, const char *tag, int id, const tns__blessMediaTokenWithIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__blessMediaTokenWithIdResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__blessMediaTokenWithIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__blessMediaTokenWithIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__blessMediaTokenWithIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__blessMediaTokenWithIdResponse * SOAP_FMAC4 soap_in_tns__blessMediaTokenWithIdResponse(struct soap *soap, const char *tag, tns__blessMediaTokenWithIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__blessMediaTokenWithIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__blessMediaTokenWithIdResponse, sizeof(tns__blessMediaTokenWithIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__blessMediaTokenWithIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__blessMediaTokenWithIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__blessMediaTokenWithIdResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__blessMediaTokenWithIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__blessMediaTokenWithIdResponse, 0, sizeof(tns__blessMediaTokenWithIdResponse), 0, soap_copy_tns__blessMediaTokenWithIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__blessMediaTokenWithIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__blessMediaTokenWithIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:blessMediaTokenWithIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__blessMediaTokenWithIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__blessMediaTokenWithIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__blessMediaTokenWithIdResponse * SOAP_FMAC4 soap_get_tns__blessMediaTokenWithIdResponse(struct soap *soap, tns__blessMediaTokenWithIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__blessMediaTokenWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__blessMediaTokenWithIdResponse * SOAP_FMAC2 soap_instantiate_tns__blessMediaTokenWithIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__blessMediaTokenWithIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__blessMediaTokenWithIdResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__blessMediaTokenWithIdResponse);
		if (size)
			*size = sizeof(tns__blessMediaTokenWithIdResponse);
		((tns__blessMediaTokenWithIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__blessMediaTokenWithIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__blessMediaTokenWithIdResponse);
		for (int i = 0; i < n; i++)
			((tns__blessMediaTokenWithIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__blessMediaTokenWithIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__blessMediaTokenWithIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__blessMediaTokenWithIdResponse %p -> %p\n", q, p));
	*(tns__blessMediaTokenWithIdResponse*)p = *(tns__blessMediaTokenWithIdResponse*)q;
}

void tns__blessMediaTokenWithId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__blessMediaTokenWithId::id);
	/* transient soap skipped */
}

void tns__blessMediaTokenWithId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__blessMediaTokenWithId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__blessMediaTokenWithId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__blessMediaTokenWithId(struct soap *soap, const char *tag, int id, const tns__blessMediaTokenWithId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__blessMediaTokenWithId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "id", -1, &(a->tns__blessMediaTokenWithId::id), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__blessMediaTokenWithId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__blessMediaTokenWithId(soap, tag, this, type);
}

SOAP_FMAC3 tns__blessMediaTokenWithId * SOAP_FMAC4 soap_in_tns__blessMediaTokenWithId(struct soap *soap, const char *tag, tns__blessMediaTokenWithId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__blessMediaTokenWithId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__blessMediaTokenWithId, sizeof(tns__blessMediaTokenWithId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__blessMediaTokenWithId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__blessMediaTokenWithId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "id", &(a->tns__blessMediaTokenWithId::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__blessMediaTokenWithId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__blessMediaTokenWithId, 0, sizeof(tns__blessMediaTokenWithId), 0, soap_copy_tns__blessMediaTokenWithId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__blessMediaTokenWithId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__blessMediaTokenWithId);
	if (this->soap_out(soap, tag?tag:"tns:blessMediaTokenWithId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__blessMediaTokenWithId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__blessMediaTokenWithId(soap, this, tag, type);
}

SOAP_FMAC3 tns__blessMediaTokenWithId * SOAP_FMAC4 soap_get_tns__blessMediaTokenWithId(struct soap *soap, tns__blessMediaTokenWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__blessMediaTokenWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__blessMediaTokenWithId * SOAP_FMAC2 soap_instantiate_tns__blessMediaTokenWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__blessMediaTokenWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__blessMediaTokenWithId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__blessMediaTokenWithId);
		if (size)
			*size = sizeof(tns__blessMediaTokenWithId);
		((tns__blessMediaTokenWithId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__blessMediaTokenWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__blessMediaTokenWithId);
		for (int i = 0; i < n; i++)
			((tns__blessMediaTokenWithId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__blessMediaTokenWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__blessMediaTokenWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__blessMediaTokenWithId %p -> %p\n", q, p));
	*(tns__blessMediaTokenWithId*)p = *(tns__blessMediaTokenWithId*)q;
}

void tns__blessMediaAnnotationWithIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__blessMediaAnnotationWithIdResponse::return_);
	/* transient soap skipped */
}

void tns__blessMediaAnnotationWithIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__blessMediaAnnotationWithIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__blessMediaAnnotationWithIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__blessMediaAnnotationWithIdResponse(struct soap *soap, const char *tag, int id, const tns__blessMediaAnnotationWithIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__blessMediaAnnotationWithIdResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__blessMediaAnnotationWithIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__blessMediaAnnotationWithIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__blessMediaAnnotationWithIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__blessMediaAnnotationWithIdResponse * SOAP_FMAC4 soap_in_tns__blessMediaAnnotationWithIdResponse(struct soap *soap, const char *tag, tns__blessMediaAnnotationWithIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__blessMediaAnnotationWithIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__blessMediaAnnotationWithIdResponse, sizeof(tns__blessMediaAnnotationWithIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__blessMediaAnnotationWithIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__blessMediaAnnotationWithIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__blessMediaAnnotationWithIdResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__blessMediaAnnotationWithIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__blessMediaAnnotationWithIdResponse, 0, sizeof(tns__blessMediaAnnotationWithIdResponse), 0, soap_copy_tns__blessMediaAnnotationWithIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__blessMediaAnnotationWithIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__blessMediaAnnotationWithIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:blessMediaAnnotationWithIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__blessMediaAnnotationWithIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__blessMediaAnnotationWithIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__blessMediaAnnotationWithIdResponse * SOAP_FMAC4 soap_get_tns__blessMediaAnnotationWithIdResponse(struct soap *soap, tns__blessMediaAnnotationWithIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__blessMediaAnnotationWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__blessMediaAnnotationWithIdResponse * SOAP_FMAC2 soap_instantiate_tns__blessMediaAnnotationWithIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__blessMediaAnnotationWithIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__blessMediaAnnotationWithIdResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__blessMediaAnnotationWithIdResponse);
		if (size)
			*size = sizeof(tns__blessMediaAnnotationWithIdResponse);
		((tns__blessMediaAnnotationWithIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__blessMediaAnnotationWithIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__blessMediaAnnotationWithIdResponse);
		for (int i = 0; i < n; i++)
			((tns__blessMediaAnnotationWithIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__blessMediaAnnotationWithIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__blessMediaAnnotationWithIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__blessMediaAnnotationWithIdResponse %p -> %p\n", q, p));
	*(tns__blessMediaAnnotationWithIdResponse*)p = *(tns__blessMediaAnnotationWithIdResponse*)q;
}

void tns__blessMediaAnnotationWithId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__blessMediaAnnotationWithId::id);
	/* transient soap skipped */
}

void tns__blessMediaAnnotationWithId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__blessMediaAnnotationWithId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__blessMediaAnnotationWithId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__blessMediaAnnotationWithId(struct soap *soap, const char *tag, int id, const tns__blessMediaAnnotationWithId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__blessMediaAnnotationWithId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "id", -1, &(a->tns__blessMediaAnnotationWithId::id), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__blessMediaAnnotationWithId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__blessMediaAnnotationWithId(soap, tag, this, type);
}

SOAP_FMAC3 tns__blessMediaAnnotationWithId * SOAP_FMAC4 soap_in_tns__blessMediaAnnotationWithId(struct soap *soap, const char *tag, tns__blessMediaAnnotationWithId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__blessMediaAnnotationWithId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__blessMediaAnnotationWithId, sizeof(tns__blessMediaAnnotationWithId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__blessMediaAnnotationWithId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__blessMediaAnnotationWithId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "id", &(a->tns__blessMediaAnnotationWithId::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__blessMediaAnnotationWithId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__blessMediaAnnotationWithId, 0, sizeof(tns__blessMediaAnnotationWithId), 0, soap_copy_tns__blessMediaAnnotationWithId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__blessMediaAnnotationWithId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__blessMediaAnnotationWithId);
	if (this->soap_out(soap, tag?tag:"tns:blessMediaAnnotationWithId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__blessMediaAnnotationWithId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__blessMediaAnnotationWithId(soap, this, tag, type);
}

SOAP_FMAC3 tns__blessMediaAnnotationWithId * SOAP_FMAC4 soap_get_tns__blessMediaAnnotationWithId(struct soap *soap, tns__blessMediaAnnotationWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__blessMediaAnnotationWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__blessMediaAnnotationWithId * SOAP_FMAC2 soap_instantiate_tns__blessMediaAnnotationWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__blessMediaAnnotationWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__blessMediaAnnotationWithId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__blessMediaAnnotationWithId);
		if (size)
			*size = sizeof(tns__blessMediaAnnotationWithId);
		((tns__blessMediaAnnotationWithId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__blessMediaAnnotationWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__blessMediaAnnotationWithId);
		for (int i = 0; i < n; i++)
			((tns__blessMediaAnnotationWithId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__blessMediaAnnotationWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__blessMediaAnnotationWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__blessMediaAnnotationWithId %p -> %p\n", q, p));
	*(tns__blessMediaAnnotationWithId*)p = *(tns__blessMediaAnnotationWithId*)q;
}

void tns__blessMediaAliasWithIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__blessMediaAliasWithIdResponse::return_);
	/* transient soap skipped */
}

void tns__blessMediaAliasWithIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__blessMediaAliasWithIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__blessMediaAliasWithIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__blessMediaAliasWithIdResponse(struct soap *soap, const char *tag, int id, const tns__blessMediaAliasWithIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__blessMediaAliasWithIdResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__blessMediaAliasWithIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__blessMediaAliasWithIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__blessMediaAliasWithIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__blessMediaAliasWithIdResponse * SOAP_FMAC4 soap_in_tns__blessMediaAliasWithIdResponse(struct soap *soap, const char *tag, tns__blessMediaAliasWithIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__blessMediaAliasWithIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__blessMediaAliasWithIdResponse, sizeof(tns__blessMediaAliasWithIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__blessMediaAliasWithIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__blessMediaAliasWithIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__blessMediaAliasWithIdResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__blessMediaAliasWithIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__blessMediaAliasWithIdResponse, 0, sizeof(tns__blessMediaAliasWithIdResponse), 0, soap_copy_tns__blessMediaAliasWithIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__blessMediaAliasWithIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__blessMediaAliasWithIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:blessMediaAliasWithIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__blessMediaAliasWithIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__blessMediaAliasWithIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__blessMediaAliasWithIdResponse * SOAP_FMAC4 soap_get_tns__blessMediaAliasWithIdResponse(struct soap *soap, tns__blessMediaAliasWithIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__blessMediaAliasWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__blessMediaAliasWithIdResponse * SOAP_FMAC2 soap_instantiate_tns__blessMediaAliasWithIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__blessMediaAliasWithIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__blessMediaAliasWithIdResponse, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__blessMediaAliasWithIdResponse);
		if (size)
			*size = sizeof(tns__blessMediaAliasWithIdResponse);
		((tns__blessMediaAliasWithIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__blessMediaAliasWithIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__blessMediaAliasWithIdResponse);
		for (int i = 0; i < n; i++)
			((tns__blessMediaAliasWithIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__blessMediaAliasWithIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__blessMediaAliasWithIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__blessMediaAliasWithIdResponse %p -> %p\n", q, p));
	*(tns__blessMediaAliasWithIdResponse*)p = *(tns__blessMediaAliasWithIdResponse*)q;
}

void tns__blessMediaAliasWithId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__blessMediaAliasWithId::id);
	/* transient soap skipped */
}

void tns__blessMediaAliasWithId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__blessMediaAliasWithId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__blessMediaAliasWithId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__blessMediaAliasWithId(struct soap *soap, const char *tag, int id, const tns__blessMediaAliasWithId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__blessMediaAliasWithId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "id", -1, &(a->tns__blessMediaAliasWithId::id), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__blessMediaAliasWithId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__blessMediaAliasWithId(soap, tag, this, type);
}

SOAP_FMAC3 tns__blessMediaAliasWithId * SOAP_FMAC4 soap_in_tns__blessMediaAliasWithId(struct soap *soap, const char *tag, tns__blessMediaAliasWithId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__blessMediaAliasWithId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__blessMediaAliasWithId, sizeof(tns__blessMediaAliasWithId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__blessMediaAliasWithId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__blessMediaAliasWithId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "id", &(a->tns__blessMediaAliasWithId::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__blessMediaAliasWithId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__blessMediaAliasWithId, 0, sizeof(tns__blessMediaAliasWithId), 0, soap_copy_tns__blessMediaAliasWithId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__blessMediaAliasWithId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__blessMediaAliasWithId);
	if (this->soap_out(soap, tag?tag:"tns:blessMediaAliasWithId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__blessMediaAliasWithId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__blessMediaAliasWithId(soap, this, tag, type);
}

SOAP_FMAC3 tns__blessMediaAliasWithId * SOAP_FMAC4 soap_get_tns__blessMediaAliasWithId(struct soap *soap, tns__blessMediaAliasWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__blessMediaAliasWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__blessMediaAliasWithId * SOAP_FMAC2 soap_instantiate_tns__blessMediaAliasWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__blessMediaAliasWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__blessMediaAliasWithId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__blessMediaAliasWithId);
		if (size)
			*size = sizeof(tns__blessMediaAliasWithId);
		((tns__blessMediaAliasWithId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__blessMediaAliasWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__blessMediaAliasWithId);
		for (int i = 0; i < n; i++)
			((tns__blessMediaAliasWithId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__blessMediaAliasWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__blessMediaAliasWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__blessMediaAliasWithId %p -> %p\n", q, p));
	*(tns__blessMediaAliasWithId*)p = *(tns__blessMediaAliasWithId*)q;
}

void tns__user::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->tns__user::annotCount);
	soap_default_int(soap, &this->tns__user::blessCount);
	soap_default_int(soap, &this->tns__user::blockCount);
	soap_default_LONG64(soap, &this->tns__user::createIp);
	soap_default_LONG64(soap, &this->tns__user::createTime);
	soap_default_int(soap, &this->tns__user::curseCount);
	this->tns__user::email = NULL;
	soap_default_LONG64(soap, &this->tns__user::flags);
	soap_default_LONG64(soap, &this->tns__user::id);
	soap_default_int(soap, &this->tns__user::language);
	soap_default_LONG64(soap, &this->tns__user::loginCount);
	soap_default_LONG64(soap, &this->tns__user::loginIp);
	soap_default_LONG64(soap, &this->tns__user::loginTime);
	this->tns__user::name = NULL;
	this->tns__user::nickname = NULL;
	this->tns__user::password = NULL;
	soap_default_int(soap, &this->tns__user::status);
	/* transient soap skipped */
}

void tns__user::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__user::email);
	soap_serialize_PointerTostd__string(soap, &this->tns__user::name);
	soap_serialize_PointerTostd__string(soap, &this->tns__user::nickname);
	soap_serialize_PointerTostd__string(soap, &this->tns__user::password);
	/* transient soap skipped */
}

int tns__user::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__user(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__user(struct soap *soap, const char *tag, int id, const tns__user *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__user), type))
		return soap->error;
	if (soap_out_int(soap, "annotCount", -1, &(a->tns__user::annotCount), ""))
		return soap->error;
	if (soap_out_int(soap, "blessCount", -1, &(a->tns__user::blessCount), ""))
		return soap->error;
	if (soap_out_int(soap, "blockCount", -1, &(a->tns__user::blockCount), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "createIp", -1, &(a->tns__user::createIp), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "createTime", -1, &(a->tns__user::createTime), ""))
		return soap->error;
	if (soap_out_int(soap, "curseCount", -1, &(a->tns__user::curseCount), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "email", -1, &(a->tns__user::email), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "flags", -1, &(a->tns__user::flags), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "id", -1, &(a->tns__user::id), ""))
		return soap->error;
	if (soap_out_int(soap, "language", -1, &(a->tns__user::language), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "loginCount", -1, &(a->tns__user::loginCount), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "loginIp", -1, &(a->tns__user::loginIp), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "loginTime", -1, &(a->tns__user::loginTime), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "name", -1, &(a->tns__user::name), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "nickname", -1, &(a->tns__user::nickname), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__user::password), ""))
		return soap->error;
	if (soap_out_int(soap, "status", -1, &(a->tns__user::status), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__user::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__user(soap, tag, this, type);
}

SOAP_FMAC3 tns__user * SOAP_FMAC4 soap_in_tns__user(struct soap *soap, const char *tag, tns__user *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__user *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__user, sizeof(tns__user), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__user)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__user *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_annotCount1 = 1;
	size_t soap_flag_blessCount1 = 1;
	size_t soap_flag_blockCount1 = 1;
	size_t soap_flag_createIp1 = 1;
	size_t soap_flag_createTime1 = 1;
	size_t soap_flag_curseCount1 = 1;
	size_t soap_flag_email1 = 1;
	size_t soap_flag_flags1 = 1;
	size_t soap_flag_id1 = 1;
	size_t soap_flag_language1 = 1;
	size_t soap_flag_loginCount1 = 1;
	size_t soap_flag_loginIp1 = 1;
	size_t soap_flag_loginTime1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_nickname1 = 1;
	size_t soap_flag_password1 = 1;
	size_t soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_annotCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "annotCount", &(a->tns__user::annotCount), "xsd:int"))
				{	soap_flag_annotCount1--;
					continue;
				}
			if (soap_flag_blessCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "blessCount", &(a->tns__user::blessCount), "xsd:int"))
				{	soap_flag_blessCount1--;
					continue;
				}
			if (soap_flag_blockCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "blockCount", &(a->tns__user::blockCount), "xsd:int"))
				{	soap_flag_blockCount1--;
					continue;
				}
			if (soap_flag_createIp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "createIp", &(a->tns__user::createIp), "xsd:long"))
				{	soap_flag_createIp1--;
					continue;
				}
			if (soap_flag_createTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "createTime", &(a->tns__user::createTime), "xsd:long"))
				{	soap_flag_createTime1--;
					continue;
				}
			if (soap_flag_curseCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "curseCount", &(a->tns__user::curseCount), "xsd:int"))
				{	soap_flag_curseCount1--;
					continue;
				}
			if (soap_flag_email1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "email", &(a->tns__user::email), "xsd:string"))
				{	soap_flag_email1--;
					continue;
				}
			if (soap_flag_flags1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "flags", &(a->tns__user::flags), "xsd:long"))
				{	soap_flag_flags1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "id", &(a->tns__user::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_language1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "language", &(a->tns__user::language), "xsd:int"))
				{	soap_flag_language1--;
					continue;
				}
			if (soap_flag_loginCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "loginCount", &(a->tns__user::loginCount), "xsd:long"))
				{	soap_flag_loginCount1--;
					continue;
				}
			if (soap_flag_loginIp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "loginIp", &(a->tns__user::loginIp), "xsd:long"))
				{	soap_flag_loginIp1--;
					continue;
				}
			if (soap_flag_loginTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "loginTime", &(a->tns__user::loginTime), "xsd:long"))
				{	soap_flag_loginTime1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "name", &(a->tns__user::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_nickname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "nickname", &(a->tns__user::nickname), "xsd:string"))
				{	soap_flag_nickname1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__user::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "status", &(a->tns__user::status), "xsd:int"))
				{	soap_flag_status1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__user *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__user, 0, sizeof(tns__user), 0, soap_copy_tns__user);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_annotCount1 > 0 || soap_flag_blessCount1 > 0 || soap_flag_blockCount1 > 0 || soap_flag_createIp1 > 0 || soap_flag_createTime1 > 0 || soap_flag_curseCount1 > 0 || soap_flag_flags1 > 0 || soap_flag_id1 > 0 || soap_flag_language1 > 0 || soap_flag_loginCount1 > 0 || soap_flag_loginIp1 > 0 || soap_flag_loginTime1 > 0 || soap_flag_status1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__user::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__user);
	if (this->soap_out(soap, tag?tag:"tns:user", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__user::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__user(soap, this, tag, type);
}

SOAP_FMAC3 tns__user * SOAP_FMAC4 soap_get_tns__user(struct soap *soap, tns__user *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__user(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__user * SOAP_FMAC2 soap_instantiate_tns__user(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__user(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__user, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__user);
		if (size)
			*size = sizeof(tns__user);
		((tns__user*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__user[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__user);
		for (int i = 0; i < n; i++)
			((tns__user*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__user*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__user(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__user %p -> %p\n", q, p));
	*(tns__user*)p = *(tns__user*)q;
}

void tns__mediaAlias::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->tns__mediaAlias::blessCount);
	soap_default_int(soap, &this->tns__mediaAlias::blockCount);
	soap_default_int(soap, &this->tns__mediaAlias::curseCount);
	soap_default_LONG64(soap, &this->tns__mediaAlias::flags);
	soap_default_LONG64(soap, &this->tns__mediaAlias::id);
	soap_default_int(soap, &this->tns__mediaAlias::language);
	soap_default_int(soap, &this->tns__mediaAlias::status);
	this->tns__mediaAlias::text = NULL;
	soap_default_LONG64(soap, &this->tns__mediaAlias::tokenId);
	soap_default_int(soap, &this->tns__mediaAlias::type);
	soap_default_LONG64(soap, &this->tns__mediaAlias::updateIp);
	soap_default_LONG64(soap, &this->tns__mediaAlias::updateTime);
	soap_default_LONG64(soap, &this->tns__mediaAlias::userId);
	/* transient soap skipped */
}

void tns__mediaAlias::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__mediaAlias::text);
	/* transient soap skipped */
}

int tns__mediaAlias::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__mediaAlias(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__mediaAlias(struct soap *soap, const char *tag, int id, const tns__mediaAlias *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__mediaAlias), type))
		return soap->error;
	if (soap_out_int(soap, "blessCount", -1, &(a->tns__mediaAlias::blessCount), ""))
		return soap->error;
	if (soap_out_int(soap, "blockCount", -1, &(a->tns__mediaAlias::blockCount), ""))
		return soap->error;
	if (soap_out_int(soap, "curseCount", -1, &(a->tns__mediaAlias::curseCount), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "flags", -1, &(a->tns__mediaAlias::flags), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "id", -1, &(a->tns__mediaAlias::id), ""))
		return soap->error;
	if (soap_out_int(soap, "language", -1, &(a->tns__mediaAlias::language), ""))
		return soap->error;
	if (soap_out_int(soap, "status", -1, &(a->tns__mediaAlias::status), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "text", -1, &(a->tns__mediaAlias::text), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "tokenId", -1, &(a->tns__mediaAlias::tokenId), ""))
		return soap->error;
	if (soap_out_int(soap, "type", -1, &(a->tns__mediaAlias::type), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "updateIp", -1, &(a->tns__mediaAlias::updateIp), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "updateTime", -1, &(a->tns__mediaAlias::updateTime), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "userId", -1, &(a->tns__mediaAlias::userId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__mediaAlias::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__mediaAlias(soap, tag, this, type);
}

SOAP_FMAC3 tns__mediaAlias * SOAP_FMAC4 soap_in_tns__mediaAlias(struct soap *soap, const char *tag, tns__mediaAlias *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__mediaAlias *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__mediaAlias, sizeof(tns__mediaAlias), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__mediaAlias)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__mediaAlias *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_blessCount1 = 1;
	size_t soap_flag_blockCount1 = 1;
	size_t soap_flag_curseCount1 = 1;
	size_t soap_flag_flags1 = 1;
	size_t soap_flag_id1 = 1;
	size_t soap_flag_language1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_text1 = 1;
	size_t soap_flag_tokenId1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_updateIp1 = 1;
	size_t soap_flag_updateTime1 = 1;
	size_t soap_flag_userId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_blessCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "blessCount", &(a->tns__mediaAlias::blessCount), "xsd:int"))
				{	soap_flag_blessCount1--;
					continue;
				}
			if (soap_flag_blockCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "blockCount", &(a->tns__mediaAlias::blockCount), "xsd:int"))
				{	soap_flag_blockCount1--;
					continue;
				}
			if (soap_flag_curseCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "curseCount", &(a->tns__mediaAlias::curseCount), "xsd:int"))
				{	soap_flag_curseCount1--;
					continue;
				}
			if (soap_flag_flags1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "flags", &(a->tns__mediaAlias::flags), "xsd:long"))
				{	soap_flag_flags1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "id", &(a->tns__mediaAlias::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_language1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "language", &(a->tns__mediaAlias::language), "xsd:int"))
				{	soap_flag_language1--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "status", &(a->tns__mediaAlias::status), "xsd:int"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_text1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "text", &(a->tns__mediaAlias::text), "xsd:string"))
				{	soap_flag_text1--;
					continue;
				}
			if (soap_flag_tokenId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "tokenId", &(a->tns__mediaAlias::tokenId), "xsd:long"))
				{	soap_flag_tokenId1--;
					continue;
				}
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "type", &(a->tns__mediaAlias::type), "xsd:int"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_updateIp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "updateIp", &(a->tns__mediaAlias::updateIp), "xsd:long"))
				{	soap_flag_updateIp1--;
					continue;
				}
			if (soap_flag_updateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "updateTime", &(a->tns__mediaAlias::updateTime), "xsd:long"))
				{	soap_flag_updateTime1--;
					continue;
				}
			if (soap_flag_userId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "userId", &(a->tns__mediaAlias::userId), "xsd:long"))
				{	soap_flag_userId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__mediaAlias *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__mediaAlias, 0, sizeof(tns__mediaAlias), 0, soap_copy_tns__mediaAlias);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_blessCount1 > 0 || soap_flag_blockCount1 > 0 || soap_flag_curseCount1 > 0 || soap_flag_flags1 > 0 || soap_flag_id1 > 0 || soap_flag_language1 > 0 || soap_flag_status1 > 0 || soap_flag_tokenId1 > 0 || soap_flag_type1 > 0 || soap_flag_updateIp1 > 0 || soap_flag_updateTime1 > 0 || soap_flag_userId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__mediaAlias::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__mediaAlias);
	if (this->soap_out(soap, tag?tag:"tns:mediaAlias", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__mediaAlias::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__mediaAlias(soap, this, tag, type);
}

SOAP_FMAC3 tns__mediaAlias * SOAP_FMAC4 soap_get_tns__mediaAlias(struct soap *soap, tns__mediaAlias *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__mediaAlias(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__mediaAlias * SOAP_FMAC2 soap_instantiate_tns__mediaAlias(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__mediaAlias(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__mediaAlias, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__mediaAlias);
		if (size)
			*size = sizeof(tns__mediaAlias);
		((tns__mediaAlias*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__mediaAlias[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__mediaAlias);
		for (int i = 0; i < n; i++)
			((tns__mediaAlias*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__mediaAlias*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__mediaAlias(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__mediaAlias %p -> %p\n", q, p));
	*(tns__mediaAlias*)p = *(tns__mediaAlias*)q;
}

void tns__mediaToken::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->tns__mediaToken::annotCount);
	soap_default_int(soap, &this->tns__mediaToken::blessCount);
	soap_default_int(soap, &this->tns__mediaToken::blockCount);
	soap_default_LONG64(soap, &this->tns__mediaToken::createIp);
	soap_default_LONG64(soap, &this->tns__mediaToken::createTime);
	soap_default_int(soap, &this->tns__mediaToken::curseCount);
	this->tns__mediaToken::digest = NULL;
	soap_default_LONG64(soap, &this->tns__mediaToken::flags);
	soap_default_LONG64(soap, &this->tns__mediaToken::id);
	soap_default_int(soap, &this->tns__mediaToken::section);
	soap_default_int(soap, &this->tns__mediaToken::status);
	soap_default_int(soap, &this->tns__mediaToken::type);
	this->tns__mediaToken::url = NULL;
	soap_default_LONG64(soap, &this->tns__mediaToken::userId);
	soap_default_int(soap, &this->tns__mediaToken::visitCount);
	/* transient soap skipped */
}

void tns__mediaToken::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__mediaToken::digest);
	soap_serialize_PointerTostd__string(soap, &this->tns__mediaToken::url);
	/* transient soap skipped */
}

int tns__mediaToken::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__mediaToken(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__mediaToken(struct soap *soap, const char *tag, int id, const tns__mediaToken *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__mediaToken), type))
		return soap->error;
	if (soap_out_int(soap, "annotCount", -1, &(a->tns__mediaToken::annotCount), ""))
		return soap->error;
	if (soap_out_int(soap, "blessCount", -1, &(a->tns__mediaToken::blessCount), ""))
		return soap->error;
	if (soap_out_int(soap, "blockCount", -1, &(a->tns__mediaToken::blockCount), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "createIp", -1, &(a->tns__mediaToken::createIp), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "createTime", -1, &(a->tns__mediaToken::createTime), ""))
		return soap->error;
	if (soap_out_int(soap, "curseCount", -1, &(a->tns__mediaToken::curseCount), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "digest", -1, &(a->tns__mediaToken::digest), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "flags", -1, &(a->tns__mediaToken::flags), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "id", -1, &(a->tns__mediaToken::id), ""))
		return soap->error;
	if (soap_out_int(soap, "section", -1, &(a->tns__mediaToken::section), ""))
		return soap->error;
	if (soap_out_int(soap, "status", -1, &(a->tns__mediaToken::status), ""))
		return soap->error;
	if (soap_out_int(soap, "type", -1, &(a->tns__mediaToken::type), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "url", -1, &(a->tns__mediaToken::url), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "userId", -1, &(a->tns__mediaToken::userId), ""))
		return soap->error;
	if (soap_out_int(soap, "visitCount", -1, &(a->tns__mediaToken::visitCount), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__mediaToken::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__mediaToken(soap, tag, this, type);
}

SOAP_FMAC3 tns__mediaToken * SOAP_FMAC4 soap_in_tns__mediaToken(struct soap *soap, const char *tag, tns__mediaToken *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__mediaToken *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__mediaToken, sizeof(tns__mediaToken), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__mediaToken)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__mediaToken *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_annotCount1 = 1;
	size_t soap_flag_blessCount1 = 1;
	size_t soap_flag_blockCount1 = 1;
	size_t soap_flag_createIp1 = 1;
	size_t soap_flag_createTime1 = 1;
	size_t soap_flag_curseCount1 = 1;
	size_t soap_flag_digest1 = 1;
	size_t soap_flag_flags1 = 1;
	size_t soap_flag_id1 = 1;
	size_t soap_flag_section1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_url1 = 1;
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_visitCount1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_annotCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "annotCount", &(a->tns__mediaToken::annotCount), "xsd:int"))
				{	soap_flag_annotCount1--;
					continue;
				}
			if (soap_flag_blessCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "blessCount", &(a->tns__mediaToken::blessCount), "xsd:int"))
				{	soap_flag_blessCount1--;
					continue;
				}
			if (soap_flag_blockCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "blockCount", &(a->tns__mediaToken::blockCount), "xsd:int"))
				{	soap_flag_blockCount1--;
					continue;
				}
			if (soap_flag_createIp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "createIp", &(a->tns__mediaToken::createIp), "xsd:long"))
				{	soap_flag_createIp1--;
					continue;
				}
			if (soap_flag_createTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "createTime", &(a->tns__mediaToken::createTime), "xsd:long"))
				{	soap_flag_createTime1--;
					continue;
				}
			if (soap_flag_curseCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "curseCount", &(a->tns__mediaToken::curseCount), "xsd:int"))
				{	soap_flag_curseCount1--;
					continue;
				}
			if (soap_flag_digest1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "digest", &(a->tns__mediaToken::digest), "xsd:string"))
				{	soap_flag_digest1--;
					continue;
				}
			if (soap_flag_flags1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "flags", &(a->tns__mediaToken::flags), "xsd:long"))
				{	soap_flag_flags1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "id", &(a->tns__mediaToken::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_section1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "section", &(a->tns__mediaToken::section), "xsd:int"))
				{	soap_flag_section1--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "status", &(a->tns__mediaToken::status), "xsd:int"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "type", &(a->tns__mediaToken::type), "xsd:int"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_url1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "url", &(a->tns__mediaToken::url), "xsd:string"))
				{	soap_flag_url1--;
					continue;
				}
			if (soap_flag_userId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "userId", &(a->tns__mediaToken::userId), "xsd:long"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_visitCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "visitCount", &(a->tns__mediaToken::visitCount), "xsd:int"))
				{	soap_flag_visitCount1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__mediaToken *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__mediaToken, 0, sizeof(tns__mediaToken), 0, soap_copy_tns__mediaToken);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_annotCount1 > 0 || soap_flag_blessCount1 > 0 || soap_flag_blockCount1 > 0 || soap_flag_createIp1 > 0 || soap_flag_createTime1 > 0 || soap_flag_curseCount1 > 0 || soap_flag_flags1 > 0 || soap_flag_id1 > 0 || soap_flag_section1 > 0 || soap_flag_status1 > 0 || soap_flag_type1 > 0 || soap_flag_userId1 > 0 || soap_flag_visitCount1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__mediaToken::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__mediaToken);
	if (this->soap_out(soap, tag?tag:"tns:mediaToken", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__mediaToken::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__mediaToken(soap, this, tag, type);
}

SOAP_FMAC3 tns__mediaToken * SOAP_FMAC4 soap_get_tns__mediaToken(struct soap *soap, tns__mediaToken *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__mediaToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__mediaToken * SOAP_FMAC2 soap_instantiate_tns__mediaToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__mediaToken(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__mediaToken, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__mediaToken);
		if (size)
			*size = sizeof(tns__mediaToken);
		((tns__mediaToken*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__mediaToken[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__mediaToken);
		for (int i = 0; i < n; i++)
			((tns__mediaToken*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__mediaToken*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__mediaToken(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__mediaToken %p -> %p\n", q, p));
	*(tns__mediaToken*)p = *(tns__mediaToken*)q;
}

void tns__mediaAnnotation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->tns__mediaAnnotation::blessCount);
	soap_default_int(soap, &this->tns__mediaAnnotation::blockCount);
	soap_default_LONG64(soap, &this->tns__mediaAnnotation::createTime);
	soap_default_LONG64(soap, &this->tns__mediaAnnotation::createIp);
	soap_default_int(soap, &this->tns__mediaAnnotation::curseCount);
	soap_default_LONG64(soap, &this->tns__mediaAnnotation::flags);
	soap_default_LONG64(soap, &this->tns__mediaAnnotation::id);
	soap_default_int(soap, &this->tns__mediaAnnotation::language);
	soap_default_LONG64(soap, &this->tns__mediaAnnotation::pos);
	soap_default_int(soap, &this->tns__mediaAnnotation::posType);
	soap_default_int(soap, &this->tns__mediaAnnotation::time);
	soap_default_int(soap, &this->tns__mediaAnnotation::status);
	this->tns__mediaAnnotation::text = NULL;
	soap_default_LONG64(soap, &this->tns__mediaAnnotation::tokenId);
	soap_default_LONG64(soap, &this->tns__mediaAnnotation::updateIp);
	soap_default_LONG64(soap, &this->tns__mediaAnnotation::updateTime);
	this->tns__mediaAnnotation::userAlias = NULL;
	soap_default_LONG64(soap, &this->tns__mediaAnnotation::userId);
	/* transient soap skipped */
}

void tns__mediaAnnotation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__mediaAnnotation::text);
	soap_serialize_PointerTostd__string(soap, &this->tns__mediaAnnotation::userAlias);
	/* transient soap skipped */
}

int tns__mediaAnnotation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__mediaAnnotation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__mediaAnnotation(struct soap *soap, const char *tag, int id, const tns__mediaAnnotation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__mediaAnnotation), type))
		return soap->error;
	if (soap_out_int(soap, "blessCount", -1, &(a->tns__mediaAnnotation::blessCount), ""))
		return soap->error;
	if (soap_out_int(soap, "blockCount", -1, &(a->tns__mediaAnnotation::blockCount), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "createTime", -1, &(a->tns__mediaAnnotation::createTime), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "createIp", -1, &(a->tns__mediaAnnotation::createIp), ""))
		return soap->error;
	if (soap_out_int(soap, "curseCount", -1, &(a->tns__mediaAnnotation::curseCount), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "flags", -1, &(a->tns__mediaAnnotation::flags), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "id", -1, &(a->tns__mediaAnnotation::id), ""))
		return soap->error;
	if (soap_out_int(soap, "language", -1, &(a->tns__mediaAnnotation::language), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "pos", -1, &(a->tns__mediaAnnotation::pos), ""))
		return soap->error;
	if (soap_out_int(soap, "posType", -1, &(a->tns__mediaAnnotation::posType), ""))
		return soap->error;
	if (soap_out_int(soap, "time", -1, &(a->tns__mediaAnnotation::time), ""))
		return soap->error;
	if (soap_out_int(soap, "status", -1, &(a->tns__mediaAnnotation::status), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "text", -1, &(a->tns__mediaAnnotation::text), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "tokenId", -1, &(a->tns__mediaAnnotation::tokenId), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "updateIp", -1, &(a->tns__mediaAnnotation::updateIp), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "updateTime", -1, &(a->tns__mediaAnnotation::updateTime), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userAlias", -1, &(a->tns__mediaAnnotation::userAlias), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "userId", -1, &(a->tns__mediaAnnotation::userId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__mediaAnnotation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__mediaAnnotation(soap, tag, this, type);
}

SOAP_FMAC3 tns__mediaAnnotation * SOAP_FMAC4 soap_in_tns__mediaAnnotation(struct soap *soap, const char *tag, tns__mediaAnnotation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__mediaAnnotation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__mediaAnnotation, sizeof(tns__mediaAnnotation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__mediaAnnotation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__mediaAnnotation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_blessCount1 = 1;
	size_t soap_flag_blockCount1 = 1;
	size_t soap_flag_createTime1 = 1;
	size_t soap_flag_createIp1 = 1;
	size_t soap_flag_curseCount1 = 1;
	size_t soap_flag_flags1 = 1;
	size_t soap_flag_id1 = 1;
	size_t soap_flag_language1 = 1;
	size_t soap_flag_pos1 = 1;
	size_t soap_flag_posType1 = 1;
	size_t soap_flag_time1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_text1 = 1;
	size_t soap_flag_tokenId1 = 1;
	size_t soap_flag_updateIp1 = 1;
	size_t soap_flag_updateTime1 = 1;
	size_t soap_flag_userAlias1 = 1;
	size_t soap_flag_userId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_blessCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "blessCount", &(a->tns__mediaAnnotation::blessCount), "xsd:int"))
				{	soap_flag_blessCount1--;
					continue;
				}
			if (soap_flag_blockCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "blockCount", &(a->tns__mediaAnnotation::blockCount), "xsd:int"))
				{	soap_flag_blockCount1--;
					continue;
				}
			if (soap_flag_createTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "createTime", &(a->tns__mediaAnnotation::createTime), "xsd:long"))
				{	soap_flag_createTime1--;
					continue;
				}
			if (soap_flag_createIp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "createIp", &(a->tns__mediaAnnotation::createIp), "xsd:long"))
				{	soap_flag_createIp1--;
					continue;
				}
			if (soap_flag_curseCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "curseCount", &(a->tns__mediaAnnotation::curseCount), "xsd:int"))
				{	soap_flag_curseCount1--;
					continue;
				}
			if (soap_flag_flags1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "flags", &(a->tns__mediaAnnotation::flags), "xsd:long"))
				{	soap_flag_flags1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "id", &(a->tns__mediaAnnotation::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_language1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "language", &(a->tns__mediaAnnotation::language), "xsd:int"))
				{	soap_flag_language1--;
					continue;
				}
			if (soap_flag_pos1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "pos", &(a->tns__mediaAnnotation::pos), "xsd:long"))
				{	soap_flag_pos1--;
					continue;
				}
			if (soap_flag_posType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "posType", &(a->tns__mediaAnnotation::posType), "xsd:int"))
				{	soap_flag_posType1--;
					continue;
				}
			if (soap_flag_time1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "time", &(a->tns__mediaAnnotation::time), "xsd:int"))
				{	soap_flag_time1--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "status", &(a->tns__mediaAnnotation::status), "xsd:int"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_text1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "text", &(a->tns__mediaAnnotation::text), "xsd:string"))
				{	soap_flag_text1--;
					continue;
				}
			if (soap_flag_tokenId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "tokenId", &(a->tns__mediaAnnotation::tokenId), "xsd:long"))
				{	soap_flag_tokenId1--;
					continue;
				}
			if (soap_flag_updateIp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "updateIp", &(a->tns__mediaAnnotation::updateIp), "xsd:long"))
				{	soap_flag_updateIp1--;
					continue;
				}
			if (soap_flag_updateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "updateTime", &(a->tns__mediaAnnotation::updateTime), "xsd:long"))
				{	soap_flag_updateTime1--;
					continue;
				}
			if (soap_flag_userAlias1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userAlias", &(a->tns__mediaAnnotation::userAlias), "xsd:string"))
				{	soap_flag_userAlias1--;
					continue;
				}
			if (soap_flag_userId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "userId", &(a->tns__mediaAnnotation::userId), "xsd:long"))
				{	soap_flag_userId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__mediaAnnotation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__mediaAnnotation, 0, sizeof(tns__mediaAnnotation), 0, soap_copy_tns__mediaAnnotation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_blessCount1 > 0 || soap_flag_blockCount1 > 0 || soap_flag_createTime1 > 0 || soap_flag_createIp1 > 0 || soap_flag_curseCount1 > 0 || soap_flag_flags1 > 0 || soap_flag_id1 > 0 || soap_flag_language1 > 0 || soap_flag_pos1 > 0 || soap_flag_posType1 > 0 || soap_flag_time1 > 0 || soap_flag_status1 > 0 || soap_flag_tokenId1 > 0 || soap_flag_updateIp1 > 0 || soap_flag_updateTime1 > 0 || soap_flag_userId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__mediaAnnotation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__mediaAnnotation);
	if (this->soap_out(soap, tag?tag:"tns:mediaAnnotation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__mediaAnnotation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__mediaAnnotation(soap, this, tag, type);
}

SOAP_FMAC3 tns__mediaAnnotation * SOAP_FMAC4 soap_get_tns__mediaAnnotation(struct soap *soap, tns__mediaAnnotation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__mediaAnnotation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__mediaAnnotation * SOAP_FMAC2 soap_instantiate_tns__mediaAnnotation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__mediaAnnotation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__mediaAnnotation, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__mediaAnnotation);
		if (size)
			*size = sizeof(tns__mediaAnnotation);
		((tns__mediaAnnotation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__mediaAnnotation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__mediaAnnotation);
		for (int i = 0; i < n; i++)
			((tns__mediaAnnotation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__mediaAnnotation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__mediaAnnotation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__mediaAnnotation %p -> %p\n", q, p));
	*(tns__mediaAnnotation*)p = *(tns__mediaAnnotation*)q;
}

void tns__gameThread::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->tns__gameThread::encoding);
	soap_default_LONG64(soap, &this->tns__gameThread::flags);
	soap_default_LONG64(soap, &this->tns__gameThread::id);
	this->tns__gameThread::provider = NULL;
	soap_default_LONG64(soap, &this->tns__gameThread::signature);
	soap_default_LONG64(soap, &this->tns__gameThread::tokenId);
	soap_default_int(soap, &this->tns__gameThread::type);
	soap_default_LONG64(soap, &this->tns__gameThread::updateIp);
	soap_default_LONG64(soap, &this->tns__gameThread::updateTime);
	soap_default_LONG64(soap, &this->tns__gameThread::userId);
	/* transient soap skipped */
}

void tns__gameThread::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__gameThread::provider);
	/* transient soap skipped */
}

int tns__gameThread::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__gameThread(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__gameThread(struct soap *soap, const char *tag, int id, const tns__gameThread *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_tns__gameThread), type))
		return soap->error;
	if (soap_out_int(soap, "encoding", -1, &(a->tns__gameThread::encoding), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "flags", -1, &(a->tns__gameThread::flags), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "id", -1, &(a->tns__gameThread::id), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "provider", -1, &(a->tns__gameThread::provider), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "signature", -1, &(a->tns__gameThread::signature), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "tokenId", -1, &(a->tns__gameThread::tokenId), ""))
		return soap->error;
	if (soap_out_int(soap, "type", -1, &(a->tns__gameThread::type), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "updateIp", -1, &(a->tns__gameThread::updateIp), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "updateTime", -1, &(a->tns__gameThread::updateTime), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "userId", -1, &(a->tns__gameThread::userId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__gameThread::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__gameThread(soap, tag, this, type);
}

SOAP_FMAC3 tns__gameThread * SOAP_FMAC4 soap_in_tns__gameThread(struct soap *soap, const char *tag, tns__gameThread *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__gameThread *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_tns__gameThread, sizeof(tns__gameThread), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Annot_tns__gameThread)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__gameThread *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_encoding1 = 1;
	size_t soap_flag_flags1 = 1;
	size_t soap_flag_id1 = 1;
	size_t soap_flag_provider1 = 1;
	size_t soap_flag_signature1 = 1;
	size_t soap_flag_tokenId1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_updateIp1 = 1;
	size_t soap_flag_updateTime1 = 1;
	size_t soap_flag_userId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_encoding1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "encoding", &(a->tns__gameThread::encoding), "xsd:int"))
				{	soap_flag_encoding1--;
					continue;
				}
			if (soap_flag_flags1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "flags", &(a->tns__gameThread::flags), "xsd:long"))
				{	soap_flag_flags1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "id", &(a->tns__gameThread::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_provider1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "provider", &(a->tns__gameThread::provider), "xsd:string"))
				{	soap_flag_provider1--;
					continue;
				}
			if (soap_flag_signature1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "signature", &(a->tns__gameThread::signature), "xsd:long"))
				{	soap_flag_signature1--;
					continue;
				}
			if (soap_flag_tokenId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "tokenId", &(a->tns__gameThread::tokenId), "xsd:long"))
				{	soap_flag_tokenId1--;
					continue;
				}
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "type", &(a->tns__gameThread::type), "xsd:int"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_updateIp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "updateIp", &(a->tns__gameThread::updateIp), "xsd:long"))
				{	soap_flag_updateIp1--;
					continue;
				}
			if (soap_flag_updateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "updateTime", &(a->tns__gameThread::updateTime), "xsd:long"))
				{	soap_flag_updateTime1--;
					continue;
				}
			if (soap_flag_userId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "userId", &(a->tns__gameThread::userId), "xsd:long"))
				{	soap_flag_userId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__gameThread *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_tns__gameThread, 0, sizeof(tns__gameThread), 0, soap_copy_tns__gameThread);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_encoding1 > 0 || soap_flag_flags1 > 0 || soap_flag_id1 > 0 || soap_flag_signature1 > 0 || soap_flag_tokenId1 > 0 || soap_flag_type1 > 0 || soap_flag_updateIp1 > 0 || soap_flag_updateTime1 > 0 || soap_flag_userId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__gameThread::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Annot_tns__gameThread);
	if (this->soap_out(soap, tag?tag:"tns:gameThread", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__gameThread::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__gameThread(soap, this, tag, type);
}

SOAP_FMAC3 tns__gameThread * SOAP_FMAC4 soap_get_tns__gameThread(struct soap *soap, tns__gameThread *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__gameThread(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__gameThread * SOAP_FMAC2 soap_instantiate_tns__gameThread(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__gameThread(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_tns__gameThread, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__gameThread);
		if (size)
			*size = sizeof(tns__gameThread);
		((tns__gameThread*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__gameThread[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__gameThread);
		for (int i = 0; i < n; i++)
			((tns__gameThread*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__gameThread*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__gameThread(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__gameThread %p -> %p\n", q, p));
	*(tns__gameThread*)p = *(tns__gameThread*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_SOAP_ENV__Fault, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_SOAP_ENV__Reason, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_SOAP_ENV__Detail, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_SOAP_ENV__Code, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Annot_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_Annot_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Annot_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_SOAP_ENV__Header, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__updateMediaAnnotationUserIdWithId(struct soap *soap, struct __tns__updateMediaAnnotationUserIdWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__updateMediaAnnotationUserIdWithId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__updateMediaAnnotationUserIdWithId(struct soap *soap, const struct __tns__updateMediaAnnotationUserIdWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__updateMediaAnnotationUserIdWithId(soap, &a->tns__updateMediaAnnotationUserIdWithId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__updateMediaAnnotationUserIdWithId(struct soap *soap, const char *tag, int id, const struct __tns__updateMediaAnnotationUserIdWithId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__updateMediaAnnotationUserIdWithId(soap, "tns:updateMediaAnnotationUserIdWithId", -1, &a->tns__updateMediaAnnotationUserIdWithId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__updateMediaAnnotationUserIdWithId * SOAP_FMAC4 soap_in___tns__updateMediaAnnotationUserIdWithId(struct soap *soap, const char *tag, struct __tns__updateMediaAnnotationUserIdWithId *a, const char *type)
{
	size_t soap_flag_tns__updateMediaAnnotationUserIdWithId_ = 1;
	short soap_flag;
	a = (struct __tns__updateMediaAnnotationUserIdWithId *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__updateMediaAnnotationUserIdWithId, sizeof(struct __tns__updateMediaAnnotationUserIdWithId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__updateMediaAnnotationUserIdWithId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__updateMediaAnnotationUserIdWithId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__updateMediaAnnotationUserIdWithId(soap, "tns:updateMediaAnnotationUserIdWithId", &a->tns__updateMediaAnnotationUserIdWithId_, "tns:updateMediaAnnotationUserIdWithId"))
				{	soap_flag_tns__updateMediaAnnotationUserIdWithId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__updateMediaAnnotationUserIdWithId(struct soap *soap, const struct __tns__updateMediaAnnotationUserIdWithId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__updateMediaAnnotationUserIdWithId(soap, tag?tag:"-tns:updateMediaAnnotationUserIdWithId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__updateMediaAnnotationUserIdWithId * SOAP_FMAC4 soap_get___tns__updateMediaAnnotationUserIdWithId(struct soap *soap, struct __tns__updateMediaAnnotationUserIdWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__updateMediaAnnotationUserIdWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__updateMediaAnnotationUserIdWithId * SOAP_FMAC2 soap_instantiate___tns__updateMediaAnnotationUserIdWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__updateMediaAnnotationUserIdWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__updateMediaAnnotationUserIdWithId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__updateMediaAnnotationUserIdWithId);
		if (size)
			*size = sizeof(struct __tns__updateMediaAnnotationUserIdWithId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__updateMediaAnnotationUserIdWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__updateMediaAnnotationUserIdWithId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__updateMediaAnnotationUserIdWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__updateMediaAnnotationUserIdWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__updateMediaAnnotationUserIdWithId %p -> %p\n", q, p));
	*(struct __tns__updateMediaAnnotationUserIdWithId*)p = *(struct __tns__updateMediaAnnotationUserIdWithId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__updateMediaAnnotationTextWithId(struct soap *soap, struct __tns__updateMediaAnnotationTextWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__updateMediaAnnotationTextWithId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__updateMediaAnnotationTextWithId(struct soap *soap, const struct __tns__updateMediaAnnotationTextWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__updateMediaAnnotationTextWithId(soap, &a->tns__updateMediaAnnotationTextWithId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__updateMediaAnnotationTextWithId(struct soap *soap, const char *tag, int id, const struct __tns__updateMediaAnnotationTextWithId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__updateMediaAnnotationTextWithId(soap, "tns:updateMediaAnnotationTextWithId", -1, &a->tns__updateMediaAnnotationTextWithId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__updateMediaAnnotationTextWithId * SOAP_FMAC4 soap_in___tns__updateMediaAnnotationTextWithId(struct soap *soap, const char *tag, struct __tns__updateMediaAnnotationTextWithId *a, const char *type)
{
	size_t soap_flag_tns__updateMediaAnnotationTextWithId_ = 1;
	short soap_flag;
	a = (struct __tns__updateMediaAnnotationTextWithId *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__updateMediaAnnotationTextWithId, sizeof(struct __tns__updateMediaAnnotationTextWithId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__updateMediaAnnotationTextWithId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__updateMediaAnnotationTextWithId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__updateMediaAnnotationTextWithId(soap, "tns:updateMediaAnnotationTextWithId", &a->tns__updateMediaAnnotationTextWithId_, "tns:updateMediaAnnotationTextWithId"))
				{	soap_flag_tns__updateMediaAnnotationTextWithId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__updateMediaAnnotationTextWithId(struct soap *soap, const struct __tns__updateMediaAnnotationTextWithId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__updateMediaAnnotationTextWithId(soap, tag?tag:"-tns:updateMediaAnnotationTextWithId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__updateMediaAnnotationTextWithId * SOAP_FMAC4 soap_get___tns__updateMediaAnnotationTextWithId(struct soap *soap, struct __tns__updateMediaAnnotationTextWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__updateMediaAnnotationTextWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__updateMediaAnnotationTextWithId * SOAP_FMAC2 soap_instantiate___tns__updateMediaAnnotationTextWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__updateMediaAnnotationTextWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__updateMediaAnnotationTextWithId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__updateMediaAnnotationTextWithId);
		if (size)
			*size = sizeof(struct __tns__updateMediaAnnotationTextWithId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__updateMediaAnnotationTextWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__updateMediaAnnotationTextWithId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__updateMediaAnnotationTextWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__updateMediaAnnotationTextWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__updateMediaAnnotationTextWithId %p -> %p\n", q, p));
	*(struct __tns__updateMediaAnnotationTextWithId*)p = *(struct __tns__updateMediaAnnotationTextWithId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__updateMediaAnnotationLanguageWithId(struct soap *soap, struct __tns__updateMediaAnnotationLanguageWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__updateMediaAnnotationLanguageWithId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__updateMediaAnnotationLanguageWithId(struct soap *soap, const struct __tns__updateMediaAnnotationLanguageWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__updateMediaAnnotationLanguageWithId(soap, &a->tns__updateMediaAnnotationLanguageWithId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__updateMediaAnnotationLanguageWithId(struct soap *soap, const char *tag, int id, const struct __tns__updateMediaAnnotationLanguageWithId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__updateMediaAnnotationLanguageWithId(soap, "tns:updateMediaAnnotationLanguageWithId", -1, &a->tns__updateMediaAnnotationLanguageWithId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__updateMediaAnnotationLanguageWithId * SOAP_FMAC4 soap_in___tns__updateMediaAnnotationLanguageWithId(struct soap *soap, const char *tag, struct __tns__updateMediaAnnotationLanguageWithId *a, const char *type)
{
	size_t soap_flag_tns__updateMediaAnnotationLanguageWithId_ = 1;
	short soap_flag;
	a = (struct __tns__updateMediaAnnotationLanguageWithId *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__updateMediaAnnotationLanguageWithId, sizeof(struct __tns__updateMediaAnnotationLanguageWithId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__updateMediaAnnotationLanguageWithId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__updateMediaAnnotationLanguageWithId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__updateMediaAnnotationLanguageWithId(soap, "tns:updateMediaAnnotationLanguageWithId", &a->tns__updateMediaAnnotationLanguageWithId_, "tns:updateMediaAnnotationLanguageWithId"))
				{	soap_flag_tns__updateMediaAnnotationLanguageWithId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__updateMediaAnnotationLanguageWithId(struct soap *soap, const struct __tns__updateMediaAnnotationLanguageWithId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__updateMediaAnnotationLanguageWithId(soap, tag?tag:"-tns:updateMediaAnnotationLanguageWithId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__updateMediaAnnotationLanguageWithId * SOAP_FMAC4 soap_get___tns__updateMediaAnnotationLanguageWithId(struct soap *soap, struct __tns__updateMediaAnnotationLanguageWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__updateMediaAnnotationLanguageWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__updateMediaAnnotationLanguageWithId * SOAP_FMAC2 soap_instantiate___tns__updateMediaAnnotationLanguageWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__updateMediaAnnotationLanguageWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__updateMediaAnnotationLanguageWithId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__updateMediaAnnotationLanguageWithId);
		if (size)
			*size = sizeof(struct __tns__updateMediaAnnotationLanguageWithId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__updateMediaAnnotationLanguageWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__updateMediaAnnotationLanguageWithId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__updateMediaAnnotationLanguageWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__updateMediaAnnotationLanguageWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__updateMediaAnnotationLanguageWithId %p -> %p\n", q, p));
	*(struct __tns__updateMediaAnnotationLanguageWithId*)p = *(struct __tns__updateMediaAnnotationLanguageWithId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__updateGameThread(struct soap *soap, struct __tns__updateGameThread *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__updateGameThread_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__updateGameThread(struct soap *soap, const struct __tns__updateGameThread *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__updateGameThread(soap, &a->tns__updateGameThread_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__updateGameThread(struct soap *soap, const char *tag, int id, const struct __tns__updateGameThread *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__updateGameThread(soap, "tns:updateGameThread", -1, &a->tns__updateGameThread_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__updateGameThread * SOAP_FMAC4 soap_in___tns__updateGameThread(struct soap *soap, const char *tag, struct __tns__updateGameThread *a, const char *type)
{
	size_t soap_flag_tns__updateGameThread_ = 1;
	short soap_flag;
	a = (struct __tns__updateGameThread *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__updateGameThread, sizeof(struct __tns__updateGameThread), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__updateGameThread(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__updateGameThread_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__updateGameThread(soap, "tns:updateGameThread", &a->tns__updateGameThread_, "tns:updateGameThread"))
				{	soap_flag_tns__updateGameThread_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__updateGameThread(struct soap *soap, const struct __tns__updateGameThread *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__updateGameThread(soap, tag?tag:"-tns:updateGameThread", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__updateGameThread * SOAP_FMAC4 soap_get___tns__updateGameThread(struct soap *soap, struct __tns__updateGameThread *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__updateGameThread(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__updateGameThread * SOAP_FMAC2 soap_instantiate___tns__updateGameThread(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__updateGameThread(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__updateGameThread, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__updateGameThread);
		if (size)
			*size = sizeof(struct __tns__updateGameThread);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__updateGameThread[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__updateGameThread);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__updateGameThread*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__updateGameThread(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__updateGameThread %p -> %p\n", q, p));
	*(struct __tns__updateGameThread*)p = *(struct __tns__updateGameThread*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__submitMediaTokenUrl(struct soap *soap, struct __tns__submitMediaTokenUrl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__submitMediaTokenUrl_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__submitMediaTokenUrl(struct soap *soap, const struct __tns__submitMediaTokenUrl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__submitMediaTokenUrl(soap, &a->tns__submitMediaTokenUrl_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__submitMediaTokenUrl(struct soap *soap, const char *tag, int id, const struct __tns__submitMediaTokenUrl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__submitMediaTokenUrl(soap, "tns:submitMediaTokenUrl", -1, &a->tns__submitMediaTokenUrl_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaTokenUrl * SOAP_FMAC4 soap_in___tns__submitMediaTokenUrl(struct soap *soap, const char *tag, struct __tns__submitMediaTokenUrl *a, const char *type)
{
	size_t soap_flag_tns__submitMediaTokenUrl_ = 1;
	short soap_flag;
	a = (struct __tns__submitMediaTokenUrl *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__submitMediaTokenUrl, sizeof(struct __tns__submitMediaTokenUrl), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__submitMediaTokenUrl(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__submitMediaTokenUrl_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__submitMediaTokenUrl(soap, "tns:submitMediaTokenUrl", &a->tns__submitMediaTokenUrl_, "tns:submitMediaTokenUrl"))
				{	soap_flag_tns__submitMediaTokenUrl_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__submitMediaTokenUrl(struct soap *soap, const struct __tns__submitMediaTokenUrl *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__submitMediaTokenUrl(soap, tag?tag:"-tns:submitMediaTokenUrl", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaTokenUrl * SOAP_FMAC4 soap_get___tns__submitMediaTokenUrl(struct soap *soap, struct __tns__submitMediaTokenUrl *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__submitMediaTokenUrl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__submitMediaTokenUrl * SOAP_FMAC2 soap_instantiate___tns__submitMediaTokenUrl(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__submitMediaTokenUrl(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__submitMediaTokenUrl, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaTokenUrl);
		if (size)
			*size = sizeof(struct __tns__submitMediaTokenUrl);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaTokenUrl[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__submitMediaTokenUrl);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__submitMediaTokenUrl*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__submitMediaTokenUrl(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__submitMediaTokenUrl %p -> %p\n", q, p));
	*(struct __tns__submitMediaTokenUrl*)p = *(struct __tns__submitMediaTokenUrl*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__submitMediaTokenDigest(struct soap *soap, struct __tns__submitMediaTokenDigest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__submitMediaTokenDigest_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__submitMediaTokenDigest(struct soap *soap, const struct __tns__submitMediaTokenDigest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__submitMediaTokenDigest(soap, &a->tns__submitMediaTokenDigest_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__submitMediaTokenDigest(struct soap *soap, const char *tag, int id, const struct __tns__submitMediaTokenDigest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__submitMediaTokenDigest(soap, "tns:submitMediaTokenDigest", -1, &a->tns__submitMediaTokenDigest_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaTokenDigest * SOAP_FMAC4 soap_in___tns__submitMediaTokenDigest(struct soap *soap, const char *tag, struct __tns__submitMediaTokenDigest *a, const char *type)
{
	size_t soap_flag_tns__submitMediaTokenDigest_ = 1;
	short soap_flag;
	a = (struct __tns__submitMediaTokenDigest *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__submitMediaTokenDigest, sizeof(struct __tns__submitMediaTokenDigest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__submitMediaTokenDigest(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__submitMediaTokenDigest_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__submitMediaTokenDigest(soap, "tns:submitMediaTokenDigest", &a->tns__submitMediaTokenDigest_, "tns:submitMediaTokenDigest"))
				{	soap_flag_tns__submitMediaTokenDigest_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__submitMediaTokenDigest(struct soap *soap, const struct __tns__submitMediaTokenDigest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__submitMediaTokenDigest(soap, tag?tag:"-tns:submitMediaTokenDigest", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaTokenDigest * SOAP_FMAC4 soap_get___tns__submitMediaTokenDigest(struct soap *soap, struct __tns__submitMediaTokenDigest *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__submitMediaTokenDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__submitMediaTokenDigest * SOAP_FMAC2 soap_instantiate___tns__submitMediaTokenDigest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__submitMediaTokenDigest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__submitMediaTokenDigest, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaTokenDigest);
		if (size)
			*size = sizeof(struct __tns__submitMediaTokenDigest);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaTokenDigest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__submitMediaTokenDigest);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__submitMediaTokenDigest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__submitMediaTokenDigest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__submitMediaTokenDigest %p -> %p\n", q, p));
	*(struct __tns__submitMediaTokenDigest*)p = *(struct __tns__submitMediaTokenDigest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__submitMediaToken(struct soap *soap, struct __tns__submitMediaToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__submitMediaToken_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__submitMediaToken(struct soap *soap, const struct __tns__submitMediaToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__submitMediaToken(soap, &a->tns__submitMediaToken_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__submitMediaToken(struct soap *soap, const char *tag, int id, const struct __tns__submitMediaToken *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__submitMediaToken(soap, "tns:submitMediaToken", -1, &a->tns__submitMediaToken_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaToken * SOAP_FMAC4 soap_in___tns__submitMediaToken(struct soap *soap, const char *tag, struct __tns__submitMediaToken *a, const char *type)
{
	size_t soap_flag_tns__submitMediaToken_ = 1;
	short soap_flag;
	a = (struct __tns__submitMediaToken *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__submitMediaToken, sizeof(struct __tns__submitMediaToken), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__submitMediaToken(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__submitMediaToken_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__submitMediaToken(soap, "tns:submitMediaToken", &a->tns__submitMediaToken_, "tns:submitMediaToken"))
				{	soap_flag_tns__submitMediaToken_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__submitMediaToken(struct soap *soap, const struct __tns__submitMediaToken *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__submitMediaToken(soap, tag?tag:"-tns:submitMediaToken", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaToken * SOAP_FMAC4 soap_get___tns__submitMediaToken(struct soap *soap, struct __tns__submitMediaToken *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__submitMediaToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__submitMediaToken * SOAP_FMAC2 soap_instantiate___tns__submitMediaToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__submitMediaToken(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__submitMediaToken, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaToken);
		if (size)
			*size = sizeof(struct __tns__submitMediaToken);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaToken[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__submitMediaToken);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__submitMediaToken*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__submitMediaToken(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__submitMediaToken %p -> %p\n", q, p));
	*(struct __tns__submitMediaToken*)p = *(struct __tns__submitMediaToken*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__submitMediaAnnotationTextWithTokenId(struct soap *soap, struct __tns__submitMediaAnnotationTextWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__submitMediaAnnotationTextWithTokenId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__submitMediaAnnotationTextWithTokenId(struct soap *soap, const struct __tns__submitMediaAnnotationTextWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__submitMediaAnnotationTextWithTokenId(soap, &a->tns__submitMediaAnnotationTextWithTokenId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__submitMediaAnnotationTextWithTokenId(struct soap *soap, const char *tag, int id, const struct __tns__submitMediaAnnotationTextWithTokenId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__submitMediaAnnotationTextWithTokenId(soap, "tns:submitMediaAnnotationTextWithTokenId", -1, &a->tns__submitMediaAnnotationTextWithTokenId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaAnnotationTextWithTokenId * SOAP_FMAC4 soap_in___tns__submitMediaAnnotationTextWithTokenId(struct soap *soap, const char *tag, struct __tns__submitMediaAnnotationTextWithTokenId *a, const char *type)
{
	size_t soap_flag_tns__submitMediaAnnotationTextWithTokenId_ = 1;
	short soap_flag;
	a = (struct __tns__submitMediaAnnotationTextWithTokenId *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__submitMediaAnnotationTextWithTokenId, sizeof(struct __tns__submitMediaAnnotationTextWithTokenId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__submitMediaAnnotationTextWithTokenId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__submitMediaAnnotationTextWithTokenId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__submitMediaAnnotationTextWithTokenId(soap, "tns:submitMediaAnnotationTextWithTokenId", &a->tns__submitMediaAnnotationTextWithTokenId_, "tns:submitMediaAnnotationTextWithTokenId"))
				{	soap_flag_tns__submitMediaAnnotationTextWithTokenId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__submitMediaAnnotationTextWithTokenId(struct soap *soap, const struct __tns__submitMediaAnnotationTextWithTokenId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__submitMediaAnnotationTextWithTokenId(soap, tag?tag:"-tns:submitMediaAnnotationTextWithTokenId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaAnnotationTextWithTokenId * SOAP_FMAC4 soap_get___tns__submitMediaAnnotationTextWithTokenId(struct soap *soap, struct __tns__submitMediaAnnotationTextWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__submitMediaAnnotationTextWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__submitMediaAnnotationTextWithTokenId * SOAP_FMAC2 soap_instantiate___tns__submitMediaAnnotationTextWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__submitMediaAnnotationTextWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__submitMediaAnnotationTextWithTokenId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaAnnotationTextWithTokenId);
		if (size)
			*size = sizeof(struct __tns__submitMediaAnnotationTextWithTokenId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaAnnotationTextWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__submitMediaAnnotationTextWithTokenId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__submitMediaAnnotationTextWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__submitMediaAnnotationTextWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__submitMediaAnnotationTextWithTokenId %p -> %p\n", q, p));
	*(struct __tns__submitMediaAnnotationTextWithTokenId*)p = *(struct __tns__submitMediaAnnotationTextWithTokenId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, struct __tns__submitMediaAnnotationTextAndTokenDigest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__submitMediaAnnotationTextAndTokenDigest_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, const struct __tns__submitMediaAnnotationTextAndTokenDigest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__submitMediaAnnotationTextAndTokenDigest(soap, &a->tns__submitMediaAnnotationTextAndTokenDigest_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, const char *tag, int id, const struct __tns__submitMediaAnnotationTextAndTokenDigest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__submitMediaAnnotationTextAndTokenDigest(soap, "tns:submitMediaAnnotationTextAndTokenDigest", -1, &a->tns__submitMediaAnnotationTextAndTokenDigest_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaAnnotationTextAndTokenDigest * SOAP_FMAC4 soap_in___tns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, const char *tag, struct __tns__submitMediaAnnotationTextAndTokenDigest *a, const char *type)
{
	size_t soap_flag_tns__submitMediaAnnotationTextAndTokenDigest_ = 1;
	short soap_flag;
	a = (struct __tns__submitMediaAnnotationTextAndTokenDigest *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__submitMediaAnnotationTextAndTokenDigest, sizeof(struct __tns__submitMediaAnnotationTextAndTokenDigest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__submitMediaAnnotationTextAndTokenDigest(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__submitMediaAnnotationTextAndTokenDigest_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__submitMediaAnnotationTextAndTokenDigest(soap, "tns:submitMediaAnnotationTextAndTokenDigest", &a->tns__submitMediaAnnotationTextAndTokenDigest_, "tns:submitMediaAnnotationTextAndTokenDigest"))
				{	soap_flag_tns__submitMediaAnnotationTextAndTokenDigest_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, const struct __tns__submitMediaAnnotationTextAndTokenDigest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__submitMediaAnnotationTextAndTokenDigest(soap, tag?tag:"-tns:submitMediaAnnotationTextAndTokenDigest", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaAnnotationTextAndTokenDigest * SOAP_FMAC4 soap_get___tns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, struct __tns__submitMediaAnnotationTextAndTokenDigest *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__submitMediaAnnotationTextAndTokenDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__submitMediaAnnotationTextAndTokenDigest * SOAP_FMAC2 soap_instantiate___tns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__submitMediaAnnotationTextAndTokenDigest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__submitMediaAnnotationTextAndTokenDigest, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaAnnotationTextAndTokenDigest);
		if (size)
			*size = sizeof(struct __tns__submitMediaAnnotationTextAndTokenDigest);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaAnnotationTextAndTokenDigest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__submitMediaAnnotationTextAndTokenDigest);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__submitMediaAnnotationTextAndTokenDigest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__submitMediaAnnotationTextAndTokenDigest %p -> %p\n", q, p));
	*(struct __tns__submitMediaAnnotationTextAndTokenDigest*)p = *(struct __tns__submitMediaAnnotationTextAndTokenDigest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__submitMediaAnnotation(struct soap *soap, struct __tns__submitMediaAnnotation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__submitMediaAnnotation_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__submitMediaAnnotation(struct soap *soap, const struct __tns__submitMediaAnnotation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__submitMediaAnnotation(soap, &a->tns__submitMediaAnnotation_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__submitMediaAnnotation(struct soap *soap, const char *tag, int id, const struct __tns__submitMediaAnnotation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__submitMediaAnnotation(soap, "tns:submitMediaAnnotation", -1, &a->tns__submitMediaAnnotation_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaAnnotation * SOAP_FMAC4 soap_in___tns__submitMediaAnnotation(struct soap *soap, const char *tag, struct __tns__submitMediaAnnotation *a, const char *type)
{
	size_t soap_flag_tns__submitMediaAnnotation_ = 1;
	short soap_flag;
	a = (struct __tns__submitMediaAnnotation *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__submitMediaAnnotation, sizeof(struct __tns__submitMediaAnnotation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__submitMediaAnnotation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__submitMediaAnnotation_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__submitMediaAnnotation(soap, "tns:submitMediaAnnotation", &a->tns__submitMediaAnnotation_, "tns:submitMediaAnnotation"))
				{	soap_flag_tns__submitMediaAnnotation_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__submitMediaAnnotation(struct soap *soap, const struct __tns__submitMediaAnnotation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__submitMediaAnnotation(soap, tag?tag:"-tns:submitMediaAnnotation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaAnnotation * SOAP_FMAC4 soap_get___tns__submitMediaAnnotation(struct soap *soap, struct __tns__submitMediaAnnotation *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__submitMediaAnnotation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__submitMediaAnnotation * SOAP_FMAC2 soap_instantiate___tns__submitMediaAnnotation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__submitMediaAnnotation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__submitMediaAnnotation, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaAnnotation);
		if (size)
			*size = sizeof(struct __tns__submitMediaAnnotation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaAnnotation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__submitMediaAnnotation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__submitMediaAnnotation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__submitMediaAnnotation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__submitMediaAnnotation %p -> %p\n", q, p));
	*(struct __tns__submitMediaAnnotation*)p = *(struct __tns__submitMediaAnnotation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__submitMediaAliasTextWithTokenId(struct soap *soap, struct __tns__submitMediaAliasTextWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__submitMediaAliasTextWithTokenId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__submitMediaAliasTextWithTokenId(struct soap *soap, const struct __tns__submitMediaAliasTextWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__submitMediaAliasTextWithTokenId(soap, &a->tns__submitMediaAliasTextWithTokenId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__submitMediaAliasTextWithTokenId(struct soap *soap, const char *tag, int id, const struct __tns__submitMediaAliasTextWithTokenId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__submitMediaAliasTextWithTokenId(soap, "tns:submitMediaAliasTextWithTokenId", -1, &a->tns__submitMediaAliasTextWithTokenId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaAliasTextWithTokenId * SOAP_FMAC4 soap_in___tns__submitMediaAliasTextWithTokenId(struct soap *soap, const char *tag, struct __tns__submitMediaAliasTextWithTokenId *a, const char *type)
{
	size_t soap_flag_tns__submitMediaAliasTextWithTokenId_ = 1;
	short soap_flag;
	a = (struct __tns__submitMediaAliasTextWithTokenId *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__submitMediaAliasTextWithTokenId, sizeof(struct __tns__submitMediaAliasTextWithTokenId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__submitMediaAliasTextWithTokenId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__submitMediaAliasTextWithTokenId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__submitMediaAliasTextWithTokenId(soap, "tns:submitMediaAliasTextWithTokenId", &a->tns__submitMediaAliasTextWithTokenId_, "tns:submitMediaAliasTextWithTokenId"))
				{	soap_flag_tns__submitMediaAliasTextWithTokenId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__submitMediaAliasTextWithTokenId(struct soap *soap, const struct __tns__submitMediaAliasTextWithTokenId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__submitMediaAliasTextWithTokenId(soap, tag?tag:"-tns:submitMediaAliasTextWithTokenId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaAliasTextWithTokenId * SOAP_FMAC4 soap_get___tns__submitMediaAliasTextWithTokenId(struct soap *soap, struct __tns__submitMediaAliasTextWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__submitMediaAliasTextWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__submitMediaAliasTextWithTokenId * SOAP_FMAC2 soap_instantiate___tns__submitMediaAliasTextWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__submitMediaAliasTextWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__submitMediaAliasTextWithTokenId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaAliasTextWithTokenId);
		if (size)
			*size = sizeof(struct __tns__submitMediaAliasTextWithTokenId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaAliasTextWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__submitMediaAliasTextWithTokenId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__submitMediaAliasTextWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__submitMediaAliasTextWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__submitMediaAliasTextWithTokenId %p -> %p\n", q, p));
	*(struct __tns__submitMediaAliasTextWithTokenId*)p = *(struct __tns__submitMediaAliasTextWithTokenId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__submitMediaAliasTextAndTokenDigest(struct soap *soap, struct __tns__submitMediaAliasTextAndTokenDigest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__submitMediaAliasTextAndTokenDigest_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__submitMediaAliasTextAndTokenDigest(struct soap *soap, const struct __tns__submitMediaAliasTextAndTokenDigest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__submitMediaAliasTextAndTokenDigest(soap, &a->tns__submitMediaAliasTextAndTokenDigest_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__submitMediaAliasTextAndTokenDigest(struct soap *soap, const char *tag, int id, const struct __tns__submitMediaAliasTextAndTokenDigest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__submitMediaAliasTextAndTokenDigest(soap, "tns:submitMediaAliasTextAndTokenDigest", -1, &a->tns__submitMediaAliasTextAndTokenDigest_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaAliasTextAndTokenDigest * SOAP_FMAC4 soap_in___tns__submitMediaAliasTextAndTokenDigest(struct soap *soap, const char *tag, struct __tns__submitMediaAliasTextAndTokenDigest *a, const char *type)
{
	size_t soap_flag_tns__submitMediaAliasTextAndTokenDigest_ = 1;
	short soap_flag;
	a = (struct __tns__submitMediaAliasTextAndTokenDigest *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__submitMediaAliasTextAndTokenDigest, sizeof(struct __tns__submitMediaAliasTextAndTokenDigest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__submitMediaAliasTextAndTokenDigest(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__submitMediaAliasTextAndTokenDigest_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__submitMediaAliasTextAndTokenDigest(soap, "tns:submitMediaAliasTextAndTokenDigest", &a->tns__submitMediaAliasTextAndTokenDigest_, "tns:submitMediaAliasTextAndTokenDigest"))
				{	soap_flag_tns__submitMediaAliasTextAndTokenDigest_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__submitMediaAliasTextAndTokenDigest(struct soap *soap, const struct __tns__submitMediaAliasTextAndTokenDigest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__submitMediaAliasTextAndTokenDigest(soap, tag?tag:"-tns:submitMediaAliasTextAndTokenDigest", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaAliasTextAndTokenDigest * SOAP_FMAC4 soap_get___tns__submitMediaAliasTextAndTokenDigest(struct soap *soap, struct __tns__submitMediaAliasTextAndTokenDigest *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__submitMediaAliasTextAndTokenDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__submitMediaAliasTextAndTokenDigest * SOAP_FMAC2 soap_instantiate___tns__submitMediaAliasTextAndTokenDigest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__submitMediaAliasTextAndTokenDigest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__submitMediaAliasTextAndTokenDigest, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaAliasTextAndTokenDigest);
		if (size)
			*size = sizeof(struct __tns__submitMediaAliasTextAndTokenDigest);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaAliasTextAndTokenDigest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__submitMediaAliasTextAndTokenDigest);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__submitMediaAliasTextAndTokenDigest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__submitMediaAliasTextAndTokenDigest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__submitMediaAliasTextAndTokenDigest %p -> %p\n", q, p));
	*(struct __tns__submitMediaAliasTextAndTokenDigest*)p = *(struct __tns__submitMediaAliasTextAndTokenDigest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__submitMediaAlias(struct soap *soap, struct __tns__submitMediaAlias *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__submitMediaAlias_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__submitMediaAlias(struct soap *soap, const struct __tns__submitMediaAlias *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__submitMediaAlias(soap, &a->tns__submitMediaAlias_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__submitMediaAlias(struct soap *soap, const char *tag, int id, const struct __tns__submitMediaAlias *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__submitMediaAlias(soap, "tns:submitMediaAlias", -1, &a->tns__submitMediaAlias_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaAlias * SOAP_FMAC4 soap_in___tns__submitMediaAlias(struct soap *soap, const char *tag, struct __tns__submitMediaAlias *a, const char *type)
{
	size_t soap_flag_tns__submitMediaAlias_ = 1;
	short soap_flag;
	a = (struct __tns__submitMediaAlias *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__submitMediaAlias, sizeof(struct __tns__submitMediaAlias), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__submitMediaAlias(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__submitMediaAlias_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__submitMediaAlias(soap, "tns:submitMediaAlias", &a->tns__submitMediaAlias_, "tns:submitMediaAlias"))
				{	soap_flag_tns__submitMediaAlias_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__submitMediaAlias(struct soap *soap, const struct __tns__submitMediaAlias *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__submitMediaAlias(soap, tag?tag:"-tns:submitMediaAlias", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaAlias * SOAP_FMAC4 soap_get___tns__submitMediaAlias(struct soap *soap, struct __tns__submitMediaAlias *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__submitMediaAlias(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__submitMediaAlias * SOAP_FMAC2 soap_instantiate___tns__submitMediaAlias(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__submitMediaAlias(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__submitMediaAlias, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaAlias);
		if (size)
			*size = sizeof(struct __tns__submitMediaAlias);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaAlias[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__submitMediaAlias);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__submitMediaAlias*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__submitMediaAlias(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__submitMediaAlias %p -> %p\n", q, p));
	*(struct __tns__submitMediaAlias*)p = *(struct __tns__submitMediaAlias*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__submitGameThread(struct soap *soap, struct __tns__submitGameThread *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__submitGameThread_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__submitGameThread(struct soap *soap, const struct __tns__submitGameThread *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__submitGameThread(soap, &a->tns__submitGameThread_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__submitGameThread(struct soap *soap, const char *tag, int id, const struct __tns__submitGameThread *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__submitGameThread(soap, "tns:submitGameThread", -1, &a->tns__submitGameThread_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitGameThread * SOAP_FMAC4 soap_in___tns__submitGameThread(struct soap *soap, const char *tag, struct __tns__submitGameThread *a, const char *type)
{
	size_t soap_flag_tns__submitGameThread_ = 1;
	short soap_flag;
	a = (struct __tns__submitGameThread *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__submitGameThread, sizeof(struct __tns__submitGameThread), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__submitGameThread(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__submitGameThread_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__submitGameThread(soap, "tns:submitGameThread", &a->tns__submitGameThread_, "tns:submitGameThread"))
				{	soap_flag_tns__submitGameThread_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__submitGameThread(struct soap *soap, const struct __tns__submitGameThread *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__submitGameThread(soap, tag?tag:"-tns:submitGameThread", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitGameThread * SOAP_FMAC4 soap_get___tns__submitGameThread(struct soap *soap, struct __tns__submitGameThread *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__submitGameThread(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__submitGameThread * SOAP_FMAC2 soap_instantiate___tns__submitGameThread(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__submitGameThread(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__submitGameThread, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitGameThread);
		if (size)
			*size = sizeof(struct __tns__submitGameThread);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitGameThread[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__submitGameThread);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__submitGameThread*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__submitGameThread(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__submitGameThread %p -> %p\n", q, p));
	*(struct __tns__submitGameThread*)p = *(struct __tns__submitGameThread*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__setUserLanguage(struct soap *soap, struct __tns__setUserLanguage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__setUserLanguage_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__setUserLanguage(struct soap *soap, const struct __tns__setUserLanguage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__setUserLanguage(soap, &a->tns__setUserLanguage_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__setUserLanguage(struct soap *soap, const char *tag, int id, const struct __tns__setUserLanguage *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__setUserLanguage(soap, "tns:setUserLanguage", -1, &a->tns__setUserLanguage_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__setUserLanguage * SOAP_FMAC4 soap_in___tns__setUserLanguage(struct soap *soap, const char *tag, struct __tns__setUserLanguage *a, const char *type)
{
	size_t soap_flag_tns__setUserLanguage_ = 1;
	short soap_flag;
	a = (struct __tns__setUserLanguage *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__setUserLanguage, sizeof(struct __tns__setUserLanguage), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__setUserLanguage(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__setUserLanguage_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__setUserLanguage(soap, "tns:setUserLanguage", &a->tns__setUserLanguage_, "tns:setUserLanguage"))
				{	soap_flag_tns__setUserLanguage_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__setUserLanguage(struct soap *soap, const struct __tns__setUserLanguage *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__setUserLanguage(soap, tag?tag:"-tns:setUserLanguage", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__setUserLanguage * SOAP_FMAC4 soap_get___tns__setUserLanguage(struct soap *soap, struct __tns__setUserLanguage *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__setUserLanguage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__setUserLanguage * SOAP_FMAC2 soap_instantiate___tns__setUserLanguage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__setUserLanguage(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__setUserLanguage, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__setUserLanguage);
		if (size)
			*size = sizeof(struct __tns__setUserLanguage);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__setUserLanguage[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__setUserLanguage);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__setUserLanguage*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__setUserLanguage(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__setUserLanguage %p -> %p\n", q, p));
	*(struct __tns__setUserLanguage*)p = *(struct __tns__setUserLanguage*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__setUserAnonymous(struct soap *soap, struct __tns__setUserAnonymous *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__setUserAnonymous_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__setUserAnonymous(struct soap *soap, const struct __tns__setUserAnonymous *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__setUserAnonymous(soap, &a->tns__setUserAnonymous_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__setUserAnonymous(struct soap *soap, const char *tag, int id, const struct __tns__setUserAnonymous *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__setUserAnonymous(soap, "tns:setUserAnonymous", -1, &a->tns__setUserAnonymous_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__setUserAnonymous * SOAP_FMAC4 soap_in___tns__setUserAnonymous(struct soap *soap, const char *tag, struct __tns__setUserAnonymous *a, const char *type)
{
	size_t soap_flag_tns__setUserAnonymous_ = 1;
	short soap_flag;
	a = (struct __tns__setUserAnonymous *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__setUserAnonymous, sizeof(struct __tns__setUserAnonymous), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__setUserAnonymous(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__setUserAnonymous_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__setUserAnonymous(soap, "tns:setUserAnonymous", &a->tns__setUserAnonymous_, "tns:setUserAnonymous"))
				{	soap_flag_tns__setUserAnonymous_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__setUserAnonymous(struct soap *soap, const struct __tns__setUserAnonymous *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__setUserAnonymous(soap, tag?tag:"-tns:setUserAnonymous", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__setUserAnonymous * SOAP_FMAC4 soap_get___tns__setUserAnonymous(struct soap *soap, struct __tns__setUserAnonymous *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__setUserAnonymous(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__setUserAnonymous * SOAP_FMAC2 soap_instantiate___tns__setUserAnonymous(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__setUserAnonymous(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__setUserAnonymous, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__setUserAnonymous);
		if (size)
			*size = sizeof(struct __tns__setUserAnonymous);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__setUserAnonymous[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__setUserAnonymous);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__setUserAnonymous*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__setUserAnonymous(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__setUserAnonymous %p -> %p\n", q, p));
	*(struct __tns__setUserAnonymous*)p = *(struct __tns__setUserAnonymous*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, struct __tns__selectRelatedMediaAnnotationsWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__selectRelatedMediaAnnotationsWithTokenId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, const struct __tns__selectRelatedMediaAnnotationsWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__selectRelatedMediaAnnotationsWithTokenId(soap, &a->tns__selectRelatedMediaAnnotationsWithTokenId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, const char *tag, int id, const struct __tns__selectRelatedMediaAnnotationsWithTokenId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__selectRelatedMediaAnnotationsWithTokenId(soap, "tns:selectRelatedMediaAnnotationsWithTokenId", -1, &a->tns__selectRelatedMediaAnnotationsWithTokenId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectRelatedMediaAnnotationsWithTokenId * SOAP_FMAC4 soap_in___tns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, const char *tag, struct __tns__selectRelatedMediaAnnotationsWithTokenId *a, const char *type)
{
	size_t soap_flag_tns__selectRelatedMediaAnnotationsWithTokenId_ = 1;
	short soap_flag;
	a = (struct __tns__selectRelatedMediaAnnotationsWithTokenId *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__selectRelatedMediaAnnotationsWithTokenId, sizeof(struct __tns__selectRelatedMediaAnnotationsWithTokenId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__selectRelatedMediaAnnotationsWithTokenId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__selectRelatedMediaAnnotationsWithTokenId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__selectRelatedMediaAnnotationsWithTokenId(soap, "tns:selectRelatedMediaAnnotationsWithTokenId", &a->tns__selectRelatedMediaAnnotationsWithTokenId_, "tns:selectRelatedMediaAnnotationsWithTokenId"))
				{	soap_flag_tns__selectRelatedMediaAnnotationsWithTokenId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, const struct __tns__selectRelatedMediaAnnotationsWithTokenId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__selectRelatedMediaAnnotationsWithTokenId(soap, tag?tag:"-tns:selectRelatedMediaAnnotationsWithTokenId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectRelatedMediaAnnotationsWithTokenId * SOAP_FMAC4 soap_get___tns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, struct __tns__selectRelatedMediaAnnotationsWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__selectRelatedMediaAnnotationsWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__selectRelatedMediaAnnotationsWithTokenId * SOAP_FMAC2 soap_instantiate___tns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__selectRelatedMediaAnnotationsWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__selectRelatedMediaAnnotationsWithTokenId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectRelatedMediaAnnotationsWithTokenId);
		if (size)
			*size = sizeof(struct __tns__selectRelatedMediaAnnotationsWithTokenId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectRelatedMediaAnnotationsWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__selectRelatedMediaAnnotationsWithTokenId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__selectRelatedMediaAnnotationsWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__selectRelatedMediaAnnotationsWithTokenId %p -> %p\n", q, p));
	*(struct __tns__selectRelatedMediaAnnotationsWithTokenId*)p = *(struct __tns__selectRelatedMediaAnnotationsWithTokenId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__selectRelatedMediaAliasesWithTokenId(struct soap *soap, struct __tns__selectRelatedMediaAliasesWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__selectRelatedMediaAliasesWithTokenId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__selectRelatedMediaAliasesWithTokenId(struct soap *soap, const struct __tns__selectRelatedMediaAliasesWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__selectRelatedMediaAliasesWithTokenId(soap, &a->tns__selectRelatedMediaAliasesWithTokenId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__selectRelatedMediaAliasesWithTokenId(struct soap *soap, const char *tag, int id, const struct __tns__selectRelatedMediaAliasesWithTokenId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__selectRelatedMediaAliasesWithTokenId(soap, "tns:selectRelatedMediaAliasesWithTokenId", -1, &a->tns__selectRelatedMediaAliasesWithTokenId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectRelatedMediaAliasesWithTokenId * SOAP_FMAC4 soap_in___tns__selectRelatedMediaAliasesWithTokenId(struct soap *soap, const char *tag, struct __tns__selectRelatedMediaAliasesWithTokenId *a, const char *type)
{
	size_t soap_flag_tns__selectRelatedMediaAliasesWithTokenId_ = 1;
	short soap_flag;
	a = (struct __tns__selectRelatedMediaAliasesWithTokenId *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__selectRelatedMediaAliasesWithTokenId, sizeof(struct __tns__selectRelatedMediaAliasesWithTokenId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__selectRelatedMediaAliasesWithTokenId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__selectRelatedMediaAliasesWithTokenId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__selectRelatedMediaAliasesWithTokenId(soap, "tns:selectRelatedMediaAliasesWithTokenId", &a->tns__selectRelatedMediaAliasesWithTokenId_, "tns:selectRelatedMediaAliasesWithTokenId"))
				{	soap_flag_tns__selectRelatedMediaAliasesWithTokenId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__selectRelatedMediaAliasesWithTokenId(struct soap *soap, const struct __tns__selectRelatedMediaAliasesWithTokenId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__selectRelatedMediaAliasesWithTokenId(soap, tag?tag:"-tns:selectRelatedMediaAliasesWithTokenId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectRelatedMediaAliasesWithTokenId * SOAP_FMAC4 soap_get___tns__selectRelatedMediaAliasesWithTokenId(struct soap *soap, struct __tns__selectRelatedMediaAliasesWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__selectRelatedMediaAliasesWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__selectRelatedMediaAliasesWithTokenId * SOAP_FMAC2 soap_instantiate___tns__selectRelatedMediaAliasesWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__selectRelatedMediaAliasesWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__selectRelatedMediaAliasesWithTokenId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectRelatedMediaAliasesWithTokenId);
		if (size)
			*size = sizeof(struct __tns__selectRelatedMediaAliasesWithTokenId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectRelatedMediaAliasesWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__selectRelatedMediaAliasesWithTokenId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__selectRelatedMediaAliasesWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__selectRelatedMediaAliasesWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__selectRelatedMediaAliasesWithTokenId %p -> %p\n", q, p));
	*(struct __tns__selectRelatedMediaAliasesWithTokenId*)p = *(struct __tns__selectRelatedMediaAliasesWithTokenId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__selectMediaTokenWithId(struct soap *soap, struct __tns__selectMediaTokenWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__selectMediaTokenWithId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__selectMediaTokenWithId(struct soap *soap, const struct __tns__selectMediaTokenWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__selectMediaTokenWithId(soap, &a->tns__selectMediaTokenWithId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__selectMediaTokenWithId(struct soap *soap, const char *tag, int id, const struct __tns__selectMediaTokenWithId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__selectMediaTokenWithId(soap, "tns:selectMediaTokenWithId", -1, &a->tns__selectMediaTokenWithId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectMediaTokenWithId * SOAP_FMAC4 soap_in___tns__selectMediaTokenWithId(struct soap *soap, const char *tag, struct __tns__selectMediaTokenWithId *a, const char *type)
{
	size_t soap_flag_tns__selectMediaTokenWithId_ = 1;
	short soap_flag;
	a = (struct __tns__selectMediaTokenWithId *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__selectMediaTokenWithId, sizeof(struct __tns__selectMediaTokenWithId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__selectMediaTokenWithId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__selectMediaTokenWithId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__selectMediaTokenWithId(soap, "tns:selectMediaTokenWithId", &a->tns__selectMediaTokenWithId_, "tns:selectMediaTokenWithId"))
				{	soap_flag_tns__selectMediaTokenWithId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__selectMediaTokenWithId(struct soap *soap, const struct __tns__selectMediaTokenWithId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__selectMediaTokenWithId(soap, tag?tag:"-tns:selectMediaTokenWithId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectMediaTokenWithId * SOAP_FMAC4 soap_get___tns__selectMediaTokenWithId(struct soap *soap, struct __tns__selectMediaTokenWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__selectMediaTokenWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__selectMediaTokenWithId * SOAP_FMAC2 soap_instantiate___tns__selectMediaTokenWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__selectMediaTokenWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__selectMediaTokenWithId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectMediaTokenWithId);
		if (size)
			*size = sizeof(struct __tns__selectMediaTokenWithId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectMediaTokenWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__selectMediaTokenWithId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__selectMediaTokenWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__selectMediaTokenWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__selectMediaTokenWithId %p -> %p\n", q, p));
	*(struct __tns__selectMediaTokenWithId*)p = *(struct __tns__selectMediaTokenWithId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__selectMediaTokenWithDigest(struct soap *soap, struct __tns__selectMediaTokenWithDigest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__selectMediaTokenWithDigest_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__selectMediaTokenWithDigest(struct soap *soap, const struct __tns__selectMediaTokenWithDigest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__selectMediaTokenWithDigest(soap, &a->tns__selectMediaTokenWithDigest_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__selectMediaTokenWithDigest(struct soap *soap, const char *tag, int id, const struct __tns__selectMediaTokenWithDigest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__selectMediaTokenWithDigest(soap, "tns:selectMediaTokenWithDigest", -1, &a->tns__selectMediaTokenWithDigest_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectMediaTokenWithDigest * SOAP_FMAC4 soap_in___tns__selectMediaTokenWithDigest(struct soap *soap, const char *tag, struct __tns__selectMediaTokenWithDigest *a, const char *type)
{
	size_t soap_flag_tns__selectMediaTokenWithDigest_ = 1;
	short soap_flag;
	a = (struct __tns__selectMediaTokenWithDigest *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__selectMediaTokenWithDigest, sizeof(struct __tns__selectMediaTokenWithDigest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__selectMediaTokenWithDigest(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__selectMediaTokenWithDigest_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__selectMediaTokenWithDigest(soap, "tns:selectMediaTokenWithDigest", &a->tns__selectMediaTokenWithDigest_, "tns:selectMediaTokenWithDigest"))
				{	soap_flag_tns__selectMediaTokenWithDigest_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__selectMediaTokenWithDigest(struct soap *soap, const struct __tns__selectMediaTokenWithDigest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__selectMediaTokenWithDigest(soap, tag?tag:"-tns:selectMediaTokenWithDigest", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectMediaTokenWithDigest * SOAP_FMAC4 soap_get___tns__selectMediaTokenWithDigest(struct soap *soap, struct __tns__selectMediaTokenWithDigest *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__selectMediaTokenWithDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__selectMediaTokenWithDigest * SOAP_FMAC2 soap_instantiate___tns__selectMediaTokenWithDigest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__selectMediaTokenWithDigest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__selectMediaTokenWithDigest, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectMediaTokenWithDigest);
		if (size)
			*size = sizeof(struct __tns__selectMediaTokenWithDigest);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectMediaTokenWithDigest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__selectMediaTokenWithDigest);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__selectMediaTokenWithDigest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__selectMediaTokenWithDigest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__selectMediaTokenWithDigest %p -> %p\n", q, p));
	*(struct __tns__selectMediaTokenWithDigest*)p = *(struct __tns__selectMediaTokenWithDigest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__selectMediaTokenIdWithUrl(struct soap *soap, struct __tns__selectMediaTokenIdWithUrl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__selectMediaTokenIdWithUrl_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__selectMediaTokenIdWithUrl(struct soap *soap, const struct __tns__selectMediaTokenIdWithUrl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__selectMediaTokenIdWithUrl(soap, &a->tns__selectMediaTokenIdWithUrl_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__selectMediaTokenIdWithUrl(struct soap *soap, const char *tag, int id, const struct __tns__selectMediaTokenIdWithUrl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__selectMediaTokenIdWithUrl(soap, "tns:selectMediaTokenIdWithUrl", -1, &a->tns__selectMediaTokenIdWithUrl_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectMediaTokenIdWithUrl * SOAP_FMAC4 soap_in___tns__selectMediaTokenIdWithUrl(struct soap *soap, const char *tag, struct __tns__selectMediaTokenIdWithUrl *a, const char *type)
{
	size_t soap_flag_tns__selectMediaTokenIdWithUrl_ = 1;
	short soap_flag;
	a = (struct __tns__selectMediaTokenIdWithUrl *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__selectMediaTokenIdWithUrl, sizeof(struct __tns__selectMediaTokenIdWithUrl), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__selectMediaTokenIdWithUrl(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__selectMediaTokenIdWithUrl_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__selectMediaTokenIdWithUrl(soap, "tns:selectMediaTokenIdWithUrl", &a->tns__selectMediaTokenIdWithUrl_, "tns:selectMediaTokenIdWithUrl"))
				{	soap_flag_tns__selectMediaTokenIdWithUrl_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__selectMediaTokenIdWithUrl(struct soap *soap, const struct __tns__selectMediaTokenIdWithUrl *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__selectMediaTokenIdWithUrl(soap, tag?tag:"-tns:selectMediaTokenIdWithUrl", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectMediaTokenIdWithUrl * SOAP_FMAC4 soap_get___tns__selectMediaTokenIdWithUrl(struct soap *soap, struct __tns__selectMediaTokenIdWithUrl *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__selectMediaTokenIdWithUrl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__selectMediaTokenIdWithUrl * SOAP_FMAC2 soap_instantiate___tns__selectMediaTokenIdWithUrl(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__selectMediaTokenIdWithUrl(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__selectMediaTokenIdWithUrl, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectMediaTokenIdWithUrl);
		if (size)
			*size = sizeof(struct __tns__selectMediaTokenIdWithUrl);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectMediaTokenIdWithUrl[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__selectMediaTokenIdWithUrl);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__selectMediaTokenIdWithUrl*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__selectMediaTokenIdWithUrl(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__selectMediaTokenIdWithUrl %p -> %p\n", q, p));
	*(struct __tns__selectMediaTokenIdWithUrl*)p = *(struct __tns__selectMediaTokenIdWithUrl*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__selectMediaTokenIdWithDigest(struct soap *soap, struct __tns__selectMediaTokenIdWithDigest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__selectMediaTokenIdWithDigest_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__selectMediaTokenIdWithDigest(struct soap *soap, const struct __tns__selectMediaTokenIdWithDigest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__selectMediaTokenIdWithDigest(soap, &a->tns__selectMediaTokenIdWithDigest_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__selectMediaTokenIdWithDigest(struct soap *soap, const char *tag, int id, const struct __tns__selectMediaTokenIdWithDigest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__selectMediaTokenIdWithDigest(soap, "tns:selectMediaTokenIdWithDigest", -1, &a->tns__selectMediaTokenIdWithDigest_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectMediaTokenIdWithDigest * SOAP_FMAC4 soap_in___tns__selectMediaTokenIdWithDigest(struct soap *soap, const char *tag, struct __tns__selectMediaTokenIdWithDigest *a, const char *type)
{
	size_t soap_flag_tns__selectMediaTokenIdWithDigest_ = 1;
	short soap_flag;
	a = (struct __tns__selectMediaTokenIdWithDigest *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__selectMediaTokenIdWithDigest, sizeof(struct __tns__selectMediaTokenIdWithDigest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__selectMediaTokenIdWithDigest(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__selectMediaTokenIdWithDigest_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__selectMediaTokenIdWithDigest(soap, "tns:selectMediaTokenIdWithDigest", &a->tns__selectMediaTokenIdWithDigest_, "tns:selectMediaTokenIdWithDigest"))
				{	soap_flag_tns__selectMediaTokenIdWithDigest_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__selectMediaTokenIdWithDigest(struct soap *soap, const struct __tns__selectMediaTokenIdWithDigest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__selectMediaTokenIdWithDigest(soap, tag?tag:"-tns:selectMediaTokenIdWithDigest", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectMediaTokenIdWithDigest * SOAP_FMAC4 soap_get___tns__selectMediaTokenIdWithDigest(struct soap *soap, struct __tns__selectMediaTokenIdWithDigest *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__selectMediaTokenIdWithDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__selectMediaTokenIdWithDigest * SOAP_FMAC2 soap_instantiate___tns__selectMediaTokenIdWithDigest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__selectMediaTokenIdWithDigest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__selectMediaTokenIdWithDigest, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectMediaTokenIdWithDigest);
		if (size)
			*size = sizeof(struct __tns__selectMediaTokenIdWithDigest);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectMediaTokenIdWithDigest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__selectMediaTokenIdWithDigest);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__selectMediaTokenIdWithDigest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__selectMediaTokenIdWithDigest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__selectMediaTokenIdWithDigest %p -> %p\n", q, p));
	*(struct __tns__selectMediaTokenIdWithDigest*)p = *(struct __tns__selectMediaTokenIdWithDigest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__selectMediaAnnotationsWithTokenId(struct soap *soap, struct __tns__selectMediaAnnotationsWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__selectMediaAnnotationsWithTokenId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__selectMediaAnnotationsWithTokenId(struct soap *soap, const struct __tns__selectMediaAnnotationsWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__selectMediaAnnotationsWithTokenId(soap, &a->tns__selectMediaAnnotationsWithTokenId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__selectMediaAnnotationsWithTokenId(struct soap *soap, const char *tag, int id, const struct __tns__selectMediaAnnotationsWithTokenId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__selectMediaAnnotationsWithTokenId(soap, "tns:selectMediaAnnotationsWithTokenId", -1, &a->tns__selectMediaAnnotationsWithTokenId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectMediaAnnotationsWithTokenId * SOAP_FMAC4 soap_in___tns__selectMediaAnnotationsWithTokenId(struct soap *soap, const char *tag, struct __tns__selectMediaAnnotationsWithTokenId *a, const char *type)
{
	size_t soap_flag_tns__selectMediaAnnotationsWithTokenId_ = 1;
	short soap_flag;
	a = (struct __tns__selectMediaAnnotationsWithTokenId *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__selectMediaAnnotationsWithTokenId, sizeof(struct __tns__selectMediaAnnotationsWithTokenId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__selectMediaAnnotationsWithTokenId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__selectMediaAnnotationsWithTokenId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__selectMediaAnnotationsWithTokenId(soap, "tns:selectMediaAnnotationsWithTokenId", &a->tns__selectMediaAnnotationsWithTokenId_, "tns:selectMediaAnnotationsWithTokenId"))
				{	soap_flag_tns__selectMediaAnnotationsWithTokenId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__selectMediaAnnotationsWithTokenId(struct soap *soap, const struct __tns__selectMediaAnnotationsWithTokenId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__selectMediaAnnotationsWithTokenId(soap, tag?tag:"-tns:selectMediaAnnotationsWithTokenId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectMediaAnnotationsWithTokenId * SOAP_FMAC4 soap_get___tns__selectMediaAnnotationsWithTokenId(struct soap *soap, struct __tns__selectMediaAnnotationsWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__selectMediaAnnotationsWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__selectMediaAnnotationsWithTokenId * SOAP_FMAC2 soap_instantiate___tns__selectMediaAnnotationsWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__selectMediaAnnotationsWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__selectMediaAnnotationsWithTokenId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectMediaAnnotationsWithTokenId);
		if (size)
			*size = sizeof(struct __tns__selectMediaAnnotationsWithTokenId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectMediaAnnotationsWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__selectMediaAnnotationsWithTokenId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__selectMediaAnnotationsWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__selectMediaAnnotationsWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__selectMediaAnnotationsWithTokenId %p -> %p\n", q, p));
	*(struct __tns__selectMediaAnnotationsWithTokenId*)p = *(struct __tns__selectMediaAnnotationsWithTokenId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__selectMediaAliasesWithTokenId(struct soap *soap, struct __tns__selectMediaAliasesWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__selectMediaAliasesWithTokenId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__selectMediaAliasesWithTokenId(struct soap *soap, const struct __tns__selectMediaAliasesWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__selectMediaAliasesWithTokenId(soap, &a->tns__selectMediaAliasesWithTokenId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__selectMediaAliasesWithTokenId(struct soap *soap, const char *tag, int id, const struct __tns__selectMediaAliasesWithTokenId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__selectMediaAliasesWithTokenId(soap, "tns:selectMediaAliasesWithTokenId", -1, &a->tns__selectMediaAliasesWithTokenId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectMediaAliasesWithTokenId * SOAP_FMAC4 soap_in___tns__selectMediaAliasesWithTokenId(struct soap *soap, const char *tag, struct __tns__selectMediaAliasesWithTokenId *a, const char *type)
{
	size_t soap_flag_tns__selectMediaAliasesWithTokenId_ = 1;
	short soap_flag;
	a = (struct __tns__selectMediaAliasesWithTokenId *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__selectMediaAliasesWithTokenId, sizeof(struct __tns__selectMediaAliasesWithTokenId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__selectMediaAliasesWithTokenId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__selectMediaAliasesWithTokenId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__selectMediaAliasesWithTokenId(soap, "tns:selectMediaAliasesWithTokenId", &a->tns__selectMediaAliasesWithTokenId_, "tns:selectMediaAliasesWithTokenId"))
				{	soap_flag_tns__selectMediaAliasesWithTokenId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__selectMediaAliasesWithTokenId(struct soap *soap, const struct __tns__selectMediaAliasesWithTokenId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__selectMediaAliasesWithTokenId(soap, tag?tag:"-tns:selectMediaAliasesWithTokenId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectMediaAliasesWithTokenId * SOAP_FMAC4 soap_get___tns__selectMediaAliasesWithTokenId(struct soap *soap, struct __tns__selectMediaAliasesWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__selectMediaAliasesWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__selectMediaAliasesWithTokenId * SOAP_FMAC2 soap_instantiate___tns__selectMediaAliasesWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__selectMediaAliasesWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__selectMediaAliasesWithTokenId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectMediaAliasesWithTokenId);
		if (size)
			*size = sizeof(struct __tns__selectMediaAliasesWithTokenId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectMediaAliasesWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__selectMediaAliasesWithTokenId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__selectMediaAliasesWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__selectMediaAliasesWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__selectMediaAliasesWithTokenId %p -> %p\n", q, p));
	*(struct __tns__selectMediaAliasesWithTokenId*)p = *(struct __tns__selectMediaAliasesWithTokenId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__selectGameThreadWithTokenId(struct soap *soap, struct __tns__selectGameThreadWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__selectGameThreadWithTokenId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__selectGameThreadWithTokenId(struct soap *soap, const struct __tns__selectGameThreadWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__selectGameThreadWithTokenId(soap, &a->tns__selectGameThreadWithTokenId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__selectGameThreadWithTokenId(struct soap *soap, const char *tag, int id, const struct __tns__selectGameThreadWithTokenId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__selectGameThreadWithTokenId(soap, "tns:selectGameThreadWithTokenId", -1, &a->tns__selectGameThreadWithTokenId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectGameThreadWithTokenId * SOAP_FMAC4 soap_in___tns__selectGameThreadWithTokenId(struct soap *soap, const char *tag, struct __tns__selectGameThreadWithTokenId *a, const char *type)
{
	size_t soap_flag_tns__selectGameThreadWithTokenId_ = 1;
	short soap_flag;
	a = (struct __tns__selectGameThreadWithTokenId *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__selectGameThreadWithTokenId, sizeof(struct __tns__selectGameThreadWithTokenId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__selectGameThreadWithTokenId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__selectGameThreadWithTokenId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__selectGameThreadWithTokenId(soap, "tns:selectGameThreadWithTokenId", &a->tns__selectGameThreadWithTokenId_, "tns:selectGameThreadWithTokenId"))
				{	soap_flag_tns__selectGameThreadWithTokenId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__selectGameThreadWithTokenId(struct soap *soap, const struct __tns__selectGameThreadWithTokenId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__selectGameThreadWithTokenId(soap, tag?tag:"-tns:selectGameThreadWithTokenId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectGameThreadWithTokenId * SOAP_FMAC4 soap_get___tns__selectGameThreadWithTokenId(struct soap *soap, struct __tns__selectGameThreadWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__selectGameThreadWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__selectGameThreadWithTokenId * SOAP_FMAC2 soap_instantiate___tns__selectGameThreadWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__selectGameThreadWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__selectGameThreadWithTokenId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectGameThreadWithTokenId);
		if (size)
			*size = sizeof(struct __tns__selectGameThreadWithTokenId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectGameThreadWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__selectGameThreadWithTokenId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__selectGameThreadWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__selectGameThreadWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__selectGameThreadWithTokenId %p -> %p\n", q, p));
	*(struct __tns__selectGameThreadWithTokenId*)p = *(struct __tns__selectGameThreadWithTokenId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__selectGameThreadWithTokenDigest(struct soap *soap, struct __tns__selectGameThreadWithTokenDigest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__selectGameThreadWithTokenDigest_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__selectGameThreadWithTokenDigest(struct soap *soap, const struct __tns__selectGameThreadWithTokenDigest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__selectGameThreadWithTokenDigest(soap, &a->tns__selectGameThreadWithTokenDigest_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__selectGameThreadWithTokenDigest(struct soap *soap, const char *tag, int id, const struct __tns__selectGameThreadWithTokenDigest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__selectGameThreadWithTokenDigest(soap, "tns:selectGameThreadWithTokenDigest", -1, &a->tns__selectGameThreadWithTokenDigest_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectGameThreadWithTokenDigest * SOAP_FMAC4 soap_in___tns__selectGameThreadWithTokenDigest(struct soap *soap, const char *tag, struct __tns__selectGameThreadWithTokenDigest *a, const char *type)
{
	size_t soap_flag_tns__selectGameThreadWithTokenDigest_ = 1;
	short soap_flag;
	a = (struct __tns__selectGameThreadWithTokenDigest *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__selectGameThreadWithTokenDigest, sizeof(struct __tns__selectGameThreadWithTokenDigest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__selectGameThreadWithTokenDigest(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__selectGameThreadWithTokenDigest_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__selectGameThreadWithTokenDigest(soap, "tns:selectGameThreadWithTokenDigest", &a->tns__selectGameThreadWithTokenDigest_, "tns:selectGameThreadWithTokenDigest"))
				{	soap_flag_tns__selectGameThreadWithTokenDigest_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__selectGameThreadWithTokenDigest(struct soap *soap, const struct __tns__selectGameThreadWithTokenDigest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__selectGameThreadWithTokenDigest(soap, tag?tag:"-tns:selectGameThreadWithTokenDigest", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectGameThreadWithTokenDigest * SOAP_FMAC4 soap_get___tns__selectGameThreadWithTokenDigest(struct soap *soap, struct __tns__selectGameThreadWithTokenDigest *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__selectGameThreadWithTokenDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__selectGameThreadWithTokenDigest * SOAP_FMAC2 soap_instantiate___tns__selectGameThreadWithTokenDigest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__selectGameThreadWithTokenDigest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__selectGameThreadWithTokenDigest, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectGameThreadWithTokenDigest);
		if (size)
			*size = sizeof(struct __tns__selectGameThreadWithTokenDigest);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectGameThreadWithTokenDigest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__selectGameThreadWithTokenDigest);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__selectGameThreadWithTokenDigest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__selectGameThreadWithTokenDigest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__selectGameThreadWithTokenDigest %p -> %p\n", q, p));
	*(struct __tns__selectGameThreadWithTokenDigest*)p = *(struct __tns__selectGameThreadWithTokenDigest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__login(struct soap *soap, struct __tns__login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__login_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__login(struct soap *soap, const struct __tns__login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__login(soap, &a->tns__login_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__login(struct soap *soap, const char *tag, int id, const struct __tns__login *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__login(soap, "tns:login", -1, &a->tns__login_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__login * SOAP_FMAC4 soap_in___tns__login(struct soap *soap, const char *tag, struct __tns__login *a, const char *type)
{
	size_t soap_flag_tns__login_ = 1;
	short soap_flag;
	a = (struct __tns__login *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__login, sizeof(struct __tns__login), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__login(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__login_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__login(soap, "tns:login", &a->tns__login_, "tns:login"))
				{	soap_flag_tns__login_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__login(struct soap *soap, const struct __tns__login *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__login(soap, tag?tag:"-tns:login", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__login * SOAP_FMAC4 soap_get___tns__login(struct soap *soap, struct __tns__login *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__login * SOAP_FMAC2 soap_instantiate___tns__login(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__login(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__login, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__login);
		if (size)
			*size = sizeof(struct __tns__login);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__login[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__login);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__login*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__login(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__login %p -> %p\n", q, p));
	*(struct __tns__login*)p = *(struct __tns__login*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__isLatestApp(struct soap *soap, struct __tns__isLatestApp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__isLatestApp_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__isLatestApp(struct soap *soap, const struct __tns__isLatestApp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__isLatestApp(soap, &a->tns__isLatestApp_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__isLatestApp(struct soap *soap, const char *tag, int id, const struct __tns__isLatestApp *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__isLatestApp(soap, "tns:isLatestApp", -1, &a->tns__isLatestApp_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__isLatestApp * SOAP_FMAC4 soap_in___tns__isLatestApp(struct soap *soap, const char *tag, struct __tns__isLatestApp *a, const char *type)
{
	size_t soap_flag_tns__isLatestApp_ = 1;
	short soap_flag;
	a = (struct __tns__isLatestApp *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__isLatestApp, sizeof(struct __tns__isLatestApp), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__isLatestApp(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__isLatestApp_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__isLatestApp(soap, "tns:isLatestApp", &a->tns__isLatestApp_, "tns:isLatestApp"))
				{	soap_flag_tns__isLatestApp_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__isLatestApp(struct soap *soap, const struct __tns__isLatestApp *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__isLatestApp(soap, tag?tag:"-tns:isLatestApp", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__isLatestApp * SOAP_FMAC4 soap_get___tns__isLatestApp(struct soap *soap, struct __tns__isLatestApp *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__isLatestApp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__isLatestApp * SOAP_FMAC2 soap_instantiate___tns__isLatestApp(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__isLatestApp(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__isLatestApp, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__isLatestApp);
		if (size)
			*size = sizeof(struct __tns__isLatestApp);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__isLatestApp[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__isLatestApp);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__isLatestApp*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__isLatestApp(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__isLatestApp %p -> %p\n", q, p));
	*(struct __tns__isLatestApp*)p = *(struct __tns__isLatestApp*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__isConnected(struct soap *soap, struct __tns__isConnected *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__isConnected_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__isConnected(struct soap *soap, const struct __tns__isConnected *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__isConnected(soap, &a->tns__isConnected_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__isConnected(struct soap *soap, const char *tag, int id, const struct __tns__isConnected *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__isConnected(soap, "tns:isConnected", -1, &a->tns__isConnected_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__isConnected * SOAP_FMAC4 soap_in___tns__isConnected(struct soap *soap, const char *tag, struct __tns__isConnected *a, const char *type)
{
	size_t soap_flag_tns__isConnected_ = 1;
	short soap_flag;
	a = (struct __tns__isConnected *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__isConnected, sizeof(struct __tns__isConnected), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__isConnected(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__isConnected_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__isConnected(soap, "tns:isConnected", &a->tns__isConnected_, "tns:isConnected"))
				{	soap_flag_tns__isConnected_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__isConnected(struct soap *soap, const struct __tns__isConnected *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__isConnected(soap, tag?tag:"-tns:isConnected", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__isConnected * SOAP_FMAC4 soap_get___tns__isConnected(struct soap *soap, struct __tns__isConnected *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__isConnected(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__isConnected * SOAP_FMAC2 soap_instantiate___tns__isConnected(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__isConnected(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__isConnected, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__isConnected);
		if (size)
			*size = sizeof(struct __tns__isConnected);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__isConnected[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__isConnected);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__isConnected*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__isConnected(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__isConnected %p -> %p\n", q, p));
	*(struct __tns__isConnected*)p = *(struct __tns__isConnected*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__isAuthorized(struct soap *soap, struct __tns__isAuthorized *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__isAuthorized_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__isAuthorized(struct soap *soap, const struct __tns__isAuthorized *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__isAuthorized(soap, &a->tns__isAuthorized_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__isAuthorized(struct soap *soap, const char *tag, int id, const struct __tns__isAuthorized *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__isAuthorized(soap, "tns:isAuthorized", -1, &a->tns__isAuthorized_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__isAuthorized * SOAP_FMAC4 soap_in___tns__isAuthorized(struct soap *soap, const char *tag, struct __tns__isAuthorized *a, const char *type)
{
	size_t soap_flag_tns__isAuthorized_ = 1;
	short soap_flag;
	a = (struct __tns__isAuthorized *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__isAuthorized, sizeof(struct __tns__isAuthorized), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__isAuthorized(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__isAuthorized_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__isAuthorized(soap, "tns:isAuthorized", &a->tns__isAuthorized_, "tns:isAuthorized"))
				{	soap_flag_tns__isAuthorized_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__isAuthorized(struct soap *soap, const struct __tns__isAuthorized *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__isAuthorized(soap, tag?tag:"-tns:isAuthorized", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__isAuthorized * SOAP_FMAC4 soap_get___tns__isAuthorized(struct soap *soap, struct __tns__isAuthorized *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__isAuthorized(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__isAuthorized * SOAP_FMAC2 soap_instantiate___tns__isAuthorized(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__isAuthorized(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__isAuthorized, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__isAuthorized);
		if (size)
			*size = sizeof(struct __tns__isAuthorized);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__isAuthorized[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__isAuthorized);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__isAuthorized*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__isAuthorized(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__isAuthorized %p -> %p\n", q, p));
	*(struct __tns__isAuthorized*)p = *(struct __tns__isAuthorized*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__getUser(struct soap *soap, struct __tns__getUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__getUser_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__getUser(struct soap *soap, const struct __tns__getUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__getUser(soap, &a->tns__getUser_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__getUser(struct soap *soap, const char *tag, int id, const struct __tns__getUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__getUser(soap, "tns:getUser", -1, &a->tns__getUser_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__getUser * SOAP_FMAC4 soap_in___tns__getUser(struct soap *soap, const char *tag, struct __tns__getUser *a, const char *type)
{
	size_t soap_flag_tns__getUser_ = 1;
	short soap_flag;
	a = (struct __tns__getUser *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__getUser, sizeof(struct __tns__getUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__getUser(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__getUser_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__getUser(soap, "tns:getUser", &a->tns__getUser_, "tns:getUser"))
				{	soap_flag_tns__getUser_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__getUser(struct soap *soap, const struct __tns__getUser *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__getUser(soap, tag?tag:"-tns:getUser", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__getUser * SOAP_FMAC4 soap_get___tns__getUser(struct soap *soap, struct __tns__getUser *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__getUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__getUser * SOAP_FMAC2 soap_instantiate___tns__getUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__getUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__getUser, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__getUser);
		if (size)
			*size = sizeof(struct __tns__getUser);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__getUser[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__getUser);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__getUser*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__getUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__getUser %p -> %p\n", q, p));
	*(struct __tns__getUser*)p = *(struct __tns__getUser*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__deleteMediaAnnotationWithId(struct soap *soap, struct __tns__deleteMediaAnnotationWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__deleteMediaAnnotationWithId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__deleteMediaAnnotationWithId(struct soap *soap, const struct __tns__deleteMediaAnnotationWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__deleteMediaAnnotationWithId(soap, &a->tns__deleteMediaAnnotationWithId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__deleteMediaAnnotationWithId(struct soap *soap, const char *tag, int id, const struct __tns__deleteMediaAnnotationWithId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__deleteMediaAnnotationWithId(soap, "tns:deleteMediaAnnotationWithId", -1, &a->tns__deleteMediaAnnotationWithId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__deleteMediaAnnotationWithId * SOAP_FMAC4 soap_in___tns__deleteMediaAnnotationWithId(struct soap *soap, const char *tag, struct __tns__deleteMediaAnnotationWithId *a, const char *type)
{
	size_t soap_flag_tns__deleteMediaAnnotationWithId_ = 1;
	short soap_flag;
	a = (struct __tns__deleteMediaAnnotationWithId *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__deleteMediaAnnotationWithId, sizeof(struct __tns__deleteMediaAnnotationWithId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__deleteMediaAnnotationWithId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__deleteMediaAnnotationWithId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__deleteMediaAnnotationWithId(soap, "tns:deleteMediaAnnotationWithId", &a->tns__deleteMediaAnnotationWithId_, "tns:deleteMediaAnnotationWithId"))
				{	soap_flag_tns__deleteMediaAnnotationWithId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__deleteMediaAnnotationWithId(struct soap *soap, const struct __tns__deleteMediaAnnotationWithId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__deleteMediaAnnotationWithId(soap, tag?tag:"-tns:deleteMediaAnnotationWithId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__deleteMediaAnnotationWithId * SOAP_FMAC4 soap_get___tns__deleteMediaAnnotationWithId(struct soap *soap, struct __tns__deleteMediaAnnotationWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__deleteMediaAnnotationWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__deleteMediaAnnotationWithId * SOAP_FMAC2 soap_instantiate___tns__deleteMediaAnnotationWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__deleteMediaAnnotationWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__deleteMediaAnnotationWithId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__deleteMediaAnnotationWithId);
		if (size)
			*size = sizeof(struct __tns__deleteMediaAnnotationWithId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__deleteMediaAnnotationWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__deleteMediaAnnotationWithId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__deleteMediaAnnotationWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__deleteMediaAnnotationWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__deleteMediaAnnotationWithId %p -> %p\n", q, p));
	*(struct __tns__deleteMediaAnnotationWithId*)p = *(struct __tns__deleteMediaAnnotationWithId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__deleteMediaAliasWithId(struct soap *soap, struct __tns__deleteMediaAliasWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__deleteMediaAliasWithId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__deleteMediaAliasWithId(struct soap *soap, const struct __tns__deleteMediaAliasWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__deleteMediaAliasWithId(soap, &a->tns__deleteMediaAliasWithId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__deleteMediaAliasWithId(struct soap *soap, const char *tag, int id, const struct __tns__deleteMediaAliasWithId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__deleteMediaAliasWithId(soap, "tns:deleteMediaAliasWithId", -1, &a->tns__deleteMediaAliasWithId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__deleteMediaAliasWithId * SOAP_FMAC4 soap_in___tns__deleteMediaAliasWithId(struct soap *soap, const char *tag, struct __tns__deleteMediaAliasWithId *a, const char *type)
{
	size_t soap_flag_tns__deleteMediaAliasWithId_ = 1;
	short soap_flag;
	a = (struct __tns__deleteMediaAliasWithId *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__deleteMediaAliasWithId, sizeof(struct __tns__deleteMediaAliasWithId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__deleteMediaAliasWithId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__deleteMediaAliasWithId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__deleteMediaAliasWithId(soap, "tns:deleteMediaAliasWithId", &a->tns__deleteMediaAliasWithId_, "tns:deleteMediaAliasWithId"))
				{	soap_flag_tns__deleteMediaAliasWithId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__deleteMediaAliasWithId(struct soap *soap, const struct __tns__deleteMediaAliasWithId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__deleteMediaAliasWithId(soap, tag?tag:"-tns:deleteMediaAliasWithId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__deleteMediaAliasWithId * SOAP_FMAC4 soap_get___tns__deleteMediaAliasWithId(struct soap *soap, struct __tns__deleteMediaAliasWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__deleteMediaAliasWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__deleteMediaAliasWithId * SOAP_FMAC2 soap_instantiate___tns__deleteMediaAliasWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__deleteMediaAliasWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__deleteMediaAliasWithId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__deleteMediaAliasWithId);
		if (size)
			*size = sizeof(struct __tns__deleteMediaAliasWithId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__deleteMediaAliasWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__deleteMediaAliasWithId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__deleteMediaAliasWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__deleteMediaAliasWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__deleteMediaAliasWithId %p -> %p\n", q, p));
	*(struct __tns__deleteMediaAliasWithId*)p = *(struct __tns__deleteMediaAliasWithId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__curseUserWithId(struct soap *soap, struct __tns__curseUserWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__curseUserWithId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__curseUserWithId(struct soap *soap, const struct __tns__curseUserWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__curseUserWithId(soap, &a->tns__curseUserWithId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__curseUserWithId(struct soap *soap, const char *tag, int id, const struct __tns__curseUserWithId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__curseUserWithId(soap, "tns:curseUserWithId", -1, &a->tns__curseUserWithId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__curseUserWithId * SOAP_FMAC4 soap_in___tns__curseUserWithId(struct soap *soap, const char *tag, struct __tns__curseUserWithId *a, const char *type)
{
	size_t soap_flag_tns__curseUserWithId_ = 1;
	short soap_flag;
	a = (struct __tns__curseUserWithId *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__curseUserWithId, sizeof(struct __tns__curseUserWithId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__curseUserWithId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__curseUserWithId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__curseUserWithId(soap, "tns:curseUserWithId", &a->tns__curseUserWithId_, "tns:curseUserWithId"))
				{	soap_flag_tns__curseUserWithId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__curseUserWithId(struct soap *soap, const struct __tns__curseUserWithId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__curseUserWithId(soap, tag?tag:"-tns:curseUserWithId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__curseUserWithId * SOAP_FMAC4 soap_get___tns__curseUserWithId(struct soap *soap, struct __tns__curseUserWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__curseUserWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__curseUserWithId * SOAP_FMAC2 soap_instantiate___tns__curseUserWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__curseUserWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__curseUserWithId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__curseUserWithId);
		if (size)
			*size = sizeof(struct __tns__curseUserWithId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__curseUserWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__curseUserWithId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__curseUserWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__curseUserWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__curseUserWithId %p -> %p\n", q, p));
	*(struct __tns__curseUserWithId*)p = *(struct __tns__curseUserWithId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__curseMediaTokenWithId(struct soap *soap, struct __tns__curseMediaTokenWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__curseMediaTokenWithId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__curseMediaTokenWithId(struct soap *soap, const struct __tns__curseMediaTokenWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__curseMediaTokenWithId(soap, &a->tns__curseMediaTokenWithId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__curseMediaTokenWithId(struct soap *soap, const char *tag, int id, const struct __tns__curseMediaTokenWithId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__curseMediaTokenWithId(soap, "tns:curseMediaTokenWithId", -1, &a->tns__curseMediaTokenWithId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__curseMediaTokenWithId * SOAP_FMAC4 soap_in___tns__curseMediaTokenWithId(struct soap *soap, const char *tag, struct __tns__curseMediaTokenWithId *a, const char *type)
{
	size_t soap_flag_tns__curseMediaTokenWithId_ = 1;
	short soap_flag;
	a = (struct __tns__curseMediaTokenWithId *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__curseMediaTokenWithId, sizeof(struct __tns__curseMediaTokenWithId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__curseMediaTokenWithId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__curseMediaTokenWithId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__curseMediaTokenWithId(soap, "tns:curseMediaTokenWithId", &a->tns__curseMediaTokenWithId_, "tns:curseMediaTokenWithId"))
				{	soap_flag_tns__curseMediaTokenWithId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__curseMediaTokenWithId(struct soap *soap, const struct __tns__curseMediaTokenWithId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__curseMediaTokenWithId(soap, tag?tag:"-tns:curseMediaTokenWithId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__curseMediaTokenWithId * SOAP_FMAC4 soap_get___tns__curseMediaTokenWithId(struct soap *soap, struct __tns__curseMediaTokenWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__curseMediaTokenWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__curseMediaTokenWithId * SOAP_FMAC2 soap_instantiate___tns__curseMediaTokenWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__curseMediaTokenWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__curseMediaTokenWithId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__curseMediaTokenWithId);
		if (size)
			*size = sizeof(struct __tns__curseMediaTokenWithId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__curseMediaTokenWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__curseMediaTokenWithId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__curseMediaTokenWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__curseMediaTokenWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__curseMediaTokenWithId %p -> %p\n", q, p));
	*(struct __tns__curseMediaTokenWithId*)p = *(struct __tns__curseMediaTokenWithId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__curseMediaAnnotationWithId(struct soap *soap, struct __tns__curseMediaAnnotationWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__curseMediaAnnotationWithId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__curseMediaAnnotationWithId(struct soap *soap, const struct __tns__curseMediaAnnotationWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__curseMediaAnnotationWithId(soap, &a->tns__curseMediaAnnotationWithId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__curseMediaAnnotationWithId(struct soap *soap, const char *tag, int id, const struct __tns__curseMediaAnnotationWithId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__curseMediaAnnotationWithId(soap, "tns:curseMediaAnnotationWithId", -1, &a->tns__curseMediaAnnotationWithId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__curseMediaAnnotationWithId * SOAP_FMAC4 soap_in___tns__curseMediaAnnotationWithId(struct soap *soap, const char *tag, struct __tns__curseMediaAnnotationWithId *a, const char *type)
{
	size_t soap_flag_tns__curseMediaAnnotationWithId_ = 1;
	short soap_flag;
	a = (struct __tns__curseMediaAnnotationWithId *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__curseMediaAnnotationWithId, sizeof(struct __tns__curseMediaAnnotationWithId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__curseMediaAnnotationWithId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__curseMediaAnnotationWithId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__curseMediaAnnotationWithId(soap, "tns:curseMediaAnnotationWithId", &a->tns__curseMediaAnnotationWithId_, "tns:curseMediaAnnotationWithId"))
				{	soap_flag_tns__curseMediaAnnotationWithId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__curseMediaAnnotationWithId(struct soap *soap, const struct __tns__curseMediaAnnotationWithId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__curseMediaAnnotationWithId(soap, tag?tag:"-tns:curseMediaAnnotationWithId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__curseMediaAnnotationWithId * SOAP_FMAC4 soap_get___tns__curseMediaAnnotationWithId(struct soap *soap, struct __tns__curseMediaAnnotationWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__curseMediaAnnotationWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__curseMediaAnnotationWithId * SOAP_FMAC2 soap_instantiate___tns__curseMediaAnnotationWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__curseMediaAnnotationWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__curseMediaAnnotationWithId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__curseMediaAnnotationWithId);
		if (size)
			*size = sizeof(struct __tns__curseMediaAnnotationWithId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__curseMediaAnnotationWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__curseMediaAnnotationWithId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__curseMediaAnnotationWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__curseMediaAnnotationWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__curseMediaAnnotationWithId %p -> %p\n", q, p));
	*(struct __tns__curseMediaAnnotationWithId*)p = *(struct __tns__curseMediaAnnotationWithId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__curseMediaAliasWithId(struct soap *soap, struct __tns__curseMediaAliasWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__curseMediaAliasWithId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__curseMediaAliasWithId(struct soap *soap, const struct __tns__curseMediaAliasWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__curseMediaAliasWithId(soap, &a->tns__curseMediaAliasWithId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__curseMediaAliasWithId(struct soap *soap, const char *tag, int id, const struct __tns__curseMediaAliasWithId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__curseMediaAliasWithId(soap, "tns:curseMediaAliasWithId", -1, &a->tns__curseMediaAliasWithId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__curseMediaAliasWithId * SOAP_FMAC4 soap_in___tns__curseMediaAliasWithId(struct soap *soap, const char *tag, struct __tns__curseMediaAliasWithId *a, const char *type)
{
	size_t soap_flag_tns__curseMediaAliasWithId_ = 1;
	short soap_flag;
	a = (struct __tns__curseMediaAliasWithId *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__curseMediaAliasWithId, sizeof(struct __tns__curseMediaAliasWithId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__curseMediaAliasWithId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__curseMediaAliasWithId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__curseMediaAliasWithId(soap, "tns:curseMediaAliasWithId", &a->tns__curseMediaAliasWithId_, "tns:curseMediaAliasWithId"))
				{	soap_flag_tns__curseMediaAliasWithId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__curseMediaAliasWithId(struct soap *soap, const struct __tns__curseMediaAliasWithId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__curseMediaAliasWithId(soap, tag?tag:"-tns:curseMediaAliasWithId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__curseMediaAliasWithId * SOAP_FMAC4 soap_get___tns__curseMediaAliasWithId(struct soap *soap, struct __tns__curseMediaAliasWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__curseMediaAliasWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__curseMediaAliasWithId * SOAP_FMAC2 soap_instantiate___tns__curseMediaAliasWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__curseMediaAliasWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__curseMediaAliasWithId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__curseMediaAliasWithId);
		if (size)
			*size = sizeof(struct __tns__curseMediaAliasWithId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__curseMediaAliasWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__curseMediaAliasWithId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__curseMediaAliasWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__curseMediaAliasWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__curseMediaAliasWithId %p -> %p\n", q, p));
	*(struct __tns__curseMediaAliasWithId*)p = *(struct __tns__curseMediaAliasWithId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__chat(struct soap *soap, struct __tns__chat *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__chat_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__chat(struct soap *soap, const struct __tns__chat *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__chat(soap, &a->tns__chat_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__chat(struct soap *soap, const char *tag, int id, const struct __tns__chat *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__chat(soap, "tns:chat", -1, &a->tns__chat_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__chat * SOAP_FMAC4 soap_in___tns__chat(struct soap *soap, const char *tag, struct __tns__chat *a, const char *type)
{
	size_t soap_flag_tns__chat_ = 1;
	short soap_flag;
	a = (struct __tns__chat *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__chat, sizeof(struct __tns__chat), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__chat(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__chat_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__chat(soap, "tns:chat", &a->tns__chat_, "tns:chat"))
				{	soap_flag_tns__chat_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__chat(struct soap *soap, const struct __tns__chat *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__chat(soap, tag?tag:"-tns:chat", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__chat * SOAP_FMAC4 soap_get___tns__chat(struct soap *soap, struct __tns__chat *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__chat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__chat * SOAP_FMAC2 soap_instantiate___tns__chat(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__chat(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__chat, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__chat);
		if (size)
			*size = sizeof(struct __tns__chat);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__chat[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__chat);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__chat*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__chat(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__chat %p -> %p\n", q, p));
	*(struct __tns__chat*)p = *(struct __tns__chat*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__blockUserWithId(struct soap *soap, struct __tns__blockUserWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__blockUserWithId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__blockUserWithId(struct soap *soap, const struct __tns__blockUserWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__blockUserWithId(soap, &a->tns__blockUserWithId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__blockUserWithId(struct soap *soap, const char *tag, int id, const struct __tns__blockUserWithId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__blockUserWithId(soap, "tns:blockUserWithId", -1, &a->tns__blockUserWithId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__blockUserWithId * SOAP_FMAC4 soap_in___tns__blockUserWithId(struct soap *soap, const char *tag, struct __tns__blockUserWithId *a, const char *type)
{
	size_t soap_flag_tns__blockUserWithId_ = 1;
	short soap_flag;
	a = (struct __tns__blockUserWithId *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__blockUserWithId, sizeof(struct __tns__blockUserWithId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__blockUserWithId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__blockUserWithId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__blockUserWithId(soap, "tns:blockUserWithId", &a->tns__blockUserWithId_, "tns:blockUserWithId"))
				{	soap_flag_tns__blockUserWithId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__blockUserWithId(struct soap *soap, const struct __tns__blockUserWithId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__blockUserWithId(soap, tag?tag:"-tns:blockUserWithId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__blockUserWithId * SOAP_FMAC4 soap_get___tns__blockUserWithId(struct soap *soap, struct __tns__blockUserWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__blockUserWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__blockUserWithId * SOAP_FMAC2 soap_instantiate___tns__blockUserWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__blockUserWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__blockUserWithId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__blockUserWithId);
		if (size)
			*size = sizeof(struct __tns__blockUserWithId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__blockUserWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__blockUserWithId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__blockUserWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__blockUserWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__blockUserWithId %p -> %p\n", q, p));
	*(struct __tns__blockUserWithId*)p = *(struct __tns__blockUserWithId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__blockMediaAnnotationWithId(struct soap *soap, struct __tns__blockMediaAnnotationWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__blockMediaAnnotationWithId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__blockMediaAnnotationWithId(struct soap *soap, const struct __tns__blockMediaAnnotationWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__blockMediaAnnotationWithId(soap, &a->tns__blockMediaAnnotationWithId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__blockMediaAnnotationWithId(struct soap *soap, const char *tag, int id, const struct __tns__blockMediaAnnotationWithId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__blockMediaAnnotationWithId(soap, "tns:blockMediaAnnotationWithId", -1, &a->tns__blockMediaAnnotationWithId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__blockMediaAnnotationWithId * SOAP_FMAC4 soap_in___tns__blockMediaAnnotationWithId(struct soap *soap, const char *tag, struct __tns__blockMediaAnnotationWithId *a, const char *type)
{
	size_t soap_flag_tns__blockMediaAnnotationWithId_ = 1;
	short soap_flag;
	a = (struct __tns__blockMediaAnnotationWithId *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__blockMediaAnnotationWithId, sizeof(struct __tns__blockMediaAnnotationWithId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__blockMediaAnnotationWithId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__blockMediaAnnotationWithId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__blockMediaAnnotationWithId(soap, "tns:blockMediaAnnotationWithId", &a->tns__blockMediaAnnotationWithId_, "tns:blockMediaAnnotationWithId"))
				{	soap_flag_tns__blockMediaAnnotationWithId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__blockMediaAnnotationWithId(struct soap *soap, const struct __tns__blockMediaAnnotationWithId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__blockMediaAnnotationWithId(soap, tag?tag:"-tns:blockMediaAnnotationWithId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__blockMediaAnnotationWithId * SOAP_FMAC4 soap_get___tns__blockMediaAnnotationWithId(struct soap *soap, struct __tns__blockMediaAnnotationWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__blockMediaAnnotationWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__blockMediaAnnotationWithId * SOAP_FMAC2 soap_instantiate___tns__blockMediaAnnotationWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__blockMediaAnnotationWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__blockMediaAnnotationWithId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__blockMediaAnnotationWithId);
		if (size)
			*size = sizeof(struct __tns__blockMediaAnnotationWithId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__blockMediaAnnotationWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__blockMediaAnnotationWithId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__blockMediaAnnotationWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__blockMediaAnnotationWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__blockMediaAnnotationWithId %p -> %p\n", q, p));
	*(struct __tns__blockMediaAnnotationWithId*)p = *(struct __tns__blockMediaAnnotationWithId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__blockMediaAliasWithId(struct soap *soap, struct __tns__blockMediaAliasWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__blockMediaAliasWithId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__blockMediaAliasWithId(struct soap *soap, const struct __tns__blockMediaAliasWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__blockMediaAliasWithId(soap, &a->tns__blockMediaAliasWithId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__blockMediaAliasWithId(struct soap *soap, const char *tag, int id, const struct __tns__blockMediaAliasWithId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__blockMediaAliasWithId(soap, "tns:blockMediaAliasWithId", -1, &a->tns__blockMediaAliasWithId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__blockMediaAliasWithId * SOAP_FMAC4 soap_in___tns__blockMediaAliasWithId(struct soap *soap, const char *tag, struct __tns__blockMediaAliasWithId *a, const char *type)
{
	size_t soap_flag_tns__blockMediaAliasWithId_ = 1;
	short soap_flag;
	a = (struct __tns__blockMediaAliasWithId *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__blockMediaAliasWithId, sizeof(struct __tns__blockMediaAliasWithId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__blockMediaAliasWithId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__blockMediaAliasWithId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__blockMediaAliasWithId(soap, "tns:blockMediaAliasWithId", &a->tns__blockMediaAliasWithId_, "tns:blockMediaAliasWithId"))
				{	soap_flag_tns__blockMediaAliasWithId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__blockMediaAliasWithId(struct soap *soap, const struct __tns__blockMediaAliasWithId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__blockMediaAliasWithId(soap, tag?tag:"-tns:blockMediaAliasWithId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__blockMediaAliasWithId * SOAP_FMAC4 soap_get___tns__blockMediaAliasWithId(struct soap *soap, struct __tns__blockMediaAliasWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__blockMediaAliasWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__blockMediaAliasWithId * SOAP_FMAC2 soap_instantiate___tns__blockMediaAliasWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__blockMediaAliasWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__blockMediaAliasWithId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__blockMediaAliasWithId);
		if (size)
			*size = sizeof(struct __tns__blockMediaAliasWithId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__blockMediaAliasWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__blockMediaAliasWithId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__blockMediaAliasWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__blockMediaAliasWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__blockMediaAliasWithId %p -> %p\n", q, p));
	*(struct __tns__blockMediaAliasWithId*)p = *(struct __tns__blockMediaAliasWithId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__blessUserWithId(struct soap *soap, struct __tns__blessUserWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__blessUserWithId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__blessUserWithId(struct soap *soap, const struct __tns__blessUserWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__blessUserWithId(soap, &a->tns__blessUserWithId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__blessUserWithId(struct soap *soap, const char *tag, int id, const struct __tns__blessUserWithId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__blessUserWithId(soap, "tns:blessUserWithId", -1, &a->tns__blessUserWithId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__blessUserWithId * SOAP_FMAC4 soap_in___tns__blessUserWithId(struct soap *soap, const char *tag, struct __tns__blessUserWithId *a, const char *type)
{
	size_t soap_flag_tns__blessUserWithId_ = 1;
	short soap_flag;
	a = (struct __tns__blessUserWithId *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__blessUserWithId, sizeof(struct __tns__blessUserWithId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__blessUserWithId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__blessUserWithId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__blessUserWithId(soap, "tns:blessUserWithId", &a->tns__blessUserWithId_, "tns:blessUserWithId"))
				{	soap_flag_tns__blessUserWithId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__blessUserWithId(struct soap *soap, const struct __tns__blessUserWithId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__blessUserWithId(soap, tag?tag:"-tns:blessUserWithId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__blessUserWithId * SOAP_FMAC4 soap_get___tns__blessUserWithId(struct soap *soap, struct __tns__blessUserWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__blessUserWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__blessUserWithId * SOAP_FMAC2 soap_instantiate___tns__blessUserWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__blessUserWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__blessUserWithId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__blessUserWithId);
		if (size)
			*size = sizeof(struct __tns__blessUserWithId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__blessUserWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__blessUserWithId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__blessUserWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__blessUserWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__blessUserWithId %p -> %p\n", q, p));
	*(struct __tns__blessUserWithId*)p = *(struct __tns__blessUserWithId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__blessMediaTokenWithId(struct soap *soap, struct __tns__blessMediaTokenWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__blessMediaTokenWithId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__blessMediaTokenWithId(struct soap *soap, const struct __tns__blessMediaTokenWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__blessMediaTokenWithId(soap, &a->tns__blessMediaTokenWithId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__blessMediaTokenWithId(struct soap *soap, const char *tag, int id, const struct __tns__blessMediaTokenWithId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__blessMediaTokenWithId(soap, "tns:blessMediaTokenWithId", -1, &a->tns__blessMediaTokenWithId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__blessMediaTokenWithId * SOAP_FMAC4 soap_in___tns__blessMediaTokenWithId(struct soap *soap, const char *tag, struct __tns__blessMediaTokenWithId *a, const char *type)
{
	size_t soap_flag_tns__blessMediaTokenWithId_ = 1;
	short soap_flag;
	a = (struct __tns__blessMediaTokenWithId *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__blessMediaTokenWithId, sizeof(struct __tns__blessMediaTokenWithId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__blessMediaTokenWithId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__blessMediaTokenWithId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__blessMediaTokenWithId(soap, "tns:blessMediaTokenWithId", &a->tns__blessMediaTokenWithId_, "tns:blessMediaTokenWithId"))
				{	soap_flag_tns__blessMediaTokenWithId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__blessMediaTokenWithId(struct soap *soap, const struct __tns__blessMediaTokenWithId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__blessMediaTokenWithId(soap, tag?tag:"-tns:blessMediaTokenWithId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__blessMediaTokenWithId * SOAP_FMAC4 soap_get___tns__blessMediaTokenWithId(struct soap *soap, struct __tns__blessMediaTokenWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__blessMediaTokenWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__blessMediaTokenWithId * SOAP_FMAC2 soap_instantiate___tns__blessMediaTokenWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__blessMediaTokenWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__blessMediaTokenWithId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__blessMediaTokenWithId);
		if (size)
			*size = sizeof(struct __tns__blessMediaTokenWithId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__blessMediaTokenWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__blessMediaTokenWithId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__blessMediaTokenWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__blessMediaTokenWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__blessMediaTokenWithId %p -> %p\n", q, p));
	*(struct __tns__blessMediaTokenWithId*)p = *(struct __tns__blessMediaTokenWithId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__blessMediaAnnotationWithId(struct soap *soap, struct __tns__blessMediaAnnotationWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__blessMediaAnnotationWithId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__blessMediaAnnotationWithId(struct soap *soap, const struct __tns__blessMediaAnnotationWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__blessMediaAnnotationWithId(soap, &a->tns__blessMediaAnnotationWithId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__blessMediaAnnotationWithId(struct soap *soap, const char *tag, int id, const struct __tns__blessMediaAnnotationWithId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__blessMediaAnnotationWithId(soap, "tns:blessMediaAnnotationWithId", -1, &a->tns__blessMediaAnnotationWithId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__blessMediaAnnotationWithId * SOAP_FMAC4 soap_in___tns__blessMediaAnnotationWithId(struct soap *soap, const char *tag, struct __tns__blessMediaAnnotationWithId *a, const char *type)
{
	size_t soap_flag_tns__blessMediaAnnotationWithId_ = 1;
	short soap_flag;
	a = (struct __tns__blessMediaAnnotationWithId *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__blessMediaAnnotationWithId, sizeof(struct __tns__blessMediaAnnotationWithId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__blessMediaAnnotationWithId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__blessMediaAnnotationWithId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__blessMediaAnnotationWithId(soap, "tns:blessMediaAnnotationWithId", &a->tns__blessMediaAnnotationWithId_, "tns:blessMediaAnnotationWithId"))
				{	soap_flag_tns__blessMediaAnnotationWithId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__blessMediaAnnotationWithId(struct soap *soap, const struct __tns__blessMediaAnnotationWithId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__blessMediaAnnotationWithId(soap, tag?tag:"-tns:blessMediaAnnotationWithId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__blessMediaAnnotationWithId * SOAP_FMAC4 soap_get___tns__blessMediaAnnotationWithId(struct soap *soap, struct __tns__blessMediaAnnotationWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__blessMediaAnnotationWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__blessMediaAnnotationWithId * SOAP_FMAC2 soap_instantiate___tns__blessMediaAnnotationWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__blessMediaAnnotationWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__blessMediaAnnotationWithId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__blessMediaAnnotationWithId);
		if (size)
			*size = sizeof(struct __tns__blessMediaAnnotationWithId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__blessMediaAnnotationWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__blessMediaAnnotationWithId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__blessMediaAnnotationWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__blessMediaAnnotationWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__blessMediaAnnotationWithId %p -> %p\n", q, p));
	*(struct __tns__blessMediaAnnotationWithId*)p = *(struct __tns__blessMediaAnnotationWithId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__blessMediaAliasWithId(struct soap *soap, struct __tns__blessMediaAliasWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__blessMediaAliasWithId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__blessMediaAliasWithId(struct soap *soap, const struct __tns__blessMediaAliasWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__blessMediaAliasWithId(soap, &a->tns__blessMediaAliasWithId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__blessMediaAliasWithId(struct soap *soap, const char *tag, int id, const struct __tns__blessMediaAliasWithId *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__blessMediaAliasWithId(soap, "tns:blessMediaAliasWithId", -1, &a->tns__blessMediaAliasWithId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__blessMediaAliasWithId * SOAP_FMAC4 soap_in___tns__blessMediaAliasWithId(struct soap *soap, const char *tag, struct __tns__blessMediaAliasWithId *a, const char *type)
{
	size_t soap_flag_tns__blessMediaAliasWithId_ = 1;
	short soap_flag;
	a = (struct __tns__blessMediaAliasWithId *)soap_id_enter(soap, "", a, SOAP_TYPE_Annot___tns__blessMediaAliasWithId, sizeof(struct __tns__blessMediaAliasWithId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__blessMediaAliasWithId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__blessMediaAliasWithId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__blessMediaAliasWithId(soap, "tns:blessMediaAliasWithId", &a->tns__blessMediaAliasWithId_, "tns:blessMediaAliasWithId"))
				{	soap_flag_tns__blessMediaAliasWithId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__blessMediaAliasWithId(struct soap *soap, const struct __tns__blessMediaAliasWithId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__blessMediaAliasWithId(soap, tag?tag:"-tns:blessMediaAliasWithId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__blessMediaAliasWithId * SOAP_FMAC4 soap_get___tns__blessMediaAliasWithId(struct soap *soap, struct __tns__blessMediaAliasWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__blessMediaAliasWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__blessMediaAliasWithId * SOAP_FMAC2 soap_instantiate___tns__blessMediaAliasWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__blessMediaAliasWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot___tns__blessMediaAliasWithId, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__blessMediaAliasWithId);
		if (size)
			*size = sizeof(struct __tns__blessMediaAliasWithId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__blessMediaAliasWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__blessMediaAliasWithId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__blessMediaAliasWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__blessMediaAliasWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__blessMediaAliasWithId %p -> %p\n", q, p));
	*(struct __tns__blessMediaAliasWithId*)p = *(struct __tns__blessMediaAliasWithId*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct SOAP_ENV__Reason *)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, *a);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct SOAP_ENV__Detail *)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, *a);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		*a = (struct SOAP_ENV__Code *)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, *a);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__updateMediaAnnotationUserIdWithIdResponse(struct soap *soap, tns__updateMediaAnnotationUserIdWithIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__updateMediaAnnotationUserIdWithIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__updateMediaAnnotationUserIdWithIdResponse(struct soap *soap, const char *tag, int id, tns__updateMediaAnnotationUserIdWithIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__updateMediaAnnotationUserIdWithIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__updateMediaAnnotationUserIdWithIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__updateMediaAnnotationUserIdWithIdResponse(struct soap *soap, const char *tag, tns__updateMediaAnnotationUserIdWithIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__updateMediaAnnotationUserIdWithIdResponse **)soap_malloc(soap, sizeof(tns__updateMediaAnnotationUserIdWithIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__updateMediaAnnotationUserIdWithIdResponse *)soap_instantiate_tns__updateMediaAnnotationUserIdWithIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__updateMediaAnnotationUserIdWithIdResponse ** p = (tns__updateMediaAnnotationUserIdWithIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__updateMediaAnnotationUserIdWithIdResponse, sizeof(tns__updateMediaAnnotationUserIdWithIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__updateMediaAnnotationUserIdWithIdResponse(struct soap *soap, tns__updateMediaAnnotationUserIdWithIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__updateMediaAnnotationUserIdWithIdResponse);
	if (soap_out_PointerTotns__updateMediaAnnotationUserIdWithIdResponse(soap, tag?tag:"tns:updateMediaAnnotationUserIdWithIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__updateMediaAnnotationUserIdWithIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__updateMediaAnnotationUserIdWithIdResponse(struct soap *soap, tns__updateMediaAnnotationUserIdWithIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__updateMediaAnnotationUserIdWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__updateMediaAnnotationUserIdWithId(struct soap *soap, tns__updateMediaAnnotationUserIdWithId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__updateMediaAnnotationUserIdWithId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__updateMediaAnnotationUserIdWithId(struct soap *soap, const char *tag, int id, tns__updateMediaAnnotationUserIdWithId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__updateMediaAnnotationUserIdWithId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__updateMediaAnnotationUserIdWithId ** SOAP_FMAC4 soap_in_PointerTotns__updateMediaAnnotationUserIdWithId(struct soap *soap, const char *tag, tns__updateMediaAnnotationUserIdWithId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__updateMediaAnnotationUserIdWithId **)soap_malloc(soap, sizeof(tns__updateMediaAnnotationUserIdWithId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__updateMediaAnnotationUserIdWithId *)soap_instantiate_tns__updateMediaAnnotationUserIdWithId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__updateMediaAnnotationUserIdWithId ** p = (tns__updateMediaAnnotationUserIdWithId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__updateMediaAnnotationUserIdWithId, sizeof(tns__updateMediaAnnotationUserIdWithId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__updateMediaAnnotationUserIdWithId(struct soap *soap, tns__updateMediaAnnotationUserIdWithId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__updateMediaAnnotationUserIdWithId);
	if (soap_out_PointerTotns__updateMediaAnnotationUserIdWithId(soap, tag?tag:"tns:updateMediaAnnotationUserIdWithId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__updateMediaAnnotationUserIdWithId ** SOAP_FMAC4 soap_get_PointerTotns__updateMediaAnnotationUserIdWithId(struct soap *soap, tns__updateMediaAnnotationUserIdWithId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__updateMediaAnnotationUserIdWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__updateMediaAnnotationTextWithIdResponse(struct soap *soap, tns__updateMediaAnnotationTextWithIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__updateMediaAnnotationTextWithIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__updateMediaAnnotationTextWithIdResponse(struct soap *soap, const char *tag, int id, tns__updateMediaAnnotationTextWithIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__updateMediaAnnotationTextWithIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__updateMediaAnnotationTextWithIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__updateMediaAnnotationTextWithIdResponse(struct soap *soap, const char *tag, tns__updateMediaAnnotationTextWithIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__updateMediaAnnotationTextWithIdResponse **)soap_malloc(soap, sizeof(tns__updateMediaAnnotationTextWithIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__updateMediaAnnotationTextWithIdResponse *)soap_instantiate_tns__updateMediaAnnotationTextWithIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__updateMediaAnnotationTextWithIdResponse ** p = (tns__updateMediaAnnotationTextWithIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__updateMediaAnnotationTextWithIdResponse, sizeof(tns__updateMediaAnnotationTextWithIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__updateMediaAnnotationTextWithIdResponse(struct soap *soap, tns__updateMediaAnnotationTextWithIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__updateMediaAnnotationTextWithIdResponse);
	if (soap_out_PointerTotns__updateMediaAnnotationTextWithIdResponse(soap, tag?tag:"tns:updateMediaAnnotationTextWithIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__updateMediaAnnotationTextWithIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__updateMediaAnnotationTextWithIdResponse(struct soap *soap, tns__updateMediaAnnotationTextWithIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__updateMediaAnnotationTextWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__updateMediaAnnotationTextWithId(struct soap *soap, tns__updateMediaAnnotationTextWithId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__updateMediaAnnotationTextWithId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__updateMediaAnnotationTextWithId(struct soap *soap, const char *tag, int id, tns__updateMediaAnnotationTextWithId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__updateMediaAnnotationTextWithId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__updateMediaAnnotationTextWithId ** SOAP_FMAC4 soap_in_PointerTotns__updateMediaAnnotationTextWithId(struct soap *soap, const char *tag, tns__updateMediaAnnotationTextWithId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__updateMediaAnnotationTextWithId **)soap_malloc(soap, sizeof(tns__updateMediaAnnotationTextWithId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__updateMediaAnnotationTextWithId *)soap_instantiate_tns__updateMediaAnnotationTextWithId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__updateMediaAnnotationTextWithId ** p = (tns__updateMediaAnnotationTextWithId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__updateMediaAnnotationTextWithId, sizeof(tns__updateMediaAnnotationTextWithId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__updateMediaAnnotationTextWithId(struct soap *soap, tns__updateMediaAnnotationTextWithId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__updateMediaAnnotationTextWithId);
	if (soap_out_PointerTotns__updateMediaAnnotationTextWithId(soap, tag?tag:"tns:updateMediaAnnotationTextWithId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__updateMediaAnnotationTextWithId ** SOAP_FMAC4 soap_get_PointerTotns__updateMediaAnnotationTextWithId(struct soap *soap, tns__updateMediaAnnotationTextWithId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__updateMediaAnnotationTextWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__updateMediaAnnotationLanguageWithIdResponse(struct soap *soap, tns__updateMediaAnnotationLanguageWithIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__updateMediaAnnotationLanguageWithIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__updateMediaAnnotationLanguageWithIdResponse(struct soap *soap, const char *tag, int id, tns__updateMediaAnnotationLanguageWithIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__updateMediaAnnotationLanguageWithIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__updateMediaAnnotationLanguageWithIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__updateMediaAnnotationLanguageWithIdResponse(struct soap *soap, const char *tag, tns__updateMediaAnnotationLanguageWithIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__updateMediaAnnotationLanguageWithIdResponse **)soap_malloc(soap, sizeof(tns__updateMediaAnnotationLanguageWithIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__updateMediaAnnotationLanguageWithIdResponse *)soap_instantiate_tns__updateMediaAnnotationLanguageWithIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__updateMediaAnnotationLanguageWithIdResponse ** p = (tns__updateMediaAnnotationLanguageWithIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__updateMediaAnnotationLanguageWithIdResponse, sizeof(tns__updateMediaAnnotationLanguageWithIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__updateMediaAnnotationLanguageWithIdResponse(struct soap *soap, tns__updateMediaAnnotationLanguageWithIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__updateMediaAnnotationLanguageWithIdResponse);
	if (soap_out_PointerTotns__updateMediaAnnotationLanguageWithIdResponse(soap, tag?tag:"tns:updateMediaAnnotationLanguageWithIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__updateMediaAnnotationLanguageWithIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__updateMediaAnnotationLanguageWithIdResponse(struct soap *soap, tns__updateMediaAnnotationLanguageWithIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__updateMediaAnnotationLanguageWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__updateMediaAnnotationLanguageWithId(struct soap *soap, tns__updateMediaAnnotationLanguageWithId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__updateMediaAnnotationLanguageWithId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__updateMediaAnnotationLanguageWithId(struct soap *soap, const char *tag, int id, tns__updateMediaAnnotationLanguageWithId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__updateMediaAnnotationLanguageWithId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__updateMediaAnnotationLanguageWithId ** SOAP_FMAC4 soap_in_PointerTotns__updateMediaAnnotationLanguageWithId(struct soap *soap, const char *tag, tns__updateMediaAnnotationLanguageWithId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__updateMediaAnnotationLanguageWithId **)soap_malloc(soap, sizeof(tns__updateMediaAnnotationLanguageWithId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__updateMediaAnnotationLanguageWithId *)soap_instantiate_tns__updateMediaAnnotationLanguageWithId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__updateMediaAnnotationLanguageWithId ** p = (tns__updateMediaAnnotationLanguageWithId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__updateMediaAnnotationLanguageWithId, sizeof(tns__updateMediaAnnotationLanguageWithId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__updateMediaAnnotationLanguageWithId(struct soap *soap, tns__updateMediaAnnotationLanguageWithId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__updateMediaAnnotationLanguageWithId);
	if (soap_out_PointerTotns__updateMediaAnnotationLanguageWithId(soap, tag?tag:"tns:updateMediaAnnotationLanguageWithId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__updateMediaAnnotationLanguageWithId ** SOAP_FMAC4 soap_get_PointerTotns__updateMediaAnnotationLanguageWithId(struct soap *soap, tns__updateMediaAnnotationLanguageWithId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__updateMediaAnnotationLanguageWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__updateGameThreadResponse(struct soap *soap, tns__updateGameThreadResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__updateGameThreadResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__updateGameThreadResponse(struct soap *soap, const char *tag, int id, tns__updateGameThreadResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__updateGameThreadResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__updateGameThreadResponse ** SOAP_FMAC4 soap_in_PointerTotns__updateGameThreadResponse(struct soap *soap, const char *tag, tns__updateGameThreadResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__updateGameThreadResponse **)soap_malloc(soap, sizeof(tns__updateGameThreadResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__updateGameThreadResponse *)soap_instantiate_tns__updateGameThreadResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__updateGameThreadResponse ** p = (tns__updateGameThreadResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__updateGameThreadResponse, sizeof(tns__updateGameThreadResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__updateGameThreadResponse(struct soap *soap, tns__updateGameThreadResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__updateGameThreadResponse);
	if (soap_out_PointerTotns__updateGameThreadResponse(soap, tag?tag:"tns:updateGameThreadResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__updateGameThreadResponse ** SOAP_FMAC4 soap_get_PointerTotns__updateGameThreadResponse(struct soap *soap, tns__updateGameThreadResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__updateGameThreadResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__updateGameThread(struct soap *soap, tns__updateGameThread *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__updateGameThread))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__updateGameThread(struct soap *soap, const char *tag, int id, tns__updateGameThread *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__updateGameThread);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__updateGameThread ** SOAP_FMAC4 soap_in_PointerTotns__updateGameThread(struct soap *soap, const char *tag, tns__updateGameThread **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__updateGameThread **)soap_malloc(soap, sizeof(tns__updateGameThread *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__updateGameThread *)soap_instantiate_tns__updateGameThread(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__updateGameThread ** p = (tns__updateGameThread **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__updateGameThread, sizeof(tns__updateGameThread), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__updateGameThread(struct soap *soap, tns__updateGameThread *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__updateGameThread);
	if (soap_out_PointerTotns__updateGameThread(soap, tag?tag:"tns:updateGameThread", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__updateGameThread ** SOAP_FMAC4 soap_get_PointerTotns__updateGameThread(struct soap *soap, tns__updateGameThread **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__updateGameThread(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaTokenUrlResponse(struct soap *soap, tns__submitMediaTokenUrlResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__submitMediaTokenUrlResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaTokenUrlResponse(struct soap *soap, const char *tag, int id, tns__submitMediaTokenUrlResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__submitMediaTokenUrlResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaTokenUrlResponse ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaTokenUrlResponse(struct soap *soap, const char *tag, tns__submitMediaTokenUrlResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaTokenUrlResponse **)soap_malloc(soap, sizeof(tns__submitMediaTokenUrlResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaTokenUrlResponse *)soap_instantiate_tns__submitMediaTokenUrlResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaTokenUrlResponse ** p = (tns__submitMediaTokenUrlResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__submitMediaTokenUrlResponse, sizeof(tns__submitMediaTokenUrlResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaTokenUrlResponse(struct soap *soap, tns__submitMediaTokenUrlResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__submitMediaTokenUrlResponse);
	if (soap_out_PointerTotns__submitMediaTokenUrlResponse(soap, tag?tag:"tns:submitMediaTokenUrlResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaTokenUrlResponse ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaTokenUrlResponse(struct soap *soap, tns__submitMediaTokenUrlResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaTokenUrlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaTokenUrl(struct soap *soap, tns__submitMediaTokenUrl *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__submitMediaTokenUrl))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaTokenUrl(struct soap *soap, const char *tag, int id, tns__submitMediaTokenUrl *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__submitMediaTokenUrl);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaTokenUrl ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaTokenUrl(struct soap *soap, const char *tag, tns__submitMediaTokenUrl **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaTokenUrl **)soap_malloc(soap, sizeof(tns__submitMediaTokenUrl *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaTokenUrl *)soap_instantiate_tns__submitMediaTokenUrl(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaTokenUrl ** p = (tns__submitMediaTokenUrl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__submitMediaTokenUrl, sizeof(tns__submitMediaTokenUrl), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaTokenUrl(struct soap *soap, tns__submitMediaTokenUrl *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__submitMediaTokenUrl);
	if (soap_out_PointerTotns__submitMediaTokenUrl(soap, tag?tag:"tns:submitMediaTokenUrl", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaTokenUrl ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaTokenUrl(struct soap *soap, tns__submitMediaTokenUrl **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaTokenUrl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaTokenDigestResponse(struct soap *soap, tns__submitMediaTokenDigestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__submitMediaTokenDigestResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaTokenDigestResponse(struct soap *soap, const char *tag, int id, tns__submitMediaTokenDigestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__submitMediaTokenDigestResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaTokenDigestResponse ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaTokenDigestResponse(struct soap *soap, const char *tag, tns__submitMediaTokenDigestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaTokenDigestResponse **)soap_malloc(soap, sizeof(tns__submitMediaTokenDigestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaTokenDigestResponse *)soap_instantiate_tns__submitMediaTokenDigestResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaTokenDigestResponse ** p = (tns__submitMediaTokenDigestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__submitMediaTokenDigestResponse, sizeof(tns__submitMediaTokenDigestResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaTokenDigestResponse(struct soap *soap, tns__submitMediaTokenDigestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__submitMediaTokenDigestResponse);
	if (soap_out_PointerTotns__submitMediaTokenDigestResponse(soap, tag?tag:"tns:submitMediaTokenDigestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaTokenDigestResponse ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaTokenDigestResponse(struct soap *soap, tns__submitMediaTokenDigestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaTokenDigestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaTokenDigest(struct soap *soap, tns__submitMediaTokenDigest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__submitMediaTokenDigest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaTokenDigest(struct soap *soap, const char *tag, int id, tns__submitMediaTokenDigest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__submitMediaTokenDigest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaTokenDigest ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaTokenDigest(struct soap *soap, const char *tag, tns__submitMediaTokenDigest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaTokenDigest **)soap_malloc(soap, sizeof(tns__submitMediaTokenDigest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaTokenDigest *)soap_instantiate_tns__submitMediaTokenDigest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaTokenDigest ** p = (tns__submitMediaTokenDigest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__submitMediaTokenDigest, sizeof(tns__submitMediaTokenDigest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaTokenDigest(struct soap *soap, tns__submitMediaTokenDigest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__submitMediaTokenDigest);
	if (soap_out_PointerTotns__submitMediaTokenDigest(soap, tag?tag:"tns:submitMediaTokenDigest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaTokenDigest ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaTokenDigest(struct soap *soap, tns__submitMediaTokenDigest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaTokenDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaTokenResponse(struct soap *soap, tns__submitMediaTokenResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__submitMediaTokenResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaTokenResponse(struct soap *soap, const char *tag, int id, tns__submitMediaTokenResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__submitMediaTokenResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaTokenResponse ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaTokenResponse(struct soap *soap, const char *tag, tns__submitMediaTokenResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaTokenResponse **)soap_malloc(soap, sizeof(tns__submitMediaTokenResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaTokenResponse *)soap_instantiate_tns__submitMediaTokenResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaTokenResponse ** p = (tns__submitMediaTokenResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__submitMediaTokenResponse, sizeof(tns__submitMediaTokenResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaTokenResponse(struct soap *soap, tns__submitMediaTokenResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__submitMediaTokenResponse);
	if (soap_out_PointerTotns__submitMediaTokenResponse(soap, tag?tag:"tns:submitMediaTokenResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaTokenResponse ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaTokenResponse(struct soap *soap, tns__submitMediaTokenResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaTokenResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaToken(struct soap *soap, tns__submitMediaToken *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__submitMediaToken))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaToken(struct soap *soap, const char *tag, int id, tns__submitMediaToken *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__submitMediaToken);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaToken ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaToken(struct soap *soap, const char *tag, tns__submitMediaToken **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaToken **)soap_malloc(soap, sizeof(tns__submitMediaToken *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaToken *)soap_instantiate_tns__submitMediaToken(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaToken ** p = (tns__submitMediaToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__submitMediaToken, sizeof(tns__submitMediaToken), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaToken(struct soap *soap, tns__submitMediaToken *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__submitMediaToken);
	if (soap_out_PointerTotns__submitMediaToken(soap, tag?tag:"tns:submitMediaToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaToken ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaToken(struct soap *soap, tns__submitMediaToken **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse(struct soap *soap, tns__submitMediaAnnotationTextWithTokenIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__submitMediaAnnotationTextWithTokenIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse(struct soap *soap, const char *tag, int id, tns__submitMediaAnnotationTextWithTokenIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__submitMediaAnnotationTextWithTokenIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextWithTokenIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse(struct soap *soap, const char *tag, tns__submitMediaAnnotationTextWithTokenIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaAnnotationTextWithTokenIdResponse **)soap_malloc(soap, sizeof(tns__submitMediaAnnotationTextWithTokenIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaAnnotationTextWithTokenIdResponse *)soap_instantiate_tns__submitMediaAnnotationTextWithTokenIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaAnnotationTextWithTokenIdResponse ** p = (tns__submitMediaAnnotationTextWithTokenIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__submitMediaAnnotationTextWithTokenIdResponse, sizeof(tns__submitMediaAnnotationTextWithTokenIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse(struct soap *soap, tns__submitMediaAnnotationTextWithTokenIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse);
	if (soap_out_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse(soap, tag?tag:"tns:submitMediaAnnotationTextWithTokenIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextWithTokenIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse(struct soap *soap, tns__submitMediaAnnotationTextWithTokenIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaAnnotationTextWithTokenId(struct soap *soap, tns__submitMediaAnnotationTextWithTokenId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__submitMediaAnnotationTextWithTokenId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaAnnotationTextWithTokenId(struct soap *soap, const char *tag, int id, tns__submitMediaAnnotationTextWithTokenId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__submitMediaAnnotationTextWithTokenId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextWithTokenId ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaAnnotationTextWithTokenId(struct soap *soap, const char *tag, tns__submitMediaAnnotationTextWithTokenId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaAnnotationTextWithTokenId **)soap_malloc(soap, sizeof(tns__submitMediaAnnotationTextWithTokenId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaAnnotationTextWithTokenId *)soap_instantiate_tns__submitMediaAnnotationTextWithTokenId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaAnnotationTextWithTokenId ** p = (tns__submitMediaAnnotationTextWithTokenId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__submitMediaAnnotationTextWithTokenId, sizeof(tns__submitMediaAnnotationTextWithTokenId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaAnnotationTextWithTokenId(struct soap *soap, tns__submitMediaAnnotationTextWithTokenId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__submitMediaAnnotationTextWithTokenId);
	if (soap_out_PointerTotns__submitMediaAnnotationTextWithTokenId(soap, tag?tag:"tns:submitMediaAnnotationTextWithTokenId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextWithTokenId ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaAnnotationTextWithTokenId(struct soap *soap, tns__submitMediaAnnotationTextWithTokenId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaAnnotationTextWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse(struct soap *soap, tns__submitMediaAnnotationTextAndTokenDigestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__submitMediaAnnotationTextAndTokenDigestResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse(struct soap *soap, const char *tag, int id, tns__submitMediaAnnotationTextAndTokenDigestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__submitMediaAnnotationTextAndTokenDigestResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextAndTokenDigestResponse ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse(struct soap *soap, const char *tag, tns__submitMediaAnnotationTextAndTokenDigestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaAnnotationTextAndTokenDigestResponse **)soap_malloc(soap, sizeof(tns__submitMediaAnnotationTextAndTokenDigestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaAnnotationTextAndTokenDigestResponse *)soap_instantiate_tns__submitMediaAnnotationTextAndTokenDigestResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaAnnotationTextAndTokenDigestResponse ** p = (tns__submitMediaAnnotationTextAndTokenDigestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__submitMediaAnnotationTextAndTokenDigestResponse, sizeof(tns__submitMediaAnnotationTextAndTokenDigestResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse(struct soap *soap, tns__submitMediaAnnotationTextAndTokenDigestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse);
	if (soap_out_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse(soap, tag?tag:"tns:submitMediaAnnotationTextAndTokenDigestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextAndTokenDigestResponse ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse(struct soap *soap, tns__submitMediaAnnotationTextAndTokenDigestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, tns__submitMediaAnnotationTextAndTokenDigest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__submitMediaAnnotationTextAndTokenDigest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, const char *tag, int id, tns__submitMediaAnnotationTextAndTokenDigest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__submitMediaAnnotationTextAndTokenDigest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextAndTokenDigest ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, const char *tag, tns__submitMediaAnnotationTextAndTokenDigest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaAnnotationTextAndTokenDigest **)soap_malloc(soap, sizeof(tns__submitMediaAnnotationTextAndTokenDigest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaAnnotationTextAndTokenDigest *)soap_instantiate_tns__submitMediaAnnotationTextAndTokenDigest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaAnnotationTextAndTokenDigest ** p = (tns__submitMediaAnnotationTextAndTokenDigest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__submitMediaAnnotationTextAndTokenDigest, sizeof(tns__submitMediaAnnotationTextAndTokenDigest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, tns__submitMediaAnnotationTextAndTokenDigest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__submitMediaAnnotationTextAndTokenDigest);
	if (soap_out_PointerTotns__submitMediaAnnotationTextAndTokenDigest(soap, tag?tag:"tns:submitMediaAnnotationTextAndTokenDigest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextAndTokenDigest ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, tns__submitMediaAnnotationTextAndTokenDigest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaAnnotationTextAndTokenDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaAnnotationResponse(struct soap *soap, tns__submitMediaAnnotationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__submitMediaAnnotationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaAnnotationResponse(struct soap *soap, const char *tag, int id, tns__submitMediaAnnotationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__submitMediaAnnotationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationResponse ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaAnnotationResponse(struct soap *soap, const char *tag, tns__submitMediaAnnotationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaAnnotationResponse **)soap_malloc(soap, sizeof(tns__submitMediaAnnotationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaAnnotationResponse *)soap_instantiate_tns__submitMediaAnnotationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaAnnotationResponse ** p = (tns__submitMediaAnnotationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__submitMediaAnnotationResponse, sizeof(tns__submitMediaAnnotationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaAnnotationResponse(struct soap *soap, tns__submitMediaAnnotationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__submitMediaAnnotationResponse);
	if (soap_out_PointerTotns__submitMediaAnnotationResponse(soap, tag?tag:"tns:submitMediaAnnotationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaAnnotationResponse ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaAnnotationResponse(struct soap *soap, tns__submitMediaAnnotationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaAnnotationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaAnnotation(struct soap *soap, tns__submitMediaAnnotation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__submitMediaAnnotation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaAnnotation(struct soap *soap, const char *tag, int id, tns__submitMediaAnnotation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__submitMediaAnnotation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaAnnotation ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaAnnotation(struct soap *soap, const char *tag, tns__submitMediaAnnotation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaAnnotation **)soap_malloc(soap, sizeof(tns__submitMediaAnnotation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaAnnotation *)soap_instantiate_tns__submitMediaAnnotation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaAnnotation ** p = (tns__submitMediaAnnotation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__submitMediaAnnotation, sizeof(tns__submitMediaAnnotation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaAnnotation(struct soap *soap, tns__submitMediaAnnotation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__submitMediaAnnotation);
	if (soap_out_PointerTotns__submitMediaAnnotation(soap, tag?tag:"tns:submitMediaAnnotation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaAnnotation ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaAnnotation(struct soap *soap, tns__submitMediaAnnotation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaAnnotation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaAliasTextWithTokenIdResponse(struct soap *soap, tns__submitMediaAliasTextWithTokenIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__submitMediaAliasTextWithTokenIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaAliasTextWithTokenIdResponse(struct soap *soap, const char *tag, int id, tns__submitMediaAliasTextWithTokenIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__submitMediaAliasTextWithTokenIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaAliasTextWithTokenIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaAliasTextWithTokenIdResponse(struct soap *soap, const char *tag, tns__submitMediaAliasTextWithTokenIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaAliasTextWithTokenIdResponse **)soap_malloc(soap, sizeof(tns__submitMediaAliasTextWithTokenIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaAliasTextWithTokenIdResponse *)soap_instantiate_tns__submitMediaAliasTextWithTokenIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaAliasTextWithTokenIdResponse ** p = (tns__submitMediaAliasTextWithTokenIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__submitMediaAliasTextWithTokenIdResponse, sizeof(tns__submitMediaAliasTextWithTokenIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaAliasTextWithTokenIdResponse(struct soap *soap, tns__submitMediaAliasTextWithTokenIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__submitMediaAliasTextWithTokenIdResponse);
	if (soap_out_PointerTotns__submitMediaAliasTextWithTokenIdResponse(soap, tag?tag:"tns:submitMediaAliasTextWithTokenIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaAliasTextWithTokenIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaAliasTextWithTokenIdResponse(struct soap *soap, tns__submitMediaAliasTextWithTokenIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaAliasTextWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaAliasTextWithTokenId(struct soap *soap, tns__submitMediaAliasTextWithTokenId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__submitMediaAliasTextWithTokenId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaAliasTextWithTokenId(struct soap *soap, const char *tag, int id, tns__submitMediaAliasTextWithTokenId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__submitMediaAliasTextWithTokenId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaAliasTextWithTokenId ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaAliasTextWithTokenId(struct soap *soap, const char *tag, tns__submitMediaAliasTextWithTokenId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaAliasTextWithTokenId **)soap_malloc(soap, sizeof(tns__submitMediaAliasTextWithTokenId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaAliasTextWithTokenId *)soap_instantiate_tns__submitMediaAliasTextWithTokenId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaAliasTextWithTokenId ** p = (tns__submitMediaAliasTextWithTokenId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__submitMediaAliasTextWithTokenId, sizeof(tns__submitMediaAliasTextWithTokenId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaAliasTextWithTokenId(struct soap *soap, tns__submitMediaAliasTextWithTokenId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__submitMediaAliasTextWithTokenId);
	if (soap_out_PointerTotns__submitMediaAliasTextWithTokenId(soap, tag?tag:"tns:submitMediaAliasTextWithTokenId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaAliasTextWithTokenId ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaAliasTextWithTokenId(struct soap *soap, tns__submitMediaAliasTextWithTokenId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaAliasTextWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaAliasTextAndTokenDigestResponse(struct soap *soap, tns__submitMediaAliasTextAndTokenDigestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__submitMediaAliasTextAndTokenDigestResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaAliasTextAndTokenDigestResponse(struct soap *soap, const char *tag, int id, tns__submitMediaAliasTextAndTokenDigestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__submitMediaAliasTextAndTokenDigestResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaAliasTextAndTokenDigestResponse ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaAliasTextAndTokenDigestResponse(struct soap *soap, const char *tag, tns__submitMediaAliasTextAndTokenDigestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaAliasTextAndTokenDigestResponse **)soap_malloc(soap, sizeof(tns__submitMediaAliasTextAndTokenDigestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaAliasTextAndTokenDigestResponse *)soap_instantiate_tns__submitMediaAliasTextAndTokenDigestResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaAliasTextAndTokenDigestResponse ** p = (tns__submitMediaAliasTextAndTokenDigestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__submitMediaAliasTextAndTokenDigestResponse, sizeof(tns__submitMediaAliasTextAndTokenDigestResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaAliasTextAndTokenDigestResponse(struct soap *soap, tns__submitMediaAliasTextAndTokenDigestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__submitMediaAliasTextAndTokenDigestResponse);
	if (soap_out_PointerTotns__submitMediaAliasTextAndTokenDigestResponse(soap, tag?tag:"tns:submitMediaAliasTextAndTokenDigestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaAliasTextAndTokenDigestResponse ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaAliasTextAndTokenDigestResponse(struct soap *soap, tns__submitMediaAliasTextAndTokenDigestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaAliasTextAndTokenDigestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaAliasTextAndTokenDigest(struct soap *soap, tns__submitMediaAliasTextAndTokenDigest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__submitMediaAliasTextAndTokenDigest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaAliasTextAndTokenDigest(struct soap *soap, const char *tag, int id, tns__submitMediaAliasTextAndTokenDigest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__submitMediaAliasTextAndTokenDigest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaAliasTextAndTokenDigest ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaAliasTextAndTokenDigest(struct soap *soap, const char *tag, tns__submitMediaAliasTextAndTokenDigest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaAliasTextAndTokenDigest **)soap_malloc(soap, sizeof(tns__submitMediaAliasTextAndTokenDigest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaAliasTextAndTokenDigest *)soap_instantiate_tns__submitMediaAliasTextAndTokenDigest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaAliasTextAndTokenDigest ** p = (tns__submitMediaAliasTextAndTokenDigest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__submitMediaAliasTextAndTokenDigest, sizeof(tns__submitMediaAliasTextAndTokenDigest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaAliasTextAndTokenDigest(struct soap *soap, tns__submitMediaAliasTextAndTokenDigest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__submitMediaAliasTextAndTokenDigest);
	if (soap_out_PointerTotns__submitMediaAliasTextAndTokenDigest(soap, tag?tag:"tns:submitMediaAliasTextAndTokenDigest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaAliasTextAndTokenDigest ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaAliasTextAndTokenDigest(struct soap *soap, tns__submitMediaAliasTextAndTokenDigest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaAliasTextAndTokenDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaAliasResponse(struct soap *soap, tns__submitMediaAliasResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__submitMediaAliasResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaAliasResponse(struct soap *soap, const char *tag, int id, tns__submitMediaAliasResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__submitMediaAliasResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaAliasResponse ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaAliasResponse(struct soap *soap, const char *tag, tns__submitMediaAliasResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaAliasResponse **)soap_malloc(soap, sizeof(tns__submitMediaAliasResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaAliasResponse *)soap_instantiate_tns__submitMediaAliasResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaAliasResponse ** p = (tns__submitMediaAliasResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__submitMediaAliasResponse, sizeof(tns__submitMediaAliasResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaAliasResponse(struct soap *soap, tns__submitMediaAliasResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__submitMediaAliasResponse);
	if (soap_out_PointerTotns__submitMediaAliasResponse(soap, tag?tag:"tns:submitMediaAliasResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaAliasResponse ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaAliasResponse(struct soap *soap, tns__submitMediaAliasResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaAliasResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaAlias(struct soap *soap, tns__submitMediaAlias *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__submitMediaAlias))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaAlias(struct soap *soap, const char *tag, int id, tns__submitMediaAlias *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__submitMediaAlias);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaAlias ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaAlias(struct soap *soap, const char *tag, tns__submitMediaAlias **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaAlias **)soap_malloc(soap, sizeof(tns__submitMediaAlias *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaAlias *)soap_instantiate_tns__submitMediaAlias(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaAlias ** p = (tns__submitMediaAlias **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__submitMediaAlias, sizeof(tns__submitMediaAlias), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaAlias(struct soap *soap, tns__submitMediaAlias *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__submitMediaAlias);
	if (soap_out_PointerTotns__submitMediaAlias(soap, tag?tag:"tns:submitMediaAlias", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaAlias ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaAlias(struct soap *soap, tns__submitMediaAlias **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaAlias(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitGameThreadResponse(struct soap *soap, tns__submitGameThreadResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__submitGameThreadResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitGameThreadResponse(struct soap *soap, const char *tag, int id, tns__submitGameThreadResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__submitGameThreadResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitGameThreadResponse ** SOAP_FMAC4 soap_in_PointerTotns__submitGameThreadResponse(struct soap *soap, const char *tag, tns__submitGameThreadResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitGameThreadResponse **)soap_malloc(soap, sizeof(tns__submitGameThreadResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitGameThreadResponse *)soap_instantiate_tns__submitGameThreadResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitGameThreadResponse ** p = (tns__submitGameThreadResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__submitGameThreadResponse, sizeof(tns__submitGameThreadResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitGameThreadResponse(struct soap *soap, tns__submitGameThreadResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__submitGameThreadResponse);
	if (soap_out_PointerTotns__submitGameThreadResponse(soap, tag?tag:"tns:submitGameThreadResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitGameThreadResponse ** SOAP_FMAC4 soap_get_PointerTotns__submitGameThreadResponse(struct soap *soap, tns__submitGameThreadResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitGameThreadResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitGameThread(struct soap *soap, tns__submitGameThread *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__submitGameThread))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitGameThread(struct soap *soap, const char *tag, int id, tns__submitGameThread *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__submitGameThread);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitGameThread ** SOAP_FMAC4 soap_in_PointerTotns__submitGameThread(struct soap *soap, const char *tag, tns__submitGameThread **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitGameThread **)soap_malloc(soap, sizeof(tns__submitGameThread *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitGameThread *)soap_instantiate_tns__submitGameThread(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitGameThread ** p = (tns__submitGameThread **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__submitGameThread, sizeof(tns__submitGameThread), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitGameThread(struct soap *soap, tns__submitGameThread *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__submitGameThread);
	if (soap_out_PointerTotns__submitGameThread(soap, tag?tag:"tns:submitGameThread", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitGameThread ** SOAP_FMAC4 soap_get_PointerTotns__submitGameThread(struct soap *soap, tns__submitGameThread **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitGameThread(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__setUserLanguageResponse(struct soap *soap, tns__setUserLanguageResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__setUserLanguageResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__setUserLanguageResponse(struct soap *soap, const char *tag, int id, tns__setUserLanguageResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__setUserLanguageResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__setUserLanguageResponse ** SOAP_FMAC4 soap_in_PointerTotns__setUserLanguageResponse(struct soap *soap, const char *tag, tns__setUserLanguageResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__setUserLanguageResponse **)soap_malloc(soap, sizeof(tns__setUserLanguageResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__setUserLanguageResponse *)soap_instantiate_tns__setUserLanguageResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__setUserLanguageResponse ** p = (tns__setUserLanguageResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__setUserLanguageResponse, sizeof(tns__setUserLanguageResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__setUserLanguageResponse(struct soap *soap, tns__setUserLanguageResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__setUserLanguageResponse);
	if (soap_out_PointerTotns__setUserLanguageResponse(soap, tag?tag:"tns:setUserLanguageResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__setUserLanguageResponse ** SOAP_FMAC4 soap_get_PointerTotns__setUserLanguageResponse(struct soap *soap, tns__setUserLanguageResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__setUserLanguageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__setUserLanguage(struct soap *soap, tns__setUserLanguage *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__setUserLanguage))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__setUserLanguage(struct soap *soap, const char *tag, int id, tns__setUserLanguage *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__setUserLanguage);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__setUserLanguage ** SOAP_FMAC4 soap_in_PointerTotns__setUserLanguage(struct soap *soap, const char *tag, tns__setUserLanguage **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__setUserLanguage **)soap_malloc(soap, sizeof(tns__setUserLanguage *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__setUserLanguage *)soap_instantiate_tns__setUserLanguage(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__setUserLanguage ** p = (tns__setUserLanguage **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__setUserLanguage, sizeof(tns__setUserLanguage), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__setUserLanguage(struct soap *soap, tns__setUserLanguage *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__setUserLanguage);
	if (soap_out_PointerTotns__setUserLanguage(soap, tag?tag:"tns:setUserLanguage", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__setUserLanguage ** SOAP_FMAC4 soap_get_PointerTotns__setUserLanguage(struct soap *soap, tns__setUserLanguage **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__setUserLanguage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__setUserAnonymousResponse(struct soap *soap, tns__setUserAnonymousResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__setUserAnonymousResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__setUserAnonymousResponse(struct soap *soap, const char *tag, int id, tns__setUserAnonymousResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__setUserAnonymousResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__setUserAnonymousResponse ** SOAP_FMAC4 soap_in_PointerTotns__setUserAnonymousResponse(struct soap *soap, const char *tag, tns__setUserAnonymousResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__setUserAnonymousResponse **)soap_malloc(soap, sizeof(tns__setUserAnonymousResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__setUserAnonymousResponse *)soap_instantiate_tns__setUserAnonymousResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__setUserAnonymousResponse ** p = (tns__setUserAnonymousResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__setUserAnonymousResponse, sizeof(tns__setUserAnonymousResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__setUserAnonymousResponse(struct soap *soap, tns__setUserAnonymousResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__setUserAnonymousResponse);
	if (soap_out_PointerTotns__setUserAnonymousResponse(soap, tag?tag:"tns:setUserAnonymousResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__setUserAnonymousResponse ** SOAP_FMAC4 soap_get_PointerTotns__setUserAnonymousResponse(struct soap *soap, tns__setUserAnonymousResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__setUserAnonymousResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__setUserAnonymous(struct soap *soap, tns__setUserAnonymous *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__setUserAnonymous))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__setUserAnonymous(struct soap *soap, const char *tag, int id, tns__setUserAnonymous *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__setUserAnonymous);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__setUserAnonymous ** SOAP_FMAC4 soap_in_PointerTotns__setUserAnonymous(struct soap *soap, const char *tag, tns__setUserAnonymous **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__setUserAnonymous **)soap_malloc(soap, sizeof(tns__setUserAnonymous *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__setUserAnonymous *)soap_instantiate_tns__setUserAnonymous(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__setUserAnonymous ** p = (tns__setUserAnonymous **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__setUserAnonymous, sizeof(tns__setUserAnonymous), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__setUserAnonymous(struct soap *soap, tns__setUserAnonymous *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__setUserAnonymous);
	if (soap_out_PointerTotns__setUserAnonymous(soap, tag?tag:"tns:setUserAnonymous", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__setUserAnonymous ** SOAP_FMAC4 soap_get_PointerTotns__setUserAnonymous(struct soap *soap, tns__setUserAnonymous **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__setUserAnonymous(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse(struct soap *soap, tns__selectRelatedMediaAnnotationsWithTokenIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__selectRelatedMediaAnnotationsWithTokenIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse(struct soap *soap, const char *tag, int id, tns__selectRelatedMediaAnnotationsWithTokenIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__selectRelatedMediaAnnotationsWithTokenIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectRelatedMediaAnnotationsWithTokenIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse(struct soap *soap, const char *tag, tns__selectRelatedMediaAnnotationsWithTokenIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectRelatedMediaAnnotationsWithTokenIdResponse **)soap_malloc(soap, sizeof(tns__selectRelatedMediaAnnotationsWithTokenIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectRelatedMediaAnnotationsWithTokenIdResponse *)soap_instantiate_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectRelatedMediaAnnotationsWithTokenIdResponse ** p = (tns__selectRelatedMediaAnnotationsWithTokenIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__selectRelatedMediaAnnotationsWithTokenIdResponse, sizeof(tns__selectRelatedMediaAnnotationsWithTokenIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse(struct soap *soap, tns__selectRelatedMediaAnnotationsWithTokenIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse);
	if (soap_out_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse(soap, tag?tag:"tns:selectRelatedMediaAnnotationsWithTokenIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectRelatedMediaAnnotationsWithTokenIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse(struct soap *soap, tns__selectRelatedMediaAnnotationsWithTokenIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, tns__selectRelatedMediaAnnotationsWithTokenId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__selectRelatedMediaAnnotationsWithTokenId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, const char *tag, int id, tns__selectRelatedMediaAnnotationsWithTokenId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__selectRelatedMediaAnnotationsWithTokenId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectRelatedMediaAnnotationsWithTokenId ** SOAP_FMAC4 soap_in_PointerTotns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, const char *tag, tns__selectRelatedMediaAnnotationsWithTokenId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectRelatedMediaAnnotationsWithTokenId **)soap_malloc(soap, sizeof(tns__selectRelatedMediaAnnotationsWithTokenId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectRelatedMediaAnnotationsWithTokenId *)soap_instantiate_tns__selectRelatedMediaAnnotationsWithTokenId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectRelatedMediaAnnotationsWithTokenId ** p = (tns__selectRelatedMediaAnnotationsWithTokenId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__selectRelatedMediaAnnotationsWithTokenId, sizeof(tns__selectRelatedMediaAnnotationsWithTokenId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, tns__selectRelatedMediaAnnotationsWithTokenId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__selectRelatedMediaAnnotationsWithTokenId);
	if (soap_out_PointerTotns__selectRelatedMediaAnnotationsWithTokenId(soap, tag?tag:"tns:selectRelatedMediaAnnotationsWithTokenId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectRelatedMediaAnnotationsWithTokenId ** SOAP_FMAC4 soap_get_PointerTotns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, tns__selectRelatedMediaAnnotationsWithTokenId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectRelatedMediaAnnotationsWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectRelatedMediaAliasesWithTokenIdResponse(struct soap *soap, tns__selectRelatedMediaAliasesWithTokenIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__selectRelatedMediaAliasesWithTokenIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectRelatedMediaAliasesWithTokenIdResponse(struct soap *soap, const char *tag, int id, tns__selectRelatedMediaAliasesWithTokenIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__selectRelatedMediaAliasesWithTokenIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectRelatedMediaAliasesWithTokenIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__selectRelatedMediaAliasesWithTokenIdResponse(struct soap *soap, const char *tag, tns__selectRelatedMediaAliasesWithTokenIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectRelatedMediaAliasesWithTokenIdResponse **)soap_malloc(soap, sizeof(tns__selectRelatedMediaAliasesWithTokenIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectRelatedMediaAliasesWithTokenIdResponse *)soap_instantiate_tns__selectRelatedMediaAliasesWithTokenIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectRelatedMediaAliasesWithTokenIdResponse ** p = (tns__selectRelatedMediaAliasesWithTokenIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__selectRelatedMediaAliasesWithTokenIdResponse, sizeof(tns__selectRelatedMediaAliasesWithTokenIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectRelatedMediaAliasesWithTokenIdResponse(struct soap *soap, tns__selectRelatedMediaAliasesWithTokenIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__selectRelatedMediaAliasesWithTokenIdResponse);
	if (soap_out_PointerTotns__selectRelatedMediaAliasesWithTokenIdResponse(soap, tag?tag:"tns:selectRelatedMediaAliasesWithTokenIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectRelatedMediaAliasesWithTokenIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__selectRelatedMediaAliasesWithTokenIdResponse(struct soap *soap, tns__selectRelatedMediaAliasesWithTokenIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectRelatedMediaAliasesWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectRelatedMediaAliasesWithTokenId(struct soap *soap, tns__selectRelatedMediaAliasesWithTokenId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__selectRelatedMediaAliasesWithTokenId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectRelatedMediaAliasesWithTokenId(struct soap *soap, const char *tag, int id, tns__selectRelatedMediaAliasesWithTokenId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__selectRelatedMediaAliasesWithTokenId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectRelatedMediaAliasesWithTokenId ** SOAP_FMAC4 soap_in_PointerTotns__selectRelatedMediaAliasesWithTokenId(struct soap *soap, const char *tag, tns__selectRelatedMediaAliasesWithTokenId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectRelatedMediaAliasesWithTokenId **)soap_malloc(soap, sizeof(tns__selectRelatedMediaAliasesWithTokenId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectRelatedMediaAliasesWithTokenId *)soap_instantiate_tns__selectRelatedMediaAliasesWithTokenId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectRelatedMediaAliasesWithTokenId ** p = (tns__selectRelatedMediaAliasesWithTokenId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__selectRelatedMediaAliasesWithTokenId, sizeof(tns__selectRelatedMediaAliasesWithTokenId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectRelatedMediaAliasesWithTokenId(struct soap *soap, tns__selectRelatedMediaAliasesWithTokenId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__selectRelatedMediaAliasesWithTokenId);
	if (soap_out_PointerTotns__selectRelatedMediaAliasesWithTokenId(soap, tag?tag:"tns:selectRelatedMediaAliasesWithTokenId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectRelatedMediaAliasesWithTokenId ** SOAP_FMAC4 soap_get_PointerTotns__selectRelatedMediaAliasesWithTokenId(struct soap *soap, tns__selectRelatedMediaAliasesWithTokenId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectRelatedMediaAliasesWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectMediaTokenWithIdResponse(struct soap *soap, tns__selectMediaTokenWithIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__selectMediaTokenWithIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectMediaTokenWithIdResponse(struct soap *soap, const char *tag, int id, tns__selectMediaTokenWithIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__selectMediaTokenWithIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectMediaTokenWithIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__selectMediaTokenWithIdResponse(struct soap *soap, const char *tag, tns__selectMediaTokenWithIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectMediaTokenWithIdResponse **)soap_malloc(soap, sizeof(tns__selectMediaTokenWithIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectMediaTokenWithIdResponse *)soap_instantiate_tns__selectMediaTokenWithIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectMediaTokenWithIdResponse ** p = (tns__selectMediaTokenWithIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__selectMediaTokenWithIdResponse, sizeof(tns__selectMediaTokenWithIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectMediaTokenWithIdResponse(struct soap *soap, tns__selectMediaTokenWithIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__selectMediaTokenWithIdResponse);
	if (soap_out_PointerTotns__selectMediaTokenWithIdResponse(soap, tag?tag:"tns:selectMediaTokenWithIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectMediaTokenWithIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__selectMediaTokenWithIdResponse(struct soap *soap, tns__selectMediaTokenWithIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectMediaTokenWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectMediaTokenWithId(struct soap *soap, tns__selectMediaTokenWithId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__selectMediaTokenWithId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectMediaTokenWithId(struct soap *soap, const char *tag, int id, tns__selectMediaTokenWithId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__selectMediaTokenWithId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectMediaTokenWithId ** SOAP_FMAC4 soap_in_PointerTotns__selectMediaTokenWithId(struct soap *soap, const char *tag, tns__selectMediaTokenWithId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectMediaTokenWithId **)soap_malloc(soap, sizeof(tns__selectMediaTokenWithId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectMediaTokenWithId *)soap_instantiate_tns__selectMediaTokenWithId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectMediaTokenWithId ** p = (tns__selectMediaTokenWithId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__selectMediaTokenWithId, sizeof(tns__selectMediaTokenWithId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectMediaTokenWithId(struct soap *soap, tns__selectMediaTokenWithId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__selectMediaTokenWithId);
	if (soap_out_PointerTotns__selectMediaTokenWithId(soap, tag?tag:"tns:selectMediaTokenWithId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectMediaTokenWithId ** SOAP_FMAC4 soap_get_PointerTotns__selectMediaTokenWithId(struct soap *soap, tns__selectMediaTokenWithId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectMediaTokenWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectMediaTokenWithDigestResponse(struct soap *soap, tns__selectMediaTokenWithDigestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__selectMediaTokenWithDigestResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectMediaTokenWithDigestResponse(struct soap *soap, const char *tag, int id, tns__selectMediaTokenWithDigestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__selectMediaTokenWithDigestResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectMediaTokenWithDigestResponse ** SOAP_FMAC4 soap_in_PointerTotns__selectMediaTokenWithDigestResponse(struct soap *soap, const char *tag, tns__selectMediaTokenWithDigestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectMediaTokenWithDigestResponse **)soap_malloc(soap, sizeof(tns__selectMediaTokenWithDigestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectMediaTokenWithDigestResponse *)soap_instantiate_tns__selectMediaTokenWithDigestResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectMediaTokenWithDigestResponse ** p = (tns__selectMediaTokenWithDigestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__selectMediaTokenWithDigestResponse, sizeof(tns__selectMediaTokenWithDigestResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectMediaTokenWithDigestResponse(struct soap *soap, tns__selectMediaTokenWithDigestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__selectMediaTokenWithDigestResponse);
	if (soap_out_PointerTotns__selectMediaTokenWithDigestResponse(soap, tag?tag:"tns:selectMediaTokenWithDigestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectMediaTokenWithDigestResponse ** SOAP_FMAC4 soap_get_PointerTotns__selectMediaTokenWithDigestResponse(struct soap *soap, tns__selectMediaTokenWithDigestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectMediaTokenWithDigestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectMediaTokenWithDigest(struct soap *soap, tns__selectMediaTokenWithDigest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__selectMediaTokenWithDigest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectMediaTokenWithDigest(struct soap *soap, const char *tag, int id, tns__selectMediaTokenWithDigest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__selectMediaTokenWithDigest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectMediaTokenWithDigest ** SOAP_FMAC4 soap_in_PointerTotns__selectMediaTokenWithDigest(struct soap *soap, const char *tag, tns__selectMediaTokenWithDigest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectMediaTokenWithDigest **)soap_malloc(soap, sizeof(tns__selectMediaTokenWithDigest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectMediaTokenWithDigest *)soap_instantiate_tns__selectMediaTokenWithDigest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectMediaTokenWithDigest ** p = (tns__selectMediaTokenWithDigest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__selectMediaTokenWithDigest, sizeof(tns__selectMediaTokenWithDigest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectMediaTokenWithDigest(struct soap *soap, tns__selectMediaTokenWithDigest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__selectMediaTokenWithDigest);
	if (soap_out_PointerTotns__selectMediaTokenWithDigest(soap, tag?tag:"tns:selectMediaTokenWithDigest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectMediaTokenWithDigest ** SOAP_FMAC4 soap_get_PointerTotns__selectMediaTokenWithDigest(struct soap *soap, tns__selectMediaTokenWithDigest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectMediaTokenWithDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectMediaTokenIdWithUrlResponse(struct soap *soap, tns__selectMediaTokenIdWithUrlResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__selectMediaTokenIdWithUrlResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectMediaTokenIdWithUrlResponse(struct soap *soap, const char *tag, int id, tns__selectMediaTokenIdWithUrlResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__selectMediaTokenIdWithUrlResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectMediaTokenIdWithUrlResponse ** SOAP_FMAC4 soap_in_PointerTotns__selectMediaTokenIdWithUrlResponse(struct soap *soap, const char *tag, tns__selectMediaTokenIdWithUrlResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectMediaTokenIdWithUrlResponse **)soap_malloc(soap, sizeof(tns__selectMediaTokenIdWithUrlResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectMediaTokenIdWithUrlResponse *)soap_instantiate_tns__selectMediaTokenIdWithUrlResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectMediaTokenIdWithUrlResponse ** p = (tns__selectMediaTokenIdWithUrlResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__selectMediaTokenIdWithUrlResponse, sizeof(tns__selectMediaTokenIdWithUrlResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectMediaTokenIdWithUrlResponse(struct soap *soap, tns__selectMediaTokenIdWithUrlResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__selectMediaTokenIdWithUrlResponse);
	if (soap_out_PointerTotns__selectMediaTokenIdWithUrlResponse(soap, tag?tag:"tns:selectMediaTokenIdWithUrlResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectMediaTokenIdWithUrlResponse ** SOAP_FMAC4 soap_get_PointerTotns__selectMediaTokenIdWithUrlResponse(struct soap *soap, tns__selectMediaTokenIdWithUrlResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectMediaTokenIdWithUrlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectMediaTokenIdWithUrl(struct soap *soap, tns__selectMediaTokenIdWithUrl *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__selectMediaTokenIdWithUrl))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectMediaTokenIdWithUrl(struct soap *soap, const char *tag, int id, tns__selectMediaTokenIdWithUrl *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__selectMediaTokenIdWithUrl);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectMediaTokenIdWithUrl ** SOAP_FMAC4 soap_in_PointerTotns__selectMediaTokenIdWithUrl(struct soap *soap, const char *tag, tns__selectMediaTokenIdWithUrl **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectMediaTokenIdWithUrl **)soap_malloc(soap, sizeof(tns__selectMediaTokenIdWithUrl *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectMediaTokenIdWithUrl *)soap_instantiate_tns__selectMediaTokenIdWithUrl(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectMediaTokenIdWithUrl ** p = (tns__selectMediaTokenIdWithUrl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__selectMediaTokenIdWithUrl, sizeof(tns__selectMediaTokenIdWithUrl), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectMediaTokenIdWithUrl(struct soap *soap, tns__selectMediaTokenIdWithUrl *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__selectMediaTokenIdWithUrl);
	if (soap_out_PointerTotns__selectMediaTokenIdWithUrl(soap, tag?tag:"tns:selectMediaTokenIdWithUrl", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectMediaTokenIdWithUrl ** SOAP_FMAC4 soap_get_PointerTotns__selectMediaTokenIdWithUrl(struct soap *soap, tns__selectMediaTokenIdWithUrl **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectMediaTokenIdWithUrl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectMediaTokenIdWithDigestResponse(struct soap *soap, tns__selectMediaTokenIdWithDigestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__selectMediaTokenIdWithDigestResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectMediaTokenIdWithDigestResponse(struct soap *soap, const char *tag, int id, tns__selectMediaTokenIdWithDigestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__selectMediaTokenIdWithDigestResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectMediaTokenIdWithDigestResponse ** SOAP_FMAC4 soap_in_PointerTotns__selectMediaTokenIdWithDigestResponse(struct soap *soap, const char *tag, tns__selectMediaTokenIdWithDigestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectMediaTokenIdWithDigestResponse **)soap_malloc(soap, sizeof(tns__selectMediaTokenIdWithDigestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectMediaTokenIdWithDigestResponse *)soap_instantiate_tns__selectMediaTokenIdWithDigestResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectMediaTokenIdWithDigestResponse ** p = (tns__selectMediaTokenIdWithDigestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__selectMediaTokenIdWithDigestResponse, sizeof(tns__selectMediaTokenIdWithDigestResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectMediaTokenIdWithDigestResponse(struct soap *soap, tns__selectMediaTokenIdWithDigestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__selectMediaTokenIdWithDigestResponse);
	if (soap_out_PointerTotns__selectMediaTokenIdWithDigestResponse(soap, tag?tag:"tns:selectMediaTokenIdWithDigestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectMediaTokenIdWithDigestResponse ** SOAP_FMAC4 soap_get_PointerTotns__selectMediaTokenIdWithDigestResponse(struct soap *soap, tns__selectMediaTokenIdWithDigestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectMediaTokenIdWithDigestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectMediaTokenIdWithDigest(struct soap *soap, tns__selectMediaTokenIdWithDigest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__selectMediaTokenIdWithDigest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectMediaTokenIdWithDigest(struct soap *soap, const char *tag, int id, tns__selectMediaTokenIdWithDigest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__selectMediaTokenIdWithDigest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectMediaTokenIdWithDigest ** SOAP_FMAC4 soap_in_PointerTotns__selectMediaTokenIdWithDigest(struct soap *soap, const char *tag, tns__selectMediaTokenIdWithDigest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectMediaTokenIdWithDigest **)soap_malloc(soap, sizeof(tns__selectMediaTokenIdWithDigest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectMediaTokenIdWithDigest *)soap_instantiate_tns__selectMediaTokenIdWithDigest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectMediaTokenIdWithDigest ** p = (tns__selectMediaTokenIdWithDigest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__selectMediaTokenIdWithDigest, sizeof(tns__selectMediaTokenIdWithDigest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectMediaTokenIdWithDigest(struct soap *soap, tns__selectMediaTokenIdWithDigest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__selectMediaTokenIdWithDigest);
	if (soap_out_PointerTotns__selectMediaTokenIdWithDigest(soap, tag?tag:"tns:selectMediaTokenIdWithDigest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectMediaTokenIdWithDigest ** SOAP_FMAC4 soap_get_PointerTotns__selectMediaTokenIdWithDigest(struct soap *soap, tns__selectMediaTokenIdWithDigest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectMediaTokenIdWithDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectMediaAnnotationsWithTokenIdResponse(struct soap *soap, tns__selectMediaAnnotationsWithTokenIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__selectMediaAnnotationsWithTokenIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectMediaAnnotationsWithTokenIdResponse(struct soap *soap, const char *tag, int id, tns__selectMediaAnnotationsWithTokenIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__selectMediaAnnotationsWithTokenIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectMediaAnnotationsWithTokenIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__selectMediaAnnotationsWithTokenIdResponse(struct soap *soap, const char *tag, tns__selectMediaAnnotationsWithTokenIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectMediaAnnotationsWithTokenIdResponse **)soap_malloc(soap, sizeof(tns__selectMediaAnnotationsWithTokenIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectMediaAnnotationsWithTokenIdResponse *)soap_instantiate_tns__selectMediaAnnotationsWithTokenIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectMediaAnnotationsWithTokenIdResponse ** p = (tns__selectMediaAnnotationsWithTokenIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__selectMediaAnnotationsWithTokenIdResponse, sizeof(tns__selectMediaAnnotationsWithTokenIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectMediaAnnotationsWithTokenIdResponse(struct soap *soap, tns__selectMediaAnnotationsWithTokenIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__selectMediaAnnotationsWithTokenIdResponse);
	if (soap_out_PointerTotns__selectMediaAnnotationsWithTokenIdResponse(soap, tag?tag:"tns:selectMediaAnnotationsWithTokenIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectMediaAnnotationsWithTokenIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__selectMediaAnnotationsWithTokenIdResponse(struct soap *soap, tns__selectMediaAnnotationsWithTokenIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectMediaAnnotationsWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectMediaAnnotationsWithTokenId(struct soap *soap, tns__selectMediaAnnotationsWithTokenId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__selectMediaAnnotationsWithTokenId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectMediaAnnotationsWithTokenId(struct soap *soap, const char *tag, int id, tns__selectMediaAnnotationsWithTokenId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__selectMediaAnnotationsWithTokenId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectMediaAnnotationsWithTokenId ** SOAP_FMAC4 soap_in_PointerTotns__selectMediaAnnotationsWithTokenId(struct soap *soap, const char *tag, tns__selectMediaAnnotationsWithTokenId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectMediaAnnotationsWithTokenId **)soap_malloc(soap, sizeof(tns__selectMediaAnnotationsWithTokenId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectMediaAnnotationsWithTokenId *)soap_instantiate_tns__selectMediaAnnotationsWithTokenId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectMediaAnnotationsWithTokenId ** p = (tns__selectMediaAnnotationsWithTokenId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__selectMediaAnnotationsWithTokenId, sizeof(tns__selectMediaAnnotationsWithTokenId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectMediaAnnotationsWithTokenId(struct soap *soap, tns__selectMediaAnnotationsWithTokenId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__selectMediaAnnotationsWithTokenId);
	if (soap_out_PointerTotns__selectMediaAnnotationsWithTokenId(soap, tag?tag:"tns:selectMediaAnnotationsWithTokenId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectMediaAnnotationsWithTokenId ** SOAP_FMAC4 soap_get_PointerTotns__selectMediaAnnotationsWithTokenId(struct soap *soap, tns__selectMediaAnnotationsWithTokenId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectMediaAnnotationsWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectMediaAliasesWithTokenIdResponse(struct soap *soap, tns__selectMediaAliasesWithTokenIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__selectMediaAliasesWithTokenIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectMediaAliasesWithTokenIdResponse(struct soap *soap, const char *tag, int id, tns__selectMediaAliasesWithTokenIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__selectMediaAliasesWithTokenIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectMediaAliasesWithTokenIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__selectMediaAliasesWithTokenIdResponse(struct soap *soap, const char *tag, tns__selectMediaAliasesWithTokenIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectMediaAliasesWithTokenIdResponse **)soap_malloc(soap, sizeof(tns__selectMediaAliasesWithTokenIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectMediaAliasesWithTokenIdResponse *)soap_instantiate_tns__selectMediaAliasesWithTokenIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectMediaAliasesWithTokenIdResponse ** p = (tns__selectMediaAliasesWithTokenIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__selectMediaAliasesWithTokenIdResponse, sizeof(tns__selectMediaAliasesWithTokenIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectMediaAliasesWithTokenIdResponse(struct soap *soap, tns__selectMediaAliasesWithTokenIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__selectMediaAliasesWithTokenIdResponse);
	if (soap_out_PointerTotns__selectMediaAliasesWithTokenIdResponse(soap, tag?tag:"tns:selectMediaAliasesWithTokenIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectMediaAliasesWithTokenIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__selectMediaAliasesWithTokenIdResponse(struct soap *soap, tns__selectMediaAliasesWithTokenIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectMediaAliasesWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectMediaAliasesWithTokenId(struct soap *soap, tns__selectMediaAliasesWithTokenId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__selectMediaAliasesWithTokenId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectMediaAliasesWithTokenId(struct soap *soap, const char *tag, int id, tns__selectMediaAliasesWithTokenId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__selectMediaAliasesWithTokenId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectMediaAliasesWithTokenId ** SOAP_FMAC4 soap_in_PointerTotns__selectMediaAliasesWithTokenId(struct soap *soap, const char *tag, tns__selectMediaAliasesWithTokenId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectMediaAliasesWithTokenId **)soap_malloc(soap, sizeof(tns__selectMediaAliasesWithTokenId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectMediaAliasesWithTokenId *)soap_instantiate_tns__selectMediaAliasesWithTokenId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectMediaAliasesWithTokenId ** p = (tns__selectMediaAliasesWithTokenId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__selectMediaAliasesWithTokenId, sizeof(tns__selectMediaAliasesWithTokenId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectMediaAliasesWithTokenId(struct soap *soap, tns__selectMediaAliasesWithTokenId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__selectMediaAliasesWithTokenId);
	if (soap_out_PointerTotns__selectMediaAliasesWithTokenId(soap, tag?tag:"tns:selectMediaAliasesWithTokenId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectMediaAliasesWithTokenId ** SOAP_FMAC4 soap_get_PointerTotns__selectMediaAliasesWithTokenId(struct soap *soap, tns__selectMediaAliasesWithTokenId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectMediaAliasesWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectGameThreadWithTokenIdResponse(struct soap *soap, tns__selectGameThreadWithTokenIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__selectGameThreadWithTokenIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectGameThreadWithTokenIdResponse(struct soap *soap, const char *tag, int id, tns__selectGameThreadWithTokenIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__selectGameThreadWithTokenIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectGameThreadWithTokenIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__selectGameThreadWithTokenIdResponse(struct soap *soap, const char *tag, tns__selectGameThreadWithTokenIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectGameThreadWithTokenIdResponse **)soap_malloc(soap, sizeof(tns__selectGameThreadWithTokenIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectGameThreadWithTokenIdResponse *)soap_instantiate_tns__selectGameThreadWithTokenIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectGameThreadWithTokenIdResponse ** p = (tns__selectGameThreadWithTokenIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__selectGameThreadWithTokenIdResponse, sizeof(tns__selectGameThreadWithTokenIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectGameThreadWithTokenIdResponse(struct soap *soap, tns__selectGameThreadWithTokenIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__selectGameThreadWithTokenIdResponse);
	if (soap_out_PointerTotns__selectGameThreadWithTokenIdResponse(soap, tag?tag:"tns:selectGameThreadWithTokenIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectGameThreadWithTokenIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__selectGameThreadWithTokenIdResponse(struct soap *soap, tns__selectGameThreadWithTokenIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectGameThreadWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectGameThreadWithTokenId(struct soap *soap, tns__selectGameThreadWithTokenId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__selectGameThreadWithTokenId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectGameThreadWithTokenId(struct soap *soap, const char *tag, int id, tns__selectGameThreadWithTokenId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__selectGameThreadWithTokenId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectGameThreadWithTokenId ** SOAP_FMAC4 soap_in_PointerTotns__selectGameThreadWithTokenId(struct soap *soap, const char *tag, tns__selectGameThreadWithTokenId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectGameThreadWithTokenId **)soap_malloc(soap, sizeof(tns__selectGameThreadWithTokenId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectGameThreadWithTokenId *)soap_instantiate_tns__selectGameThreadWithTokenId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectGameThreadWithTokenId ** p = (tns__selectGameThreadWithTokenId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__selectGameThreadWithTokenId, sizeof(tns__selectGameThreadWithTokenId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectGameThreadWithTokenId(struct soap *soap, tns__selectGameThreadWithTokenId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__selectGameThreadWithTokenId);
	if (soap_out_PointerTotns__selectGameThreadWithTokenId(soap, tag?tag:"tns:selectGameThreadWithTokenId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectGameThreadWithTokenId ** SOAP_FMAC4 soap_get_PointerTotns__selectGameThreadWithTokenId(struct soap *soap, tns__selectGameThreadWithTokenId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectGameThreadWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectGameThreadWithTokenDigestResponse(struct soap *soap, tns__selectGameThreadWithTokenDigestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__selectGameThreadWithTokenDigestResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectGameThreadWithTokenDigestResponse(struct soap *soap, const char *tag, int id, tns__selectGameThreadWithTokenDigestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__selectGameThreadWithTokenDigestResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectGameThreadWithTokenDigestResponse ** SOAP_FMAC4 soap_in_PointerTotns__selectGameThreadWithTokenDigestResponse(struct soap *soap, const char *tag, tns__selectGameThreadWithTokenDigestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectGameThreadWithTokenDigestResponse **)soap_malloc(soap, sizeof(tns__selectGameThreadWithTokenDigestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectGameThreadWithTokenDigestResponse *)soap_instantiate_tns__selectGameThreadWithTokenDigestResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectGameThreadWithTokenDigestResponse ** p = (tns__selectGameThreadWithTokenDigestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__selectGameThreadWithTokenDigestResponse, sizeof(tns__selectGameThreadWithTokenDigestResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectGameThreadWithTokenDigestResponse(struct soap *soap, tns__selectGameThreadWithTokenDigestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__selectGameThreadWithTokenDigestResponse);
	if (soap_out_PointerTotns__selectGameThreadWithTokenDigestResponse(soap, tag?tag:"tns:selectGameThreadWithTokenDigestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectGameThreadWithTokenDigestResponse ** SOAP_FMAC4 soap_get_PointerTotns__selectGameThreadWithTokenDigestResponse(struct soap *soap, tns__selectGameThreadWithTokenDigestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectGameThreadWithTokenDigestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectGameThreadWithTokenDigest(struct soap *soap, tns__selectGameThreadWithTokenDigest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__selectGameThreadWithTokenDigest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectGameThreadWithTokenDigest(struct soap *soap, const char *tag, int id, tns__selectGameThreadWithTokenDigest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__selectGameThreadWithTokenDigest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectGameThreadWithTokenDigest ** SOAP_FMAC4 soap_in_PointerTotns__selectGameThreadWithTokenDigest(struct soap *soap, const char *tag, tns__selectGameThreadWithTokenDigest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectGameThreadWithTokenDigest **)soap_malloc(soap, sizeof(tns__selectGameThreadWithTokenDigest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectGameThreadWithTokenDigest *)soap_instantiate_tns__selectGameThreadWithTokenDigest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectGameThreadWithTokenDigest ** p = (tns__selectGameThreadWithTokenDigest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__selectGameThreadWithTokenDigest, sizeof(tns__selectGameThreadWithTokenDigest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectGameThreadWithTokenDigest(struct soap *soap, tns__selectGameThreadWithTokenDigest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__selectGameThreadWithTokenDigest);
	if (soap_out_PointerTotns__selectGameThreadWithTokenDigest(soap, tag?tag:"tns:selectGameThreadWithTokenDigest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectGameThreadWithTokenDigest ** SOAP_FMAC4 soap_get_PointerTotns__selectGameThreadWithTokenDigest(struct soap *soap, tns__selectGameThreadWithTokenDigest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectGameThreadWithTokenDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__loginResponse(struct soap *soap, tns__loginResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__loginResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__loginResponse(struct soap *soap, const char *tag, int id, tns__loginResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__loginResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__loginResponse ** SOAP_FMAC4 soap_in_PointerTotns__loginResponse(struct soap *soap, const char *tag, tns__loginResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__loginResponse **)soap_malloc(soap, sizeof(tns__loginResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__loginResponse *)soap_instantiate_tns__loginResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__loginResponse ** p = (tns__loginResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__loginResponse, sizeof(tns__loginResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__loginResponse(struct soap *soap, tns__loginResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__loginResponse);
	if (soap_out_PointerTotns__loginResponse(soap, tag?tag:"tns:loginResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__loginResponse ** SOAP_FMAC4 soap_get_PointerTotns__loginResponse(struct soap *soap, tns__loginResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__loginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__login(struct soap *soap, tns__login *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__login))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__login(struct soap *soap, const char *tag, int id, tns__login *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__login);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__login ** SOAP_FMAC4 soap_in_PointerTotns__login(struct soap *soap, const char *tag, tns__login **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__login **)soap_malloc(soap, sizeof(tns__login *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__login *)soap_instantiate_tns__login(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__login ** p = (tns__login **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__login, sizeof(tns__login), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__login(struct soap *soap, tns__login *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__login);
	if (soap_out_PointerTotns__login(soap, tag?tag:"tns:login", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__login ** SOAP_FMAC4 soap_get_PointerTotns__login(struct soap *soap, tns__login **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__isLatestAppResponse(struct soap *soap, tns__isLatestAppResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__isLatestAppResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__isLatestAppResponse(struct soap *soap, const char *tag, int id, tns__isLatestAppResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__isLatestAppResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__isLatestAppResponse ** SOAP_FMAC4 soap_in_PointerTotns__isLatestAppResponse(struct soap *soap, const char *tag, tns__isLatestAppResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__isLatestAppResponse **)soap_malloc(soap, sizeof(tns__isLatestAppResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__isLatestAppResponse *)soap_instantiate_tns__isLatestAppResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__isLatestAppResponse ** p = (tns__isLatestAppResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__isLatestAppResponse, sizeof(tns__isLatestAppResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__isLatestAppResponse(struct soap *soap, tns__isLatestAppResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__isLatestAppResponse);
	if (soap_out_PointerTotns__isLatestAppResponse(soap, tag?tag:"tns:isLatestAppResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__isLatestAppResponse ** SOAP_FMAC4 soap_get_PointerTotns__isLatestAppResponse(struct soap *soap, tns__isLatestAppResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__isLatestAppResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__isLatestApp(struct soap *soap, tns__isLatestApp *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__isLatestApp))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__isLatestApp(struct soap *soap, const char *tag, int id, tns__isLatestApp *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__isLatestApp);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__isLatestApp ** SOAP_FMAC4 soap_in_PointerTotns__isLatestApp(struct soap *soap, const char *tag, tns__isLatestApp **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__isLatestApp **)soap_malloc(soap, sizeof(tns__isLatestApp *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__isLatestApp *)soap_instantiate_tns__isLatestApp(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__isLatestApp ** p = (tns__isLatestApp **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__isLatestApp, sizeof(tns__isLatestApp), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__isLatestApp(struct soap *soap, tns__isLatestApp *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__isLatestApp);
	if (soap_out_PointerTotns__isLatestApp(soap, tag?tag:"tns:isLatestApp", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__isLatestApp ** SOAP_FMAC4 soap_get_PointerTotns__isLatestApp(struct soap *soap, tns__isLatestApp **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__isLatestApp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__isConnectedResponse(struct soap *soap, tns__isConnectedResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__isConnectedResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__isConnectedResponse(struct soap *soap, const char *tag, int id, tns__isConnectedResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__isConnectedResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__isConnectedResponse ** SOAP_FMAC4 soap_in_PointerTotns__isConnectedResponse(struct soap *soap, const char *tag, tns__isConnectedResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__isConnectedResponse **)soap_malloc(soap, sizeof(tns__isConnectedResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__isConnectedResponse *)soap_instantiate_tns__isConnectedResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__isConnectedResponse ** p = (tns__isConnectedResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__isConnectedResponse, sizeof(tns__isConnectedResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__isConnectedResponse(struct soap *soap, tns__isConnectedResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__isConnectedResponse);
	if (soap_out_PointerTotns__isConnectedResponse(soap, tag?tag:"tns:isConnectedResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__isConnectedResponse ** SOAP_FMAC4 soap_get_PointerTotns__isConnectedResponse(struct soap *soap, tns__isConnectedResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__isConnectedResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__isConnected(struct soap *soap, tns__isConnected *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__isConnected))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__isConnected(struct soap *soap, const char *tag, int id, tns__isConnected *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__isConnected);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__isConnected ** SOAP_FMAC4 soap_in_PointerTotns__isConnected(struct soap *soap, const char *tag, tns__isConnected **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__isConnected **)soap_malloc(soap, sizeof(tns__isConnected *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__isConnected *)soap_instantiate_tns__isConnected(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__isConnected ** p = (tns__isConnected **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__isConnected, sizeof(tns__isConnected), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__isConnected(struct soap *soap, tns__isConnected *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__isConnected);
	if (soap_out_PointerTotns__isConnected(soap, tag?tag:"tns:isConnected", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__isConnected ** SOAP_FMAC4 soap_get_PointerTotns__isConnected(struct soap *soap, tns__isConnected **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__isConnected(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__isAuthorizedResponse(struct soap *soap, tns__isAuthorizedResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__isAuthorizedResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__isAuthorizedResponse(struct soap *soap, const char *tag, int id, tns__isAuthorizedResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__isAuthorizedResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__isAuthorizedResponse ** SOAP_FMAC4 soap_in_PointerTotns__isAuthorizedResponse(struct soap *soap, const char *tag, tns__isAuthorizedResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__isAuthorizedResponse **)soap_malloc(soap, sizeof(tns__isAuthorizedResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__isAuthorizedResponse *)soap_instantiate_tns__isAuthorizedResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__isAuthorizedResponse ** p = (tns__isAuthorizedResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__isAuthorizedResponse, sizeof(tns__isAuthorizedResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__isAuthorizedResponse(struct soap *soap, tns__isAuthorizedResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__isAuthorizedResponse);
	if (soap_out_PointerTotns__isAuthorizedResponse(soap, tag?tag:"tns:isAuthorizedResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__isAuthorizedResponse ** SOAP_FMAC4 soap_get_PointerTotns__isAuthorizedResponse(struct soap *soap, tns__isAuthorizedResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__isAuthorizedResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__isAuthorized(struct soap *soap, tns__isAuthorized *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__isAuthorized))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__isAuthorized(struct soap *soap, const char *tag, int id, tns__isAuthorized *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__isAuthorized);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__isAuthorized ** SOAP_FMAC4 soap_in_PointerTotns__isAuthorized(struct soap *soap, const char *tag, tns__isAuthorized **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__isAuthorized **)soap_malloc(soap, sizeof(tns__isAuthorized *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__isAuthorized *)soap_instantiate_tns__isAuthorized(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__isAuthorized ** p = (tns__isAuthorized **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__isAuthorized, sizeof(tns__isAuthorized), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__isAuthorized(struct soap *soap, tns__isAuthorized *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__isAuthorized);
	if (soap_out_PointerTotns__isAuthorized(soap, tag?tag:"tns:isAuthorized", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__isAuthorized ** SOAP_FMAC4 soap_get_PointerTotns__isAuthorized(struct soap *soap, tns__isAuthorized **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__isAuthorized(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__getUserResponse(struct soap *soap, tns__getUserResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__getUserResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__getUserResponse(struct soap *soap, const char *tag, int id, tns__getUserResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__getUserResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__getUserResponse ** SOAP_FMAC4 soap_in_PointerTotns__getUserResponse(struct soap *soap, const char *tag, tns__getUserResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__getUserResponse **)soap_malloc(soap, sizeof(tns__getUserResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__getUserResponse *)soap_instantiate_tns__getUserResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__getUserResponse ** p = (tns__getUserResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__getUserResponse, sizeof(tns__getUserResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__getUserResponse(struct soap *soap, tns__getUserResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__getUserResponse);
	if (soap_out_PointerTotns__getUserResponse(soap, tag?tag:"tns:getUserResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__getUserResponse ** SOAP_FMAC4 soap_get_PointerTotns__getUserResponse(struct soap *soap, tns__getUserResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__getUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__getUser(struct soap *soap, tns__getUser *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__getUser))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__getUser(struct soap *soap, const char *tag, int id, tns__getUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__getUser);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__getUser ** SOAP_FMAC4 soap_in_PointerTotns__getUser(struct soap *soap, const char *tag, tns__getUser **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__getUser **)soap_malloc(soap, sizeof(tns__getUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__getUser *)soap_instantiate_tns__getUser(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__getUser ** p = (tns__getUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__getUser, sizeof(tns__getUser), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__getUser(struct soap *soap, tns__getUser *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__getUser);
	if (soap_out_PointerTotns__getUser(soap, tag?tag:"tns:getUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__getUser ** SOAP_FMAC4 soap_get_PointerTotns__getUser(struct soap *soap, tns__getUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__getUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__deleteMediaAnnotationWithIdResponse(struct soap *soap, tns__deleteMediaAnnotationWithIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__deleteMediaAnnotationWithIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__deleteMediaAnnotationWithIdResponse(struct soap *soap, const char *tag, int id, tns__deleteMediaAnnotationWithIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__deleteMediaAnnotationWithIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__deleteMediaAnnotationWithIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__deleteMediaAnnotationWithIdResponse(struct soap *soap, const char *tag, tns__deleteMediaAnnotationWithIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__deleteMediaAnnotationWithIdResponse **)soap_malloc(soap, sizeof(tns__deleteMediaAnnotationWithIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__deleteMediaAnnotationWithIdResponse *)soap_instantiate_tns__deleteMediaAnnotationWithIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__deleteMediaAnnotationWithIdResponse ** p = (tns__deleteMediaAnnotationWithIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__deleteMediaAnnotationWithIdResponse, sizeof(tns__deleteMediaAnnotationWithIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__deleteMediaAnnotationWithIdResponse(struct soap *soap, tns__deleteMediaAnnotationWithIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__deleteMediaAnnotationWithIdResponse);
	if (soap_out_PointerTotns__deleteMediaAnnotationWithIdResponse(soap, tag?tag:"tns:deleteMediaAnnotationWithIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__deleteMediaAnnotationWithIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__deleteMediaAnnotationWithIdResponse(struct soap *soap, tns__deleteMediaAnnotationWithIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__deleteMediaAnnotationWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__deleteMediaAnnotationWithId(struct soap *soap, tns__deleteMediaAnnotationWithId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__deleteMediaAnnotationWithId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__deleteMediaAnnotationWithId(struct soap *soap, const char *tag, int id, tns__deleteMediaAnnotationWithId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__deleteMediaAnnotationWithId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__deleteMediaAnnotationWithId ** SOAP_FMAC4 soap_in_PointerTotns__deleteMediaAnnotationWithId(struct soap *soap, const char *tag, tns__deleteMediaAnnotationWithId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__deleteMediaAnnotationWithId **)soap_malloc(soap, sizeof(tns__deleteMediaAnnotationWithId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__deleteMediaAnnotationWithId *)soap_instantiate_tns__deleteMediaAnnotationWithId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__deleteMediaAnnotationWithId ** p = (tns__deleteMediaAnnotationWithId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__deleteMediaAnnotationWithId, sizeof(tns__deleteMediaAnnotationWithId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__deleteMediaAnnotationWithId(struct soap *soap, tns__deleteMediaAnnotationWithId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__deleteMediaAnnotationWithId);
	if (soap_out_PointerTotns__deleteMediaAnnotationWithId(soap, tag?tag:"tns:deleteMediaAnnotationWithId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__deleteMediaAnnotationWithId ** SOAP_FMAC4 soap_get_PointerTotns__deleteMediaAnnotationWithId(struct soap *soap, tns__deleteMediaAnnotationWithId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__deleteMediaAnnotationWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__deleteMediaAliasWithIdResponse(struct soap *soap, tns__deleteMediaAliasWithIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__deleteMediaAliasWithIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__deleteMediaAliasWithIdResponse(struct soap *soap, const char *tag, int id, tns__deleteMediaAliasWithIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__deleteMediaAliasWithIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__deleteMediaAliasWithIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__deleteMediaAliasWithIdResponse(struct soap *soap, const char *tag, tns__deleteMediaAliasWithIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__deleteMediaAliasWithIdResponse **)soap_malloc(soap, sizeof(tns__deleteMediaAliasWithIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__deleteMediaAliasWithIdResponse *)soap_instantiate_tns__deleteMediaAliasWithIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__deleteMediaAliasWithIdResponse ** p = (tns__deleteMediaAliasWithIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__deleteMediaAliasWithIdResponse, sizeof(tns__deleteMediaAliasWithIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__deleteMediaAliasWithIdResponse(struct soap *soap, tns__deleteMediaAliasWithIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__deleteMediaAliasWithIdResponse);
	if (soap_out_PointerTotns__deleteMediaAliasWithIdResponse(soap, tag?tag:"tns:deleteMediaAliasWithIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__deleteMediaAliasWithIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__deleteMediaAliasWithIdResponse(struct soap *soap, tns__deleteMediaAliasWithIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__deleteMediaAliasWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__deleteMediaAliasWithId(struct soap *soap, tns__deleteMediaAliasWithId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__deleteMediaAliasWithId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__deleteMediaAliasWithId(struct soap *soap, const char *tag, int id, tns__deleteMediaAliasWithId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__deleteMediaAliasWithId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__deleteMediaAliasWithId ** SOAP_FMAC4 soap_in_PointerTotns__deleteMediaAliasWithId(struct soap *soap, const char *tag, tns__deleteMediaAliasWithId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__deleteMediaAliasWithId **)soap_malloc(soap, sizeof(tns__deleteMediaAliasWithId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__deleteMediaAliasWithId *)soap_instantiate_tns__deleteMediaAliasWithId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__deleteMediaAliasWithId ** p = (tns__deleteMediaAliasWithId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__deleteMediaAliasWithId, sizeof(tns__deleteMediaAliasWithId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__deleteMediaAliasWithId(struct soap *soap, tns__deleteMediaAliasWithId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__deleteMediaAliasWithId);
	if (soap_out_PointerTotns__deleteMediaAliasWithId(soap, tag?tag:"tns:deleteMediaAliasWithId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__deleteMediaAliasWithId ** SOAP_FMAC4 soap_get_PointerTotns__deleteMediaAliasWithId(struct soap *soap, tns__deleteMediaAliasWithId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__deleteMediaAliasWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__curseUserWithIdResponse(struct soap *soap, tns__curseUserWithIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__curseUserWithIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__curseUserWithIdResponse(struct soap *soap, const char *tag, int id, tns__curseUserWithIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__curseUserWithIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__curseUserWithIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__curseUserWithIdResponse(struct soap *soap, const char *tag, tns__curseUserWithIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__curseUserWithIdResponse **)soap_malloc(soap, sizeof(tns__curseUserWithIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__curseUserWithIdResponse *)soap_instantiate_tns__curseUserWithIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__curseUserWithIdResponse ** p = (tns__curseUserWithIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__curseUserWithIdResponse, sizeof(tns__curseUserWithIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__curseUserWithIdResponse(struct soap *soap, tns__curseUserWithIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__curseUserWithIdResponse);
	if (soap_out_PointerTotns__curseUserWithIdResponse(soap, tag?tag:"tns:curseUserWithIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__curseUserWithIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__curseUserWithIdResponse(struct soap *soap, tns__curseUserWithIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__curseUserWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__curseUserWithId(struct soap *soap, tns__curseUserWithId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__curseUserWithId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__curseUserWithId(struct soap *soap, const char *tag, int id, tns__curseUserWithId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__curseUserWithId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__curseUserWithId ** SOAP_FMAC4 soap_in_PointerTotns__curseUserWithId(struct soap *soap, const char *tag, tns__curseUserWithId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__curseUserWithId **)soap_malloc(soap, sizeof(tns__curseUserWithId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__curseUserWithId *)soap_instantiate_tns__curseUserWithId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__curseUserWithId ** p = (tns__curseUserWithId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__curseUserWithId, sizeof(tns__curseUserWithId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__curseUserWithId(struct soap *soap, tns__curseUserWithId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__curseUserWithId);
	if (soap_out_PointerTotns__curseUserWithId(soap, tag?tag:"tns:curseUserWithId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__curseUserWithId ** SOAP_FMAC4 soap_get_PointerTotns__curseUserWithId(struct soap *soap, tns__curseUserWithId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__curseUserWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__curseMediaTokenWithIdResponse(struct soap *soap, tns__curseMediaTokenWithIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__curseMediaTokenWithIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__curseMediaTokenWithIdResponse(struct soap *soap, const char *tag, int id, tns__curseMediaTokenWithIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__curseMediaTokenWithIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__curseMediaTokenWithIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__curseMediaTokenWithIdResponse(struct soap *soap, const char *tag, tns__curseMediaTokenWithIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__curseMediaTokenWithIdResponse **)soap_malloc(soap, sizeof(tns__curseMediaTokenWithIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__curseMediaTokenWithIdResponse *)soap_instantiate_tns__curseMediaTokenWithIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__curseMediaTokenWithIdResponse ** p = (tns__curseMediaTokenWithIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__curseMediaTokenWithIdResponse, sizeof(tns__curseMediaTokenWithIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__curseMediaTokenWithIdResponse(struct soap *soap, tns__curseMediaTokenWithIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__curseMediaTokenWithIdResponse);
	if (soap_out_PointerTotns__curseMediaTokenWithIdResponse(soap, tag?tag:"tns:curseMediaTokenWithIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__curseMediaTokenWithIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__curseMediaTokenWithIdResponse(struct soap *soap, tns__curseMediaTokenWithIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__curseMediaTokenWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__curseMediaTokenWithId(struct soap *soap, tns__curseMediaTokenWithId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__curseMediaTokenWithId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__curseMediaTokenWithId(struct soap *soap, const char *tag, int id, tns__curseMediaTokenWithId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__curseMediaTokenWithId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__curseMediaTokenWithId ** SOAP_FMAC4 soap_in_PointerTotns__curseMediaTokenWithId(struct soap *soap, const char *tag, tns__curseMediaTokenWithId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__curseMediaTokenWithId **)soap_malloc(soap, sizeof(tns__curseMediaTokenWithId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__curseMediaTokenWithId *)soap_instantiate_tns__curseMediaTokenWithId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__curseMediaTokenWithId ** p = (tns__curseMediaTokenWithId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__curseMediaTokenWithId, sizeof(tns__curseMediaTokenWithId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__curseMediaTokenWithId(struct soap *soap, tns__curseMediaTokenWithId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__curseMediaTokenWithId);
	if (soap_out_PointerTotns__curseMediaTokenWithId(soap, tag?tag:"tns:curseMediaTokenWithId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__curseMediaTokenWithId ** SOAP_FMAC4 soap_get_PointerTotns__curseMediaTokenWithId(struct soap *soap, tns__curseMediaTokenWithId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__curseMediaTokenWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__curseMediaAnnotationWithIdResponse(struct soap *soap, tns__curseMediaAnnotationWithIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__curseMediaAnnotationWithIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__curseMediaAnnotationWithIdResponse(struct soap *soap, const char *tag, int id, tns__curseMediaAnnotationWithIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__curseMediaAnnotationWithIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__curseMediaAnnotationWithIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__curseMediaAnnotationWithIdResponse(struct soap *soap, const char *tag, tns__curseMediaAnnotationWithIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__curseMediaAnnotationWithIdResponse **)soap_malloc(soap, sizeof(tns__curseMediaAnnotationWithIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__curseMediaAnnotationWithIdResponse *)soap_instantiate_tns__curseMediaAnnotationWithIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__curseMediaAnnotationWithIdResponse ** p = (tns__curseMediaAnnotationWithIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__curseMediaAnnotationWithIdResponse, sizeof(tns__curseMediaAnnotationWithIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__curseMediaAnnotationWithIdResponse(struct soap *soap, tns__curseMediaAnnotationWithIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__curseMediaAnnotationWithIdResponse);
	if (soap_out_PointerTotns__curseMediaAnnotationWithIdResponse(soap, tag?tag:"tns:curseMediaAnnotationWithIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__curseMediaAnnotationWithIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__curseMediaAnnotationWithIdResponse(struct soap *soap, tns__curseMediaAnnotationWithIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__curseMediaAnnotationWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__curseMediaAnnotationWithId(struct soap *soap, tns__curseMediaAnnotationWithId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__curseMediaAnnotationWithId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__curseMediaAnnotationWithId(struct soap *soap, const char *tag, int id, tns__curseMediaAnnotationWithId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__curseMediaAnnotationWithId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__curseMediaAnnotationWithId ** SOAP_FMAC4 soap_in_PointerTotns__curseMediaAnnotationWithId(struct soap *soap, const char *tag, tns__curseMediaAnnotationWithId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__curseMediaAnnotationWithId **)soap_malloc(soap, sizeof(tns__curseMediaAnnotationWithId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__curseMediaAnnotationWithId *)soap_instantiate_tns__curseMediaAnnotationWithId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__curseMediaAnnotationWithId ** p = (tns__curseMediaAnnotationWithId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__curseMediaAnnotationWithId, sizeof(tns__curseMediaAnnotationWithId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__curseMediaAnnotationWithId(struct soap *soap, tns__curseMediaAnnotationWithId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__curseMediaAnnotationWithId);
	if (soap_out_PointerTotns__curseMediaAnnotationWithId(soap, tag?tag:"tns:curseMediaAnnotationWithId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__curseMediaAnnotationWithId ** SOAP_FMAC4 soap_get_PointerTotns__curseMediaAnnotationWithId(struct soap *soap, tns__curseMediaAnnotationWithId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__curseMediaAnnotationWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__curseMediaAliasWithIdResponse(struct soap *soap, tns__curseMediaAliasWithIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__curseMediaAliasWithIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__curseMediaAliasWithIdResponse(struct soap *soap, const char *tag, int id, tns__curseMediaAliasWithIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__curseMediaAliasWithIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__curseMediaAliasWithIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__curseMediaAliasWithIdResponse(struct soap *soap, const char *tag, tns__curseMediaAliasWithIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__curseMediaAliasWithIdResponse **)soap_malloc(soap, sizeof(tns__curseMediaAliasWithIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__curseMediaAliasWithIdResponse *)soap_instantiate_tns__curseMediaAliasWithIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__curseMediaAliasWithIdResponse ** p = (tns__curseMediaAliasWithIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__curseMediaAliasWithIdResponse, sizeof(tns__curseMediaAliasWithIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__curseMediaAliasWithIdResponse(struct soap *soap, tns__curseMediaAliasWithIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__curseMediaAliasWithIdResponse);
	if (soap_out_PointerTotns__curseMediaAliasWithIdResponse(soap, tag?tag:"tns:curseMediaAliasWithIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__curseMediaAliasWithIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__curseMediaAliasWithIdResponse(struct soap *soap, tns__curseMediaAliasWithIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__curseMediaAliasWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__curseMediaAliasWithId(struct soap *soap, tns__curseMediaAliasWithId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__curseMediaAliasWithId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__curseMediaAliasWithId(struct soap *soap, const char *tag, int id, tns__curseMediaAliasWithId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__curseMediaAliasWithId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__curseMediaAliasWithId ** SOAP_FMAC4 soap_in_PointerTotns__curseMediaAliasWithId(struct soap *soap, const char *tag, tns__curseMediaAliasWithId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__curseMediaAliasWithId **)soap_malloc(soap, sizeof(tns__curseMediaAliasWithId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__curseMediaAliasWithId *)soap_instantiate_tns__curseMediaAliasWithId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__curseMediaAliasWithId ** p = (tns__curseMediaAliasWithId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__curseMediaAliasWithId, sizeof(tns__curseMediaAliasWithId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__curseMediaAliasWithId(struct soap *soap, tns__curseMediaAliasWithId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__curseMediaAliasWithId);
	if (soap_out_PointerTotns__curseMediaAliasWithId(soap, tag?tag:"tns:curseMediaAliasWithId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__curseMediaAliasWithId ** SOAP_FMAC4 soap_get_PointerTotns__curseMediaAliasWithId(struct soap *soap, tns__curseMediaAliasWithId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__curseMediaAliasWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__chatResponse(struct soap *soap, tns__chatResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__chatResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__chatResponse(struct soap *soap, const char *tag, int id, tns__chatResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__chatResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__chatResponse ** SOAP_FMAC4 soap_in_PointerTotns__chatResponse(struct soap *soap, const char *tag, tns__chatResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__chatResponse **)soap_malloc(soap, sizeof(tns__chatResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__chatResponse *)soap_instantiate_tns__chatResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__chatResponse ** p = (tns__chatResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__chatResponse, sizeof(tns__chatResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__chatResponse(struct soap *soap, tns__chatResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__chatResponse);
	if (soap_out_PointerTotns__chatResponse(soap, tag?tag:"tns:chatResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__chatResponse ** SOAP_FMAC4 soap_get_PointerTotns__chatResponse(struct soap *soap, tns__chatResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__chatResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__chat(struct soap *soap, tns__chat *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__chat))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__chat(struct soap *soap, const char *tag, int id, tns__chat *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__chat);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__chat ** SOAP_FMAC4 soap_in_PointerTotns__chat(struct soap *soap, const char *tag, tns__chat **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__chat **)soap_malloc(soap, sizeof(tns__chat *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__chat *)soap_instantiate_tns__chat(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__chat ** p = (tns__chat **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__chat, sizeof(tns__chat), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__chat(struct soap *soap, tns__chat *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__chat);
	if (soap_out_PointerTotns__chat(soap, tag?tag:"tns:chat", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__chat ** SOAP_FMAC4 soap_get_PointerTotns__chat(struct soap *soap, tns__chat **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__chat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__blockUserWithIdResponse(struct soap *soap, tns__blockUserWithIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__blockUserWithIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__blockUserWithIdResponse(struct soap *soap, const char *tag, int id, tns__blockUserWithIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__blockUserWithIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__blockUserWithIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__blockUserWithIdResponse(struct soap *soap, const char *tag, tns__blockUserWithIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__blockUserWithIdResponse **)soap_malloc(soap, sizeof(tns__blockUserWithIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__blockUserWithIdResponse *)soap_instantiate_tns__blockUserWithIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__blockUserWithIdResponse ** p = (tns__blockUserWithIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__blockUserWithIdResponse, sizeof(tns__blockUserWithIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__blockUserWithIdResponse(struct soap *soap, tns__blockUserWithIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__blockUserWithIdResponse);
	if (soap_out_PointerTotns__blockUserWithIdResponse(soap, tag?tag:"tns:blockUserWithIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__blockUserWithIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__blockUserWithIdResponse(struct soap *soap, tns__blockUserWithIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__blockUserWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__blockUserWithId(struct soap *soap, tns__blockUserWithId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__blockUserWithId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__blockUserWithId(struct soap *soap, const char *tag, int id, tns__blockUserWithId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__blockUserWithId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__blockUserWithId ** SOAP_FMAC4 soap_in_PointerTotns__blockUserWithId(struct soap *soap, const char *tag, tns__blockUserWithId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__blockUserWithId **)soap_malloc(soap, sizeof(tns__blockUserWithId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__blockUserWithId *)soap_instantiate_tns__blockUserWithId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__blockUserWithId ** p = (tns__blockUserWithId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__blockUserWithId, sizeof(tns__blockUserWithId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__blockUserWithId(struct soap *soap, tns__blockUserWithId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__blockUserWithId);
	if (soap_out_PointerTotns__blockUserWithId(soap, tag?tag:"tns:blockUserWithId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__blockUserWithId ** SOAP_FMAC4 soap_get_PointerTotns__blockUserWithId(struct soap *soap, tns__blockUserWithId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__blockUserWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__blockMediaAnnotationWithIdResponse(struct soap *soap, tns__blockMediaAnnotationWithIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__blockMediaAnnotationWithIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__blockMediaAnnotationWithIdResponse(struct soap *soap, const char *tag, int id, tns__blockMediaAnnotationWithIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__blockMediaAnnotationWithIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__blockMediaAnnotationWithIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__blockMediaAnnotationWithIdResponse(struct soap *soap, const char *tag, tns__blockMediaAnnotationWithIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__blockMediaAnnotationWithIdResponse **)soap_malloc(soap, sizeof(tns__blockMediaAnnotationWithIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__blockMediaAnnotationWithIdResponse *)soap_instantiate_tns__blockMediaAnnotationWithIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__blockMediaAnnotationWithIdResponse ** p = (tns__blockMediaAnnotationWithIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__blockMediaAnnotationWithIdResponse, sizeof(tns__blockMediaAnnotationWithIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__blockMediaAnnotationWithIdResponse(struct soap *soap, tns__blockMediaAnnotationWithIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__blockMediaAnnotationWithIdResponse);
	if (soap_out_PointerTotns__blockMediaAnnotationWithIdResponse(soap, tag?tag:"tns:blockMediaAnnotationWithIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__blockMediaAnnotationWithIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__blockMediaAnnotationWithIdResponse(struct soap *soap, tns__blockMediaAnnotationWithIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__blockMediaAnnotationWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__blockMediaAnnotationWithId(struct soap *soap, tns__blockMediaAnnotationWithId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__blockMediaAnnotationWithId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__blockMediaAnnotationWithId(struct soap *soap, const char *tag, int id, tns__blockMediaAnnotationWithId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__blockMediaAnnotationWithId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__blockMediaAnnotationWithId ** SOAP_FMAC4 soap_in_PointerTotns__blockMediaAnnotationWithId(struct soap *soap, const char *tag, tns__blockMediaAnnotationWithId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__blockMediaAnnotationWithId **)soap_malloc(soap, sizeof(tns__blockMediaAnnotationWithId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__blockMediaAnnotationWithId *)soap_instantiate_tns__blockMediaAnnotationWithId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__blockMediaAnnotationWithId ** p = (tns__blockMediaAnnotationWithId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__blockMediaAnnotationWithId, sizeof(tns__blockMediaAnnotationWithId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__blockMediaAnnotationWithId(struct soap *soap, tns__blockMediaAnnotationWithId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__blockMediaAnnotationWithId);
	if (soap_out_PointerTotns__blockMediaAnnotationWithId(soap, tag?tag:"tns:blockMediaAnnotationWithId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__blockMediaAnnotationWithId ** SOAP_FMAC4 soap_get_PointerTotns__blockMediaAnnotationWithId(struct soap *soap, tns__blockMediaAnnotationWithId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__blockMediaAnnotationWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__blockMediaAliasWithIdResponse(struct soap *soap, tns__blockMediaAliasWithIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__blockMediaAliasWithIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__blockMediaAliasWithIdResponse(struct soap *soap, const char *tag, int id, tns__blockMediaAliasWithIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__blockMediaAliasWithIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__blockMediaAliasWithIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__blockMediaAliasWithIdResponse(struct soap *soap, const char *tag, tns__blockMediaAliasWithIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__blockMediaAliasWithIdResponse **)soap_malloc(soap, sizeof(tns__blockMediaAliasWithIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__blockMediaAliasWithIdResponse *)soap_instantiate_tns__blockMediaAliasWithIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__blockMediaAliasWithIdResponse ** p = (tns__blockMediaAliasWithIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__blockMediaAliasWithIdResponse, sizeof(tns__blockMediaAliasWithIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__blockMediaAliasWithIdResponse(struct soap *soap, tns__blockMediaAliasWithIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__blockMediaAliasWithIdResponse);
	if (soap_out_PointerTotns__blockMediaAliasWithIdResponse(soap, tag?tag:"tns:blockMediaAliasWithIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__blockMediaAliasWithIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__blockMediaAliasWithIdResponse(struct soap *soap, tns__blockMediaAliasWithIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__blockMediaAliasWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__blockMediaAliasWithId(struct soap *soap, tns__blockMediaAliasWithId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__blockMediaAliasWithId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__blockMediaAliasWithId(struct soap *soap, const char *tag, int id, tns__blockMediaAliasWithId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__blockMediaAliasWithId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__blockMediaAliasWithId ** SOAP_FMAC4 soap_in_PointerTotns__blockMediaAliasWithId(struct soap *soap, const char *tag, tns__blockMediaAliasWithId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__blockMediaAliasWithId **)soap_malloc(soap, sizeof(tns__blockMediaAliasWithId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__blockMediaAliasWithId *)soap_instantiate_tns__blockMediaAliasWithId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__blockMediaAliasWithId ** p = (tns__blockMediaAliasWithId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__blockMediaAliasWithId, sizeof(tns__blockMediaAliasWithId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__blockMediaAliasWithId(struct soap *soap, tns__blockMediaAliasWithId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__blockMediaAliasWithId);
	if (soap_out_PointerTotns__blockMediaAliasWithId(soap, tag?tag:"tns:blockMediaAliasWithId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__blockMediaAliasWithId ** SOAP_FMAC4 soap_get_PointerTotns__blockMediaAliasWithId(struct soap *soap, tns__blockMediaAliasWithId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__blockMediaAliasWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__blessUserWithIdResponse(struct soap *soap, tns__blessUserWithIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__blessUserWithIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__blessUserWithIdResponse(struct soap *soap, const char *tag, int id, tns__blessUserWithIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__blessUserWithIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__blessUserWithIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__blessUserWithIdResponse(struct soap *soap, const char *tag, tns__blessUserWithIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__blessUserWithIdResponse **)soap_malloc(soap, sizeof(tns__blessUserWithIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__blessUserWithIdResponse *)soap_instantiate_tns__blessUserWithIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__blessUserWithIdResponse ** p = (tns__blessUserWithIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__blessUserWithIdResponse, sizeof(tns__blessUserWithIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__blessUserWithIdResponse(struct soap *soap, tns__blessUserWithIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__blessUserWithIdResponse);
	if (soap_out_PointerTotns__blessUserWithIdResponse(soap, tag?tag:"tns:blessUserWithIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__blessUserWithIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__blessUserWithIdResponse(struct soap *soap, tns__blessUserWithIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__blessUserWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__blessUserWithId(struct soap *soap, tns__blessUserWithId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__blessUserWithId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__blessUserWithId(struct soap *soap, const char *tag, int id, tns__blessUserWithId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__blessUserWithId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__blessUserWithId ** SOAP_FMAC4 soap_in_PointerTotns__blessUserWithId(struct soap *soap, const char *tag, tns__blessUserWithId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__blessUserWithId **)soap_malloc(soap, sizeof(tns__blessUserWithId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__blessUserWithId *)soap_instantiate_tns__blessUserWithId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__blessUserWithId ** p = (tns__blessUserWithId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__blessUserWithId, sizeof(tns__blessUserWithId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__blessUserWithId(struct soap *soap, tns__blessUserWithId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__blessUserWithId);
	if (soap_out_PointerTotns__blessUserWithId(soap, tag?tag:"tns:blessUserWithId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__blessUserWithId ** SOAP_FMAC4 soap_get_PointerTotns__blessUserWithId(struct soap *soap, tns__blessUserWithId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__blessUserWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__blessMediaTokenWithIdResponse(struct soap *soap, tns__blessMediaTokenWithIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__blessMediaTokenWithIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__blessMediaTokenWithIdResponse(struct soap *soap, const char *tag, int id, tns__blessMediaTokenWithIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__blessMediaTokenWithIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__blessMediaTokenWithIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__blessMediaTokenWithIdResponse(struct soap *soap, const char *tag, tns__blessMediaTokenWithIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__blessMediaTokenWithIdResponse **)soap_malloc(soap, sizeof(tns__blessMediaTokenWithIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__blessMediaTokenWithIdResponse *)soap_instantiate_tns__blessMediaTokenWithIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__blessMediaTokenWithIdResponse ** p = (tns__blessMediaTokenWithIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__blessMediaTokenWithIdResponse, sizeof(tns__blessMediaTokenWithIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__blessMediaTokenWithIdResponse(struct soap *soap, tns__blessMediaTokenWithIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__blessMediaTokenWithIdResponse);
	if (soap_out_PointerTotns__blessMediaTokenWithIdResponse(soap, tag?tag:"tns:blessMediaTokenWithIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__blessMediaTokenWithIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__blessMediaTokenWithIdResponse(struct soap *soap, tns__blessMediaTokenWithIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__blessMediaTokenWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__blessMediaTokenWithId(struct soap *soap, tns__blessMediaTokenWithId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__blessMediaTokenWithId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__blessMediaTokenWithId(struct soap *soap, const char *tag, int id, tns__blessMediaTokenWithId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__blessMediaTokenWithId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__blessMediaTokenWithId ** SOAP_FMAC4 soap_in_PointerTotns__blessMediaTokenWithId(struct soap *soap, const char *tag, tns__blessMediaTokenWithId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__blessMediaTokenWithId **)soap_malloc(soap, sizeof(tns__blessMediaTokenWithId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__blessMediaTokenWithId *)soap_instantiate_tns__blessMediaTokenWithId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__blessMediaTokenWithId ** p = (tns__blessMediaTokenWithId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__blessMediaTokenWithId, sizeof(tns__blessMediaTokenWithId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__blessMediaTokenWithId(struct soap *soap, tns__blessMediaTokenWithId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__blessMediaTokenWithId);
	if (soap_out_PointerTotns__blessMediaTokenWithId(soap, tag?tag:"tns:blessMediaTokenWithId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__blessMediaTokenWithId ** SOAP_FMAC4 soap_get_PointerTotns__blessMediaTokenWithId(struct soap *soap, tns__blessMediaTokenWithId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__blessMediaTokenWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__blessMediaAnnotationWithIdResponse(struct soap *soap, tns__blessMediaAnnotationWithIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__blessMediaAnnotationWithIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__blessMediaAnnotationWithIdResponse(struct soap *soap, const char *tag, int id, tns__blessMediaAnnotationWithIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__blessMediaAnnotationWithIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__blessMediaAnnotationWithIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__blessMediaAnnotationWithIdResponse(struct soap *soap, const char *tag, tns__blessMediaAnnotationWithIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__blessMediaAnnotationWithIdResponse **)soap_malloc(soap, sizeof(tns__blessMediaAnnotationWithIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__blessMediaAnnotationWithIdResponse *)soap_instantiate_tns__blessMediaAnnotationWithIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__blessMediaAnnotationWithIdResponse ** p = (tns__blessMediaAnnotationWithIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__blessMediaAnnotationWithIdResponse, sizeof(tns__blessMediaAnnotationWithIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__blessMediaAnnotationWithIdResponse(struct soap *soap, tns__blessMediaAnnotationWithIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__blessMediaAnnotationWithIdResponse);
	if (soap_out_PointerTotns__blessMediaAnnotationWithIdResponse(soap, tag?tag:"tns:blessMediaAnnotationWithIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__blessMediaAnnotationWithIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__blessMediaAnnotationWithIdResponse(struct soap *soap, tns__blessMediaAnnotationWithIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__blessMediaAnnotationWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__blessMediaAnnotationWithId(struct soap *soap, tns__blessMediaAnnotationWithId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__blessMediaAnnotationWithId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__blessMediaAnnotationWithId(struct soap *soap, const char *tag, int id, tns__blessMediaAnnotationWithId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__blessMediaAnnotationWithId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__blessMediaAnnotationWithId ** SOAP_FMAC4 soap_in_PointerTotns__blessMediaAnnotationWithId(struct soap *soap, const char *tag, tns__blessMediaAnnotationWithId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__blessMediaAnnotationWithId **)soap_malloc(soap, sizeof(tns__blessMediaAnnotationWithId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__blessMediaAnnotationWithId *)soap_instantiate_tns__blessMediaAnnotationWithId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__blessMediaAnnotationWithId ** p = (tns__blessMediaAnnotationWithId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__blessMediaAnnotationWithId, sizeof(tns__blessMediaAnnotationWithId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__blessMediaAnnotationWithId(struct soap *soap, tns__blessMediaAnnotationWithId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__blessMediaAnnotationWithId);
	if (soap_out_PointerTotns__blessMediaAnnotationWithId(soap, tag?tag:"tns:blessMediaAnnotationWithId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__blessMediaAnnotationWithId ** SOAP_FMAC4 soap_get_PointerTotns__blessMediaAnnotationWithId(struct soap *soap, tns__blessMediaAnnotationWithId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__blessMediaAnnotationWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__blessMediaAliasWithIdResponse(struct soap *soap, tns__blessMediaAliasWithIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__blessMediaAliasWithIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__blessMediaAliasWithIdResponse(struct soap *soap, const char *tag, int id, tns__blessMediaAliasWithIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__blessMediaAliasWithIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__blessMediaAliasWithIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__blessMediaAliasWithIdResponse(struct soap *soap, const char *tag, tns__blessMediaAliasWithIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__blessMediaAliasWithIdResponse **)soap_malloc(soap, sizeof(tns__blessMediaAliasWithIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__blessMediaAliasWithIdResponse *)soap_instantiate_tns__blessMediaAliasWithIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__blessMediaAliasWithIdResponse ** p = (tns__blessMediaAliasWithIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__blessMediaAliasWithIdResponse, sizeof(tns__blessMediaAliasWithIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__blessMediaAliasWithIdResponse(struct soap *soap, tns__blessMediaAliasWithIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__blessMediaAliasWithIdResponse);
	if (soap_out_PointerTotns__blessMediaAliasWithIdResponse(soap, tag?tag:"tns:blessMediaAliasWithIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__blessMediaAliasWithIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__blessMediaAliasWithIdResponse(struct soap *soap, tns__blessMediaAliasWithIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__blessMediaAliasWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__blessMediaAliasWithId(struct soap *soap, tns__blessMediaAliasWithId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__blessMediaAliasWithId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__blessMediaAliasWithId(struct soap *soap, const char *tag, int id, tns__blessMediaAliasWithId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__blessMediaAliasWithId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__blessMediaAliasWithId ** SOAP_FMAC4 soap_in_PointerTotns__blessMediaAliasWithId(struct soap *soap, const char *tag, tns__blessMediaAliasWithId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__blessMediaAliasWithId **)soap_malloc(soap, sizeof(tns__blessMediaAliasWithId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__blessMediaAliasWithId *)soap_instantiate_tns__blessMediaAliasWithId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__blessMediaAliasWithId ** p = (tns__blessMediaAliasWithId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__blessMediaAliasWithId, sizeof(tns__blessMediaAliasWithId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__blessMediaAliasWithId(struct soap *soap, tns__blessMediaAliasWithId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__blessMediaAliasWithId);
	if (soap_out_PointerTotns__blessMediaAliasWithId(soap, tag?tag:"tns:blessMediaAliasWithId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__blessMediaAliasWithId ** SOAP_FMAC4 soap_get_PointerTotns__blessMediaAliasWithId(struct soap *soap, tns__blessMediaAliasWithId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__blessMediaAliasWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__mediaToken(struct soap *soap, tns__mediaToken *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__mediaToken))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__mediaToken(struct soap *soap, const char *tag, int id, tns__mediaToken *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__mediaToken);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__mediaToken ** SOAP_FMAC4 soap_in_PointerTotns__mediaToken(struct soap *soap, const char *tag, tns__mediaToken **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__mediaToken **)soap_malloc(soap, sizeof(tns__mediaToken *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__mediaToken *)soap_instantiate_tns__mediaToken(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__mediaToken ** p = (tns__mediaToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__mediaToken, sizeof(tns__mediaToken), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__mediaToken(struct soap *soap, tns__mediaToken *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__mediaToken);
	if (soap_out_PointerTotns__mediaToken(soap, tag?tag:"tns:mediaToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__mediaToken ** SOAP_FMAC4 soap_get_PointerTotns__mediaToken(struct soap *soap, tns__mediaToken **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__mediaToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__mediaAnnotation(struct soap *soap, tns__mediaAnnotation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__mediaAnnotation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__mediaAnnotation(struct soap *soap, const char *tag, int id, tns__mediaAnnotation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__mediaAnnotation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__mediaAnnotation ** SOAP_FMAC4 soap_in_PointerTotns__mediaAnnotation(struct soap *soap, const char *tag, tns__mediaAnnotation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__mediaAnnotation **)soap_malloc(soap, sizeof(tns__mediaAnnotation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__mediaAnnotation *)soap_instantiate_tns__mediaAnnotation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__mediaAnnotation ** p = (tns__mediaAnnotation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__mediaAnnotation, sizeof(tns__mediaAnnotation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__mediaAnnotation(struct soap *soap, tns__mediaAnnotation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__mediaAnnotation);
	if (soap_out_PointerTotns__mediaAnnotation(soap, tag?tag:"tns:mediaAnnotation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__mediaAnnotation ** SOAP_FMAC4 soap_get_PointerTotns__mediaAnnotation(struct soap *soap, tns__mediaAnnotation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__mediaAnnotation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__mediaAlias(struct soap *soap, tns__mediaAlias *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__mediaAlias))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__mediaAlias(struct soap *soap, const char *tag, int id, tns__mediaAlias *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__mediaAlias);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__mediaAlias ** SOAP_FMAC4 soap_in_PointerTotns__mediaAlias(struct soap *soap, const char *tag, tns__mediaAlias **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__mediaAlias **)soap_malloc(soap, sizeof(tns__mediaAlias *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__mediaAlias *)soap_instantiate_tns__mediaAlias(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__mediaAlias ** p = (tns__mediaAlias **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__mediaAlias, sizeof(tns__mediaAlias), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__mediaAlias(struct soap *soap, tns__mediaAlias *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__mediaAlias);
	if (soap_out_PointerTotns__mediaAlias(soap, tag?tag:"tns:mediaAlias", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__mediaAlias ** SOAP_FMAC4 soap_get_PointerTotns__mediaAlias(struct soap *soap, tns__mediaAlias **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__mediaAlias(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__gameThread(struct soap *soap, tns__gameThread *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__gameThread))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__gameThread(struct soap *soap, const char *tag, int id, tns__gameThread *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__gameThread);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__gameThread ** SOAP_FMAC4 soap_in_PointerTotns__gameThread(struct soap *soap, const char *tag, tns__gameThread **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__gameThread **)soap_malloc(soap, sizeof(tns__gameThread *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__gameThread *)soap_instantiate_tns__gameThread(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__gameThread ** p = (tns__gameThread **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__gameThread, sizeof(tns__gameThread), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__gameThread(struct soap *soap, tns__gameThread *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__gameThread);
	if (soap_out_PointerTotns__gameThread(soap, tag?tag:"tns:gameThread", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__gameThread ** SOAP_FMAC4 soap_get_PointerTotns__gameThread(struct soap *soap, tns__gameThread **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__gameThread(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__user(struct soap *soap, tns__user *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_tns__user))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__user(struct soap *soap, const char *tag, int id, tns__user *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_tns__user);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__user ** SOAP_FMAC4 soap_in_PointerTotns__user(struct soap *soap, const char *tag, tns__user **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__user **)soap_malloc(soap, sizeof(tns__user *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__user *)soap_instantiate_tns__user(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__user ** p = (tns__user **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_tns__user, sizeof(tns__user), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__user(struct soap *soap, tns__user *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTotns__user);
	if (soap_out_PointerTotns__user(soap, tag?tag:"tns:user", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__user ** SOAP_FMAC4 soap_get_PointerTotns__user(struct soap *soap, tns__user **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__user(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Annot_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Annot_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Annot_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_Annot__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_Annot__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_Annot_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_Annot_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_Annot_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Annot_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTotns__mediaAnnotation(struct soap *soap, std::vector<tns__mediaAnnotation * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTotns__mediaAnnotation(struct soap *soap, const std::vector<tns__mediaAnnotation * >*a)
{
	for (std::vector<tns__mediaAnnotation * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTotns__mediaAnnotation(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTotns__mediaAnnotation(struct soap *soap, const char *tag, int id, const std::vector<tns__mediaAnnotation * >*a, const char *type)
{
	for (std::vector<tns__mediaAnnotation * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTotns__mediaAnnotation(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tns__mediaAnnotation * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTotns__mediaAnnotation(struct soap *soap, const char *tag, std::vector<tns__mediaAnnotation * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTotns__mediaAnnotation(soap, -1)))
		return NULL;
	tns__mediaAnnotation *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_Annot_tns__mediaAnnotation, SOAP_TYPE_Annot_std__vectorTemplateOfPointerTotns__mediaAnnotation, sizeof(tns__mediaAnnotation), 1))
				break;
			if (!soap_in_PointerTotns__mediaAnnotation(soap, tag, NULL, "tns:mediaAnnotation"))
				break;
		}
		else
		{
			if (!soap_in_PointerTotns__mediaAnnotation(soap, tag, &n, "tns:mediaAnnotation"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tns__mediaAnnotation * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTotns__mediaAnnotation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTotns__mediaAnnotation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_std__vectorTemplateOfPointerTotns__mediaAnnotation, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tns__mediaAnnotation * >);
		if (size)
			*size = sizeof(std::vector<tns__mediaAnnotation * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tns__mediaAnnotation * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<tns__mediaAnnotation * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<tns__mediaAnnotation * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTotns__mediaAnnotation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<tns__mediaAnnotation * > %p -> %p\n", q, p));
	*(std::vector<tns__mediaAnnotation * >*)p = *(std::vector<tns__mediaAnnotation * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTotns__mediaAlias(struct soap *soap, std::vector<tns__mediaAlias * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTotns__mediaAlias(struct soap *soap, const std::vector<tns__mediaAlias * >*a)
{
	for (std::vector<tns__mediaAlias * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTotns__mediaAlias(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTotns__mediaAlias(struct soap *soap, const char *tag, int id, const std::vector<tns__mediaAlias * >*a, const char *type)
{
	for (std::vector<tns__mediaAlias * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTotns__mediaAlias(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tns__mediaAlias * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTotns__mediaAlias(struct soap *soap, const char *tag, std::vector<tns__mediaAlias * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTotns__mediaAlias(soap, -1)))
		return NULL;
	tns__mediaAlias *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_Annot_tns__mediaAlias, SOAP_TYPE_Annot_std__vectorTemplateOfPointerTotns__mediaAlias, sizeof(tns__mediaAlias), 1))
				break;
			if (!soap_in_PointerTotns__mediaAlias(soap, tag, NULL, "tns:mediaAlias"))
				break;
		}
		else
		{
			if (!soap_in_PointerTotns__mediaAlias(soap, tag, &n, "tns:mediaAlias"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tns__mediaAlias * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTotns__mediaAlias(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTotns__mediaAlias(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Annot_std__vectorTemplateOfPointerTotns__mediaAlias, n, Annot_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tns__mediaAlias * >);
		if (size)
			*size = sizeof(std::vector<tns__mediaAlias * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tns__mediaAlias * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<tns__mediaAlias * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<tns__mediaAlias * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTotns__mediaAlias(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<tns__mediaAlias * > %p -> %p\n", q, p));
	*(std::vector<tns__mediaAlias * >*)p = *(std::vector<tns__mediaAlias * >*)q;
}

} // namespace Annot


#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of AnnotC.cpp */
