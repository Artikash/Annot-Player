/* ServerSoapC.cpp
   Generated by gSOAP 2.8.3 from _serversoap.h

Copyright(C) 2000-2011, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
1) GPL or 2) Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "ServerSoapH.h"

namespace ServerSoap {

SOAP_SOURCE_STAMP("@(#) ServerSoapC.cpp ver 2.8.3 2011-11-01 21:50:28 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_ServerSoap_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_ServerSoap_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_ServerSoap_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_ServerSoap_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ServerSoap_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithIdResponse:
		return soap_in_tns__updateMediaAnnotationTextWithIdResponse(soap, NULL, NULL, "tns:updateMediaAnnotationTextWithIdResponse");
	case SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithId:
		return soap_in_tns__updateMediaAnnotationTextWithId(soap, NULL, NULL, "tns:updateMediaAnnotationTextWithId");
	case SOAP_TYPE_ServerSoap_tns__updateGameAnnotationTextWithIdResponse:
		return soap_in_tns__updateGameAnnotationTextWithIdResponse(soap, NULL, NULL, "tns:updateGameAnnotationTextWithIdResponse");
	case SOAP_TYPE_ServerSoap_tns__updateGameAnnotationTextWithId:
		return soap_in_tns__updateGameAnnotationTextWithId(soap, NULL, NULL, "tns:updateGameAnnotationTextWithId");
	case SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigestResponse:
		return soap_in_tns__submitMediaTokenDigestResponse(soap, NULL, NULL, "tns:submitMediaTokenDigestResponse");
	case SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigest:
		return soap_in_tns__submitMediaTokenDigest(soap, NULL, NULL, "tns:submitMediaTokenDigest");
	case SOAP_TYPE_ServerSoap_tns__submitMediaTokenResponse:
		return soap_in_tns__submitMediaTokenResponse(soap, NULL, NULL, "tns:submitMediaTokenResponse");
	case SOAP_TYPE_ServerSoap_tns__submitMediaToken:
		return soap_in_tns__submitMediaToken(soap, NULL, NULL, "tns:submitMediaToken");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenIdResponse:
		return soap_in_tns__submitMediaAnnotationTextWithTokenIdResponse(soap, NULL, NULL, "tns:submitMediaAnnotationTextWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenId:
		return soap_in_tns__submitMediaAnnotationTextWithTokenId(soap, NULL, NULL, "tns:submitMediaAnnotationTextWithTokenId");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigestResponse:
		return soap_in_tns__submitMediaAnnotationTextAndTokenDigestResponse(soap, NULL, NULL, "tns:submitMediaAnnotationTextAndTokenDigestResponse");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigest:
		return soap_in_tns__submitMediaAnnotationTextAndTokenDigest(soap, NULL, NULL, "tns:submitMediaAnnotationTextAndTokenDigest");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationResponse:
		return soap_in_tns__submitMediaAnnotationResponse(soap, NULL, NULL, "tns:submitMediaAnnotationResponse");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotation:
		return soap_in_tns__submitMediaAnnotation(soap, NULL, NULL, "tns:submitMediaAnnotation");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenIdResponse:
		return soap_in_tns__submitMediaAliasTextWithTokenIdResponse(soap, NULL, NULL, "tns:submitMediaAliasTextWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenId:
		return soap_in_tns__submitMediaAliasTextWithTokenId(soap, NULL, NULL, "tns:submitMediaAliasTextWithTokenId");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigestResponse:
		return soap_in_tns__submitMediaAliasTextAndTokenDigestResponse(soap, NULL, NULL, "tns:submitMediaAliasTextAndTokenDigestResponse");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigest:
		return soap_in_tns__submitMediaAliasTextAndTokenDigest(soap, NULL, NULL, "tns:submitMediaAliasTextAndTokenDigest");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasResponse:
		return soap_in_tns__submitMediaAliasResponse(soap, NULL, NULL, "tns:submitMediaAliasResponse");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAlias:
		return soap_in_tns__submitMediaAlias(soap, NULL, NULL, "tns:submitMediaAlias");
	case SOAP_TYPE_ServerSoap_tns__submitGameTokenDigestResponse:
		return soap_in_tns__submitGameTokenDigestResponse(soap, NULL, NULL, "tns:submitGameTokenDigestResponse");
	case SOAP_TYPE_ServerSoap_tns__submitGameTokenDigest:
		return soap_in_tns__submitGameTokenDigest(soap, NULL, NULL, "tns:submitGameTokenDigest");
	case SOAP_TYPE_ServerSoap_tns__submitGameTokenResponse:
		return soap_in_tns__submitGameTokenResponse(soap, NULL, NULL, "tns:submitGameTokenResponse");
	case SOAP_TYPE_ServerSoap_tns__submitGameToken:
		return soap_in_tns__submitGameToken(soap, NULL, NULL, "tns:submitGameToken");
	case SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextWithTokenIdResponse:
		return soap_in_tns__submitGameAnnotationTextWithTokenIdResponse(soap, NULL, NULL, "tns:submitGameAnnotationTextWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextWithTokenId:
		return soap_in_tns__submitGameAnnotationTextWithTokenId(soap, NULL, NULL, "tns:submitGameAnnotationTextWithTokenId");
	case SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextAndTokenDigestResponse:
		return soap_in_tns__submitGameAnnotationTextAndTokenDigestResponse(soap, NULL, NULL, "tns:submitGameAnnotationTextAndTokenDigestResponse");
	case SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextAndTokenDigest:
		return soap_in_tns__submitGameAnnotationTextAndTokenDigest(soap, NULL, NULL, "tns:submitGameAnnotationTextAndTokenDigest");
	case SOAP_TYPE_ServerSoap_tns__submitGameAnnotationResponse:
		return soap_in_tns__submitGameAnnotationResponse(soap, NULL, NULL, "tns:submitGameAnnotationResponse");
	case SOAP_TYPE_ServerSoap_tns__submitGameAnnotation:
		return soap_in_tns__submitGameAnnotation(soap, NULL, NULL, "tns:submitGameAnnotation");
	case SOAP_TYPE_ServerSoap_tns__submitGameAliasTextWithTokenIdResponse:
		return soap_in_tns__submitGameAliasTextWithTokenIdResponse(soap, NULL, NULL, "tns:submitGameAliasTextWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_tns__submitGameAliasTextWithTokenId:
		return soap_in_tns__submitGameAliasTextWithTokenId(soap, NULL, NULL, "tns:submitGameAliasTextWithTokenId");
	case SOAP_TYPE_ServerSoap_tns__submitGameAliasTextAndTokenDigestResponse:
		return soap_in_tns__submitGameAliasTextAndTokenDigestResponse(soap, NULL, NULL, "tns:submitGameAliasTextAndTokenDigestResponse");
	case SOAP_TYPE_ServerSoap_tns__submitGameAliasTextAndTokenDigest:
		return soap_in_tns__submitGameAliasTextAndTokenDigest(soap, NULL, NULL, "tns:submitGameAliasTextAndTokenDigest");
	case SOAP_TYPE_ServerSoap_tns__submitGameAliasResponse:
		return soap_in_tns__submitGameAliasResponse(soap, NULL, NULL, "tns:submitGameAliasResponse");
	case SOAP_TYPE_ServerSoap_tns__submitGameAlias:
		return soap_in_tns__submitGameAlias(soap, NULL, NULL, "tns:submitGameAlias");
	case SOAP_TYPE_ServerSoap_tns__setUserLanguageResponse:
		return soap_in_tns__setUserLanguageResponse(soap, NULL, NULL, "tns:setUserLanguageResponse");
	case SOAP_TYPE_ServerSoap_tns__setUserLanguage:
		return soap_in_tns__setUserLanguage(soap, NULL, NULL, "tns:setUserLanguage");
	case SOAP_TYPE_ServerSoap_tns__setUserAnonymousResponse:
		return soap_in_tns__setUserAnonymousResponse(soap, NULL, NULL, "tns:setUserAnonymousResponse");
	case SOAP_TYPE_ServerSoap_tns__setUserAnonymous:
		return soap_in_tns__setUserAnonymous(soap, NULL, NULL, "tns:setUserAnonymous");
	case SOAP_TYPE_ServerSoap_tns__selectUserResponse:
		return soap_in_tns__selectUserResponse(soap, NULL, NULL, "tns:selectUserResponse");
	case SOAP_TYPE_ServerSoap_tns__selectUser:
		return soap_in_tns__selectUser(soap, NULL, NULL, "tns:selectUser");
	case SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenIdResponse:
		return soap_in_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(soap, NULL, NULL, "tns:selectRelatedMediaAnnotationsWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenId:
		return soap_in_tns__selectRelatedMediaAnnotationsWithTokenId(soap, NULL, NULL, "tns:selectRelatedMediaAnnotationsWithTokenId");
	case SOAP_TYPE_ServerSoap_tns__selectRelatedGameAnnotationsWithTokenIdResponse:
		return soap_in_tns__selectRelatedGameAnnotationsWithTokenIdResponse(soap, NULL, NULL, "tns:selectRelatedGameAnnotationsWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_tns__selectRelatedGameAnnotationsWithTokenId:
		return soap_in_tns__selectRelatedGameAnnotationsWithTokenId(soap, NULL, NULL, "tns:selectRelatedGameAnnotationsWithTokenId");
	case SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithIdResponse:
		return soap_in_tns__selectMediaTokenWithIdResponse(soap, NULL, NULL, "tns:selectMediaTokenWithIdResponse");
	case SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithId:
		return soap_in_tns__selectMediaTokenWithId(soap, NULL, NULL, "tns:selectMediaTokenWithId");
	case SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigestResponse:
		return soap_in_tns__selectMediaTokenWithDigestResponse(soap, NULL, NULL, "tns:selectMediaTokenWithDigestResponse");
	case SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigest:
		return soap_in_tns__selectMediaTokenWithDigest(soap, NULL, NULL, "tns:selectMediaTokenWithDigest");
	case SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenIdResponse:
		return soap_in_tns__selectMediaAnnotationsWithTokenIdResponse(soap, NULL, NULL, "tns:selectMediaAnnotationsWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenId:
		return soap_in_tns__selectMediaAnnotationsWithTokenId(soap, NULL, NULL, "tns:selectMediaAnnotationsWithTokenId");
	case SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenIdResponse:
		return soap_in_tns__selectMediaAliasesWithTokenIdResponse(soap, NULL, NULL, "tns:selectMediaAliasesWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenId:
		return soap_in_tns__selectMediaAliasesWithTokenId(soap, NULL, NULL, "tns:selectMediaAliasesWithTokenId");
	case SOAP_TYPE_ServerSoap_tns__selectGameTokenWithIdResponse:
		return soap_in_tns__selectGameTokenWithIdResponse(soap, NULL, NULL, "tns:selectGameTokenWithIdResponse");
	case SOAP_TYPE_ServerSoap_tns__selectGameTokenWithId:
		return soap_in_tns__selectGameTokenWithId(soap, NULL, NULL, "tns:selectGameTokenWithId");
	case SOAP_TYPE_ServerSoap_tns__selectGameTokenWithDigestResponse:
		return soap_in_tns__selectGameTokenWithDigestResponse(soap, NULL, NULL, "tns:selectGameTokenWithDigestResponse");
	case SOAP_TYPE_ServerSoap_tns__selectGameTokenWithDigest:
		return soap_in_tns__selectGameTokenWithDigest(soap, NULL, NULL, "tns:selectGameTokenWithDigest");
	case SOAP_TYPE_ServerSoap_tns__selectGameAnnotationsWithTokenIdResponse:
		return soap_in_tns__selectGameAnnotationsWithTokenIdResponse(soap, NULL, NULL, "tns:selectGameAnnotationsWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_tns__selectGameAnnotationsWithTokenId:
		return soap_in_tns__selectGameAnnotationsWithTokenId(soap, NULL, NULL, "tns:selectGameAnnotationsWithTokenId");
	case SOAP_TYPE_ServerSoap_tns__selectGameAliasesWithTokenIdResponse:
		return soap_in_tns__selectGameAliasesWithTokenIdResponse(soap, NULL, NULL, "tns:selectGameAliasesWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_tns__selectGameAliasesWithTokenId:
		return soap_in_tns__selectGameAliasesWithTokenId(soap, NULL, NULL, "tns:selectGameAliasesWithTokenId");
	case SOAP_TYPE_ServerSoap_tns__isConnectedResponse:
		return soap_in_tns__isConnectedResponse(soap, NULL, NULL, "tns:isConnectedResponse");
	case SOAP_TYPE_ServerSoap_tns__isConnected:
		return soap_in_tns__isConnected(soap, NULL, NULL, "tns:isConnected");
	case SOAP_TYPE_ServerSoap_tns__isClientUpdatedResponse:
		return soap_in_tns__isClientUpdatedResponse(soap, NULL, NULL, "tns:isClientUpdatedResponse");
	case SOAP_TYPE_ServerSoap_tns__isClientUpdated:
		return soap_in_tns__isClientUpdated(soap, NULL, NULL, "tns:isClientUpdated");
	case SOAP_TYPE_ServerSoap_tns__chatResponse:
		return soap_in_tns__chatResponse(soap, NULL, NULL, "tns:chatResponse");
	case SOAP_TYPE_ServerSoap_tns__chat:
		return soap_in_tns__chat(soap, NULL, NULL, "tns:chat");
	case SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithIdResponse:
		return soap_in_tns__blessMediaAnnotationWithIdResponse(soap, NULL, NULL, "tns:blessMediaAnnotationWithIdResponse");
	case SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithId:
		return soap_in_tns__blessMediaAnnotationWithId(soap, NULL, NULL, "tns:blessMediaAnnotationWithId");
	case SOAP_TYPE_ServerSoap_tns__blessGameAnnotationWithIdResponse:
		return soap_in_tns__blessGameAnnotationWithIdResponse(soap, NULL, NULL, "tns:blessGameAnnotationWithIdResponse");
	case SOAP_TYPE_ServerSoap_tns__blessGameAnnotationWithId:
		return soap_in_tns__blessGameAnnotationWithId(soap, NULL, NULL, "tns:blessGameAnnotationWithId");
	case SOAP_TYPE_ServerSoap_tns__user:
		return soap_in_tns__user(soap, NULL, NULL, "tns:user");
	case SOAP_TYPE_ServerSoap_tns__mediaAlias:
		return soap_in_tns__mediaAlias(soap, NULL, NULL, "tns:mediaAlias");
	case SOAP_TYPE_ServerSoap_tns__mediaToken:
		return soap_in_tns__mediaToken(soap, NULL, NULL, "tns:mediaToken");
	case SOAP_TYPE_ServerSoap_tns__mediaAnnotation:
		return soap_in_tns__mediaAnnotation(soap, NULL, NULL, "tns:mediaAnnotation");
	case SOAP_TYPE_ServerSoap_tns__gameAlias:
		return soap_in_tns__gameAlias(soap, NULL, NULL, "tns:gameAlias");
	case SOAP_TYPE_ServerSoap_tns__gameToken:
		return soap_in_tns__gameToken(soap, NULL, NULL, "tns:gameToken");
	case SOAP_TYPE_ServerSoap_tns__gameAnnotation:
		return soap_in_tns__gameAnnotation(soap, NULL, NULL, "tns:gameAnnotation");
	case SOAP_TYPE_ServerSoap_PointerTotns__updateMediaAnnotationTextWithIdResponse:
		return soap_in_PointerTotns__updateMediaAnnotationTextWithIdResponse(soap, NULL, NULL, "tns:updateMediaAnnotationTextWithIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__updateMediaAnnotationTextWithId:
		return soap_in_PointerTotns__updateMediaAnnotationTextWithId(soap, NULL, NULL, "tns:updateMediaAnnotationTextWithId");
	case SOAP_TYPE_ServerSoap_PointerTotns__updateGameAnnotationTextWithIdResponse:
		return soap_in_PointerTotns__updateGameAnnotationTextWithIdResponse(soap, NULL, NULL, "tns:updateGameAnnotationTextWithIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__updateGameAnnotationTextWithId:
		return soap_in_PointerTotns__updateGameAnnotationTextWithId(soap, NULL, NULL, "tns:updateGameAnnotationTextWithId");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaTokenDigestResponse:
		return soap_in_PointerTotns__submitMediaTokenDigestResponse(soap, NULL, NULL, "tns:submitMediaTokenDigestResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaTokenDigest:
		return soap_in_PointerTotns__submitMediaTokenDigest(soap, NULL, NULL, "tns:submitMediaTokenDigest");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaTokenResponse:
		return soap_in_PointerTotns__submitMediaTokenResponse(soap, NULL, NULL, "tns:submitMediaTokenResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaToken:
		return soap_in_PointerTotns__submitMediaToken(soap, NULL, NULL, "tns:submitMediaToken");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse:
		return soap_in_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse(soap, NULL, NULL, "tns:submitMediaAnnotationTextWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotationTextWithTokenId:
		return soap_in_PointerTotns__submitMediaAnnotationTextWithTokenId(soap, NULL, NULL, "tns:submitMediaAnnotationTextWithTokenId");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse:
		return soap_in_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse(soap, NULL, NULL, "tns:submitMediaAnnotationTextAndTokenDigestResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotationTextAndTokenDigest:
		return soap_in_PointerTotns__submitMediaAnnotationTextAndTokenDigest(soap, NULL, NULL, "tns:submitMediaAnnotationTextAndTokenDigest");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotationResponse:
		return soap_in_PointerTotns__submitMediaAnnotationResponse(soap, NULL, NULL, "tns:submitMediaAnnotationResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotation:
		return soap_in_PointerTotns__submitMediaAnnotation(soap, NULL, NULL, "tns:submitMediaAnnotation");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAliasTextWithTokenIdResponse:
		return soap_in_PointerTotns__submitMediaAliasTextWithTokenIdResponse(soap, NULL, NULL, "tns:submitMediaAliasTextWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAliasTextWithTokenId:
		return soap_in_PointerTotns__submitMediaAliasTextWithTokenId(soap, NULL, NULL, "tns:submitMediaAliasTextWithTokenId");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAliasTextAndTokenDigestResponse:
		return soap_in_PointerTotns__submitMediaAliasTextAndTokenDigestResponse(soap, NULL, NULL, "tns:submitMediaAliasTextAndTokenDigestResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAliasTextAndTokenDigest:
		return soap_in_PointerTotns__submitMediaAliasTextAndTokenDigest(soap, NULL, NULL, "tns:submitMediaAliasTextAndTokenDigest");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAliasResponse:
		return soap_in_PointerTotns__submitMediaAliasResponse(soap, NULL, NULL, "tns:submitMediaAliasResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAlias:
		return soap_in_PointerTotns__submitMediaAlias(soap, NULL, NULL, "tns:submitMediaAlias");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameTokenDigestResponse:
		return soap_in_PointerTotns__submitGameTokenDigestResponse(soap, NULL, NULL, "tns:submitGameTokenDigestResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameTokenDigest:
		return soap_in_PointerTotns__submitGameTokenDigest(soap, NULL, NULL, "tns:submitGameTokenDigest");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameTokenResponse:
		return soap_in_PointerTotns__submitGameTokenResponse(soap, NULL, NULL, "tns:submitGameTokenResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameToken:
		return soap_in_PointerTotns__submitGameToken(soap, NULL, NULL, "tns:submitGameToken");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameAnnotationTextWithTokenIdResponse:
		return soap_in_PointerTotns__submitGameAnnotationTextWithTokenIdResponse(soap, NULL, NULL, "tns:submitGameAnnotationTextWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameAnnotationTextWithTokenId:
		return soap_in_PointerTotns__submitGameAnnotationTextWithTokenId(soap, NULL, NULL, "tns:submitGameAnnotationTextWithTokenId");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameAnnotationTextAndTokenDigestResponse:
		return soap_in_PointerTotns__submitGameAnnotationTextAndTokenDigestResponse(soap, NULL, NULL, "tns:submitGameAnnotationTextAndTokenDigestResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameAnnotationTextAndTokenDigest:
		return soap_in_PointerTotns__submitGameAnnotationTextAndTokenDigest(soap, NULL, NULL, "tns:submitGameAnnotationTextAndTokenDigest");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameAnnotationResponse:
		return soap_in_PointerTotns__submitGameAnnotationResponse(soap, NULL, NULL, "tns:submitGameAnnotationResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameAnnotation:
		return soap_in_PointerTotns__submitGameAnnotation(soap, NULL, NULL, "tns:submitGameAnnotation");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameAliasTextWithTokenIdResponse:
		return soap_in_PointerTotns__submitGameAliasTextWithTokenIdResponse(soap, NULL, NULL, "tns:submitGameAliasTextWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameAliasTextWithTokenId:
		return soap_in_PointerTotns__submitGameAliasTextWithTokenId(soap, NULL, NULL, "tns:submitGameAliasTextWithTokenId");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameAliasTextAndTokenDigestResponse:
		return soap_in_PointerTotns__submitGameAliasTextAndTokenDigestResponse(soap, NULL, NULL, "tns:submitGameAliasTextAndTokenDigestResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameAliasTextAndTokenDigest:
		return soap_in_PointerTotns__submitGameAliasTextAndTokenDigest(soap, NULL, NULL, "tns:submitGameAliasTextAndTokenDigest");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameAliasResponse:
		return soap_in_PointerTotns__submitGameAliasResponse(soap, NULL, NULL, "tns:submitGameAliasResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameAlias:
		return soap_in_PointerTotns__submitGameAlias(soap, NULL, NULL, "tns:submitGameAlias");
	case SOAP_TYPE_ServerSoap_PointerTotns__setUserLanguageResponse:
		return soap_in_PointerTotns__setUserLanguageResponse(soap, NULL, NULL, "tns:setUserLanguageResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__setUserLanguage:
		return soap_in_PointerTotns__setUserLanguage(soap, NULL, NULL, "tns:setUserLanguage");
	case SOAP_TYPE_ServerSoap_PointerTotns__setUserAnonymousResponse:
		return soap_in_PointerTotns__setUserAnonymousResponse(soap, NULL, NULL, "tns:setUserAnonymousResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__setUserAnonymous:
		return soap_in_PointerTotns__setUserAnonymous(soap, NULL, NULL, "tns:setUserAnonymous");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectUserResponse:
		return soap_in_PointerTotns__selectUserResponse(soap, NULL, NULL, "tns:selectUserResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectUser:
		return soap_in_PointerTotns__selectUser(soap, NULL, NULL, "tns:selectUser");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse:
		return soap_in_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse(soap, NULL, NULL, "tns:selectRelatedMediaAnnotationsWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectRelatedMediaAnnotationsWithTokenId:
		return soap_in_PointerTotns__selectRelatedMediaAnnotationsWithTokenId(soap, NULL, NULL, "tns:selectRelatedMediaAnnotationsWithTokenId");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectRelatedGameAnnotationsWithTokenIdResponse:
		return soap_in_PointerTotns__selectRelatedGameAnnotationsWithTokenIdResponse(soap, NULL, NULL, "tns:selectRelatedGameAnnotationsWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectRelatedGameAnnotationsWithTokenId:
		return soap_in_PointerTotns__selectRelatedGameAnnotationsWithTokenId(soap, NULL, NULL, "tns:selectRelatedGameAnnotationsWithTokenId");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaTokenWithIdResponse:
		return soap_in_PointerTotns__selectMediaTokenWithIdResponse(soap, NULL, NULL, "tns:selectMediaTokenWithIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaTokenWithId:
		return soap_in_PointerTotns__selectMediaTokenWithId(soap, NULL, NULL, "tns:selectMediaTokenWithId");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaTokenWithDigestResponse:
		return soap_in_PointerTotns__selectMediaTokenWithDigestResponse(soap, NULL, NULL, "tns:selectMediaTokenWithDigestResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaTokenWithDigest:
		return soap_in_PointerTotns__selectMediaTokenWithDigest(soap, NULL, NULL, "tns:selectMediaTokenWithDigest");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaAnnotationsWithTokenIdResponse:
		return soap_in_PointerTotns__selectMediaAnnotationsWithTokenIdResponse(soap, NULL, NULL, "tns:selectMediaAnnotationsWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaAnnotationsWithTokenId:
		return soap_in_PointerTotns__selectMediaAnnotationsWithTokenId(soap, NULL, NULL, "tns:selectMediaAnnotationsWithTokenId");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaAliasesWithTokenIdResponse:
		return soap_in_PointerTotns__selectMediaAliasesWithTokenIdResponse(soap, NULL, NULL, "tns:selectMediaAliasesWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaAliasesWithTokenId:
		return soap_in_PointerTotns__selectMediaAliasesWithTokenId(soap, NULL, NULL, "tns:selectMediaAliasesWithTokenId");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectGameTokenWithIdResponse:
		return soap_in_PointerTotns__selectGameTokenWithIdResponse(soap, NULL, NULL, "tns:selectGameTokenWithIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectGameTokenWithId:
		return soap_in_PointerTotns__selectGameTokenWithId(soap, NULL, NULL, "tns:selectGameTokenWithId");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectGameTokenWithDigestResponse:
		return soap_in_PointerTotns__selectGameTokenWithDigestResponse(soap, NULL, NULL, "tns:selectGameTokenWithDigestResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectGameTokenWithDigest:
		return soap_in_PointerTotns__selectGameTokenWithDigest(soap, NULL, NULL, "tns:selectGameTokenWithDigest");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectGameAnnotationsWithTokenIdResponse:
		return soap_in_PointerTotns__selectGameAnnotationsWithTokenIdResponse(soap, NULL, NULL, "tns:selectGameAnnotationsWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectGameAnnotationsWithTokenId:
		return soap_in_PointerTotns__selectGameAnnotationsWithTokenId(soap, NULL, NULL, "tns:selectGameAnnotationsWithTokenId");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectGameAliasesWithTokenIdResponse:
		return soap_in_PointerTotns__selectGameAliasesWithTokenIdResponse(soap, NULL, NULL, "tns:selectGameAliasesWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectGameAliasesWithTokenId:
		return soap_in_PointerTotns__selectGameAliasesWithTokenId(soap, NULL, NULL, "tns:selectGameAliasesWithTokenId");
	case SOAP_TYPE_ServerSoap_PointerTotns__isConnectedResponse:
		return soap_in_PointerTotns__isConnectedResponse(soap, NULL, NULL, "tns:isConnectedResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__isConnected:
		return soap_in_PointerTotns__isConnected(soap, NULL, NULL, "tns:isConnected");
	case SOAP_TYPE_ServerSoap_PointerTotns__isClientUpdatedResponse:
		return soap_in_PointerTotns__isClientUpdatedResponse(soap, NULL, NULL, "tns:isClientUpdatedResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__isClientUpdated:
		return soap_in_PointerTotns__isClientUpdated(soap, NULL, NULL, "tns:isClientUpdated");
	case SOAP_TYPE_ServerSoap_PointerTotns__chatResponse:
		return soap_in_PointerTotns__chatResponse(soap, NULL, NULL, "tns:chatResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__chat:
		return soap_in_PointerTotns__chat(soap, NULL, NULL, "tns:chat");
	case SOAP_TYPE_ServerSoap_PointerTotns__blessMediaAnnotationWithIdResponse:
		return soap_in_PointerTotns__blessMediaAnnotationWithIdResponse(soap, NULL, NULL, "tns:blessMediaAnnotationWithIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__blessMediaAnnotationWithId:
		return soap_in_PointerTotns__blessMediaAnnotationWithId(soap, NULL, NULL, "tns:blessMediaAnnotationWithId");
	case SOAP_TYPE_ServerSoap_PointerTotns__blessGameAnnotationWithIdResponse:
		return soap_in_PointerTotns__blessGameAnnotationWithIdResponse(soap, NULL, NULL, "tns:blessGameAnnotationWithIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__blessGameAnnotationWithId:
		return soap_in_PointerTotns__blessGameAnnotationWithId(soap, NULL, NULL, "tns:blessGameAnnotationWithId");
	case SOAP_TYPE_ServerSoap_PointerTotns__user:
		return soap_in_PointerTotns__user(soap, NULL, NULL, "tns:user");
	case SOAP_TYPE_ServerSoap_PointerTotns__mediaToken:
		return soap_in_PointerTotns__mediaToken(soap, NULL, NULL, "tns:mediaToken");
	case SOAP_TYPE_ServerSoap_PointerTotns__mediaAnnotation:
		return soap_in_PointerTotns__mediaAnnotation(soap, NULL, NULL, "tns:mediaAnnotation");
	case SOAP_TYPE_ServerSoap_PointerTotns__mediaAlias:
		return soap_in_PointerTotns__mediaAlias(soap, NULL, NULL, "tns:mediaAlias");
	case SOAP_TYPE_ServerSoap_PointerTotns__gameToken:
		return soap_in_PointerTotns__gameToken(soap, NULL, NULL, "tns:gameToken");
	case SOAP_TYPE_ServerSoap_PointerTotns__gameAnnotation:
		return soap_in_PointerTotns__gameAnnotation(soap, NULL, NULL, "tns:gameAnnotation");
	case SOAP_TYPE_ServerSoap_PointerTotns__gameAlias:
		return soap_in_PointerTotns__gameAlias(soap, NULL, NULL, "tns:gameAlias");
	case SOAP_TYPE_ServerSoap_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ServerSoap__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ServerSoap_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_ServerSoap_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:updateMediaAnnotationTextWithIdResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithIdResponse;
			return soap_in_tns__updateMediaAnnotationTextWithIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:updateMediaAnnotationTextWithId"))
		{	*type = SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithId;
			return soap_in_tns__updateMediaAnnotationTextWithId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:updateGameAnnotationTextWithIdResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__updateGameAnnotationTextWithIdResponse;
			return soap_in_tns__updateGameAnnotationTextWithIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:updateGameAnnotationTextWithId"))
		{	*type = SOAP_TYPE_ServerSoap_tns__updateGameAnnotationTextWithId;
			return soap_in_tns__updateGameAnnotationTextWithId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaTokenDigestResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigestResponse;
			return soap_in_tns__submitMediaTokenDigestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaTokenDigest"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigest;
			return soap_in_tns__submitMediaTokenDigest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaTokenResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitMediaTokenResponse;
			return soap_in_tns__submitMediaTokenResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaToken"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitMediaToken;
			return soap_in_tns__submitMediaToken(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaAnnotationTextWithTokenIdResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenIdResponse;
			return soap_in_tns__submitMediaAnnotationTextWithTokenIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaAnnotationTextWithTokenId"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenId;
			return soap_in_tns__submitMediaAnnotationTextWithTokenId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaAnnotationTextAndTokenDigestResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigestResponse;
			return soap_in_tns__submitMediaAnnotationTextAndTokenDigestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaAnnotationTextAndTokenDigest"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigest;
			return soap_in_tns__submitMediaAnnotationTextAndTokenDigest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaAnnotationResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationResponse;
			return soap_in_tns__submitMediaAnnotationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaAnnotation"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitMediaAnnotation;
			return soap_in_tns__submitMediaAnnotation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaAliasTextWithTokenIdResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenIdResponse;
			return soap_in_tns__submitMediaAliasTextWithTokenIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaAliasTextWithTokenId"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenId;
			return soap_in_tns__submitMediaAliasTextWithTokenId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaAliasTextAndTokenDigestResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigestResponse;
			return soap_in_tns__submitMediaAliasTextAndTokenDigestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaAliasTextAndTokenDigest"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigest;
			return soap_in_tns__submitMediaAliasTextAndTokenDigest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaAliasResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitMediaAliasResponse;
			return soap_in_tns__submitMediaAliasResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaAlias"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitMediaAlias;
			return soap_in_tns__submitMediaAlias(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitGameTokenDigestResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitGameTokenDigestResponse;
			return soap_in_tns__submitGameTokenDigestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitGameTokenDigest"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitGameTokenDigest;
			return soap_in_tns__submitGameTokenDigest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitGameTokenResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitGameTokenResponse;
			return soap_in_tns__submitGameTokenResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitGameToken"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitGameToken;
			return soap_in_tns__submitGameToken(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitGameAnnotationTextWithTokenIdResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextWithTokenIdResponse;
			return soap_in_tns__submitGameAnnotationTextWithTokenIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitGameAnnotationTextWithTokenId"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextWithTokenId;
			return soap_in_tns__submitGameAnnotationTextWithTokenId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitGameAnnotationTextAndTokenDigestResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextAndTokenDigestResponse;
			return soap_in_tns__submitGameAnnotationTextAndTokenDigestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitGameAnnotationTextAndTokenDigest"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextAndTokenDigest;
			return soap_in_tns__submitGameAnnotationTextAndTokenDigest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitGameAnnotationResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitGameAnnotationResponse;
			return soap_in_tns__submitGameAnnotationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitGameAnnotation"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitGameAnnotation;
			return soap_in_tns__submitGameAnnotation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitGameAliasTextWithTokenIdResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitGameAliasTextWithTokenIdResponse;
			return soap_in_tns__submitGameAliasTextWithTokenIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitGameAliasTextWithTokenId"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitGameAliasTextWithTokenId;
			return soap_in_tns__submitGameAliasTextWithTokenId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitGameAliasTextAndTokenDigestResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitGameAliasTextAndTokenDigestResponse;
			return soap_in_tns__submitGameAliasTextAndTokenDigestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitGameAliasTextAndTokenDigest"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitGameAliasTextAndTokenDigest;
			return soap_in_tns__submitGameAliasTextAndTokenDigest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitGameAliasResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitGameAliasResponse;
			return soap_in_tns__submitGameAliasResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitGameAlias"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitGameAlias;
			return soap_in_tns__submitGameAlias(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:setUserLanguageResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__setUserLanguageResponse;
			return soap_in_tns__setUserLanguageResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:setUserLanguage"))
		{	*type = SOAP_TYPE_ServerSoap_tns__setUserLanguage;
			return soap_in_tns__setUserLanguage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:setUserAnonymousResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__setUserAnonymousResponse;
			return soap_in_tns__setUserAnonymousResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:setUserAnonymous"))
		{	*type = SOAP_TYPE_ServerSoap_tns__setUserAnonymous;
			return soap_in_tns__setUserAnonymous(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectUserResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__selectUserResponse;
			return soap_in_tns__selectUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectUser"))
		{	*type = SOAP_TYPE_ServerSoap_tns__selectUser;
			return soap_in_tns__selectUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectRelatedMediaAnnotationsWithTokenIdResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenIdResponse;
			return soap_in_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectRelatedMediaAnnotationsWithTokenId"))
		{	*type = SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenId;
			return soap_in_tns__selectRelatedMediaAnnotationsWithTokenId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectRelatedGameAnnotationsWithTokenIdResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__selectRelatedGameAnnotationsWithTokenIdResponse;
			return soap_in_tns__selectRelatedGameAnnotationsWithTokenIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectRelatedGameAnnotationsWithTokenId"))
		{	*type = SOAP_TYPE_ServerSoap_tns__selectRelatedGameAnnotationsWithTokenId;
			return soap_in_tns__selectRelatedGameAnnotationsWithTokenId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectMediaTokenWithIdResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithIdResponse;
			return soap_in_tns__selectMediaTokenWithIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectMediaTokenWithId"))
		{	*type = SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithId;
			return soap_in_tns__selectMediaTokenWithId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectMediaTokenWithDigestResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigestResponse;
			return soap_in_tns__selectMediaTokenWithDigestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectMediaTokenWithDigest"))
		{	*type = SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigest;
			return soap_in_tns__selectMediaTokenWithDigest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectMediaAnnotationsWithTokenIdResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenIdResponse;
			return soap_in_tns__selectMediaAnnotationsWithTokenIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectMediaAnnotationsWithTokenId"))
		{	*type = SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenId;
			return soap_in_tns__selectMediaAnnotationsWithTokenId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectMediaAliasesWithTokenIdResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenIdResponse;
			return soap_in_tns__selectMediaAliasesWithTokenIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectMediaAliasesWithTokenId"))
		{	*type = SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenId;
			return soap_in_tns__selectMediaAliasesWithTokenId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectGameTokenWithIdResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__selectGameTokenWithIdResponse;
			return soap_in_tns__selectGameTokenWithIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectGameTokenWithId"))
		{	*type = SOAP_TYPE_ServerSoap_tns__selectGameTokenWithId;
			return soap_in_tns__selectGameTokenWithId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectGameTokenWithDigestResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__selectGameTokenWithDigestResponse;
			return soap_in_tns__selectGameTokenWithDigestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectGameTokenWithDigest"))
		{	*type = SOAP_TYPE_ServerSoap_tns__selectGameTokenWithDigest;
			return soap_in_tns__selectGameTokenWithDigest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectGameAnnotationsWithTokenIdResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__selectGameAnnotationsWithTokenIdResponse;
			return soap_in_tns__selectGameAnnotationsWithTokenIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectGameAnnotationsWithTokenId"))
		{	*type = SOAP_TYPE_ServerSoap_tns__selectGameAnnotationsWithTokenId;
			return soap_in_tns__selectGameAnnotationsWithTokenId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectGameAliasesWithTokenIdResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__selectGameAliasesWithTokenIdResponse;
			return soap_in_tns__selectGameAliasesWithTokenIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectGameAliasesWithTokenId"))
		{	*type = SOAP_TYPE_ServerSoap_tns__selectGameAliasesWithTokenId;
			return soap_in_tns__selectGameAliasesWithTokenId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:isConnectedResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__isConnectedResponse;
			return soap_in_tns__isConnectedResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:isConnected"))
		{	*type = SOAP_TYPE_ServerSoap_tns__isConnected;
			return soap_in_tns__isConnected(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:isClientUpdatedResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__isClientUpdatedResponse;
			return soap_in_tns__isClientUpdatedResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:isClientUpdated"))
		{	*type = SOAP_TYPE_ServerSoap_tns__isClientUpdated;
			return soap_in_tns__isClientUpdated(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:chatResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__chatResponse;
			return soap_in_tns__chatResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:chat"))
		{	*type = SOAP_TYPE_ServerSoap_tns__chat;
			return soap_in_tns__chat(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:blessMediaAnnotationWithIdResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithIdResponse;
			return soap_in_tns__blessMediaAnnotationWithIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:blessMediaAnnotationWithId"))
		{	*type = SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithId;
			return soap_in_tns__blessMediaAnnotationWithId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:blessGameAnnotationWithIdResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__blessGameAnnotationWithIdResponse;
			return soap_in_tns__blessGameAnnotationWithIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:blessGameAnnotationWithId"))
		{	*type = SOAP_TYPE_ServerSoap_tns__blessGameAnnotationWithId;
			return soap_in_tns__blessGameAnnotationWithId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:user"))
		{	*type = SOAP_TYPE_ServerSoap_tns__user;
			return soap_in_tns__user(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:mediaAlias"))
		{	*type = SOAP_TYPE_ServerSoap_tns__mediaAlias;
			return soap_in_tns__mediaAlias(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:mediaToken"))
		{	*type = SOAP_TYPE_ServerSoap_tns__mediaToken;
			return soap_in_tns__mediaToken(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:mediaAnnotation"))
		{	*type = SOAP_TYPE_ServerSoap_tns__mediaAnnotation;
			return soap_in_tns__mediaAnnotation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:gameAlias"))
		{	*type = SOAP_TYPE_ServerSoap_tns__gameAlias;
			return soap_in_tns__gameAlias(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:gameToken"))
		{	*type = SOAP_TYPE_ServerSoap_tns__gameToken;
			return soap_in_tns__gameToken(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:gameAnnotation"))
		{	*type = SOAP_TYPE_ServerSoap_tns__gameAnnotation;
			return soap_in_tns__gameAnnotation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_ServerSoap_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_ServerSoap_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_ServerSoap_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_ServerSoap_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE_ServerSoap__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_ServerSoap_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_ServerSoap_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_ServerSoap_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_ServerSoap_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_ServerSoap_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_ServerSoap_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithIdResponse:
		return ((tns__updateMediaAnnotationTextWithIdResponse *)ptr)->soap_out(soap, tag, id, "tns:updateMediaAnnotationTextWithIdResponse");
	case SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithId:
		return ((tns__updateMediaAnnotationTextWithId *)ptr)->soap_out(soap, tag, id, "tns:updateMediaAnnotationTextWithId");
	case SOAP_TYPE_ServerSoap_tns__updateGameAnnotationTextWithIdResponse:
		return ((tns__updateGameAnnotationTextWithIdResponse *)ptr)->soap_out(soap, tag, id, "tns:updateGameAnnotationTextWithIdResponse");
	case SOAP_TYPE_ServerSoap_tns__updateGameAnnotationTextWithId:
		return ((tns__updateGameAnnotationTextWithId *)ptr)->soap_out(soap, tag, id, "tns:updateGameAnnotationTextWithId");
	case SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigestResponse:
		return ((tns__submitMediaTokenDigestResponse *)ptr)->soap_out(soap, tag, id, "tns:submitMediaTokenDigestResponse");
	case SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigest:
		return ((tns__submitMediaTokenDigest *)ptr)->soap_out(soap, tag, id, "tns:submitMediaTokenDigest");
	case SOAP_TYPE_ServerSoap_tns__submitMediaTokenResponse:
		return ((tns__submitMediaTokenResponse *)ptr)->soap_out(soap, tag, id, "tns:submitMediaTokenResponse");
	case SOAP_TYPE_ServerSoap_tns__submitMediaToken:
		return ((tns__submitMediaToken *)ptr)->soap_out(soap, tag, id, "tns:submitMediaToken");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenIdResponse:
		return ((tns__submitMediaAnnotationTextWithTokenIdResponse *)ptr)->soap_out(soap, tag, id, "tns:submitMediaAnnotationTextWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenId:
		return ((tns__submitMediaAnnotationTextWithTokenId *)ptr)->soap_out(soap, tag, id, "tns:submitMediaAnnotationTextWithTokenId");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigestResponse:
		return ((tns__submitMediaAnnotationTextAndTokenDigestResponse *)ptr)->soap_out(soap, tag, id, "tns:submitMediaAnnotationTextAndTokenDigestResponse");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigest:
		return ((tns__submitMediaAnnotationTextAndTokenDigest *)ptr)->soap_out(soap, tag, id, "tns:submitMediaAnnotationTextAndTokenDigest");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationResponse:
		return ((tns__submitMediaAnnotationResponse *)ptr)->soap_out(soap, tag, id, "tns:submitMediaAnnotationResponse");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotation:
		return ((tns__submitMediaAnnotation *)ptr)->soap_out(soap, tag, id, "tns:submitMediaAnnotation");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenIdResponse:
		return ((tns__submitMediaAliasTextWithTokenIdResponse *)ptr)->soap_out(soap, tag, id, "tns:submitMediaAliasTextWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenId:
		return ((tns__submitMediaAliasTextWithTokenId *)ptr)->soap_out(soap, tag, id, "tns:submitMediaAliasTextWithTokenId");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigestResponse:
		return ((tns__submitMediaAliasTextAndTokenDigestResponse *)ptr)->soap_out(soap, tag, id, "tns:submitMediaAliasTextAndTokenDigestResponse");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigest:
		return ((tns__submitMediaAliasTextAndTokenDigest *)ptr)->soap_out(soap, tag, id, "tns:submitMediaAliasTextAndTokenDigest");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasResponse:
		return ((tns__submitMediaAliasResponse *)ptr)->soap_out(soap, tag, id, "tns:submitMediaAliasResponse");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAlias:
		return ((tns__submitMediaAlias *)ptr)->soap_out(soap, tag, id, "tns:submitMediaAlias");
	case SOAP_TYPE_ServerSoap_tns__submitGameTokenDigestResponse:
		return ((tns__submitGameTokenDigestResponse *)ptr)->soap_out(soap, tag, id, "tns:submitGameTokenDigestResponse");
	case SOAP_TYPE_ServerSoap_tns__submitGameTokenDigest:
		return ((tns__submitGameTokenDigest *)ptr)->soap_out(soap, tag, id, "tns:submitGameTokenDigest");
	case SOAP_TYPE_ServerSoap_tns__submitGameTokenResponse:
		return ((tns__submitGameTokenResponse *)ptr)->soap_out(soap, tag, id, "tns:submitGameTokenResponse");
	case SOAP_TYPE_ServerSoap_tns__submitGameToken:
		return ((tns__submitGameToken *)ptr)->soap_out(soap, tag, id, "tns:submitGameToken");
	case SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextWithTokenIdResponse:
		return ((tns__submitGameAnnotationTextWithTokenIdResponse *)ptr)->soap_out(soap, tag, id, "tns:submitGameAnnotationTextWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextWithTokenId:
		return ((tns__submitGameAnnotationTextWithTokenId *)ptr)->soap_out(soap, tag, id, "tns:submitGameAnnotationTextWithTokenId");
	case SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextAndTokenDigestResponse:
		return ((tns__submitGameAnnotationTextAndTokenDigestResponse *)ptr)->soap_out(soap, tag, id, "tns:submitGameAnnotationTextAndTokenDigestResponse");
	case SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextAndTokenDigest:
		return ((tns__submitGameAnnotationTextAndTokenDigest *)ptr)->soap_out(soap, tag, id, "tns:submitGameAnnotationTextAndTokenDigest");
	case SOAP_TYPE_ServerSoap_tns__submitGameAnnotationResponse:
		return ((tns__submitGameAnnotationResponse *)ptr)->soap_out(soap, tag, id, "tns:submitGameAnnotationResponse");
	case SOAP_TYPE_ServerSoap_tns__submitGameAnnotation:
		return ((tns__submitGameAnnotation *)ptr)->soap_out(soap, tag, id, "tns:submitGameAnnotation");
	case SOAP_TYPE_ServerSoap_tns__submitGameAliasTextWithTokenIdResponse:
		return ((tns__submitGameAliasTextWithTokenIdResponse *)ptr)->soap_out(soap, tag, id, "tns:submitGameAliasTextWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_tns__submitGameAliasTextWithTokenId:
		return ((tns__submitGameAliasTextWithTokenId *)ptr)->soap_out(soap, tag, id, "tns:submitGameAliasTextWithTokenId");
	case SOAP_TYPE_ServerSoap_tns__submitGameAliasTextAndTokenDigestResponse:
		return ((tns__submitGameAliasTextAndTokenDigestResponse *)ptr)->soap_out(soap, tag, id, "tns:submitGameAliasTextAndTokenDigestResponse");
	case SOAP_TYPE_ServerSoap_tns__submitGameAliasTextAndTokenDigest:
		return ((tns__submitGameAliasTextAndTokenDigest *)ptr)->soap_out(soap, tag, id, "tns:submitGameAliasTextAndTokenDigest");
	case SOAP_TYPE_ServerSoap_tns__submitGameAliasResponse:
		return ((tns__submitGameAliasResponse *)ptr)->soap_out(soap, tag, id, "tns:submitGameAliasResponse");
	case SOAP_TYPE_ServerSoap_tns__submitGameAlias:
		return ((tns__submitGameAlias *)ptr)->soap_out(soap, tag, id, "tns:submitGameAlias");
	case SOAP_TYPE_ServerSoap_tns__setUserLanguageResponse:
		return ((tns__setUserLanguageResponse *)ptr)->soap_out(soap, tag, id, "tns:setUserLanguageResponse");
	case SOAP_TYPE_ServerSoap_tns__setUserLanguage:
		return ((tns__setUserLanguage *)ptr)->soap_out(soap, tag, id, "tns:setUserLanguage");
	case SOAP_TYPE_ServerSoap_tns__setUserAnonymousResponse:
		return ((tns__setUserAnonymousResponse *)ptr)->soap_out(soap, tag, id, "tns:setUserAnonymousResponse");
	case SOAP_TYPE_ServerSoap_tns__setUserAnonymous:
		return ((tns__setUserAnonymous *)ptr)->soap_out(soap, tag, id, "tns:setUserAnonymous");
	case SOAP_TYPE_ServerSoap_tns__selectUserResponse:
		return ((tns__selectUserResponse *)ptr)->soap_out(soap, tag, id, "tns:selectUserResponse");
	case SOAP_TYPE_ServerSoap_tns__selectUser:
		return ((tns__selectUser *)ptr)->soap_out(soap, tag, id, "tns:selectUser");
	case SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenIdResponse:
		return ((tns__selectRelatedMediaAnnotationsWithTokenIdResponse *)ptr)->soap_out(soap, tag, id, "tns:selectRelatedMediaAnnotationsWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenId:
		return ((tns__selectRelatedMediaAnnotationsWithTokenId *)ptr)->soap_out(soap, tag, id, "tns:selectRelatedMediaAnnotationsWithTokenId");
	case SOAP_TYPE_ServerSoap_tns__selectRelatedGameAnnotationsWithTokenIdResponse:
		return ((tns__selectRelatedGameAnnotationsWithTokenIdResponse *)ptr)->soap_out(soap, tag, id, "tns:selectRelatedGameAnnotationsWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_tns__selectRelatedGameAnnotationsWithTokenId:
		return ((tns__selectRelatedGameAnnotationsWithTokenId *)ptr)->soap_out(soap, tag, id, "tns:selectRelatedGameAnnotationsWithTokenId");
	case SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithIdResponse:
		return ((tns__selectMediaTokenWithIdResponse *)ptr)->soap_out(soap, tag, id, "tns:selectMediaTokenWithIdResponse");
	case SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithId:
		return ((tns__selectMediaTokenWithId *)ptr)->soap_out(soap, tag, id, "tns:selectMediaTokenWithId");
	case SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigestResponse:
		return ((tns__selectMediaTokenWithDigestResponse *)ptr)->soap_out(soap, tag, id, "tns:selectMediaTokenWithDigestResponse");
	case SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigest:
		return ((tns__selectMediaTokenWithDigest *)ptr)->soap_out(soap, tag, id, "tns:selectMediaTokenWithDigest");
	case SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenIdResponse:
		return ((tns__selectMediaAnnotationsWithTokenIdResponse *)ptr)->soap_out(soap, tag, id, "tns:selectMediaAnnotationsWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenId:
		return ((tns__selectMediaAnnotationsWithTokenId *)ptr)->soap_out(soap, tag, id, "tns:selectMediaAnnotationsWithTokenId");
	case SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenIdResponse:
		return ((tns__selectMediaAliasesWithTokenIdResponse *)ptr)->soap_out(soap, tag, id, "tns:selectMediaAliasesWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenId:
		return ((tns__selectMediaAliasesWithTokenId *)ptr)->soap_out(soap, tag, id, "tns:selectMediaAliasesWithTokenId");
	case SOAP_TYPE_ServerSoap_tns__selectGameTokenWithIdResponse:
		return ((tns__selectGameTokenWithIdResponse *)ptr)->soap_out(soap, tag, id, "tns:selectGameTokenWithIdResponse");
	case SOAP_TYPE_ServerSoap_tns__selectGameTokenWithId:
		return ((tns__selectGameTokenWithId *)ptr)->soap_out(soap, tag, id, "tns:selectGameTokenWithId");
	case SOAP_TYPE_ServerSoap_tns__selectGameTokenWithDigestResponse:
		return ((tns__selectGameTokenWithDigestResponse *)ptr)->soap_out(soap, tag, id, "tns:selectGameTokenWithDigestResponse");
	case SOAP_TYPE_ServerSoap_tns__selectGameTokenWithDigest:
		return ((tns__selectGameTokenWithDigest *)ptr)->soap_out(soap, tag, id, "tns:selectGameTokenWithDigest");
	case SOAP_TYPE_ServerSoap_tns__selectGameAnnotationsWithTokenIdResponse:
		return ((tns__selectGameAnnotationsWithTokenIdResponse *)ptr)->soap_out(soap, tag, id, "tns:selectGameAnnotationsWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_tns__selectGameAnnotationsWithTokenId:
		return ((tns__selectGameAnnotationsWithTokenId *)ptr)->soap_out(soap, tag, id, "tns:selectGameAnnotationsWithTokenId");
	case SOAP_TYPE_ServerSoap_tns__selectGameAliasesWithTokenIdResponse:
		return ((tns__selectGameAliasesWithTokenIdResponse *)ptr)->soap_out(soap, tag, id, "tns:selectGameAliasesWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_tns__selectGameAliasesWithTokenId:
		return ((tns__selectGameAliasesWithTokenId *)ptr)->soap_out(soap, tag, id, "tns:selectGameAliasesWithTokenId");
	case SOAP_TYPE_ServerSoap_tns__isConnectedResponse:
		return ((tns__isConnectedResponse *)ptr)->soap_out(soap, tag, id, "tns:isConnectedResponse");
	case SOAP_TYPE_ServerSoap_tns__isConnected:
		return ((tns__isConnected *)ptr)->soap_out(soap, tag, id, "tns:isConnected");
	case SOAP_TYPE_ServerSoap_tns__isClientUpdatedResponse:
		return ((tns__isClientUpdatedResponse *)ptr)->soap_out(soap, tag, id, "tns:isClientUpdatedResponse");
	case SOAP_TYPE_ServerSoap_tns__isClientUpdated:
		return ((tns__isClientUpdated *)ptr)->soap_out(soap, tag, id, "tns:isClientUpdated");
	case SOAP_TYPE_ServerSoap_tns__chatResponse:
		return ((tns__chatResponse *)ptr)->soap_out(soap, tag, id, "tns:chatResponse");
	case SOAP_TYPE_ServerSoap_tns__chat:
		return ((tns__chat *)ptr)->soap_out(soap, tag, id, "tns:chat");
	case SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithIdResponse:
		return ((tns__blessMediaAnnotationWithIdResponse *)ptr)->soap_out(soap, tag, id, "tns:blessMediaAnnotationWithIdResponse");
	case SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithId:
		return ((tns__blessMediaAnnotationWithId *)ptr)->soap_out(soap, tag, id, "tns:blessMediaAnnotationWithId");
	case SOAP_TYPE_ServerSoap_tns__blessGameAnnotationWithIdResponse:
		return ((tns__blessGameAnnotationWithIdResponse *)ptr)->soap_out(soap, tag, id, "tns:blessGameAnnotationWithIdResponse");
	case SOAP_TYPE_ServerSoap_tns__blessGameAnnotationWithId:
		return ((tns__blessGameAnnotationWithId *)ptr)->soap_out(soap, tag, id, "tns:blessGameAnnotationWithId");
	case SOAP_TYPE_ServerSoap_tns__user:
		return ((tns__user *)ptr)->soap_out(soap, tag, id, "tns:user");
	case SOAP_TYPE_ServerSoap_tns__mediaAlias:
		return ((tns__mediaAlias *)ptr)->soap_out(soap, tag, id, "tns:mediaAlias");
	case SOAP_TYPE_ServerSoap_tns__mediaToken:
		return ((tns__mediaToken *)ptr)->soap_out(soap, tag, id, "tns:mediaToken");
	case SOAP_TYPE_ServerSoap_tns__mediaAnnotation:
		return ((tns__mediaAnnotation *)ptr)->soap_out(soap, tag, id, "tns:mediaAnnotation");
	case SOAP_TYPE_ServerSoap_tns__gameAlias:
		return ((tns__gameAlias *)ptr)->soap_out(soap, tag, id, "tns:gameAlias");
	case SOAP_TYPE_ServerSoap_tns__gameToken:
		return ((tns__gameToken *)ptr)->soap_out(soap, tag, id, "tns:gameToken");
	case SOAP_TYPE_ServerSoap_tns__gameAnnotation:
		return ((tns__gameAnnotation *)ptr)->soap_out(soap, tag, id, "tns:gameAnnotation");
	case SOAP_TYPE_ServerSoap_PointerTotns__updateMediaAnnotationTextWithIdResponse:
		return soap_out_PointerTotns__updateMediaAnnotationTextWithIdResponse(soap, tag, id, (tns__updateMediaAnnotationTextWithIdResponse *const*)ptr, "tns:updateMediaAnnotationTextWithIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__updateMediaAnnotationTextWithId:
		return soap_out_PointerTotns__updateMediaAnnotationTextWithId(soap, tag, id, (tns__updateMediaAnnotationTextWithId *const*)ptr, "tns:updateMediaAnnotationTextWithId");
	case SOAP_TYPE_ServerSoap_PointerTotns__updateGameAnnotationTextWithIdResponse:
		return soap_out_PointerTotns__updateGameAnnotationTextWithIdResponse(soap, tag, id, (tns__updateGameAnnotationTextWithIdResponse *const*)ptr, "tns:updateGameAnnotationTextWithIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__updateGameAnnotationTextWithId:
		return soap_out_PointerTotns__updateGameAnnotationTextWithId(soap, tag, id, (tns__updateGameAnnotationTextWithId *const*)ptr, "tns:updateGameAnnotationTextWithId");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaTokenDigestResponse:
		return soap_out_PointerTotns__submitMediaTokenDigestResponse(soap, tag, id, (tns__submitMediaTokenDigestResponse *const*)ptr, "tns:submitMediaTokenDigestResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaTokenDigest:
		return soap_out_PointerTotns__submitMediaTokenDigest(soap, tag, id, (tns__submitMediaTokenDigest *const*)ptr, "tns:submitMediaTokenDigest");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaTokenResponse:
		return soap_out_PointerTotns__submitMediaTokenResponse(soap, tag, id, (tns__submitMediaTokenResponse *const*)ptr, "tns:submitMediaTokenResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaToken:
		return soap_out_PointerTotns__submitMediaToken(soap, tag, id, (tns__submitMediaToken *const*)ptr, "tns:submitMediaToken");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse:
		return soap_out_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse(soap, tag, id, (tns__submitMediaAnnotationTextWithTokenIdResponse *const*)ptr, "tns:submitMediaAnnotationTextWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotationTextWithTokenId:
		return soap_out_PointerTotns__submitMediaAnnotationTextWithTokenId(soap, tag, id, (tns__submitMediaAnnotationTextWithTokenId *const*)ptr, "tns:submitMediaAnnotationTextWithTokenId");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse:
		return soap_out_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse(soap, tag, id, (tns__submitMediaAnnotationTextAndTokenDigestResponse *const*)ptr, "tns:submitMediaAnnotationTextAndTokenDigestResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotationTextAndTokenDigest:
		return soap_out_PointerTotns__submitMediaAnnotationTextAndTokenDigest(soap, tag, id, (tns__submitMediaAnnotationTextAndTokenDigest *const*)ptr, "tns:submitMediaAnnotationTextAndTokenDigest");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotationResponse:
		return soap_out_PointerTotns__submitMediaAnnotationResponse(soap, tag, id, (tns__submitMediaAnnotationResponse *const*)ptr, "tns:submitMediaAnnotationResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotation:
		return soap_out_PointerTotns__submitMediaAnnotation(soap, tag, id, (tns__submitMediaAnnotation *const*)ptr, "tns:submitMediaAnnotation");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAliasTextWithTokenIdResponse:
		return soap_out_PointerTotns__submitMediaAliasTextWithTokenIdResponse(soap, tag, id, (tns__submitMediaAliasTextWithTokenIdResponse *const*)ptr, "tns:submitMediaAliasTextWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAliasTextWithTokenId:
		return soap_out_PointerTotns__submitMediaAliasTextWithTokenId(soap, tag, id, (tns__submitMediaAliasTextWithTokenId *const*)ptr, "tns:submitMediaAliasTextWithTokenId");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAliasTextAndTokenDigestResponse:
		return soap_out_PointerTotns__submitMediaAliasTextAndTokenDigestResponse(soap, tag, id, (tns__submitMediaAliasTextAndTokenDigestResponse *const*)ptr, "tns:submitMediaAliasTextAndTokenDigestResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAliasTextAndTokenDigest:
		return soap_out_PointerTotns__submitMediaAliasTextAndTokenDigest(soap, tag, id, (tns__submitMediaAliasTextAndTokenDigest *const*)ptr, "tns:submitMediaAliasTextAndTokenDigest");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAliasResponse:
		return soap_out_PointerTotns__submitMediaAliasResponse(soap, tag, id, (tns__submitMediaAliasResponse *const*)ptr, "tns:submitMediaAliasResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAlias:
		return soap_out_PointerTotns__submitMediaAlias(soap, tag, id, (tns__submitMediaAlias *const*)ptr, "tns:submitMediaAlias");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameTokenDigestResponse:
		return soap_out_PointerTotns__submitGameTokenDigestResponse(soap, tag, id, (tns__submitGameTokenDigestResponse *const*)ptr, "tns:submitGameTokenDigestResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameTokenDigest:
		return soap_out_PointerTotns__submitGameTokenDigest(soap, tag, id, (tns__submitGameTokenDigest *const*)ptr, "tns:submitGameTokenDigest");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameTokenResponse:
		return soap_out_PointerTotns__submitGameTokenResponse(soap, tag, id, (tns__submitGameTokenResponse *const*)ptr, "tns:submitGameTokenResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameToken:
		return soap_out_PointerTotns__submitGameToken(soap, tag, id, (tns__submitGameToken *const*)ptr, "tns:submitGameToken");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameAnnotationTextWithTokenIdResponse:
		return soap_out_PointerTotns__submitGameAnnotationTextWithTokenIdResponse(soap, tag, id, (tns__submitGameAnnotationTextWithTokenIdResponse *const*)ptr, "tns:submitGameAnnotationTextWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameAnnotationTextWithTokenId:
		return soap_out_PointerTotns__submitGameAnnotationTextWithTokenId(soap, tag, id, (tns__submitGameAnnotationTextWithTokenId *const*)ptr, "tns:submitGameAnnotationTextWithTokenId");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameAnnotationTextAndTokenDigestResponse:
		return soap_out_PointerTotns__submitGameAnnotationTextAndTokenDigestResponse(soap, tag, id, (tns__submitGameAnnotationTextAndTokenDigestResponse *const*)ptr, "tns:submitGameAnnotationTextAndTokenDigestResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameAnnotationTextAndTokenDigest:
		return soap_out_PointerTotns__submitGameAnnotationTextAndTokenDigest(soap, tag, id, (tns__submitGameAnnotationTextAndTokenDigest *const*)ptr, "tns:submitGameAnnotationTextAndTokenDigest");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameAnnotationResponse:
		return soap_out_PointerTotns__submitGameAnnotationResponse(soap, tag, id, (tns__submitGameAnnotationResponse *const*)ptr, "tns:submitGameAnnotationResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameAnnotation:
		return soap_out_PointerTotns__submitGameAnnotation(soap, tag, id, (tns__submitGameAnnotation *const*)ptr, "tns:submitGameAnnotation");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameAliasTextWithTokenIdResponse:
		return soap_out_PointerTotns__submitGameAliasTextWithTokenIdResponse(soap, tag, id, (tns__submitGameAliasTextWithTokenIdResponse *const*)ptr, "tns:submitGameAliasTextWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameAliasTextWithTokenId:
		return soap_out_PointerTotns__submitGameAliasTextWithTokenId(soap, tag, id, (tns__submitGameAliasTextWithTokenId *const*)ptr, "tns:submitGameAliasTextWithTokenId");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameAliasTextAndTokenDigestResponse:
		return soap_out_PointerTotns__submitGameAliasTextAndTokenDigestResponse(soap, tag, id, (tns__submitGameAliasTextAndTokenDigestResponse *const*)ptr, "tns:submitGameAliasTextAndTokenDigestResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameAliasTextAndTokenDigest:
		return soap_out_PointerTotns__submitGameAliasTextAndTokenDigest(soap, tag, id, (tns__submitGameAliasTextAndTokenDigest *const*)ptr, "tns:submitGameAliasTextAndTokenDigest");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameAliasResponse:
		return soap_out_PointerTotns__submitGameAliasResponse(soap, tag, id, (tns__submitGameAliasResponse *const*)ptr, "tns:submitGameAliasResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameAlias:
		return soap_out_PointerTotns__submitGameAlias(soap, tag, id, (tns__submitGameAlias *const*)ptr, "tns:submitGameAlias");
	case SOAP_TYPE_ServerSoap_PointerTotns__setUserLanguageResponse:
		return soap_out_PointerTotns__setUserLanguageResponse(soap, tag, id, (tns__setUserLanguageResponse *const*)ptr, "tns:setUserLanguageResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__setUserLanguage:
		return soap_out_PointerTotns__setUserLanguage(soap, tag, id, (tns__setUserLanguage *const*)ptr, "tns:setUserLanguage");
	case SOAP_TYPE_ServerSoap_PointerTotns__setUserAnonymousResponse:
		return soap_out_PointerTotns__setUserAnonymousResponse(soap, tag, id, (tns__setUserAnonymousResponse *const*)ptr, "tns:setUserAnonymousResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__setUserAnonymous:
		return soap_out_PointerTotns__setUserAnonymous(soap, tag, id, (tns__setUserAnonymous *const*)ptr, "tns:setUserAnonymous");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectUserResponse:
		return soap_out_PointerTotns__selectUserResponse(soap, tag, id, (tns__selectUserResponse *const*)ptr, "tns:selectUserResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectUser:
		return soap_out_PointerTotns__selectUser(soap, tag, id, (tns__selectUser *const*)ptr, "tns:selectUser");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse:
		return soap_out_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse(soap, tag, id, (tns__selectRelatedMediaAnnotationsWithTokenIdResponse *const*)ptr, "tns:selectRelatedMediaAnnotationsWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectRelatedMediaAnnotationsWithTokenId:
		return soap_out_PointerTotns__selectRelatedMediaAnnotationsWithTokenId(soap, tag, id, (tns__selectRelatedMediaAnnotationsWithTokenId *const*)ptr, "tns:selectRelatedMediaAnnotationsWithTokenId");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectRelatedGameAnnotationsWithTokenIdResponse:
		return soap_out_PointerTotns__selectRelatedGameAnnotationsWithTokenIdResponse(soap, tag, id, (tns__selectRelatedGameAnnotationsWithTokenIdResponse *const*)ptr, "tns:selectRelatedGameAnnotationsWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectRelatedGameAnnotationsWithTokenId:
		return soap_out_PointerTotns__selectRelatedGameAnnotationsWithTokenId(soap, tag, id, (tns__selectRelatedGameAnnotationsWithTokenId *const*)ptr, "tns:selectRelatedGameAnnotationsWithTokenId");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaTokenWithIdResponse:
		return soap_out_PointerTotns__selectMediaTokenWithIdResponse(soap, tag, id, (tns__selectMediaTokenWithIdResponse *const*)ptr, "tns:selectMediaTokenWithIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaTokenWithId:
		return soap_out_PointerTotns__selectMediaTokenWithId(soap, tag, id, (tns__selectMediaTokenWithId *const*)ptr, "tns:selectMediaTokenWithId");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaTokenWithDigestResponse:
		return soap_out_PointerTotns__selectMediaTokenWithDigestResponse(soap, tag, id, (tns__selectMediaTokenWithDigestResponse *const*)ptr, "tns:selectMediaTokenWithDigestResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaTokenWithDigest:
		return soap_out_PointerTotns__selectMediaTokenWithDigest(soap, tag, id, (tns__selectMediaTokenWithDigest *const*)ptr, "tns:selectMediaTokenWithDigest");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaAnnotationsWithTokenIdResponse:
		return soap_out_PointerTotns__selectMediaAnnotationsWithTokenIdResponse(soap, tag, id, (tns__selectMediaAnnotationsWithTokenIdResponse *const*)ptr, "tns:selectMediaAnnotationsWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaAnnotationsWithTokenId:
		return soap_out_PointerTotns__selectMediaAnnotationsWithTokenId(soap, tag, id, (tns__selectMediaAnnotationsWithTokenId *const*)ptr, "tns:selectMediaAnnotationsWithTokenId");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaAliasesWithTokenIdResponse:
		return soap_out_PointerTotns__selectMediaAliasesWithTokenIdResponse(soap, tag, id, (tns__selectMediaAliasesWithTokenIdResponse *const*)ptr, "tns:selectMediaAliasesWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaAliasesWithTokenId:
		return soap_out_PointerTotns__selectMediaAliasesWithTokenId(soap, tag, id, (tns__selectMediaAliasesWithTokenId *const*)ptr, "tns:selectMediaAliasesWithTokenId");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectGameTokenWithIdResponse:
		return soap_out_PointerTotns__selectGameTokenWithIdResponse(soap, tag, id, (tns__selectGameTokenWithIdResponse *const*)ptr, "tns:selectGameTokenWithIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectGameTokenWithId:
		return soap_out_PointerTotns__selectGameTokenWithId(soap, tag, id, (tns__selectGameTokenWithId *const*)ptr, "tns:selectGameTokenWithId");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectGameTokenWithDigestResponse:
		return soap_out_PointerTotns__selectGameTokenWithDigestResponse(soap, tag, id, (tns__selectGameTokenWithDigestResponse *const*)ptr, "tns:selectGameTokenWithDigestResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectGameTokenWithDigest:
		return soap_out_PointerTotns__selectGameTokenWithDigest(soap, tag, id, (tns__selectGameTokenWithDigest *const*)ptr, "tns:selectGameTokenWithDigest");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectGameAnnotationsWithTokenIdResponse:
		return soap_out_PointerTotns__selectGameAnnotationsWithTokenIdResponse(soap, tag, id, (tns__selectGameAnnotationsWithTokenIdResponse *const*)ptr, "tns:selectGameAnnotationsWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectGameAnnotationsWithTokenId:
		return soap_out_PointerTotns__selectGameAnnotationsWithTokenId(soap, tag, id, (tns__selectGameAnnotationsWithTokenId *const*)ptr, "tns:selectGameAnnotationsWithTokenId");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectGameAliasesWithTokenIdResponse:
		return soap_out_PointerTotns__selectGameAliasesWithTokenIdResponse(soap, tag, id, (tns__selectGameAliasesWithTokenIdResponse *const*)ptr, "tns:selectGameAliasesWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectGameAliasesWithTokenId:
		return soap_out_PointerTotns__selectGameAliasesWithTokenId(soap, tag, id, (tns__selectGameAliasesWithTokenId *const*)ptr, "tns:selectGameAliasesWithTokenId");
	case SOAP_TYPE_ServerSoap_PointerTotns__isConnectedResponse:
		return soap_out_PointerTotns__isConnectedResponse(soap, tag, id, (tns__isConnectedResponse *const*)ptr, "tns:isConnectedResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__isConnected:
		return soap_out_PointerTotns__isConnected(soap, tag, id, (tns__isConnected *const*)ptr, "tns:isConnected");
	case SOAP_TYPE_ServerSoap_PointerTotns__isClientUpdatedResponse:
		return soap_out_PointerTotns__isClientUpdatedResponse(soap, tag, id, (tns__isClientUpdatedResponse *const*)ptr, "tns:isClientUpdatedResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__isClientUpdated:
		return soap_out_PointerTotns__isClientUpdated(soap, tag, id, (tns__isClientUpdated *const*)ptr, "tns:isClientUpdated");
	case SOAP_TYPE_ServerSoap_PointerTotns__chatResponse:
		return soap_out_PointerTotns__chatResponse(soap, tag, id, (tns__chatResponse *const*)ptr, "tns:chatResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__chat:
		return soap_out_PointerTotns__chat(soap, tag, id, (tns__chat *const*)ptr, "tns:chat");
	case SOAP_TYPE_ServerSoap_PointerTotns__blessMediaAnnotationWithIdResponse:
		return soap_out_PointerTotns__blessMediaAnnotationWithIdResponse(soap, tag, id, (tns__blessMediaAnnotationWithIdResponse *const*)ptr, "tns:blessMediaAnnotationWithIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__blessMediaAnnotationWithId:
		return soap_out_PointerTotns__blessMediaAnnotationWithId(soap, tag, id, (tns__blessMediaAnnotationWithId *const*)ptr, "tns:blessMediaAnnotationWithId");
	case SOAP_TYPE_ServerSoap_PointerTotns__blessGameAnnotationWithIdResponse:
		return soap_out_PointerTotns__blessGameAnnotationWithIdResponse(soap, tag, id, (tns__blessGameAnnotationWithIdResponse *const*)ptr, "tns:blessGameAnnotationWithIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__blessGameAnnotationWithId:
		return soap_out_PointerTotns__blessGameAnnotationWithId(soap, tag, id, (tns__blessGameAnnotationWithId *const*)ptr, "tns:blessGameAnnotationWithId");
	case SOAP_TYPE_ServerSoap_PointerTotns__user:
		return soap_out_PointerTotns__user(soap, tag, id, (tns__user *const*)ptr, "tns:user");
	case SOAP_TYPE_ServerSoap_PointerTotns__mediaToken:
		return soap_out_PointerTotns__mediaToken(soap, tag, id, (tns__mediaToken *const*)ptr, "tns:mediaToken");
	case SOAP_TYPE_ServerSoap_PointerTotns__mediaAnnotation:
		return soap_out_PointerTotns__mediaAnnotation(soap, tag, id, (tns__mediaAnnotation *const*)ptr, "tns:mediaAnnotation");
	case SOAP_TYPE_ServerSoap_PointerTotns__mediaAlias:
		return soap_out_PointerTotns__mediaAlias(soap, tag, id, (tns__mediaAlias *const*)ptr, "tns:mediaAlias");
	case SOAP_TYPE_ServerSoap_PointerTotns__gameToken:
		return soap_out_PointerTotns__gameToken(soap, tag, id, (tns__gameToken *const*)ptr, "tns:gameToken");
	case SOAP_TYPE_ServerSoap_PointerTotns__gameAnnotation:
		return soap_out_PointerTotns__gameAnnotation(soap, tag, id, (tns__gameAnnotation *const*)ptr, "tns:gameAnnotation");
	case SOAP_TYPE_ServerSoap_PointerTotns__gameAlias:
		return soap_out_PointerTotns__gameAlias(soap, tag, id, (tns__gameAlias *const*)ptr, "tns:gameAlias");
	case SOAP_TYPE_ServerSoap_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_ServerSoap__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_ServerSoap_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_ServerSoap_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithIdResponse:
		((tns__updateMediaAnnotationTextWithIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithId:
		((tns__updateMediaAnnotationTextWithId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__updateGameAnnotationTextWithIdResponse:
		((tns__updateGameAnnotationTextWithIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__updateGameAnnotationTextWithId:
		((tns__updateGameAnnotationTextWithId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigestResponse:
		((tns__submitMediaTokenDigestResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigest:
		((tns__submitMediaTokenDigest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaTokenResponse:
		((tns__submitMediaTokenResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaToken:
		((tns__submitMediaToken *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenIdResponse:
		((tns__submitMediaAnnotationTextWithTokenIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenId:
		((tns__submitMediaAnnotationTextWithTokenId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigestResponse:
		((tns__submitMediaAnnotationTextAndTokenDigestResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigest:
		((tns__submitMediaAnnotationTextAndTokenDigest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationResponse:
		((tns__submitMediaAnnotationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotation:
		((tns__submitMediaAnnotation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenIdResponse:
		((tns__submitMediaAliasTextWithTokenIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenId:
		((tns__submitMediaAliasTextWithTokenId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigestResponse:
		((tns__submitMediaAliasTextAndTokenDigestResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigest:
		((tns__submitMediaAliasTextAndTokenDigest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasResponse:
		((tns__submitMediaAliasResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAlias:
		((tns__submitMediaAlias *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitGameTokenDigestResponse:
		((tns__submitGameTokenDigestResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitGameTokenDigest:
		((tns__submitGameTokenDigest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitGameTokenResponse:
		((tns__submitGameTokenResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitGameToken:
		((tns__submitGameToken *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextWithTokenIdResponse:
		((tns__submitGameAnnotationTextWithTokenIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextWithTokenId:
		((tns__submitGameAnnotationTextWithTokenId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextAndTokenDigestResponse:
		((tns__submitGameAnnotationTextAndTokenDigestResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextAndTokenDigest:
		((tns__submitGameAnnotationTextAndTokenDigest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitGameAnnotationResponse:
		((tns__submitGameAnnotationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitGameAnnotation:
		((tns__submitGameAnnotation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitGameAliasTextWithTokenIdResponse:
		((tns__submitGameAliasTextWithTokenIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitGameAliasTextWithTokenId:
		((tns__submitGameAliasTextWithTokenId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitGameAliasTextAndTokenDigestResponse:
		((tns__submitGameAliasTextAndTokenDigestResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitGameAliasTextAndTokenDigest:
		((tns__submitGameAliasTextAndTokenDigest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitGameAliasResponse:
		((tns__submitGameAliasResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitGameAlias:
		((tns__submitGameAlias *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__setUserLanguageResponse:
		((tns__setUserLanguageResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__setUserLanguage:
		((tns__setUserLanguage *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__setUserAnonymousResponse:
		((tns__setUserAnonymousResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__setUserAnonymous:
		((tns__setUserAnonymous *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectUserResponse:
		((tns__selectUserResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectUser:
		((tns__selectUser *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenIdResponse:
		((tns__selectRelatedMediaAnnotationsWithTokenIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenId:
		((tns__selectRelatedMediaAnnotationsWithTokenId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectRelatedGameAnnotationsWithTokenIdResponse:
		((tns__selectRelatedGameAnnotationsWithTokenIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectRelatedGameAnnotationsWithTokenId:
		((tns__selectRelatedGameAnnotationsWithTokenId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithIdResponse:
		((tns__selectMediaTokenWithIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithId:
		((tns__selectMediaTokenWithId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigestResponse:
		((tns__selectMediaTokenWithDigestResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigest:
		((tns__selectMediaTokenWithDigest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenIdResponse:
		((tns__selectMediaAnnotationsWithTokenIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenId:
		((tns__selectMediaAnnotationsWithTokenId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenIdResponse:
		((tns__selectMediaAliasesWithTokenIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenId:
		((tns__selectMediaAliasesWithTokenId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectGameTokenWithIdResponse:
		((tns__selectGameTokenWithIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectGameTokenWithId:
		((tns__selectGameTokenWithId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectGameTokenWithDigestResponse:
		((tns__selectGameTokenWithDigestResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectGameTokenWithDigest:
		((tns__selectGameTokenWithDigest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectGameAnnotationsWithTokenIdResponse:
		((tns__selectGameAnnotationsWithTokenIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectGameAnnotationsWithTokenId:
		((tns__selectGameAnnotationsWithTokenId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectGameAliasesWithTokenIdResponse:
		((tns__selectGameAliasesWithTokenIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectGameAliasesWithTokenId:
		((tns__selectGameAliasesWithTokenId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__isConnectedResponse:
		((tns__isConnectedResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__isConnected:
		((tns__isConnected *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__isClientUpdatedResponse:
		((tns__isClientUpdatedResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__isClientUpdated:
		((tns__isClientUpdated *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__chatResponse:
		((tns__chatResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__chat:
		((tns__chat *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithIdResponse:
		((tns__blessMediaAnnotationWithIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithId:
		((tns__blessMediaAnnotationWithId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__blessGameAnnotationWithIdResponse:
		((tns__blessGameAnnotationWithIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__blessGameAnnotationWithId:
		((tns__blessGameAnnotationWithId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__user:
		((tns__user *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__mediaAlias:
		((tns__mediaAlias *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__mediaToken:
		((tns__mediaToken *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__mediaAnnotation:
		((tns__mediaAnnotation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__gameAlias:
		((tns__gameAlias *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__gameToken:
		((tns__gameToken *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__gameAnnotation:
		((tns__gameAnnotation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap___tns__updateMediaAnnotationTextWithId:
		soap_serialize___tns__updateMediaAnnotationTextWithId(soap, (const struct __tns__updateMediaAnnotationTextWithId *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__updateGameAnnotationTextWithId:
		soap_serialize___tns__updateGameAnnotationTextWithId(soap, (const struct __tns__updateGameAnnotationTextWithId *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitMediaTokenDigest:
		soap_serialize___tns__submitMediaTokenDigest(soap, (const struct __tns__submitMediaTokenDigest *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitMediaToken:
		soap_serialize___tns__submitMediaToken(soap, (const struct __tns__submitMediaToken *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitMediaAnnotationTextWithTokenId:
		soap_serialize___tns__submitMediaAnnotationTextWithTokenId(soap, (const struct __tns__submitMediaAnnotationTextWithTokenId *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitMediaAnnotationTextAndTokenDigest:
		soap_serialize___tns__submitMediaAnnotationTextAndTokenDigest(soap, (const struct __tns__submitMediaAnnotationTextAndTokenDigest *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitMediaAnnotation:
		soap_serialize___tns__submitMediaAnnotation(soap, (const struct __tns__submitMediaAnnotation *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitMediaAliasTextWithTokenId:
		soap_serialize___tns__submitMediaAliasTextWithTokenId(soap, (const struct __tns__submitMediaAliasTextWithTokenId *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitMediaAliasTextAndTokenDigest:
		soap_serialize___tns__submitMediaAliasTextAndTokenDigest(soap, (const struct __tns__submitMediaAliasTextAndTokenDigest *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitMediaAlias:
		soap_serialize___tns__submitMediaAlias(soap, (const struct __tns__submitMediaAlias *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitGameTokenDigest:
		soap_serialize___tns__submitGameTokenDigest(soap, (const struct __tns__submitGameTokenDigest *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitGameToken:
		soap_serialize___tns__submitGameToken(soap, (const struct __tns__submitGameToken *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitGameAnnotationTextWithTokenId:
		soap_serialize___tns__submitGameAnnotationTextWithTokenId(soap, (const struct __tns__submitGameAnnotationTextWithTokenId *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitGameAnnotationTextAndTokenDigest:
		soap_serialize___tns__submitGameAnnotationTextAndTokenDigest(soap, (const struct __tns__submitGameAnnotationTextAndTokenDigest *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitGameAnnotation:
		soap_serialize___tns__submitGameAnnotation(soap, (const struct __tns__submitGameAnnotation *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitGameAliasTextWithTokenId:
		soap_serialize___tns__submitGameAliasTextWithTokenId(soap, (const struct __tns__submitGameAliasTextWithTokenId *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitGameAliasTextAndTokenDigest:
		soap_serialize___tns__submitGameAliasTextAndTokenDigest(soap, (const struct __tns__submitGameAliasTextAndTokenDigest *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitGameAlias:
		soap_serialize___tns__submitGameAlias(soap, (const struct __tns__submitGameAlias *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__setUserLanguage:
		soap_serialize___tns__setUserLanguage(soap, (const struct __tns__setUserLanguage *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__setUserAnonymous:
		soap_serialize___tns__setUserAnonymous(soap, (const struct __tns__setUserAnonymous *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__selectUser:
		soap_serialize___tns__selectUser(soap, (const struct __tns__selectUser *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__selectRelatedMediaAnnotationsWithTokenId:
		soap_serialize___tns__selectRelatedMediaAnnotationsWithTokenId(soap, (const struct __tns__selectRelatedMediaAnnotationsWithTokenId *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__selectRelatedGameAnnotationsWithTokenId:
		soap_serialize___tns__selectRelatedGameAnnotationsWithTokenId(soap, (const struct __tns__selectRelatedGameAnnotationsWithTokenId *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__selectMediaTokenWithId:
		soap_serialize___tns__selectMediaTokenWithId(soap, (const struct __tns__selectMediaTokenWithId *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__selectMediaTokenWithDigest:
		soap_serialize___tns__selectMediaTokenWithDigest(soap, (const struct __tns__selectMediaTokenWithDigest *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__selectMediaAnnotationsWithTokenId:
		soap_serialize___tns__selectMediaAnnotationsWithTokenId(soap, (const struct __tns__selectMediaAnnotationsWithTokenId *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__selectMediaAliasesWithTokenId:
		soap_serialize___tns__selectMediaAliasesWithTokenId(soap, (const struct __tns__selectMediaAliasesWithTokenId *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__selectGameTokenWithId:
		soap_serialize___tns__selectGameTokenWithId(soap, (const struct __tns__selectGameTokenWithId *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__selectGameTokenWithDigest:
		soap_serialize___tns__selectGameTokenWithDigest(soap, (const struct __tns__selectGameTokenWithDigest *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__selectGameAnnotationsWithTokenId:
		soap_serialize___tns__selectGameAnnotationsWithTokenId(soap, (const struct __tns__selectGameAnnotationsWithTokenId *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__selectGameAliasesWithTokenId:
		soap_serialize___tns__selectGameAliasesWithTokenId(soap, (const struct __tns__selectGameAliasesWithTokenId *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__isConnected:
		soap_serialize___tns__isConnected(soap, (const struct __tns__isConnected *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__isClientUpdated:
		soap_serialize___tns__isClientUpdated(soap, (const struct __tns__isClientUpdated *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__chat:
		soap_serialize___tns__chat(soap, (const struct __tns__chat *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__blessMediaAnnotationWithId:
		soap_serialize___tns__blessMediaAnnotationWithId(soap, (const struct __tns__blessMediaAnnotationWithId *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__blessGameAnnotationWithId:
		soap_serialize___tns__blessGameAnnotationWithId(soap, (const struct __tns__blessGameAnnotationWithId *)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__updateMediaAnnotationTextWithIdResponse:
		soap_serialize_PointerTotns__updateMediaAnnotationTextWithIdResponse(soap, (tns__updateMediaAnnotationTextWithIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__updateMediaAnnotationTextWithId:
		soap_serialize_PointerTotns__updateMediaAnnotationTextWithId(soap, (tns__updateMediaAnnotationTextWithId *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__updateGameAnnotationTextWithIdResponse:
		soap_serialize_PointerTotns__updateGameAnnotationTextWithIdResponse(soap, (tns__updateGameAnnotationTextWithIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__updateGameAnnotationTextWithId:
		soap_serialize_PointerTotns__updateGameAnnotationTextWithId(soap, (tns__updateGameAnnotationTextWithId *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaTokenDigestResponse:
		soap_serialize_PointerTotns__submitMediaTokenDigestResponse(soap, (tns__submitMediaTokenDigestResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaTokenDigest:
		soap_serialize_PointerTotns__submitMediaTokenDigest(soap, (tns__submitMediaTokenDigest *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaTokenResponse:
		soap_serialize_PointerTotns__submitMediaTokenResponse(soap, (tns__submitMediaTokenResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaToken:
		soap_serialize_PointerTotns__submitMediaToken(soap, (tns__submitMediaToken *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse:
		soap_serialize_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse(soap, (tns__submitMediaAnnotationTextWithTokenIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotationTextWithTokenId:
		soap_serialize_PointerTotns__submitMediaAnnotationTextWithTokenId(soap, (tns__submitMediaAnnotationTextWithTokenId *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse:
		soap_serialize_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse(soap, (tns__submitMediaAnnotationTextAndTokenDigestResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotationTextAndTokenDigest:
		soap_serialize_PointerTotns__submitMediaAnnotationTextAndTokenDigest(soap, (tns__submitMediaAnnotationTextAndTokenDigest *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotationResponse:
		soap_serialize_PointerTotns__submitMediaAnnotationResponse(soap, (tns__submitMediaAnnotationResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotation:
		soap_serialize_PointerTotns__submitMediaAnnotation(soap, (tns__submitMediaAnnotation *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAliasTextWithTokenIdResponse:
		soap_serialize_PointerTotns__submitMediaAliasTextWithTokenIdResponse(soap, (tns__submitMediaAliasTextWithTokenIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAliasTextWithTokenId:
		soap_serialize_PointerTotns__submitMediaAliasTextWithTokenId(soap, (tns__submitMediaAliasTextWithTokenId *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAliasTextAndTokenDigestResponse:
		soap_serialize_PointerTotns__submitMediaAliasTextAndTokenDigestResponse(soap, (tns__submitMediaAliasTextAndTokenDigestResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAliasTextAndTokenDigest:
		soap_serialize_PointerTotns__submitMediaAliasTextAndTokenDigest(soap, (tns__submitMediaAliasTextAndTokenDigest *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAliasResponse:
		soap_serialize_PointerTotns__submitMediaAliasResponse(soap, (tns__submitMediaAliasResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAlias:
		soap_serialize_PointerTotns__submitMediaAlias(soap, (tns__submitMediaAlias *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameTokenDigestResponse:
		soap_serialize_PointerTotns__submitGameTokenDigestResponse(soap, (tns__submitGameTokenDigestResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameTokenDigest:
		soap_serialize_PointerTotns__submitGameTokenDigest(soap, (tns__submitGameTokenDigest *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameTokenResponse:
		soap_serialize_PointerTotns__submitGameTokenResponse(soap, (tns__submitGameTokenResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameToken:
		soap_serialize_PointerTotns__submitGameToken(soap, (tns__submitGameToken *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameAnnotationTextWithTokenIdResponse:
		soap_serialize_PointerTotns__submitGameAnnotationTextWithTokenIdResponse(soap, (tns__submitGameAnnotationTextWithTokenIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameAnnotationTextWithTokenId:
		soap_serialize_PointerTotns__submitGameAnnotationTextWithTokenId(soap, (tns__submitGameAnnotationTextWithTokenId *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameAnnotationTextAndTokenDigestResponse:
		soap_serialize_PointerTotns__submitGameAnnotationTextAndTokenDigestResponse(soap, (tns__submitGameAnnotationTextAndTokenDigestResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameAnnotationTextAndTokenDigest:
		soap_serialize_PointerTotns__submitGameAnnotationTextAndTokenDigest(soap, (tns__submitGameAnnotationTextAndTokenDigest *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameAnnotationResponse:
		soap_serialize_PointerTotns__submitGameAnnotationResponse(soap, (tns__submitGameAnnotationResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameAnnotation:
		soap_serialize_PointerTotns__submitGameAnnotation(soap, (tns__submitGameAnnotation *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameAliasTextWithTokenIdResponse:
		soap_serialize_PointerTotns__submitGameAliasTextWithTokenIdResponse(soap, (tns__submitGameAliasTextWithTokenIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameAliasTextWithTokenId:
		soap_serialize_PointerTotns__submitGameAliasTextWithTokenId(soap, (tns__submitGameAliasTextWithTokenId *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameAliasTextAndTokenDigestResponse:
		soap_serialize_PointerTotns__submitGameAliasTextAndTokenDigestResponse(soap, (tns__submitGameAliasTextAndTokenDigestResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameAliasTextAndTokenDigest:
		soap_serialize_PointerTotns__submitGameAliasTextAndTokenDigest(soap, (tns__submitGameAliasTextAndTokenDigest *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameAliasResponse:
		soap_serialize_PointerTotns__submitGameAliasResponse(soap, (tns__submitGameAliasResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitGameAlias:
		soap_serialize_PointerTotns__submitGameAlias(soap, (tns__submitGameAlias *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__setUserLanguageResponse:
		soap_serialize_PointerTotns__setUserLanguageResponse(soap, (tns__setUserLanguageResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__setUserLanguage:
		soap_serialize_PointerTotns__setUserLanguage(soap, (tns__setUserLanguage *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__setUserAnonymousResponse:
		soap_serialize_PointerTotns__setUserAnonymousResponse(soap, (tns__setUserAnonymousResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__setUserAnonymous:
		soap_serialize_PointerTotns__setUserAnonymous(soap, (tns__setUserAnonymous *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__selectUserResponse:
		soap_serialize_PointerTotns__selectUserResponse(soap, (tns__selectUserResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__selectUser:
		soap_serialize_PointerTotns__selectUser(soap, (tns__selectUser *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse:
		soap_serialize_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse(soap, (tns__selectRelatedMediaAnnotationsWithTokenIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__selectRelatedMediaAnnotationsWithTokenId:
		soap_serialize_PointerTotns__selectRelatedMediaAnnotationsWithTokenId(soap, (tns__selectRelatedMediaAnnotationsWithTokenId *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__selectRelatedGameAnnotationsWithTokenIdResponse:
		soap_serialize_PointerTotns__selectRelatedGameAnnotationsWithTokenIdResponse(soap, (tns__selectRelatedGameAnnotationsWithTokenIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__selectRelatedGameAnnotationsWithTokenId:
		soap_serialize_PointerTotns__selectRelatedGameAnnotationsWithTokenId(soap, (tns__selectRelatedGameAnnotationsWithTokenId *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaTokenWithIdResponse:
		soap_serialize_PointerTotns__selectMediaTokenWithIdResponse(soap, (tns__selectMediaTokenWithIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaTokenWithId:
		soap_serialize_PointerTotns__selectMediaTokenWithId(soap, (tns__selectMediaTokenWithId *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaTokenWithDigestResponse:
		soap_serialize_PointerTotns__selectMediaTokenWithDigestResponse(soap, (tns__selectMediaTokenWithDigestResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaTokenWithDigest:
		soap_serialize_PointerTotns__selectMediaTokenWithDigest(soap, (tns__selectMediaTokenWithDigest *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaAnnotationsWithTokenIdResponse:
		soap_serialize_PointerTotns__selectMediaAnnotationsWithTokenIdResponse(soap, (tns__selectMediaAnnotationsWithTokenIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaAnnotationsWithTokenId:
		soap_serialize_PointerTotns__selectMediaAnnotationsWithTokenId(soap, (tns__selectMediaAnnotationsWithTokenId *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaAliasesWithTokenIdResponse:
		soap_serialize_PointerTotns__selectMediaAliasesWithTokenIdResponse(soap, (tns__selectMediaAliasesWithTokenIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaAliasesWithTokenId:
		soap_serialize_PointerTotns__selectMediaAliasesWithTokenId(soap, (tns__selectMediaAliasesWithTokenId *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__selectGameTokenWithIdResponse:
		soap_serialize_PointerTotns__selectGameTokenWithIdResponse(soap, (tns__selectGameTokenWithIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__selectGameTokenWithId:
		soap_serialize_PointerTotns__selectGameTokenWithId(soap, (tns__selectGameTokenWithId *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__selectGameTokenWithDigestResponse:
		soap_serialize_PointerTotns__selectGameTokenWithDigestResponse(soap, (tns__selectGameTokenWithDigestResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__selectGameTokenWithDigest:
		soap_serialize_PointerTotns__selectGameTokenWithDigest(soap, (tns__selectGameTokenWithDigest *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__selectGameAnnotationsWithTokenIdResponse:
		soap_serialize_PointerTotns__selectGameAnnotationsWithTokenIdResponse(soap, (tns__selectGameAnnotationsWithTokenIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__selectGameAnnotationsWithTokenId:
		soap_serialize_PointerTotns__selectGameAnnotationsWithTokenId(soap, (tns__selectGameAnnotationsWithTokenId *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__selectGameAliasesWithTokenIdResponse:
		soap_serialize_PointerTotns__selectGameAliasesWithTokenIdResponse(soap, (tns__selectGameAliasesWithTokenIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__selectGameAliasesWithTokenId:
		soap_serialize_PointerTotns__selectGameAliasesWithTokenId(soap, (tns__selectGameAliasesWithTokenId *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__isConnectedResponse:
		soap_serialize_PointerTotns__isConnectedResponse(soap, (tns__isConnectedResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__isConnected:
		soap_serialize_PointerTotns__isConnected(soap, (tns__isConnected *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__isClientUpdatedResponse:
		soap_serialize_PointerTotns__isClientUpdatedResponse(soap, (tns__isClientUpdatedResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__isClientUpdated:
		soap_serialize_PointerTotns__isClientUpdated(soap, (tns__isClientUpdated *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__chatResponse:
		soap_serialize_PointerTotns__chatResponse(soap, (tns__chatResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__chat:
		soap_serialize_PointerTotns__chat(soap, (tns__chat *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__blessMediaAnnotationWithIdResponse:
		soap_serialize_PointerTotns__blessMediaAnnotationWithIdResponse(soap, (tns__blessMediaAnnotationWithIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__blessMediaAnnotationWithId:
		soap_serialize_PointerTotns__blessMediaAnnotationWithId(soap, (tns__blessMediaAnnotationWithId *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__blessGameAnnotationWithIdResponse:
		soap_serialize_PointerTotns__blessGameAnnotationWithIdResponse(soap, (tns__blessGameAnnotationWithIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__blessGameAnnotationWithId:
		soap_serialize_PointerTotns__blessGameAnnotationWithId(soap, (tns__blessGameAnnotationWithId *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__user:
		soap_serialize_PointerTotns__user(soap, (tns__user *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__mediaToken:
		soap_serialize_PointerTotns__mediaToken(soap, (tns__mediaToken *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__mediaAnnotation:
		soap_serialize_PointerTotns__mediaAnnotation(soap, (tns__mediaAnnotation *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__mediaAlias:
		soap_serialize_PointerTotns__mediaAlias(soap, (tns__mediaAlias *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__gameToken:
		soap_serialize_PointerTotns__gameToken(soap, (tns__gameToken *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__gameAnnotation:
		soap_serialize_PointerTotns__gameAnnotation(soap, (tns__gameAnnotation *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__gameAlias:
		soap_serialize_PointerTotns__gameAlias(soap, (tns__gameAlias *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_ServerSoap_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 ServerSoap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_ServerSoap_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__gameAnnotation:
		return (void*)soap_instantiate_tns__gameAnnotation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__gameToken:
		return (void*)soap_instantiate_tns__gameToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__gameAlias:
		return (void*)soap_instantiate_tns__gameAlias(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__mediaAnnotation:
		return (void*)soap_instantiate_tns__mediaAnnotation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__mediaToken:
		return (void*)soap_instantiate_tns__mediaToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__mediaAlias:
		return (void*)soap_instantiate_tns__mediaAlias(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__user:
		return (void*)soap_instantiate_tns__user(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__blessGameAnnotationWithId:
		return (void*)soap_instantiate_tns__blessGameAnnotationWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__blessGameAnnotationWithIdResponse:
		return (void*)soap_instantiate_tns__blessGameAnnotationWithIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithId:
		return (void*)soap_instantiate_tns__blessMediaAnnotationWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithIdResponse:
		return (void*)soap_instantiate_tns__blessMediaAnnotationWithIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__chat:
		return (void*)soap_instantiate_tns__chat(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__chatResponse:
		return (void*)soap_instantiate_tns__chatResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__isClientUpdated:
		return (void*)soap_instantiate_tns__isClientUpdated(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__isClientUpdatedResponse:
		return (void*)soap_instantiate_tns__isClientUpdatedResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__isConnected:
		return (void*)soap_instantiate_tns__isConnected(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__isConnectedResponse:
		return (void*)soap_instantiate_tns__isConnectedResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__selectGameAliasesWithTokenId:
		return (void*)soap_instantiate_tns__selectGameAliasesWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__selectGameAliasesWithTokenIdResponse:
		return (void*)soap_instantiate_tns__selectGameAliasesWithTokenIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__selectGameAnnotationsWithTokenId:
		return (void*)soap_instantiate_tns__selectGameAnnotationsWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__selectGameAnnotationsWithTokenIdResponse:
		return (void*)soap_instantiate_tns__selectGameAnnotationsWithTokenIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__selectGameTokenWithDigest:
		return (void*)soap_instantiate_tns__selectGameTokenWithDigest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__selectGameTokenWithDigestResponse:
		return (void*)soap_instantiate_tns__selectGameTokenWithDigestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__selectGameTokenWithId:
		return (void*)soap_instantiate_tns__selectGameTokenWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__selectGameTokenWithIdResponse:
		return (void*)soap_instantiate_tns__selectGameTokenWithIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenId:
		return (void*)soap_instantiate_tns__selectMediaAliasesWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenIdResponse:
		return (void*)soap_instantiate_tns__selectMediaAliasesWithTokenIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenId:
		return (void*)soap_instantiate_tns__selectMediaAnnotationsWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenIdResponse:
		return (void*)soap_instantiate_tns__selectMediaAnnotationsWithTokenIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigest:
		return (void*)soap_instantiate_tns__selectMediaTokenWithDigest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigestResponse:
		return (void*)soap_instantiate_tns__selectMediaTokenWithDigestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithId:
		return (void*)soap_instantiate_tns__selectMediaTokenWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithIdResponse:
		return (void*)soap_instantiate_tns__selectMediaTokenWithIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__selectRelatedGameAnnotationsWithTokenId:
		return (void*)soap_instantiate_tns__selectRelatedGameAnnotationsWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__selectRelatedGameAnnotationsWithTokenIdResponse:
		return (void*)soap_instantiate_tns__selectRelatedGameAnnotationsWithTokenIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenId:
		return (void*)soap_instantiate_tns__selectRelatedMediaAnnotationsWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenIdResponse:
		return (void*)soap_instantiate_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__selectUser:
		return (void*)soap_instantiate_tns__selectUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__selectUserResponse:
		return (void*)soap_instantiate_tns__selectUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__setUserAnonymous:
		return (void*)soap_instantiate_tns__setUserAnonymous(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__setUserAnonymousResponse:
		return (void*)soap_instantiate_tns__setUserAnonymousResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__setUserLanguage:
		return (void*)soap_instantiate_tns__setUserLanguage(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__setUserLanguageResponse:
		return (void*)soap_instantiate_tns__setUserLanguageResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitGameAlias:
		return (void*)soap_instantiate_tns__submitGameAlias(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitGameAliasResponse:
		return (void*)soap_instantiate_tns__submitGameAliasResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitGameAliasTextAndTokenDigest:
		return (void*)soap_instantiate_tns__submitGameAliasTextAndTokenDigest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitGameAliasTextAndTokenDigestResponse:
		return (void*)soap_instantiate_tns__submitGameAliasTextAndTokenDigestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitGameAliasTextWithTokenId:
		return (void*)soap_instantiate_tns__submitGameAliasTextWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitGameAliasTextWithTokenIdResponse:
		return (void*)soap_instantiate_tns__submitGameAliasTextWithTokenIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitGameAnnotation:
		return (void*)soap_instantiate_tns__submitGameAnnotation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitGameAnnotationResponse:
		return (void*)soap_instantiate_tns__submitGameAnnotationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextAndTokenDigest:
		return (void*)soap_instantiate_tns__submitGameAnnotationTextAndTokenDigest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextAndTokenDigestResponse:
		return (void*)soap_instantiate_tns__submitGameAnnotationTextAndTokenDigestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextWithTokenId:
		return (void*)soap_instantiate_tns__submitGameAnnotationTextWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextWithTokenIdResponse:
		return (void*)soap_instantiate_tns__submitGameAnnotationTextWithTokenIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitGameToken:
		return (void*)soap_instantiate_tns__submitGameToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitGameTokenResponse:
		return (void*)soap_instantiate_tns__submitGameTokenResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitGameTokenDigest:
		return (void*)soap_instantiate_tns__submitGameTokenDigest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitGameTokenDigestResponse:
		return (void*)soap_instantiate_tns__submitGameTokenDigestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitMediaAlias:
		return (void*)soap_instantiate_tns__submitMediaAlias(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasResponse:
		return (void*)soap_instantiate_tns__submitMediaAliasResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigest:
		return (void*)soap_instantiate_tns__submitMediaAliasTextAndTokenDigest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigestResponse:
		return (void*)soap_instantiate_tns__submitMediaAliasTextAndTokenDigestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenId:
		return (void*)soap_instantiate_tns__submitMediaAliasTextWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenIdResponse:
		return (void*)soap_instantiate_tns__submitMediaAliasTextWithTokenIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotation:
		return (void*)soap_instantiate_tns__submitMediaAnnotation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationResponse:
		return (void*)soap_instantiate_tns__submitMediaAnnotationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigest:
		return (void*)soap_instantiate_tns__submitMediaAnnotationTextAndTokenDigest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigestResponse:
		return (void*)soap_instantiate_tns__submitMediaAnnotationTextAndTokenDigestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenId:
		return (void*)soap_instantiate_tns__submitMediaAnnotationTextWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenIdResponse:
		return (void*)soap_instantiate_tns__submitMediaAnnotationTextWithTokenIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitMediaToken:
		return (void*)soap_instantiate_tns__submitMediaToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitMediaTokenResponse:
		return (void*)soap_instantiate_tns__submitMediaTokenResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigest:
		return (void*)soap_instantiate_tns__submitMediaTokenDigest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigestResponse:
		return (void*)soap_instantiate_tns__submitMediaTokenDigestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__updateGameAnnotationTextWithId:
		return (void*)soap_instantiate_tns__updateGameAnnotationTextWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__updateGameAnnotationTextWithIdResponse:
		return (void*)soap_instantiate_tns__updateGameAnnotationTextWithIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithId:
		return (void*)soap_instantiate_tns__updateMediaAnnotationTextWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithIdResponse:
		return (void*)soap_instantiate_tns__updateMediaAnnotationTextWithIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__blessGameAnnotationWithId:
		return (void*)soap_instantiate___tns__blessGameAnnotationWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__blessMediaAnnotationWithId:
		return (void*)soap_instantiate___tns__blessMediaAnnotationWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__chat:
		return (void*)soap_instantiate___tns__chat(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__isClientUpdated:
		return (void*)soap_instantiate___tns__isClientUpdated(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__isConnected:
		return (void*)soap_instantiate___tns__isConnected(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__selectGameAliasesWithTokenId:
		return (void*)soap_instantiate___tns__selectGameAliasesWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__selectGameAnnotationsWithTokenId:
		return (void*)soap_instantiate___tns__selectGameAnnotationsWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__selectGameTokenWithDigest:
		return (void*)soap_instantiate___tns__selectGameTokenWithDigest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__selectGameTokenWithId:
		return (void*)soap_instantiate___tns__selectGameTokenWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__selectMediaAliasesWithTokenId:
		return (void*)soap_instantiate___tns__selectMediaAliasesWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__selectMediaAnnotationsWithTokenId:
		return (void*)soap_instantiate___tns__selectMediaAnnotationsWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__selectMediaTokenWithDigest:
		return (void*)soap_instantiate___tns__selectMediaTokenWithDigest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__selectMediaTokenWithId:
		return (void*)soap_instantiate___tns__selectMediaTokenWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__selectRelatedGameAnnotationsWithTokenId:
		return (void*)soap_instantiate___tns__selectRelatedGameAnnotationsWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__selectRelatedMediaAnnotationsWithTokenId:
		return (void*)soap_instantiate___tns__selectRelatedMediaAnnotationsWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__selectUser:
		return (void*)soap_instantiate___tns__selectUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__setUserAnonymous:
		return (void*)soap_instantiate___tns__setUserAnonymous(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__setUserLanguage:
		return (void*)soap_instantiate___tns__setUserLanguage(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__submitGameAlias:
		return (void*)soap_instantiate___tns__submitGameAlias(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__submitGameAliasTextAndTokenDigest:
		return (void*)soap_instantiate___tns__submitGameAliasTextAndTokenDigest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__submitGameAliasTextWithTokenId:
		return (void*)soap_instantiate___tns__submitGameAliasTextWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__submitGameAnnotation:
		return (void*)soap_instantiate___tns__submitGameAnnotation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__submitGameAnnotationTextAndTokenDigest:
		return (void*)soap_instantiate___tns__submitGameAnnotationTextAndTokenDigest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__submitGameAnnotationTextWithTokenId:
		return (void*)soap_instantiate___tns__submitGameAnnotationTextWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__submitGameToken:
		return (void*)soap_instantiate___tns__submitGameToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__submitGameTokenDigest:
		return (void*)soap_instantiate___tns__submitGameTokenDigest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__submitMediaAlias:
		return (void*)soap_instantiate___tns__submitMediaAlias(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__submitMediaAliasTextAndTokenDigest:
		return (void*)soap_instantiate___tns__submitMediaAliasTextAndTokenDigest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__submitMediaAliasTextWithTokenId:
		return (void*)soap_instantiate___tns__submitMediaAliasTextWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__submitMediaAnnotation:
		return (void*)soap_instantiate___tns__submitMediaAnnotation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__submitMediaAnnotationTextAndTokenDigest:
		return (void*)soap_instantiate___tns__submitMediaAnnotationTextAndTokenDigest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__submitMediaAnnotationTextWithTokenId:
		return (void*)soap_instantiate___tns__submitMediaAnnotationTextWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__submitMediaToken:
		return (void*)soap_instantiate___tns__submitMediaToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__submitMediaTokenDigest:
		return (void*)soap_instantiate___tns__submitMediaTokenDigest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__updateGameAnnotationTextWithId:
		return (void*)soap_instantiate___tns__updateGameAnnotationTextWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__updateMediaAnnotationTextWithId:
		return (void*)soap_instantiate___tns__updateMediaAnnotationTextWithId(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_ServerSoap_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_ServerSoap_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_ServerSoap_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_ServerSoap_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_ServerSoap_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_ServerSoap_std__vectorTemplateOfPointerTotns__mediaAnnotation:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTotns__mediaAnnotation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_std__vectorTemplateOfPointerTotns__mediaAlias:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTotns__mediaAlias(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_std__vectorTemplateOfPointerTotns__gameAnnotation:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTotns__gameAnnotation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_std__vectorTemplateOfPointerTotns__gameAlias:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTotns__gameAlias(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 ServerSoap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_ServerSoap_std__string:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__gameAnnotation:
		if (p->size < 0)
			SOAP_DELETE((tns__gameAnnotation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__gameAnnotation*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__gameToken:
		if (p->size < 0)
			SOAP_DELETE((tns__gameToken*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__gameToken*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__gameAlias:
		if (p->size < 0)
			SOAP_DELETE((tns__gameAlias*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__gameAlias*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__mediaAnnotation:
		if (p->size < 0)
			SOAP_DELETE((tns__mediaAnnotation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__mediaAnnotation*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__mediaToken:
		if (p->size < 0)
			SOAP_DELETE((tns__mediaToken*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__mediaToken*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__mediaAlias:
		if (p->size < 0)
			SOAP_DELETE((tns__mediaAlias*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__mediaAlias*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__user:
		if (p->size < 0)
			SOAP_DELETE((tns__user*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__user*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__blessGameAnnotationWithId:
		if (p->size < 0)
			SOAP_DELETE((tns__blessGameAnnotationWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__blessGameAnnotationWithId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__blessGameAnnotationWithIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__blessGameAnnotationWithIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__blessGameAnnotationWithIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithId:
		if (p->size < 0)
			SOAP_DELETE((tns__blessMediaAnnotationWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__blessMediaAnnotationWithId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__blessMediaAnnotationWithIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__blessMediaAnnotationWithIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__chat:
		if (p->size < 0)
			SOAP_DELETE((tns__chat*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__chat*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__chatResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__chatResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__chatResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__isClientUpdated:
		if (p->size < 0)
			SOAP_DELETE((tns__isClientUpdated*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__isClientUpdated*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__isClientUpdatedResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__isClientUpdatedResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__isClientUpdatedResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__isConnected:
		if (p->size < 0)
			SOAP_DELETE((tns__isConnected*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__isConnected*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__isConnectedResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__isConnectedResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__isConnectedResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectGameAliasesWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((tns__selectGameAliasesWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectGameAliasesWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectGameAliasesWithTokenIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__selectGameAliasesWithTokenIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectGameAliasesWithTokenIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectGameAnnotationsWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((tns__selectGameAnnotationsWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectGameAnnotationsWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectGameAnnotationsWithTokenIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__selectGameAnnotationsWithTokenIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectGameAnnotationsWithTokenIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectGameTokenWithDigest:
		if (p->size < 0)
			SOAP_DELETE((tns__selectGameTokenWithDigest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectGameTokenWithDigest*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectGameTokenWithDigestResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__selectGameTokenWithDigestResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectGameTokenWithDigestResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectGameTokenWithId:
		if (p->size < 0)
			SOAP_DELETE((tns__selectGameTokenWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectGameTokenWithId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectGameTokenWithIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__selectGameTokenWithIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectGameTokenWithIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((tns__selectMediaAliasesWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectMediaAliasesWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__selectMediaAliasesWithTokenIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectMediaAliasesWithTokenIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((tns__selectMediaAnnotationsWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectMediaAnnotationsWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__selectMediaAnnotationsWithTokenIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectMediaAnnotationsWithTokenIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigest:
		if (p->size < 0)
			SOAP_DELETE((tns__selectMediaTokenWithDigest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectMediaTokenWithDigest*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigestResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__selectMediaTokenWithDigestResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectMediaTokenWithDigestResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithId:
		if (p->size < 0)
			SOAP_DELETE((tns__selectMediaTokenWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectMediaTokenWithId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__selectMediaTokenWithIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectMediaTokenWithIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectRelatedGameAnnotationsWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((tns__selectRelatedGameAnnotationsWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectRelatedGameAnnotationsWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectRelatedGameAnnotationsWithTokenIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__selectRelatedGameAnnotationsWithTokenIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectRelatedGameAnnotationsWithTokenIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((tns__selectRelatedMediaAnnotationsWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectRelatedMediaAnnotationsWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__selectRelatedMediaAnnotationsWithTokenIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectRelatedMediaAnnotationsWithTokenIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectUser:
		if (p->size < 0)
			SOAP_DELETE((tns__selectUser*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectUser*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectUserResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__selectUserResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectUserResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__setUserAnonymous:
		if (p->size < 0)
			SOAP_DELETE((tns__setUserAnonymous*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__setUserAnonymous*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__setUserAnonymousResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__setUserAnonymousResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__setUserAnonymousResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__setUserLanguage:
		if (p->size < 0)
			SOAP_DELETE((tns__setUserLanguage*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__setUserLanguage*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__setUserLanguageResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__setUserLanguageResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__setUserLanguageResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitGameAlias:
		if (p->size < 0)
			SOAP_DELETE((tns__submitGameAlias*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitGameAlias*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitGameAliasResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__submitGameAliasResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitGameAliasResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitGameAliasTextAndTokenDigest:
		if (p->size < 0)
			SOAP_DELETE((tns__submitGameAliasTextAndTokenDigest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitGameAliasTextAndTokenDigest*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitGameAliasTextAndTokenDigestResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__submitGameAliasTextAndTokenDigestResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitGameAliasTextAndTokenDigestResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitGameAliasTextWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((tns__submitGameAliasTextWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitGameAliasTextWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitGameAliasTextWithTokenIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__submitGameAliasTextWithTokenIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitGameAliasTextWithTokenIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitGameAnnotation:
		if (p->size < 0)
			SOAP_DELETE((tns__submitGameAnnotation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitGameAnnotation*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitGameAnnotationResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__submitGameAnnotationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitGameAnnotationResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextAndTokenDigest:
		if (p->size < 0)
			SOAP_DELETE((tns__submitGameAnnotationTextAndTokenDigest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitGameAnnotationTextAndTokenDigest*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextAndTokenDigestResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__submitGameAnnotationTextAndTokenDigestResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitGameAnnotationTextAndTokenDigestResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((tns__submitGameAnnotationTextWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitGameAnnotationTextWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextWithTokenIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__submitGameAnnotationTextWithTokenIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitGameAnnotationTextWithTokenIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitGameToken:
		if (p->size < 0)
			SOAP_DELETE((tns__submitGameToken*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitGameToken*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitGameTokenResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__submitGameTokenResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitGameTokenResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitGameTokenDigest:
		if (p->size < 0)
			SOAP_DELETE((tns__submitGameTokenDigest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitGameTokenDigest*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitGameTokenDigestResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__submitGameTokenDigestResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitGameTokenDigestResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAlias:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaAlias*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaAlias*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaAliasResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaAliasResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigest:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaAliasTextAndTokenDigest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaAliasTextAndTokenDigest*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigestResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaAliasTextAndTokenDigestResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaAliasTextAndTokenDigestResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaAliasTextWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaAliasTextWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaAliasTextWithTokenIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaAliasTextWithTokenIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotation:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaAnnotation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaAnnotation*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaAnnotationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaAnnotationResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigest:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaAnnotationTextAndTokenDigest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaAnnotationTextAndTokenDigest*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigestResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaAnnotationTextAndTokenDigestResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaAnnotationTextAndTokenDigestResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaAnnotationTextWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaAnnotationTextWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaAnnotationTextWithTokenIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaAnnotationTextWithTokenIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaToken:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaToken*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaToken*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaTokenResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaTokenResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaTokenResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigest:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaTokenDigest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaTokenDigest*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigestResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaTokenDigestResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaTokenDigestResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__updateGameAnnotationTextWithId:
		if (p->size < 0)
			SOAP_DELETE((tns__updateGameAnnotationTextWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__updateGameAnnotationTextWithId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__updateGameAnnotationTextWithIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__updateGameAnnotationTextWithIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__updateGameAnnotationTextWithIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithId:
		if (p->size < 0)
			SOAP_DELETE((tns__updateMediaAnnotationTextWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__updateMediaAnnotationTextWithId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__updateMediaAnnotationTextWithIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__updateMediaAnnotationTextWithIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__blessGameAnnotationWithId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__blessGameAnnotationWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__blessGameAnnotationWithId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__blessMediaAnnotationWithId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__blessMediaAnnotationWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__blessMediaAnnotationWithId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__chat:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__chat*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__chat*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__isClientUpdated:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__isClientUpdated*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__isClientUpdated*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__isConnected:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__isConnected*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__isConnected*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__selectGameAliasesWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__selectGameAliasesWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__selectGameAliasesWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__selectGameAnnotationsWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__selectGameAnnotationsWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__selectGameAnnotationsWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__selectGameTokenWithDigest:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__selectGameTokenWithDigest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__selectGameTokenWithDigest*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__selectGameTokenWithId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__selectGameTokenWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__selectGameTokenWithId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__selectMediaAliasesWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__selectMediaAliasesWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__selectMediaAliasesWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__selectMediaAnnotationsWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__selectMediaAnnotationsWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__selectMediaAnnotationsWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__selectMediaTokenWithDigest:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__selectMediaTokenWithDigest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__selectMediaTokenWithDigest*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__selectMediaTokenWithId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__selectMediaTokenWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__selectMediaTokenWithId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__selectRelatedGameAnnotationsWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__selectRelatedGameAnnotationsWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__selectRelatedGameAnnotationsWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__selectRelatedMediaAnnotationsWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__selectRelatedMediaAnnotationsWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__selectRelatedMediaAnnotationsWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__selectUser:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__selectUser*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__selectUser*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__setUserAnonymous:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__setUserAnonymous*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__setUserAnonymous*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__setUserLanguage:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__setUserLanguage*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__setUserLanguage*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitGameAlias:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__submitGameAlias*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__submitGameAlias*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitGameAliasTextAndTokenDigest:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__submitGameAliasTextAndTokenDigest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__submitGameAliasTextAndTokenDigest*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitGameAliasTextWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__submitGameAliasTextWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__submitGameAliasTextWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitGameAnnotation:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__submitGameAnnotation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__submitGameAnnotation*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitGameAnnotationTextAndTokenDigest:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__submitGameAnnotationTextAndTokenDigest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__submitGameAnnotationTextAndTokenDigest*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitGameAnnotationTextWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__submitGameAnnotationTextWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__submitGameAnnotationTextWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitGameToken:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__submitGameToken*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__submitGameToken*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitGameTokenDigest:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__submitGameTokenDigest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__submitGameTokenDigest*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitMediaAlias:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__submitMediaAlias*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__submitMediaAlias*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitMediaAliasTextAndTokenDigest:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__submitMediaAliasTextAndTokenDigest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__submitMediaAliasTextAndTokenDigest*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitMediaAliasTextWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__submitMediaAliasTextWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__submitMediaAliasTextWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitMediaAnnotation:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__submitMediaAnnotation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__submitMediaAnnotation*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitMediaAnnotationTextAndTokenDigest:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__submitMediaAnnotationTextAndTokenDigest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__submitMediaAnnotationTextAndTokenDigest*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitMediaAnnotationTextWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__submitMediaAnnotationTextWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__submitMediaAnnotationTextWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitMediaToken:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__submitMediaToken*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__submitMediaToken*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitMediaTokenDigest:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__submitMediaTokenDigest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__submitMediaTokenDigest*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__updateGameAnnotationTextWithId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__updateGameAnnotationTextWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__updateGameAnnotationTextWithId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__updateMediaAnnotationTextWithId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__updateMediaAnnotationTextWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__updateMediaAnnotationTextWithId*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_ServerSoap_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_ServerSoap_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_ServerSoap_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_ServerSoap_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_ServerSoap_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	case SOAP_TYPE_ServerSoap_std__vectorTemplateOfPointerTotns__mediaAnnotation:
		if (p->size < 0)
			SOAP_DELETE((std::vector<tns__mediaAnnotation * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<tns__mediaAnnotation * >*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_std__vectorTemplateOfPointerTotns__mediaAlias:
		if (p->size < 0)
			SOAP_DELETE((std::vector<tns__mediaAlias * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<tns__mediaAlias * >*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_std__vectorTemplateOfPointerTotns__gameAnnotation:
		if (p->size < 0)
			SOAP_DELETE((std::vector<tns__gameAnnotation * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<tns__gameAnnotation * >*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_std__vectorTemplateOfPointerTotns__gameAlias:
		if (p->size < 0)
			SOAP_DELETE((std::vector<tns__gameAlias * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<tns__gameAlias * >*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, ServerSoap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, ServerSoap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 ServerSoap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_ServerSoap_std__vectorTemplateOfPointerTotns__mediaAnnotation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container ServerSoap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<tns__mediaAnnotation * >*)p)[len] = *(tns__mediaAnnotation **)q;
		break;
	case SOAP_TYPE_ServerSoap_std__vectorTemplateOfPointerTotns__mediaAlias:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container ServerSoap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<tns__mediaAlias * >*)p)[len] = *(tns__mediaAlias **)q;
		break;
	case SOAP_TYPE_ServerSoap_std__vectorTemplateOfPointerTotns__gameAnnotation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container ServerSoap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<tns__gameAnnotation * >*)p)[len] = *(tns__gameAnnotation **)q;
		break;
	case SOAP_TYPE_ServerSoap_std__vectorTemplateOfPointerTotns__gameAlias:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container ServerSoap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<tns__gameAlias * >*)p)[len] = *(tns__gameAlias **)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_ServerSoap_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_ServerSoap_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_ServerSoap_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_ServerSoap_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_ServerSoap_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{	LONG64 *p;
	p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_ServerSoap_LONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_LONG64);
	if (soap_out_LONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ServerSoap_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ServerSoap_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, 0, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ServerSoap_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_ServerSoap_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_std__string, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::string[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void tns__updateMediaAnnotationTextWithIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__updateMediaAnnotationTextWithIdResponse::return_);
	/* transient soap skipped */
}

void tns__updateMediaAnnotationTextWithIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__updateMediaAnnotationTextWithIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__updateMediaAnnotationTextWithIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__updateMediaAnnotationTextWithIdResponse(struct soap *soap, const char *tag, int id, const tns__updateMediaAnnotationTextWithIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithIdResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__updateMediaAnnotationTextWithIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__updateMediaAnnotationTextWithIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__updateMediaAnnotationTextWithIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__updateMediaAnnotationTextWithIdResponse * SOAP_FMAC4 soap_in_tns__updateMediaAnnotationTextWithIdResponse(struct soap *soap, const char *tag, tns__updateMediaAnnotationTextWithIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__updateMediaAnnotationTextWithIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithIdResponse, sizeof(tns__updateMediaAnnotationTextWithIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__updateMediaAnnotationTextWithIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__updateMediaAnnotationTextWithIdResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__updateMediaAnnotationTextWithIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithIdResponse, 0, sizeof(tns__updateMediaAnnotationTextWithIdResponse), 0, soap_copy_tns__updateMediaAnnotationTextWithIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__updateMediaAnnotationTextWithIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:updateMediaAnnotationTextWithIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__updateMediaAnnotationTextWithIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__updateMediaAnnotationTextWithIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__updateMediaAnnotationTextWithIdResponse * SOAP_FMAC4 soap_get_tns__updateMediaAnnotationTextWithIdResponse(struct soap *soap, tns__updateMediaAnnotationTextWithIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__updateMediaAnnotationTextWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__updateMediaAnnotationTextWithIdResponse * SOAP_FMAC2 soap_instantiate_tns__updateMediaAnnotationTextWithIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__updateMediaAnnotationTextWithIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithIdResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__updateMediaAnnotationTextWithIdResponse);
		if (size)
			*size = sizeof(tns__updateMediaAnnotationTextWithIdResponse);
		((tns__updateMediaAnnotationTextWithIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__updateMediaAnnotationTextWithIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__updateMediaAnnotationTextWithIdResponse);
		for (int i = 0; i < n; i++)
			((tns__updateMediaAnnotationTextWithIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__updateMediaAnnotationTextWithIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__updateMediaAnnotationTextWithIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__updateMediaAnnotationTextWithIdResponse %p -> %p\n", q, p));
	*(tns__updateMediaAnnotationTextWithIdResponse*)p = *(tns__updateMediaAnnotationTextWithIdResponse*)q;
}

void tns__updateMediaAnnotationTextWithId::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__updateMediaAnnotationTextWithId::arg0 = NULL;
	soap_default_LONG64(soap, &this->tns__updateMediaAnnotationTextWithId::arg1);
	this->tns__updateMediaAnnotationTextWithId::userName = NULL;
	this->tns__updateMediaAnnotationTextWithId::password = NULL;
	/* transient soap skipped */
}

void tns__updateMediaAnnotationTextWithId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__updateMediaAnnotationTextWithId::arg0);
	soap_serialize_PointerTostd__string(soap, &this->tns__updateMediaAnnotationTextWithId::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__updateMediaAnnotationTextWithId::password);
	/* transient soap skipped */
}

int tns__updateMediaAnnotationTextWithId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__updateMediaAnnotationTextWithId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__updateMediaAnnotationTextWithId(struct soap *soap, const char *tag, int id, const tns__updateMediaAnnotationTextWithId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithId), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->tns__updateMediaAnnotationTextWithId::arg0), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "arg1", -1, &(a->tns__updateMediaAnnotationTextWithId::arg1), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__updateMediaAnnotationTextWithId::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__updateMediaAnnotationTextWithId::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__updateMediaAnnotationTextWithId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__updateMediaAnnotationTextWithId(soap, tag, this, type);
}

SOAP_FMAC3 tns__updateMediaAnnotationTextWithId * SOAP_FMAC4 soap_in_tns__updateMediaAnnotationTextWithId(struct soap *soap, const char *tag, tns__updateMediaAnnotationTextWithId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__updateMediaAnnotationTextWithId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithId, sizeof(tns__updateMediaAnnotationTextWithId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__updateMediaAnnotationTextWithId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->tns__updateMediaAnnotationTextWithId::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "arg1", &(a->tns__updateMediaAnnotationTextWithId::arg1), "xsd:long"))
				{	soap_flag_arg11--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__updateMediaAnnotationTextWithId::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__updateMediaAnnotationTextWithId::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__updateMediaAnnotationTextWithId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithId, 0, sizeof(tns__updateMediaAnnotationTextWithId), 0, soap_copy_tns__updateMediaAnnotationTextWithId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg11 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__updateMediaAnnotationTextWithId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithId);
	if (this->soap_out(soap, tag?tag:"tns:updateMediaAnnotationTextWithId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__updateMediaAnnotationTextWithId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__updateMediaAnnotationTextWithId(soap, this, tag, type);
}

SOAP_FMAC3 tns__updateMediaAnnotationTextWithId * SOAP_FMAC4 soap_get_tns__updateMediaAnnotationTextWithId(struct soap *soap, tns__updateMediaAnnotationTextWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__updateMediaAnnotationTextWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__updateMediaAnnotationTextWithId * SOAP_FMAC2 soap_instantiate_tns__updateMediaAnnotationTextWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__updateMediaAnnotationTextWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__updateMediaAnnotationTextWithId);
		if (size)
			*size = sizeof(tns__updateMediaAnnotationTextWithId);
		((tns__updateMediaAnnotationTextWithId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__updateMediaAnnotationTextWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__updateMediaAnnotationTextWithId);
		for (int i = 0; i < n; i++)
			((tns__updateMediaAnnotationTextWithId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__updateMediaAnnotationTextWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__updateMediaAnnotationTextWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__updateMediaAnnotationTextWithId %p -> %p\n", q, p));
	*(tns__updateMediaAnnotationTextWithId*)p = *(tns__updateMediaAnnotationTextWithId*)q;
}

void tns__updateGameAnnotationTextWithIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__updateGameAnnotationTextWithIdResponse::return_);
	/* transient soap skipped */
}

void tns__updateGameAnnotationTextWithIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__updateGameAnnotationTextWithIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__updateGameAnnotationTextWithIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__updateGameAnnotationTextWithIdResponse(struct soap *soap, const char *tag, int id, const tns__updateGameAnnotationTextWithIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__updateGameAnnotationTextWithIdResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__updateGameAnnotationTextWithIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__updateGameAnnotationTextWithIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__updateGameAnnotationTextWithIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__updateGameAnnotationTextWithIdResponse * SOAP_FMAC4 soap_in_tns__updateGameAnnotationTextWithIdResponse(struct soap *soap, const char *tag, tns__updateGameAnnotationTextWithIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__updateGameAnnotationTextWithIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__updateGameAnnotationTextWithIdResponse, sizeof(tns__updateGameAnnotationTextWithIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__updateGameAnnotationTextWithIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__updateGameAnnotationTextWithIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__updateGameAnnotationTextWithIdResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__updateGameAnnotationTextWithIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__updateGameAnnotationTextWithIdResponse, 0, sizeof(tns__updateGameAnnotationTextWithIdResponse), 0, soap_copy_tns__updateGameAnnotationTextWithIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__updateGameAnnotationTextWithIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__updateGameAnnotationTextWithIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:updateGameAnnotationTextWithIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__updateGameAnnotationTextWithIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__updateGameAnnotationTextWithIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__updateGameAnnotationTextWithIdResponse * SOAP_FMAC4 soap_get_tns__updateGameAnnotationTextWithIdResponse(struct soap *soap, tns__updateGameAnnotationTextWithIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__updateGameAnnotationTextWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__updateGameAnnotationTextWithIdResponse * SOAP_FMAC2 soap_instantiate_tns__updateGameAnnotationTextWithIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__updateGameAnnotationTextWithIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__updateGameAnnotationTextWithIdResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__updateGameAnnotationTextWithIdResponse);
		if (size)
			*size = sizeof(tns__updateGameAnnotationTextWithIdResponse);
		((tns__updateGameAnnotationTextWithIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__updateGameAnnotationTextWithIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__updateGameAnnotationTextWithIdResponse);
		for (int i = 0; i < n; i++)
			((tns__updateGameAnnotationTextWithIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__updateGameAnnotationTextWithIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__updateGameAnnotationTextWithIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__updateGameAnnotationTextWithIdResponse %p -> %p\n", q, p));
	*(tns__updateGameAnnotationTextWithIdResponse*)p = *(tns__updateGameAnnotationTextWithIdResponse*)q;
}

void tns__updateGameAnnotationTextWithId::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__updateGameAnnotationTextWithId::arg0 = NULL;
	soap_default_LONG64(soap, &this->tns__updateGameAnnotationTextWithId::arg1);
	this->tns__updateGameAnnotationTextWithId::userName = NULL;
	this->tns__updateGameAnnotationTextWithId::password = NULL;
	/* transient soap skipped */
}

void tns__updateGameAnnotationTextWithId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__updateGameAnnotationTextWithId::arg0);
	soap_serialize_PointerTostd__string(soap, &this->tns__updateGameAnnotationTextWithId::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__updateGameAnnotationTextWithId::password);
	/* transient soap skipped */
}

int tns__updateGameAnnotationTextWithId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__updateGameAnnotationTextWithId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__updateGameAnnotationTextWithId(struct soap *soap, const char *tag, int id, const tns__updateGameAnnotationTextWithId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__updateGameAnnotationTextWithId), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->tns__updateGameAnnotationTextWithId::arg0), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "arg1", -1, &(a->tns__updateGameAnnotationTextWithId::arg1), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__updateGameAnnotationTextWithId::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__updateGameAnnotationTextWithId::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__updateGameAnnotationTextWithId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__updateGameAnnotationTextWithId(soap, tag, this, type);
}

SOAP_FMAC3 tns__updateGameAnnotationTextWithId * SOAP_FMAC4 soap_in_tns__updateGameAnnotationTextWithId(struct soap *soap, const char *tag, tns__updateGameAnnotationTextWithId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__updateGameAnnotationTextWithId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__updateGameAnnotationTextWithId, sizeof(tns__updateGameAnnotationTextWithId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__updateGameAnnotationTextWithId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__updateGameAnnotationTextWithId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->tns__updateGameAnnotationTextWithId::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "arg1", &(a->tns__updateGameAnnotationTextWithId::arg1), "xsd:long"))
				{	soap_flag_arg11--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__updateGameAnnotationTextWithId::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__updateGameAnnotationTextWithId::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__updateGameAnnotationTextWithId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__updateGameAnnotationTextWithId, 0, sizeof(tns__updateGameAnnotationTextWithId), 0, soap_copy_tns__updateGameAnnotationTextWithId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg11 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__updateGameAnnotationTextWithId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__updateGameAnnotationTextWithId);
	if (this->soap_out(soap, tag?tag:"tns:updateGameAnnotationTextWithId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__updateGameAnnotationTextWithId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__updateGameAnnotationTextWithId(soap, this, tag, type);
}

SOAP_FMAC3 tns__updateGameAnnotationTextWithId * SOAP_FMAC4 soap_get_tns__updateGameAnnotationTextWithId(struct soap *soap, tns__updateGameAnnotationTextWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__updateGameAnnotationTextWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__updateGameAnnotationTextWithId * SOAP_FMAC2 soap_instantiate_tns__updateGameAnnotationTextWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__updateGameAnnotationTextWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__updateGameAnnotationTextWithId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__updateGameAnnotationTextWithId);
		if (size)
			*size = sizeof(tns__updateGameAnnotationTextWithId);
		((tns__updateGameAnnotationTextWithId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__updateGameAnnotationTextWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__updateGameAnnotationTextWithId);
		for (int i = 0; i < n; i++)
			((tns__updateGameAnnotationTextWithId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__updateGameAnnotationTextWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__updateGameAnnotationTextWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__updateGameAnnotationTextWithId %p -> %p\n", q, p));
	*(tns__updateGameAnnotationTextWithId*)p = *(tns__updateGameAnnotationTextWithId*)q;
}

void tns__submitMediaTokenDigestResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__submitMediaTokenDigestResponse::return_);
	/* transient soap skipped */
}

void tns__submitMediaTokenDigestResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__submitMediaTokenDigestResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaTokenDigestResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaTokenDigestResponse(struct soap *soap, const char *tag, int id, const tns__submitMediaTokenDigestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigestResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "return", -1, &(a->tns__submitMediaTokenDigestResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaTokenDigestResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaTokenDigestResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaTokenDigestResponse * SOAP_FMAC4 soap_in_tns__submitMediaTokenDigestResponse(struct soap *soap, const char *tag, tns__submitMediaTokenDigestResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaTokenDigestResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigestResponse, sizeof(tns__submitMediaTokenDigestResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigestResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaTokenDigestResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "return", &(a->tns__submitMediaTokenDigestResponse::return_), "xsd:long"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaTokenDigestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigestResponse, 0, sizeof(tns__submitMediaTokenDigestResponse), 0, soap_copy_tns__submitMediaTokenDigestResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitMediaTokenDigestResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigestResponse);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaTokenDigestResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaTokenDigestResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaTokenDigestResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaTokenDigestResponse * SOAP_FMAC4 soap_get_tns__submitMediaTokenDigestResponse(struct soap *soap, tns__submitMediaTokenDigestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaTokenDigestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaTokenDigestResponse * SOAP_FMAC2 soap_instantiate_tns__submitMediaTokenDigestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaTokenDigestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigestResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaTokenDigestResponse);
		if (size)
			*size = sizeof(tns__submitMediaTokenDigestResponse);
		((tns__submitMediaTokenDigestResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaTokenDigestResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaTokenDigestResponse);
		for (int i = 0; i < n; i++)
			((tns__submitMediaTokenDigestResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaTokenDigestResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaTokenDigestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaTokenDigestResponse %p -> %p\n", q, p));
	*(tns__submitMediaTokenDigestResponse*)p = *(tns__submitMediaTokenDigestResponse*)q;
}

void tns__submitMediaTokenDigest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__submitMediaTokenDigest::arg0 = NULL;
	this->tns__submitMediaTokenDigest::userName = NULL;
	this->tns__submitMediaTokenDigest::password = NULL;
	/* transient soap skipped */
}

void tns__submitMediaTokenDigest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaTokenDigest::arg0);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaTokenDigest::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaTokenDigest::password);
	/* transient soap skipped */
}

int tns__submitMediaTokenDigest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaTokenDigest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaTokenDigest(struct soap *soap, const char *tag, int id, const tns__submitMediaTokenDigest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigest), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->tns__submitMediaTokenDigest::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__submitMediaTokenDigest::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__submitMediaTokenDigest::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaTokenDigest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaTokenDigest(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaTokenDigest * SOAP_FMAC4 soap_in_tns__submitMediaTokenDigest(struct soap *soap, const char *tag, tns__submitMediaTokenDigest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaTokenDigest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigest, sizeof(tns__submitMediaTokenDigest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaTokenDigest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->tns__submitMediaTokenDigest::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__submitMediaTokenDigest::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__submitMediaTokenDigest::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaTokenDigest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigest, 0, sizeof(tns__submitMediaTokenDigest), 0, soap_copy_tns__submitMediaTokenDigest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__submitMediaTokenDigest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigest);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaTokenDigest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaTokenDigest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaTokenDigest(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaTokenDigest * SOAP_FMAC4 soap_get_tns__submitMediaTokenDigest(struct soap *soap, tns__submitMediaTokenDigest *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaTokenDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaTokenDigest * SOAP_FMAC2 soap_instantiate_tns__submitMediaTokenDigest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaTokenDigest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigest, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaTokenDigest);
		if (size)
			*size = sizeof(tns__submitMediaTokenDigest);
		((tns__submitMediaTokenDigest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaTokenDigest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaTokenDigest);
		for (int i = 0; i < n; i++)
			((tns__submitMediaTokenDigest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaTokenDigest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaTokenDigest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaTokenDigest %p -> %p\n", q, p));
	*(tns__submitMediaTokenDigest*)p = *(tns__submitMediaTokenDigest*)q;
}

void tns__submitMediaTokenResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__submitMediaTokenResponse::return_);
	/* transient soap skipped */
}

void tns__submitMediaTokenResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__submitMediaTokenResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaTokenResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaTokenResponse(struct soap *soap, const char *tag, int id, const tns__submitMediaTokenResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitMediaTokenResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "return", -1, &(a->tns__submitMediaTokenResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaTokenResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaTokenResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaTokenResponse * SOAP_FMAC4 soap_in_tns__submitMediaTokenResponse(struct soap *soap, const char *tag, tns__submitMediaTokenResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaTokenResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitMediaTokenResponse, sizeof(tns__submitMediaTokenResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitMediaTokenResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaTokenResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "return", &(a->tns__submitMediaTokenResponse::return_), "xsd:long"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaTokenResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitMediaTokenResponse, 0, sizeof(tns__submitMediaTokenResponse), 0, soap_copy_tns__submitMediaTokenResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitMediaTokenResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitMediaTokenResponse);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaTokenResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaTokenResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaTokenResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaTokenResponse * SOAP_FMAC4 soap_get_tns__submitMediaTokenResponse(struct soap *soap, tns__submitMediaTokenResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaTokenResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaTokenResponse * SOAP_FMAC2 soap_instantiate_tns__submitMediaTokenResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaTokenResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitMediaTokenResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaTokenResponse);
		if (size)
			*size = sizeof(tns__submitMediaTokenResponse);
		((tns__submitMediaTokenResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaTokenResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaTokenResponse);
		for (int i = 0; i < n; i++)
			((tns__submitMediaTokenResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaTokenResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaTokenResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaTokenResponse %p -> %p\n", q, p));
	*(tns__submitMediaTokenResponse*)p = *(tns__submitMediaTokenResponse*)q;
}

void tns__submitMediaToken::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__submitMediaToken::arg0 = NULL;
	this->tns__submitMediaToken::userName = NULL;
	this->tns__submitMediaToken::password = NULL;
	/* transient soap skipped */
}

void tns__submitMediaToken::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__mediaToken(soap, &this->tns__submitMediaToken::arg0);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaToken::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaToken::password);
	/* transient soap skipped */
}

int tns__submitMediaToken::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaToken(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaToken(struct soap *soap, const char *tag, int id, const tns__submitMediaToken *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitMediaToken), type))
		return soap->error;
	if (soap_out_PointerTotns__mediaToken(soap, "arg0", -1, &(a->tns__submitMediaToken::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__submitMediaToken::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__submitMediaToken::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaToken::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaToken(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaToken * SOAP_FMAC4 soap_in_tns__submitMediaToken(struct soap *soap, const char *tag, tns__submitMediaToken *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaToken *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitMediaToken, sizeof(tns__submitMediaToken), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitMediaToken)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaToken *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__mediaToken(soap, "arg0", &(a->tns__submitMediaToken::arg0), "tns:mediaToken"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__submitMediaToken::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__submitMediaToken::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaToken *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitMediaToken, 0, sizeof(tns__submitMediaToken), 0, soap_copy_tns__submitMediaToken);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__submitMediaToken::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitMediaToken);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaToken", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaToken::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaToken(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaToken * SOAP_FMAC4 soap_get_tns__submitMediaToken(struct soap *soap, tns__submitMediaToken *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaToken * SOAP_FMAC2 soap_instantiate_tns__submitMediaToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaToken(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitMediaToken, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaToken);
		if (size)
			*size = sizeof(tns__submitMediaToken);
		((tns__submitMediaToken*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaToken[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaToken);
		for (int i = 0; i < n; i++)
			((tns__submitMediaToken*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaToken*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaToken(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaToken %p -> %p\n", q, p));
	*(tns__submitMediaToken*)p = *(tns__submitMediaToken*)q;
}

void tns__submitMediaAnnotationTextWithTokenIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__submitMediaAnnotationTextWithTokenIdResponse::return_);
	/* transient soap skipped */
}

void tns__submitMediaAnnotationTextWithTokenIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__submitMediaAnnotationTextWithTokenIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaAnnotationTextWithTokenIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaAnnotationTextWithTokenIdResponse(struct soap *soap, const char *tag, int id, const tns__submitMediaAnnotationTextWithTokenIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenIdResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "return", -1, &(a->tns__submitMediaAnnotationTextWithTokenIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaAnnotationTextWithTokenIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaAnnotationTextWithTokenIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextWithTokenIdResponse * SOAP_FMAC4 soap_in_tns__submitMediaAnnotationTextWithTokenIdResponse(struct soap *soap, const char *tag, tns__submitMediaAnnotationTextWithTokenIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaAnnotationTextWithTokenIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenIdResponse, sizeof(tns__submitMediaAnnotationTextWithTokenIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaAnnotationTextWithTokenIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "return", &(a->tns__submitMediaAnnotationTextWithTokenIdResponse::return_), "xsd:long"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaAnnotationTextWithTokenIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenIdResponse, 0, sizeof(tns__submitMediaAnnotationTextWithTokenIdResponse), 0, soap_copy_tns__submitMediaAnnotationTextWithTokenIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitMediaAnnotationTextWithTokenIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaAnnotationTextWithTokenIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaAnnotationTextWithTokenIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaAnnotationTextWithTokenIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextWithTokenIdResponse * SOAP_FMAC4 soap_get_tns__submitMediaAnnotationTextWithTokenIdResponse(struct soap *soap, tns__submitMediaAnnotationTextWithTokenIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaAnnotationTextWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaAnnotationTextWithTokenIdResponse * SOAP_FMAC2 soap_instantiate_tns__submitMediaAnnotationTextWithTokenIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaAnnotationTextWithTokenIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenIdResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAnnotationTextWithTokenIdResponse);
		if (size)
			*size = sizeof(tns__submitMediaAnnotationTextWithTokenIdResponse);
		((tns__submitMediaAnnotationTextWithTokenIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAnnotationTextWithTokenIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaAnnotationTextWithTokenIdResponse);
		for (int i = 0; i < n; i++)
			((tns__submitMediaAnnotationTextWithTokenIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaAnnotationTextWithTokenIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaAnnotationTextWithTokenIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaAnnotationTextWithTokenIdResponse %p -> %p\n", q, p));
	*(tns__submitMediaAnnotationTextWithTokenIdResponse*)p = *(tns__submitMediaAnnotationTextWithTokenIdResponse*)q;
}

void tns__submitMediaAnnotationTextWithTokenId::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__submitMediaAnnotationTextWithTokenId::arg0 = NULL;
	soap_default_LONG64(soap, &this->tns__submitMediaAnnotationTextWithTokenId::arg1);
	soap_default_int(soap, &this->tns__submitMediaAnnotationTextWithTokenId::arg2);
	soap_default_LONG64(soap, &this->tns__submitMediaAnnotationTextWithTokenId::arg3);
	this->tns__submitMediaAnnotationTextWithTokenId::userName = NULL;
	this->tns__submitMediaAnnotationTextWithTokenId::password = NULL;
	/* transient soap skipped */
}

void tns__submitMediaAnnotationTextWithTokenId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAnnotationTextWithTokenId::arg0);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAnnotationTextWithTokenId::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAnnotationTextWithTokenId::password);
	/* transient soap skipped */
}

int tns__submitMediaAnnotationTextWithTokenId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaAnnotationTextWithTokenId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaAnnotationTextWithTokenId(struct soap *soap, const char *tag, int id, const tns__submitMediaAnnotationTextWithTokenId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenId), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->tns__submitMediaAnnotationTextWithTokenId::arg0), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "arg1", -1, &(a->tns__submitMediaAnnotationTextWithTokenId::arg1), ""))
		return soap->error;
	if (soap_out_int(soap, "arg2", -1, &(a->tns__submitMediaAnnotationTextWithTokenId::arg2), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "arg3", -1, &(a->tns__submitMediaAnnotationTextWithTokenId::arg3), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__submitMediaAnnotationTextWithTokenId::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__submitMediaAnnotationTextWithTokenId::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaAnnotationTextWithTokenId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaAnnotationTextWithTokenId(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextWithTokenId * SOAP_FMAC4 soap_in_tns__submitMediaAnnotationTextWithTokenId(struct soap *soap, const char *tag, tns__submitMediaAnnotationTextWithTokenId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaAnnotationTextWithTokenId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenId, sizeof(tns__submitMediaAnnotationTextWithTokenId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaAnnotationTextWithTokenId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	size_t soap_flag_arg31 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->tns__submitMediaAnnotationTextWithTokenId::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "arg1", &(a->tns__submitMediaAnnotationTextWithTokenId::arg1), "xsd:long"))
				{	soap_flag_arg11--;
					continue;
				}
			if (soap_flag_arg21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "arg2", &(a->tns__submitMediaAnnotationTextWithTokenId::arg2), "xsd:int"))
				{	soap_flag_arg21--;
					continue;
				}
			if (soap_flag_arg31 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "arg3", &(a->tns__submitMediaAnnotationTextWithTokenId::arg3), "xsd:long"))
				{	soap_flag_arg31--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__submitMediaAnnotationTextWithTokenId::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__submitMediaAnnotationTextWithTokenId::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaAnnotationTextWithTokenId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenId, 0, sizeof(tns__submitMediaAnnotationTextWithTokenId), 0, soap_copy_tns__submitMediaAnnotationTextWithTokenId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg11 > 0 || soap_flag_arg21 > 0 || soap_flag_arg31 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitMediaAnnotationTextWithTokenId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenId);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaAnnotationTextWithTokenId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaAnnotationTextWithTokenId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaAnnotationTextWithTokenId(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextWithTokenId * SOAP_FMAC4 soap_get_tns__submitMediaAnnotationTextWithTokenId(struct soap *soap, tns__submitMediaAnnotationTextWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaAnnotationTextWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaAnnotationTextWithTokenId * SOAP_FMAC2 soap_instantiate_tns__submitMediaAnnotationTextWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaAnnotationTextWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAnnotationTextWithTokenId);
		if (size)
			*size = sizeof(tns__submitMediaAnnotationTextWithTokenId);
		((tns__submitMediaAnnotationTextWithTokenId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAnnotationTextWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaAnnotationTextWithTokenId);
		for (int i = 0; i < n; i++)
			((tns__submitMediaAnnotationTextWithTokenId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaAnnotationTextWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaAnnotationTextWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaAnnotationTextWithTokenId %p -> %p\n", q, p));
	*(tns__submitMediaAnnotationTextWithTokenId*)p = *(tns__submitMediaAnnotationTextWithTokenId*)q;
}

void tns__submitMediaAnnotationTextAndTokenDigestResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__submitMediaAnnotationTextAndTokenDigestResponse::return_);
	/* transient soap skipped */
}

void tns__submitMediaAnnotationTextAndTokenDigestResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__submitMediaAnnotationTextAndTokenDigestResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaAnnotationTextAndTokenDigestResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaAnnotationTextAndTokenDigestResponse(struct soap *soap, const char *tag, int id, const tns__submitMediaAnnotationTextAndTokenDigestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigestResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "return", -1, &(a->tns__submitMediaAnnotationTextAndTokenDigestResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaAnnotationTextAndTokenDigestResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaAnnotationTextAndTokenDigestResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextAndTokenDigestResponse * SOAP_FMAC4 soap_in_tns__submitMediaAnnotationTextAndTokenDigestResponse(struct soap *soap, const char *tag, tns__submitMediaAnnotationTextAndTokenDigestResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaAnnotationTextAndTokenDigestResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigestResponse, sizeof(tns__submitMediaAnnotationTextAndTokenDigestResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigestResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaAnnotationTextAndTokenDigestResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "return", &(a->tns__submitMediaAnnotationTextAndTokenDigestResponse::return_), "xsd:long"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaAnnotationTextAndTokenDigestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigestResponse, 0, sizeof(tns__submitMediaAnnotationTextAndTokenDigestResponse), 0, soap_copy_tns__submitMediaAnnotationTextAndTokenDigestResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitMediaAnnotationTextAndTokenDigestResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigestResponse);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaAnnotationTextAndTokenDigestResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaAnnotationTextAndTokenDigestResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaAnnotationTextAndTokenDigestResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextAndTokenDigestResponse * SOAP_FMAC4 soap_get_tns__submitMediaAnnotationTextAndTokenDigestResponse(struct soap *soap, tns__submitMediaAnnotationTextAndTokenDigestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaAnnotationTextAndTokenDigestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaAnnotationTextAndTokenDigestResponse * SOAP_FMAC2 soap_instantiate_tns__submitMediaAnnotationTextAndTokenDigestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaAnnotationTextAndTokenDigestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigestResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAnnotationTextAndTokenDigestResponse);
		if (size)
			*size = sizeof(tns__submitMediaAnnotationTextAndTokenDigestResponse);
		((tns__submitMediaAnnotationTextAndTokenDigestResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAnnotationTextAndTokenDigestResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaAnnotationTextAndTokenDigestResponse);
		for (int i = 0; i < n; i++)
			((tns__submitMediaAnnotationTextAndTokenDigestResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaAnnotationTextAndTokenDigestResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaAnnotationTextAndTokenDigestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaAnnotationTextAndTokenDigestResponse %p -> %p\n", q, p));
	*(tns__submitMediaAnnotationTextAndTokenDigestResponse*)p = *(tns__submitMediaAnnotationTextAndTokenDigestResponse*)q;
}

void tns__submitMediaAnnotationTextAndTokenDigest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__submitMediaAnnotationTextAndTokenDigest::arg0 = NULL;
	soap_default_LONG64(soap, &this->tns__submitMediaAnnotationTextAndTokenDigest::arg1);
	soap_default_int(soap, &this->tns__submitMediaAnnotationTextAndTokenDigest::arg2);
	this->tns__submitMediaAnnotationTextAndTokenDigest::arg3 = NULL;
	this->tns__submitMediaAnnotationTextAndTokenDigest::userName = NULL;
	this->tns__submitMediaAnnotationTextAndTokenDigest::password = NULL;
	/* transient soap skipped */
}

void tns__submitMediaAnnotationTextAndTokenDigest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAnnotationTextAndTokenDigest::arg0);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAnnotationTextAndTokenDigest::arg3);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAnnotationTextAndTokenDigest::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAnnotationTextAndTokenDigest::password);
	/* transient soap skipped */
}

int tns__submitMediaAnnotationTextAndTokenDigest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaAnnotationTextAndTokenDigest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, const char *tag, int id, const tns__submitMediaAnnotationTextAndTokenDigest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigest), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->tns__submitMediaAnnotationTextAndTokenDigest::arg0), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "arg1", -1, &(a->tns__submitMediaAnnotationTextAndTokenDigest::arg1), ""))
		return soap->error;
	if (soap_out_int(soap, "arg2", -1, &(a->tns__submitMediaAnnotationTextAndTokenDigest::arg2), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg3", -1, &(a->tns__submitMediaAnnotationTextAndTokenDigest::arg3), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__submitMediaAnnotationTextAndTokenDigest::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__submitMediaAnnotationTextAndTokenDigest::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaAnnotationTextAndTokenDigest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaAnnotationTextAndTokenDigest(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextAndTokenDigest * SOAP_FMAC4 soap_in_tns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, const char *tag, tns__submitMediaAnnotationTextAndTokenDigest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaAnnotationTextAndTokenDigest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigest, sizeof(tns__submitMediaAnnotationTextAndTokenDigest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaAnnotationTextAndTokenDigest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	size_t soap_flag_arg31 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->tns__submitMediaAnnotationTextAndTokenDigest::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "arg1", &(a->tns__submitMediaAnnotationTextAndTokenDigest::arg1), "xsd:long"))
				{	soap_flag_arg11--;
					continue;
				}
			if (soap_flag_arg21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "arg2", &(a->tns__submitMediaAnnotationTextAndTokenDigest::arg2), "xsd:int"))
				{	soap_flag_arg21--;
					continue;
				}
			if (soap_flag_arg31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg3", &(a->tns__submitMediaAnnotationTextAndTokenDigest::arg3), "xsd:string"))
				{	soap_flag_arg31--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__submitMediaAnnotationTextAndTokenDigest::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__submitMediaAnnotationTextAndTokenDigest::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaAnnotationTextAndTokenDigest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigest, 0, sizeof(tns__submitMediaAnnotationTextAndTokenDigest), 0, soap_copy_tns__submitMediaAnnotationTextAndTokenDigest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg11 > 0 || soap_flag_arg21 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitMediaAnnotationTextAndTokenDigest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigest);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaAnnotationTextAndTokenDigest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaAnnotationTextAndTokenDigest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaAnnotationTextAndTokenDigest(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextAndTokenDigest * SOAP_FMAC4 soap_get_tns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, tns__submitMediaAnnotationTextAndTokenDigest *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaAnnotationTextAndTokenDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaAnnotationTextAndTokenDigest * SOAP_FMAC2 soap_instantiate_tns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaAnnotationTextAndTokenDigest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigest, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAnnotationTextAndTokenDigest);
		if (size)
			*size = sizeof(tns__submitMediaAnnotationTextAndTokenDigest);
		((tns__submitMediaAnnotationTextAndTokenDigest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAnnotationTextAndTokenDigest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaAnnotationTextAndTokenDigest);
		for (int i = 0; i < n; i++)
			((tns__submitMediaAnnotationTextAndTokenDigest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaAnnotationTextAndTokenDigest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaAnnotationTextAndTokenDigest %p -> %p\n", q, p));
	*(tns__submitMediaAnnotationTextAndTokenDigest*)p = *(tns__submitMediaAnnotationTextAndTokenDigest*)q;
}

void tns__submitMediaAnnotationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__submitMediaAnnotationResponse::return_);
	/* transient soap skipped */
}

void tns__submitMediaAnnotationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__submitMediaAnnotationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaAnnotationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaAnnotationResponse(struct soap *soap, const char *tag, int id, const tns__submitMediaAnnotationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "return", -1, &(a->tns__submitMediaAnnotationResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaAnnotationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaAnnotationResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationResponse * SOAP_FMAC4 soap_in_tns__submitMediaAnnotationResponse(struct soap *soap, const char *tag, tns__submitMediaAnnotationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaAnnotationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationResponse, sizeof(tns__submitMediaAnnotationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaAnnotationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "return", &(a->tns__submitMediaAnnotationResponse::return_), "xsd:long"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaAnnotationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationResponse, 0, sizeof(tns__submitMediaAnnotationResponse), 0, soap_copy_tns__submitMediaAnnotationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitMediaAnnotationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationResponse);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaAnnotationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaAnnotationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaAnnotationResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationResponse * SOAP_FMAC4 soap_get_tns__submitMediaAnnotationResponse(struct soap *soap, tns__submitMediaAnnotationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaAnnotationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaAnnotationResponse * SOAP_FMAC2 soap_instantiate_tns__submitMediaAnnotationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaAnnotationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAnnotationResponse);
		if (size)
			*size = sizeof(tns__submitMediaAnnotationResponse);
		((tns__submitMediaAnnotationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAnnotationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaAnnotationResponse);
		for (int i = 0; i < n; i++)
			((tns__submitMediaAnnotationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaAnnotationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaAnnotationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaAnnotationResponse %p -> %p\n", q, p));
	*(tns__submitMediaAnnotationResponse*)p = *(tns__submitMediaAnnotationResponse*)q;
}

void tns__submitMediaAnnotation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__submitMediaAnnotation::arg0 = NULL;
	this->tns__submitMediaAnnotation::userName = NULL;
	this->tns__submitMediaAnnotation::password = NULL;
	/* transient soap skipped */
}

void tns__submitMediaAnnotation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__mediaAnnotation(soap, &this->tns__submitMediaAnnotation::arg0);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAnnotation::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAnnotation::password);
	/* transient soap skipped */
}

int tns__submitMediaAnnotation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaAnnotation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaAnnotation(struct soap *soap, const char *tag, int id, const tns__submitMediaAnnotation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotation), type))
		return soap->error;
	if (soap_out_PointerTotns__mediaAnnotation(soap, "arg0", -1, &(a->tns__submitMediaAnnotation::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__submitMediaAnnotation::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__submitMediaAnnotation::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaAnnotation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaAnnotation(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaAnnotation * SOAP_FMAC4 soap_in_tns__submitMediaAnnotation(struct soap *soap, const char *tag, tns__submitMediaAnnotation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaAnnotation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotation, sizeof(tns__submitMediaAnnotation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitMediaAnnotation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaAnnotation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__mediaAnnotation(soap, "arg0", &(a->tns__submitMediaAnnotation::arg0), "tns:mediaAnnotation"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__submitMediaAnnotation::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__submitMediaAnnotation::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaAnnotation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotation, 0, sizeof(tns__submitMediaAnnotation), 0, soap_copy_tns__submitMediaAnnotation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__submitMediaAnnotation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotation);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaAnnotation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaAnnotation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaAnnotation(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaAnnotation * SOAP_FMAC4 soap_get_tns__submitMediaAnnotation(struct soap *soap, tns__submitMediaAnnotation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaAnnotation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaAnnotation * SOAP_FMAC2 soap_instantiate_tns__submitMediaAnnotation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaAnnotation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotation, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAnnotation);
		if (size)
			*size = sizeof(tns__submitMediaAnnotation);
		((tns__submitMediaAnnotation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAnnotation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaAnnotation);
		for (int i = 0; i < n; i++)
			((tns__submitMediaAnnotation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaAnnotation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaAnnotation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaAnnotation %p -> %p\n", q, p));
	*(tns__submitMediaAnnotation*)p = *(tns__submitMediaAnnotation*)q;
}

void tns__submitMediaAliasTextWithTokenIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__submitMediaAliasTextWithTokenIdResponse::return_);
	/* transient soap skipped */
}

void tns__submitMediaAliasTextWithTokenIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__submitMediaAliasTextWithTokenIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaAliasTextWithTokenIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaAliasTextWithTokenIdResponse(struct soap *soap, const char *tag, int id, const tns__submitMediaAliasTextWithTokenIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenIdResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "return", -1, &(a->tns__submitMediaAliasTextWithTokenIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaAliasTextWithTokenIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaAliasTextWithTokenIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaAliasTextWithTokenIdResponse * SOAP_FMAC4 soap_in_tns__submitMediaAliasTextWithTokenIdResponse(struct soap *soap, const char *tag, tns__submitMediaAliasTextWithTokenIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaAliasTextWithTokenIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenIdResponse, sizeof(tns__submitMediaAliasTextWithTokenIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaAliasTextWithTokenIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "return", &(a->tns__submitMediaAliasTextWithTokenIdResponse::return_), "xsd:long"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaAliasTextWithTokenIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenIdResponse, 0, sizeof(tns__submitMediaAliasTextWithTokenIdResponse), 0, soap_copy_tns__submitMediaAliasTextWithTokenIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitMediaAliasTextWithTokenIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaAliasTextWithTokenIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaAliasTextWithTokenIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaAliasTextWithTokenIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaAliasTextWithTokenIdResponse * SOAP_FMAC4 soap_get_tns__submitMediaAliasTextWithTokenIdResponse(struct soap *soap, tns__submitMediaAliasTextWithTokenIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaAliasTextWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaAliasTextWithTokenIdResponse * SOAP_FMAC2 soap_instantiate_tns__submitMediaAliasTextWithTokenIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaAliasTextWithTokenIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenIdResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAliasTextWithTokenIdResponse);
		if (size)
			*size = sizeof(tns__submitMediaAliasTextWithTokenIdResponse);
		((tns__submitMediaAliasTextWithTokenIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAliasTextWithTokenIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaAliasTextWithTokenIdResponse);
		for (int i = 0; i < n; i++)
			((tns__submitMediaAliasTextWithTokenIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaAliasTextWithTokenIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaAliasTextWithTokenIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaAliasTextWithTokenIdResponse %p -> %p\n", q, p));
	*(tns__submitMediaAliasTextWithTokenIdResponse*)p = *(tns__submitMediaAliasTextWithTokenIdResponse*)q;
}

void tns__submitMediaAliasTextWithTokenId::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__submitMediaAliasTextWithTokenId::arg0 = NULL;
	soap_default_int(soap, &this->tns__submitMediaAliasTextWithTokenId::arg1);
	soap_default_LONG64(soap, &this->tns__submitMediaAliasTextWithTokenId::arg2);
	this->tns__submitMediaAliasTextWithTokenId::userName = NULL;
	this->tns__submitMediaAliasTextWithTokenId::password = NULL;
	/* transient soap skipped */
}

void tns__submitMediaAliasTextWithTokenId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAliasTextWithTokenId::arg0);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAliasTextWithTokenId::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAliasTextWithTokenId::password);
	/* transient soap skipped */
}

int tns__submitMediaAliasTextWithTokenId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaAliasTextWithTokenId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaAliasTextWithTokenId(struct soap *soap, const char *tag, int id, const tns__submitMediaAliasTextWithTokenId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenId), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->tns__submitMediaAliasTextWithTokenId::arg0), ""))
		return soap->error;
	if (soap_out_int(soap, "arg1", -1, &(a->tns__submitMediaAliasTextWithTokenId::arg1), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "arg2", -1, &(a->tns__submitMediaAliasTextWithTokenId::arg2), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__submitMediaAliasTextWithTokenId::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__submitMediaAliasTextWithTokenId::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaAliasTextWithTokenId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaAliasTextWithTokenId(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaAliasTextWithTokenId * SOAP_FMAC4 soap_in_tns__submitMediaAliasTextWithTokenId(struct soap *soap, const char *tag, tns__submitMediaAliasTextWithTokenId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaAliasTextWithTokenId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenId, sizeof(tns__submitMediaAliasTextWithTokenId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaAliasTextWithTokenId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->tns__submitMediaAliasTextWithTokenId::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "arg1", &(a->tns__submitMediaAliasTextWithTokenId::arg1), "xsd:int"))
				{	soap_flag_arg11--;
					continue;
				}
			if (soap_flag_arg21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "arg2", &(a->tns__submitMediaAliasTextWithTokenId::arg2), "xsd:long"))
				{	soap_flag_arg21--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__submitMediaAliasTextWithTokenId::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__submitMediaAliasTextWithTokenId::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaAliasTextWithTokenId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenId, 0, sizeof(tns__submitMediaAliasTextWithTokenId), 0, soap_copy_tns__submitMediaAliasTextWithTokenId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg11 > 0 || soap_flag_arg21 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitMediaAliasTextWithTokenId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenId);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaAliasTextWithTokenId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaAliasTextWithTokenId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaAliasTextWithTokenId(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaAliasTextWithTokenId * SOAP_FMAC4 soap_get_tns__submitMediaAliasTextWithTokenId(struct soap *soap, tns__submitMediaAliasTextWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaAliasTextWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaAliasTextWithTokenId * SOAP_FMAC2 soap_instantiate_tns__submitMediaAliasTextWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaAliasTextWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAliasTextWithTokenId);
		if (size)
			*size = sizeof(tns__submitMediaAliasTextWithTokenId);
		((tns__submitMediaAliasTextWithTokenId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAliasTextWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaAliasTextWithTokenId);
		for (int i = 0; i < n; i++)
			((tns__submitMediaAliasTextWithTokenId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaAliasTextWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaAliasTextWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaAliasTextWithTokenId %p -> %p\n", q, p));
	*(tns__submitMediaAliasTextWithTokenId*)p = *(tns__submitMediaAliasTextWithTokenId*)q;
}

void tns__submitMediaAliasTextAndTokenDigestResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__submitMediaAliasTextAndTokenDigestResponse::return_);
	/* transient soap skipped */
}

void tns__submitMediaAliasTextAndTokenDigestResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__submitMediaAliasTextAndTokenDigestResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaAliasTextAndTokenDigestResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaAliasTextAndTokenDigestResponse(struct soap *soap, const char *tag, int id, const tns__submitMediaAliasTextAndTokenDigestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigestResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "return", -1, &(a->tns__submitMediaAliasTextAndTokenDigestResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaAliasTextAndTokenDigestResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaAliasTextAndTokenDigestResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaAliasTextAndTokenDigestResponse * SOAP_FMAC4 soap_in_tns__submitMediaAliasTextAndTokenDigestResponse(struct soap *soap, const char *tag, tns__submitMediaAliasTextAndTokenDigestResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaAliasTextAndTokenDigestResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigestResponse, sizeof(tns__submitMediaAliasTextAndTokenDigestResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigestResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaAliasTextAndTokenDigestResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "return", &(a->tns__submitMediaAliasTextAndTokenDigestResponse::return_), "xsd:long"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaAliasTextAndTokenDigestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigestResponse, 0, sizeof(tns__submitMediaAliasTextAndTokenDigestResponse), 0, soap_copy_tns__submitMediaAliasTextAndTokenDigestResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitMediaAliasTextAndTokenDigestResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigestResponse);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaAliasTextAndTokenDigestResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaAliasTextAndTokenDigestResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaAliasTextAndTokenDigestResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaAliasTextAndTokenDigestResponse * SOAP_FMAC4 soap_get_tns__submitMediaAliasTextAndTokenDigestResponse(struct soap *soap, tns__submitMediaAliasTextAndTokenDigestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaAliasTextAndTokenDigestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaAliasTextAndTokenDigestResponse * SOAP_FMAC2 soap_instantiate_tns__submitMediaAliasTextAndTokenDigestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaAliasTextAndTokenDigestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigestResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAliasTextAndTokenDigestResponse);
		if (size)
			*size = sizeof(tns__submitMediaAliasTextAndTokenDigestResponse);
		((tns__submitMediaAliasTextAndTokenDigestResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAliasTextAndTokenDigestResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaAliasTextAndTokenDigestResponse);
		for (int i = 0; i < n; i++)
			((tns__submitMediaAliasTextAndTokenDigestResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaAliasTextAndTokenDigestResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaAliasTextAndTokenDigestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaAliasTextAndTokenDigestResponse %p -> %p\n", q, p));
	*(tns__submitMediaAliasTextAndTokenDigestResponse*)p = *(tns__submitMediaAliasTextAndTokenDigestResponse*)q;
}

void tns__submitMediaAliasTextAndTokenDigest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__submitMediaAliasTextAndTokenDigest::arg0 = NULL;
	soap_default_int(soap, &this->tns__submitMediaAliasTextAndTokenDigest::arg1);
	this->tns__submitMediaAliasTextAndTokenDigest::arg2 = NULL;
	this->tns__submitMediaAliasTextAndTokenDigest::userName = NULL;
	this->tns__submitMediaAliasTextAndTokenDigest::password = NULL;
	/* transient soap skipped */
}

void tns__submitMediaAliasTextAndTokenDigest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAliasTextAndTokenDigest::arg0);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAliasTextAndTokenDigest::arg2);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAliasTextAndTokenDigest::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAliasTextAndTokenDigest::password);
	/* transient soap skipped */
}

int tns__submitMediaAliasTextAndTokenDigest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaAliasTextAndTokenDigest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaAliasTextAndTokenDigest(struct soap *soap, const char *tag, int id, const tns__submitMediaAliasTextAndTokenDigest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigest), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->tns__submitMediaAliasTextAndTokenDigest::arg0), ""))
		return soap->error;
	if (soap_out_int(soap, "arg1", -1, &(a->tns__submitMediaAliasTextAndTokenDigest::arg1), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg2", -1, &(a->tns__submitMediaAliasTextAndTokenDigest::arg2), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__submitMediaAliasTextAndTokenDigest::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__submitMediaAliasTextAndTokenDigest::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaAliasTextAndTokenDigest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaAliasTextAndTokenDigest(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaAliasTextAndTokenDigest * SOAP_FMAC4 soap_in_tns__submitMediaAliasTextAndTokenDigest(struct soap *soap, const char *tag, tns__submitMediaAliasTextAndTokenDigest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaAliasTextAndTokenDigest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigest, sizeof(tns__submitMediaAliasTextAndTokenDigest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaAliasTextAndTokenDigest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->tns__submitMediaAliasTextAndTokenDigest::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "arg1", &(a->tns__submitMediaAliasTextAndTokenDigest::arg1), "xsd:int"))
				{	soap_flag_arg11--;
					continue;
				}
			if (soap_flag_arg21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg2", &(a->tns__submitMediaAliasTextAndTokenDigest::arg2), "xsd:string"))
				{	soap_flag_arg21--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__submitMediaAliasTextAndTokenDigest::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__submitMediaAliasTextAndTokenDigest::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaAliasTextAndTokenDigest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigest, 0, sizeof(tns__submitMediaAliasTextAndTokenDigest), 0, soap_copy_tns__submitMediaAliasTextAndTokenDigest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg11 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitMediaAliasTextAndTokenDigest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigest);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaAliasTextAndTokenDigest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaAliasTextAndTokenDigest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaAliasTextAndTokenDigest(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaAliasTextAndTokenDigest * SOAP_FMAC4 soap_get_tns__submitMediaAliasTextAndTokenDigest(struct soap *soap, tns__submitMediaAliasTextAndTokenDigest *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaAliasTextAndTokenDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaAliasTextAndTokenDigest * SOAP_FMAC2 soap_instantiate_tns__submitMediaAliasTextAndTokenDigest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaAliasTextAndTokenDigest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigest, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAliasTextAndTokenDigest);
		if (size)
			*size = sizeof(tns__submitMediaAliasTextAndTokenDigest);
		((tns__submitMediaAliasTextAndTokenDigest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAliasTextAndTokenDigest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaAliasTextAndTokenDigest);
		for (int i = 0; i < n; i++)
			((tns__submitMediaAliasTextAndTokenDigest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaAliasTextAndTokenDigest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaAliasTextAndTokenDigest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaAliasTextAndTokenDigest %p -> %p\n", q, p));
	*(tns__submitMediaAliasTextAndTokenDigest*)p = *(tns__submitMediaAliasTextAndTokenDigest*)q;
}

void tns__submitMediaAliasResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__submitMediaAliasResponse::return_);
	/* transient soap skipped */
}

void tns__submitMediaAliasResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__submitMediaAliasResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaAliasResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaAliasResponse(struct soap *soap, const char *tag, int id, const tns__submitMediaAliasResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAliasResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "return", -1, &(a->tns__submitMediaAliasResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaAliasResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaAliasResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaAliasResponse * SOAP_FMAC4 soap_in_tns__submitMediaAliasResponse(struct soap *soap, const char *tag, tns__submitMediaAliasResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaAliasResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAliasResponse, sizeof(tns__submitMediaAliasResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitMediaAliasResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaAliasResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "return", &(a->tns__submitMediaAliasResponse::return_), "xsd:long"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaAliasResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitMediaAliasResponse, 0, sizeof(tns__submitMediaAliasResponse), 0, soap_copy_tns__submitMediaAliasResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitMediaAliasResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitMediaAliasResponse);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaAliasResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaAliasResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaAliasResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaAliasResponse * SOAP_FMAC4 soap_get_tns__submitMediaAliasResponse(struct soap *soap, tns__submitMediaAliasResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaAliasResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaAliasResponse * SOAP_FMAC2 soap_instantiate_tns__submitMediaAliasResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaAliasResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitMediaAliasResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAliasResponse);
		if (size)
			*size = sizeof(tns__submitMediaAliasResponse);
		((tns__submitMediaAliasResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAliasResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaAliasResponse);
		for (int i = 0; i < n; i++)
			((tns__submitMediaAliasResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaAliasResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaAliasResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaAliasResponse %p -> %p\n", q, p));
	*(tns__submitMediaAliasResponse*)p = *(tns__submitMediaAliasResponse*)q;
}

void tns__submitMediaAlias::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__submitMediaAlias::arg0 = NULL;
	this->tns__submitMediaAlias::userName = NULL;
	this->tns__submitMediaAlias::password = NULL;
	/* transient soap skipped */
}

void tns__submitMediaAlias::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__mediaAlias(soap, &this->tns__submitMediaAlias::arg0);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAlias::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAlias::password);
	/* transient soap skipped */
}

int tns__submitMediaAlias::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaAlias(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaAlias(struct soap *soap, const char *tag, int id, const tns__submitMediaAlias *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAlias), type))
		return soap->error;
	if (soap_out_PointerTotns__mediaAlias(soap, "arg0", -1, &(a->tns__submitMediaAlias::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__submitMediaAlias::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__submitMediaAlias::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaAlias::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaAlias(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaAlias * SOAP_FMAC4 soap_in_tns__submitMediaAlias(struct soap *soap, const char *tag, tns__submitMediaAlias *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaAlias *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAlias, sizeof(tns__submitMediaAlias), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitMediaAlias)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaAlias *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__mediaAlias(soap, "arg0", &(a->tns__submitMediaAlias::arg0), "tns:mediaAlias"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__submitMediaAlias::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__submitMediaAlias::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaAlias *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitMediaAlias, 0, sizeof(tns__submitMediaAlias), 0, soap_copy_tns__submitMediaAlias);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__submitMediaAlias::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitMediaAlias);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaAlias", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaAlias::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaAlias(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaAlias * SOAP_FMAC4 soap_get_tns__submitMediaAlias(struct soap *soap, tns__submitMediaAlias *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaAlias(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaAlias * SOAP_FMAC2 soap_instantiate_tns__submitMediaAlias(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaAlias(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitMediaAlias, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAlias);
		if (size)
			*size = sizeof(tns__submitMediaAlias);
		((tns__submitMediaAlias*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAlias[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaAlias);
		for (int i = 0; i < n; i++)
			((tns__submitMediaAlias*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaAlias*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaAlias(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaAlias %p -> %p\n", q, p));
	*(tns__submitMediaAlias*)p = *(tns__submitMediaAlias*)q;
}

void tns__submitGameTokenDigestResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__submitGameTokenDigestResponse::return_);
	/* transient soap skipped */
}

void tns__submitGameTokenDigestResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__submitGameTokenDigestResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitGameTokenDigestResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitGameTokenDigestResponse(struct soap *soap, const char *tag, int id, const tns__submitGameTokenDigestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitGameTokenDigestResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "return", -1, &(a->tns__submitGameTokenDigestResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitGameTokenDigestResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitGameTokenDigestResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitGameTokenDigestResponse * SOAP_FMAC4 soap_in_tns__submitGameTokenDigestResponse(struct soap *soap, const char *tag, tns__submitGameTokenDigestResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitGameTokenDigestResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitGameTokenDigestResponse, sizeof(tns__submitGameTokenDigestResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitGameTokenDigestResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitGameTokenDigestResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "return", &(a->tns__submitGameTokenDigestResponse::return_), "xsd:long"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitGameTokenDigestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitGameTokenDigestResponse, 0, sizeof(tns__submitGameTokenDigestResponse), 0, soap_copy_tns__submitGameTokenDigestResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitGameTokenDigestResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitGameTokenDigestResponse);
	if (this->soap_out(soap, tag?tag:"tns:submitGameTokenDigestResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitGameTokenDigestResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitGameTokenDigestResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitGameTokenDigestResponse * SOAP_FMAC4 soap_get_tns__submitGameTokenDigestResponse(struct soap *soap, tns__submitGameTokenDigestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitGameTokenDigestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitGameTokenDigestResponse * SOAP_FMAC2 soap_instantiate_tns__submitGameTokenDigestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitGameTokenDigestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitGameTokenDigestResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitGameTokenDigestResponse);
		if (size)
			*size = sizeof(tns__submitGameTokenDigestResponse);
		((tns__submitGameTokenDigestResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitGameTokenDigestResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitGameTokenDigestResponse);
		for (int i = 0; i < n; i++)
			((tns__submitGameTokenDigestResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitGameTokenDigestResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitGameTokenDigestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitGameTokenDigestResponse %p -> %p\n", q, p));
	*(tns__submitGameTokenDigestResponse*)p = *(tns__submitGameTokenDigestResponse*)q;
}

void tns__submitGameTokenDigest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__submitGameTokenDigest::arg0 = NULL;
	this->tns__submitGameTokenDigest::userName = NULL;
	this->tns__submitGameTokenDigest::password = NULL;
	/* transient soap skipped */
}

void tns__submitGameTokenDigest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__submitGameTokenDigest::arg0);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitGameTokenDigest::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitGameTokenDigest::password);
	/* transient soap skipped */
}

int tns__submitGameTokenDigest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitGameTokenDigest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitGameTokenDigest(struct soap *soap, const char *tag, int id, const tns__submitGameTokenDigest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitGameTokenDigest), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->tns__submitGameTokenDigest::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__submitGameTokenDigest::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__submitGameTokenDigest::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitGameTokenDigest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitGameTokenDigest(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitGameTokenDigest * SOAP_FMAC4 soap_in_tns__submitGameTokenDigest(struct soap *soap, const char *tag, tns__submitGameTokenDigest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitGameTokenDigest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitGameTokenDigest, sizeof(tns__submitGameTokenDigest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitGameTokenDigest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitGameTokenDigest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->tns__submitGameTokenDigest::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__submitGameTokenDigest::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__submitGameTokenDigest::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitGameTokenDigest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitGameTokenDigest, 0, sizeof(tns__submitGameTokenDigest), 0, soap_copy_tns__submitGameTokenDigest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__submitGameTokenDigest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitGameTokenDigest);
	if (this->soap_out(soap, tag?tag:"tns:submitGameTokenDigest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitGameTokenDigest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitGameTokenDigest(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitGameTokenDigest * SOAP_FMAC4 soap_get_tns__submitGameTokenDigest(struct soap *soap, tns__submitGameTokenDigest *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitGameTokenDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitGameTokenDigest * SOAP_FMAC2 soap_instantiate_tns__submitGameTokenDigest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitGameTokenDigest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitGameTokenDigest, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitGameTokenDigest);
		if (size)
			*size = sizeof(tns__submitGameTokenDigest);
		((tns__submitGameTokenDigest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitGameTokenDigest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitGameTokenDigest);
		for (int i = 0; i < n; i++)
			((tns__submitGameTokenDigest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitGameTokenDigest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitGameTokenDigest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitGameTokenDigest %p -> %p\n", q, p));
	*(tns__submitGameTokenDigest*)p = *(tns__submitGameTokenDigest*)q;
}

void tns__submitGameTokenResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__submitGameTokenResponse::return_);
	/* transient soap skipped */
}

void tns__submitGameTokenResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__submitGameTokenResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitGameTokenResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitGameTokenResponse(struct soap *soap, const char *tag, int id, const tns__submitGameTokenResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitGameTokenResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "return", -1, &(a->tns__submitGameTokenResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitGameTokenResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitGameTokenResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitGameTokenResponse * SOAP_FMAC4 soap_in_tns__submitGameTokenResponse(struct soap *soap, const char *tag, tns__submitGameTokenResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitGameTokenResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitGameTokenResponse, sizeof(tns__submitGameTokenResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitGameTokenResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitGameTokenResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "return", &(a->tns__submitGameTokenResponse::return_), "xsd:long"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitGameTokenResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitGameTokenResponse, 0, sizeof(tns__submitGameTokenResponse), 0, soap_copy_tns__submitGameTokenResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitGameTokenResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitGameTokenResponse);
	if (this->soap_out(soap, tag?tag:"tns:submitGameTokenResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitGameTokenResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitGameTokenResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitGameTokenResponse * SOAP_FMAC4 soap_get_tns__submitGameTokenResponse(struct soap *soap, tns__submitGameTokenResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitGameTokenResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitGameTokenResponse * SOAP_FMAC2 soap_instantiate_tns__submitGameTokenResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitGameTokenResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitGameTokenResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitGameTokenResponse);
		if (size)
			*size = sizeof(tns__submitGameTokenResponse);
		((tns__submitGameTokenResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitGameTokenResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitGameTokenResponse);
		for (int i = 0; i < n; i++)
			((tns__submitGameTokenResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitGameTokenResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitGameTokenResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitGameTokenResponse %p -> %p\n", q, p));
	*(tns__submitGameTokenResponse*)p = *(tns__submitGameTokenResponse*)q;
}

void tns__submitGameToken::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__submitGameToken::arg0 = NULL;
	this->tns__submitGameToken::userName = NULL;
	this->tns__submitGameToken::password = NULL;
	/* transient soap skipped */
}

void tns__submitGameToken::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__gameToken(soap, &this->tns__submitGameToken::arg0);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitGameToken::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitGameToken::password);
	/* transient soap skipped */
}

int tns__submitGameToken::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitGameToken(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitGameToken(struct soap *soap, const char *tag, int id, const tns__submitGameToken *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitGameToken), type))
		return soap->error;
	if (soap_out_PointerTotns__gameToken(soap, "arg0", -1, &(a->tns__submitGameToken::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__submitGameToken::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__submitGameToken::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitGameToken::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitGameToken(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitGameToken * SOAP_FMAC4 soap_in_tns__submitGameToken(struct soap *soap, const char *tag, tns__submitGameToken *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitGameToken *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitGameToken, sizeof(tns__submitGameToken), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitGameToken)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitGameToken *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__gameToken(soap, "arg0", &(a->tns__submitGameToken::arg0), "tns:gameToken"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__submitGameToken::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__submitGameToken::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitGameToken *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitGameToken, 0, sizeof(tns__submitGameToken), 0, soap_copy_tns__submitGameToken);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__submitGameToken::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitGameToken);
	if (this->soap_out(soap, tag?tag:"tns:submitGameToken", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitGameToken::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitGameToken(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitGameToken * SOAP_FMAC4 soap_get_tns__submitGameToken(struct soap *soap, tns__submitGameToken *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitGameToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitGameToken * SOAP_FMAC2 soap_instantiate_tns__submitGameToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitGameToken(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitGameToken, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitGameToken);
		if (size)
			*size = sizeof(tns__submitGameToken);
		((tns__submitGameToken*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitGameToken[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitGameToken);
		for (int i = 0; i < n; i++)
			((tns__submitGameToken*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitGameToken*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitGameToken(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitGameToken %p -> %p\n", q, p));
	*(tns__submitGameToken*)p = *(tns__submitGameToken*)q;
}

void tns__submitGameAnnotationTextWithTokenIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__submitGameAnnotationTextWithTokenIdResponse::return_);
	/* transient soap skipped */
}

void tns__submitGameAnnotationTextWithTokenIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__submitGameAnnotationTextWithTokenIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitGameAnnotationTextWithTokenIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitGameAnnotationTextWithTokenIdResponse(struct soap *soap, const char *tag, int id, const tns__submitGameAnnotationTextWithTokenIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextWithTokenIdResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "return", -1, &(a->tns__submitGameAnnotationTextWithTokenIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitGameAnnotationTextWithTokenIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitGameAnnotationTextWithTokenIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitGameAnnotationTextWithTokenIdResponse * SOAP_FMAC4 soap_in_tns__submitGameAnnotationTextWithTokenIdResponse(struct soap *soap, const char *tag, tns__submitGameAnnotationTextWithTokenIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitGameAnnotationTextWithTokenIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextWithTokenIdResponse, sizeof(tns__submitGameAnnotationTextWithTokenIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextWithTokenIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitGameAnnotationTextWithTokenIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "return", &(a->tns__submitGameAnnotationTextWithTokenIdResponse::return_), "xsd:long"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitGameAnnotationTextWithTokenIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextWithTokenIdResponse, 0, sizeof(tns__submitGameAnnotationTextWithTokenIdResponse), 0, soap_copy_tns__submitGameAnnotationTextWithTokenIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitGameAnnotationTextWithTokenIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextWithTokenIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:submitGameAnnotationTextWithTokenIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitGameAnnotationTextWithTokenIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitGameAnnotationTextWithTokenIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitGameAnnotationTextWithTokenIdResponse * SOAP_FMAC4 soap_get_tns__submitGameAnnotationTextWithTokenIdResponse(struct soap *soap, tns__submitGameAnnotationTextWithTokenIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitGameAnnotationTextWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitGameAnnotationTextWithTokenIdResponse * SOAP_FMAC2 soap_instantiate_tns__submitGameAnnotationTextWithTokenIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitGameAnnotationTextWithTokenIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextWithTokenIdResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitGameAnnotationTextWithTokenIdResponse);
		if (size)
			*size = sizeof(tns__submitGameAnnotationTextWithTokenIdResponse);
		((tns__submitGameAnnotationTextWithTokenIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitGameAnnotationTextWithTokenIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitGameAnnotationTextWithTokenIdResponse);
		for (int i = 0; i < n; i++)
			((tns__submitGameAnnotationTextWithTokenIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitGameAnnotationTextWithTokenIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitGameAnnotationTextWithTokenIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitGameAnnotationTextWithTokenIdResponse %p -> %p\n", q, p));
	*(tns__submitGameAnnotationTextWithTokenIdResponse*)p = *(tns__submitGameAnnotationTextWithTokenIdResponse*)q;
}

void tns__submitGameAnnotationTextWithTokenId::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__submitGameAnnotationTextWithTokenId::arg0 = NULL;
	soap_default_LONG64(soap, &this->tns__submitGameAnnotationTextWithTokenId::arg1);
	soap_default_int(soap, &this->tns__submitGameAnnotationTextWithTokenId::arg2);
	soap_default_LONG64(soap, &this->tns__submitGameAnnotationTextWithTokenId::arg3);
	this->tns__submitGameAnnotationTextWithTokenId::userName = NULL;
	this->tns__submitGameAnnotationTextWithTokenId::password = NULL;
	/* transient soap skipped */
}

void tns__submitGameAnnotationTextWithTokenId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__submitGameAnnotationTextWithTokenId::arg0);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitGameAnnotationTextWithTokenId::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitGameAnnotationTextWithTokenId::password);
	/* transient soap skipped */
}

int tns__submitGameAnnotationTextWithTokenId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitGameAnnotationTextWithTokenId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitGameAnnotationTextWithTokenId(struct soap *soap, const char *tag, int id, const tns__submitGameAnnotationTextWithTokenId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextWithTokenId), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->tns__submitGameAnnotationTextWithTokenId::arg0), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "arg1", -1, &(a->tns__submitGameAnnotationTextWithTokenId::arg1), ""))
		return soap->error;
	if (soap_out_int(soap, "arg2", -1, &(a->tns__submitGameAnnotationTextWithTokenId::arg2), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "arg3", -1, &(a->tns__submitGameAnnotationTextWithTokenId::arg3), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__submitGameAnnotationTextWithTokenId::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__submitGameAnnotationTextWithTokenId::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitGameAnnotationTextWithTokenId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitGameAnnotationTextWithTokenId(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitGameAnnotationTextWithTokenId * SOAP_FMAC4 soap_in_tns__submitGameAnnotationTextWithTokenId(struct soap *soap, const char *tag, tns__submitGameAnnotationTextWithTokenId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitGameAnnotationTextWithTokenId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextWithTokenId, sizeof(tns__submitGameAnnotationTextWithTokenId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextWithTokenId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitGameAnnotationTextWithTokenId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	size_t soap_flag_arg31 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->tns__submitGameAnnotationTextWithTokenId::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "arg1", &(a->tns__submitGameAnnotationTextWithTokenId::arg1), "xsd:long"))
				{	soap_flag_arg11--;
					continue;
				}
			if (soap_flag_arg21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "arg2", &(a->tns__submitGameAnnotationTextWithTokenId::arg2), "xsd:int"))
				{	soap_flag_arg21--;
					continue;
				}
			if (soap_flag_arg31 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "arg3", &(a->tns__submitGameAnnotationTextWithTokenId::arg3), "xsd:long"))
				{	soap_flag_arg31--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__submitGameAnnotationTextWithTokenId::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__submitGameAnnotationTextWithTokenId::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitGameAnnotationTextWithTokenId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextWithTokenId, 0, sizeof(tns__submitGameAnnotationTextWithTokenId), 0, soap_copy_tns__submitGameAnnotationTextWithTokenId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg11 > 0 || soap_flag_arg21 > 0 || soap_flag_arg31 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitGameAnnotationTextWithTokenId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextWithTokenId);
	if (this->soap_out(soap, tag?tag:"tns:submitGameAnnotationTextWithTokenId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitGameAnnotationTextWithTokenId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitGameAnnotationTextWithTokenId(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitGameAnnotationTextWithTokenId * SOAP_FMAC4 soap_get_tns__submitGameAnnotationTextWithTokenId(struct soap *soap, tns__submitGameAnnotationTextWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitGameAnnotationTextWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitGameAnnotationTextWithTokenId * SOAP_FMAC2 soap_instantiate_tns__submitGameAnnotationTextWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitGameAnnotationTextWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextWithTokenId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitGameAnnotationTextWithTokenId);
		if (size)
			*size = sizeof(tns__submitGameAnnotationTextWithTokenId);
		((tns__submitGameAnnotationTextWithTokenId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitGameAnnotationTextWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitGameAnnotationTextWithTokenId);
		for (int i = 0; i < n; i++)
			((tns__submitGameAnnotationTextWithTokenId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitGameAnnotationTextWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitGameAnnotationTextWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitGameAnnotationTextWithTokenId %p -> %p\n", q, p));
	*(tns__submitGameAnnotationTextWithTokenId*)p = *(tns__submitGameAnnotationTextWithTokenId*)q;
}

void tns__submitGameAnnotationTextAndTokenDigestResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__submitGameAnnotationTextAndTokenDigestResponse::return_);
	/* transient soap skipped */
}

void tns__submitGameAnnotationTextAndTokenDigestResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__submitGameAnnotationTextAndTokenDigestResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitGameAnnotationTextAndTokenDigestResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitGameAnnotationTextAndTokenDigestResponse(struct soap *soap, const char *tag, int id, const tns__submitGameAnnotationTextAndTokenDigestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextAndTokenDigestResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "return", -1, &(a->tns__submitGameAnnotationTextAndTokenDigestResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitGameAnnotationTextAndTokenDigestResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitGameAnnotationTextAndTokenDigestResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitGameAnnotationTextAndTokenDigestResponse * SOAP_FMAC4 soap_in_tns__submitGameAnnotationTextAndTokenDigestResponse(struct soap *soap, const char *tag, tns__submitGameAnnotationTextAndTokenDigestResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitGameAnnotationTextAndTokenDigestResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextAndTokenDigestResponse, sizeof(tns__submitGameAnnotationTextAndTokenDigestResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextAndTokenDigestResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitGameAnnotationTextAndTokenDigestResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "return", &(a->tns__submitGameAnnotationTextAndTokenDigestResponse::return_), "xsd:long"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitGameAnnotationTextAndTokenDigestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextAndTokenDigestResponse, 0, sizeof(tns__submitGameAnnotationTextAndTokenDigestResponse), 0, soap_copy_tns__submitGameAnnotationTextAndTokenDigestResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitGameAnnotationTextAndTokenDigestResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextAndTokenDigestResponse);
	if (this->soap_out(soap, tag?tag:"tns:submitGameAnnotationTextAndTokenDigestResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitGameAnnotationTextAndTokenDigestResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitGameAnnotationTextAndTokenDigestResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitGameAnnotationTextAndTokenDigestResponse * SOAP_FMAC4 soap_get_tns__submitGameAnnotationTextAndTokenDigestResponse(struct soap *soap, tns__submitGameAnnotationTextAndTokenDigestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitGameAnnotationTextAndTokenDigestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitGameAnnotationTextAndTokenDigestResponse * SOAP_FMAC2 soap_instantiate_tns__submitGameAnnotationTextAndTokenDigestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitGameAnnotationTextAndTokenDigestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextAndTokenDigestResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitGameAnnotationTextAndTokenDigestResponse);
		if (size)
			*size = sizeof(tns__submitGameAnnotationTextAndTokenDigestResponse);
		((tns__submitGameAnnotationTextAndTokenDigestResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitGameAnnotationTextAndTokenDigestResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitGameAnnotationTextAndTokenDigestResponse);
		for (int i = 0; i < n; i++)
			((tns__submitGameAnnotationTextAndTokenDigestResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitGameAnnotationTextAndTokenDigestResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitGameAnnotationTextAndTokenDigestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitGameAnnotationTextAndTokenDigestResponse %p -> %p\n", q, p));
	*(tns__submitGameAnnotationTextAndTokenDigestResponse*)p = *(tns__submitGameAnnotationTextAndTokenDigestResponse*)q;
}

void tns__submitGameAnnotationTextAndTokenDigest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__submitGameAnnotationTextAndTokenDigest::arg0 = NULL;
	soap_default_LONG64(soap, &this->tns__submitGameAnnotationTextAndTokenDigest::arg1);
	soap_default_int(soap, &this->tns__submitGameAnnotationTextAndTokenDigest::arg2);
	this->tns__submitGameAnnotationTextAndTokenDigest::arg3 = NULL;
	this->tns__submitGameAnnotationTextAndTokenDigest::userName = NULL;
	this->tns__submitGameAnnotationTextAndTokenDigest::password = NULL;
	/* transient soap skipped */
}

void tns__submitGameAnnotationTextAndTokenDigest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__submitGameAnnotationTextAndTokenDigest::arg0);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitGameAnnotationTextAndTokenDigest::arg3);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitGameAnnotationTextAndTokenDigest::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitGameAnnotationTextAndTokenDigest::password);
	/* transient soap skipped */
}

int tns__submitGameAnnotationTextAndTokenDigest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitGameAnnotationTextAndTokenDigest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitGameAnnotationTextAndTokenDigest(struct soap *soap, const char *tag, int id, const tns__submitGameAnnotationTextAndTokenDigest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextAndTokenDigest), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->tns__submitGameAnnotationTextAndTokenDigest::arg0), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "arg1", -1, &(a->tns__submitGameAnnotationTextAndTokenDigest::arg1), ""))
		return soap->error;
	if (soap_out_int(soap, "arg2", -1, &(a->tns__submitGameAnnotationTextAndTokenDigest::arg2), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg3", -1, &(a->tns__submitGameAnnotationTextAndTokenDigest::arg3), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__submitGameAnnotationTextAndTokenDigest::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__submitGameAnnotationTextAndTokenDigest::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitGameAnnotationTextAndTokenDigest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitGameAnnotationTextAndTokenDigest(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitGameAnnotationTextAndTokenDigest * SOAP_FMAC4 soap_in_tns__submitGameAnnotationTextAndTokenDigest(struct soap *soap, const char *tag, tns__submitGameAnnotationTextAndTokenDigest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitGameAnnotationTextAndTokenDigest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextAndTokenDigest, sizeof(tns__submitGameAnnotationTextAndTokenDigest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextAndTokenDigest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitGameAnnotationTextAndTokenDigest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	size_t soap_flag_arg31 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->tns__submitGameAnnotationTextAndTokenDigest::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "arg1", &(a->tns__submitGameAnnotationTextAndTokenDigest::arg1), "xsd:long"))
				{	soap_flag_arg11--;
					continue;
				}
			if (soap_flag_arg21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "arg2", &(a->tns__submitGameAnnotationTextAndTokenDigest::arg2), "xsd:int"))
				{	soap_flag_arg21--;
					continue;
				}
			if (soap_flag_arg31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg3", &(a->tns__submitGameAnnotationTextAndTokenDigest::arg3), "xsd:string"))
				{	soap_flag_arg31--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__submitGameAnnotationTextAndTokenDigest::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__submitGameAnnotationTextAndTokenDigest::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitGameAnnotationTextAndTokenDigest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextAndTokenDigest, 0, sizeof(tns__submitGameAnnotationTextAndTokenDigest), 0, soap_copy_tns__submitGameAnnotationTextAndTokenDigest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg11 > 0 || soap_flag_arg21 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitGameAnnotationTextAndTokenDigest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextAndTokenDigest);
	if (this->soap_out(soap, tag?tag:"tns:submitGameAnnotationTextAndTokenDigest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitGameAnnotationTextAndTokenDigest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitGameAnnotationTextAndTokenDigest(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitGameAnnotationTextAndTokenDigest * SOAP_FMAC4 soap_get_tns__submitGameAnnotationTextAndTokenDigest(struct soap *soap, tns__submitGameAnnotationTextAndTokenDigest *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitGameAnnotationTextAndTokenDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitGameAnnotationTextAndTokenDigest * SOAP_FMAC2 soap_instantiate_tns__submitGameAnnotationTextAndTokenDigest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitGameAnnotationTextAndTokenDigest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextAndTokenDigest, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitGameAnnotationTextAndTokenDigest);
		if (size)
			*size = sizeof(tns__submitGameAnnotationTextAndTokenDigest);
		((tns__submitGameAnnotationTextAndTokenDigest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitGameAnnotationTextAndTokenDigest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitGameAnnotationTextAndTokenDigest);
		for (int i = 0; i < n; i++)
			((tns__submitGameAnnotationTextAndTokenDigest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitGameAnnotationTextAndTokenDigest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitGameAnnotationTextAndTokenDigest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitGameAnnotationTextAndTokenDigest %p -> %p\n", q, p));
	*(tns__submitGameAnnotationTextAndTokenDigest*)p = *(tns__submitGameAnnotationTextAndTokenDigest*)q;
}

void tns__submitGameAnnotationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__submitGameAnnotationResponse::return_);
	/* transient soap skipped */
}

void tns__submitGameAnnotationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__submitGameAnnotationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitGameAnnotationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitGameAnnotationResponse(struct soap *soap, const char *tag, int id, const tns__submitGameAnnotationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitGameAnnotationResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "return", -1, &(a->tns__submitGameAnnotationResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitGameAnnotationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitGameAnnotationResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitGameAnnotationResponse * SOAP_FMAC4 soap_in_tns__submitGameAnnotationResponse(struct soap *soap, const char *tag, tns__submitGameAnnotationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitGameAnnotationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitGameAnnotationResponse, sizeof(tns__submitGameAnnotationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitGameAnnotationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitGameAnnotationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "return", &(a->tns__submitGameAnnotationResponse::return_), "xsd:long"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitGameAnnotationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitGameAnnotationResponse, 0, sizeof(tns__submitGameAnnotationResponse), 0, soap_copy_tns__submitGameAnnotationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitGameAnnotationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitGameAnnotationResponse);
	if (this->soap_out(soap, tag?tag:"tns:submitGameAnnotationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitGameAnnotationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitGameAnnotationResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitGameAnnotationResponse * SOAP_FMAC4 soap_get_tns__submitGameAnnotationResponse(struct soap *soap, tns__submitGameAnnotationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitGameAnnotationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitGameAnnotationResponse * SOAP_FMAC2 soap_instantiate_tns__submitGameAnnotationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitGameAnnotationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitGameAnnotationResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitGameAnnotationResponse);
		if (size)
			*size = sizeof(tns__submitGameAnnotationResponse);
		((tns__submitGameAnnotationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitGameAnnotationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitGameAnnotationResponse);
		for (int i = 0; i < n; i++)
			((tns__submitGameAnnotationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitGameAnnotationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitGameAnnotationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitGameAnnotationResponse %p -> %p\n", q, p));
	*(tns__submitGameAnnotationResponse*)p = *(tns__submitGameAnnotationResponse*)q;
}

void tns__submitGameAnnotation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__submitGameAnnotation::arg0 = NULL;
	this->tns__submitGameAnnotation::userName = NULL;
	this->tns__submitGameAnnotation::password = NULL;
	/* transient soap skipped */
}

void tns__submitGameAnnotation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__gameAnnotation(soap, &this->tns__submitGameAnnotation::arg0);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitGameAnnotation::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitGameAnnotation::password);
	/* transient soap skipped */
}

int tns__submitGameAnnotation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitGameAnnotation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitGameAnnotation(struct soap *soap, const char *tag, int id, const tns__submitGameAnnotation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitGameAnnotation), type))
		return soap->error;
	if (soap_out_PointerTotns__gameAnnotation(soap, "arg0", -1, &(a->tns__submitGameAnnotation::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__submitGameAnnotation::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__submitGameAnnotation::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitGameAnnotation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitGameAnnotation(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitGameAnnotation * SOAP_FMAC4 soap_in_tns__submitGameAnnotation(struct soap *soap, const char *tag, tns__submitGameAnnotation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitGameAnnotation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitGameAnnotation, sizeof(tns__submitGameAnnotation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitGameAnnotation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitGameAnnotation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__gameAnnotation(soap, "arg0", &(a->tns__submitGameAnnotation::arg0), "tns:gameAnnotation"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__submitGameAnnotation::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__submitGameAnnotation::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitGameAnnotation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitGameAnnotation, 0, sizeof(tns__submitGameAnnotation), 0, soap_copy_tns__submitGameAnnotation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__submitGameAnnotation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitGameAnnotation);
	if (this->soap_out(soap, tag?tag:"tns:submitGameAnnotation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitGameAnnotation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitGameAnnotation(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitGameAnnotation * SOAP_FMAC4 soap_get_tns__submitGameAnnotation(struct soap *soap, tns__submitGameAnnotation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitGameAnnotation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitGameAnnotation * SOAP_FMAC2 soap_instantiate_tns__submitGameAnnotation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitGameAnnotation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitGameAnnotation, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitGameAnnotation);
		if (size)
			*size = sizeof(tns__submitGameAnnotation);
		((tns__submitGameAnnotation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitGameAnnotation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitGameAnnotation);
		for (int i = 0; i < n; i++)
			((tns__submitGameAnnotation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitGameAnnotation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitGameAnnotation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitGameAnnotation %p -> %p\n", q, p));
	*(tns__submitGameAnnotation*)p = *(tns__submitGameAnnotation*)q;
}

void tns__submitGameAliasTextWithTokenIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__submitGameAliasTextWithTokenIdResponse::return_);
	/* transient soap skipped */
}

void tns__submitGameAliasTextWithTokenIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__submitGameAliasTextWithTokenIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitGameAliasTextWithTokenIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitGameAliasTextWithTokenIdResponse(struct soap *soap, const char *tag, int id, const tns__submitGameAliasTextWithTokenIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitGameAliasTextWithTokenIdResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "return", -1, &(a->tns__submitGameAliasTextWithTokenIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitGameAliasTextWithTokenIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitGameAliasTextWithTokenIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitGameAliasTextWithTokenIdResponse * SOAP_FMAC4 soap_in_tns__submitGameAliasTextWithTokenIdResponse(struct soap *soap, const char *tag, tns__submitGameAliasTextWithTokenIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitGameAliasTextWithTokenIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitGameAliasTextWithTokenIdResponse, sizeof(tns__submitGameAliasTextWithTokenIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitGameAliasTextWithTokenIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitGameAliasTextWithTokenIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "return", &(a->tns__submitGameAliasTextWithTokenIdResponse::return_), "xsd:long"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitGameAliasTextWithTokenIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitGameAliasTextWithTokenIdResponse, 0, sizeof(tns__submitGameAliasTextWithTokenIdResponse), 0, soap_copy_tns__submitGameAliasTextWithTokenIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitGameAliasTextWithTokenIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitGameAliasTextWithTokenIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:submitGameAliasTextWithTokenIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitGameAliasTextWithTokenIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitGameAliasTextWithTokenIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitGameAliasTextWithTokenIdResponse * SOAP_FMAC4 soap_get_tns__submitGameAliasTextWithTokenIdResponse(struct soap *soap, tns__submitGameAliasTextWithTokenIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitGameAliasTextWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitGameAliasTextWithTokenIdResponse * SOAP_FMAC2 soap_instantiate_tns__submitGameAliasTextWithTokenIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitGameAliasTextWithTokenIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitGameAliasTextWithTokenIdResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitGameAliasTextWithTokenIdResponse);
		if (size)
			*size = sizeof(tns__submitGameAliasTextWithTokenIdResponse);
		((tns__submitGameAliasTextWithTokenIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitGameAliasTextWithTokenIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitGameAliasTextWithTokenIdResponse);
		for (int i = 0; i < n; i++)
			((tns__submitGameAliasTextWithTokenIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitGameAliasTextWithTokenIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitGameAliasTextWithTokenIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitGameAliasTextWithTokenIdResponse %p -> %p\n", q, p));
	*(tns__submitGameAliasTextWithTokenIdResponse*)p = *(tns__submitGameAliasTextWithTokenIdResponse*)q;
}

void tns__submitGameAliasTextWithTokenId::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__submitGameAliasTextWithTokenId::arg0 = NULL;
	soap_default_int(soap, &this->tns__submitGameAliasTextWithTokenId::arg1);
	soap_default_LONG64(soap, &this->tns__submitGameAliasTextWithTokenId::arg2);
	this->tns__submitGameAliasTextWithTokenId::userName = NULL;
	this->tns__submitGameAliasTextWithTokenId::password = NULL;
	/* transient soap skipped */
}

void tns__submitGameAliasTextWithTokenId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__submitGameAliasTextWithTokenId::arg0);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitGameAliasTextWithTokenId::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitGameAliasTextWithTokenId::password);
	/* transient soap skipped */
}

int tns__submitGameAliasTextWithTokenId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitGameAliasTextWithTokenId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitGameAliasTextWithTokenId(struct soap *soap, const char *tag, int id, const tns__submitGameAliasTextWithTokenId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitGameAliasTextWithTokenId), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->tns__submitGameAliasTextWithTokenId::arg0), ""))
		return soap->error;
	if (soap_out_int(soap, "arg1", -1, &(a->tns__submitGameAliasTextWithTokenId::arg1), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "arg2", -1, &(a->tns__submitGameAliasTextWithTokenId::arg2), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__submitGameAliasTextWithTokenId::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__submitGameAliasTextWithTokenId::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitGameAliasTextWithTokenId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitGameAliasTextWithTokenId(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitGameAliasTextWithTokenId * SOAP_FMAC4 soap_in_tns__submitGameAliasTextWithTokenId(struct soap *soap, const char *tag, tns__submitGameAliasTextWithTokenId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitGameAliasTextWithTokenId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitGameAliasTextWithTokenId, sizeof(tns__submitGameAliasTextWithTokenId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitGameAliasTextWithTokenId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitGameAliasTextWithTokenId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->tns__submitGameAliasTextWithTokenId::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "arg1", &(a->tns__submitGameAliasTextWithTokenId::arg1), "xsd:int"))
				{	soap_flag_arg11--;
					continue;
				}
			if (soap_flag_arg21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "arg2", &(a->tns__submitGameAliasTextWithTokenId::arg2), "xsd:long"))
				{	soap_flag_arg21--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__submitGameAliasTextWithTokenId::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__submitGameAliasTextWithTokenId::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitGameAliasTextWithTokenId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitGameAliasTextWithTokenId, 0, sizeof(tns__submitGameAliasTextWithTokenId), 0, soap_copy_tns__submitGameAliasTextWithTokenId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg11 > 0 || soap_flag_arg21 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitGameAliasTextWithTokenId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitGameAliasTextWithTokenId);
	if (this->soap_out(soap, tag?tag:"tns:submitGameAliasTextWithTokenId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitGameAliasTextWithTokenId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitGameAliasTextWithTokenId(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitGameAliasTextWithTokenId * SOAP_FMAC4 soap_get_tns__submitGameAliasTextWithTokenId(struct soap *soap, tns__submitGameAliasTextWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitGameAliasTextWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitGameAliasTextWithTokenId * SOAP_FMAC2 soap_instantiate_tns__submitGameAliasTextWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitGameAliasTextWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitGameAliasTextWithTokenId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitGameAliasTextWithTokenId);
		if (size)
			*size = sizeof(tns__submitGameAliasTextWithTokenId);
		((tns__submitGameAliasTextWithTokenId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitGameAliasTextWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitGameAliasTextWithTokenId);
		for (int i = 0; i < n; i++)
			((tns__submitGameAliasTextWithTokenId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitGameAliasTextWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitGameAliasTextWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitGameAliasTextWithTokenId %p -> %p\n", q, p));
	*(tns__submitGameAliasTextWithTokenId*)p = *(tns__submitGameAliasTextWithTokenId*)q;
}

void tns__submitGameAliasTextAndTokenDigestResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__submitGameAliasTextAndTokenDigestResponse::return_);
	/* transient soap skipped */
}

void tns__submitGameAliasTextAndTokenDigestResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__submitGameAliasTextAndTokenDigestResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitGameAliasTextAndTokenDigestResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitGameAliasTextAndTokenDigestResponse(struct soap *soap, const char *tag, int id, const tns__submitGameAliasTextAndTokenDigestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitGameAliasTextAndTokenDigestResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "return", -1, &(a->tns__submitGameAliasTextAndTokenDigestResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitGameAliasTextAndTokenDigestResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitGameAliasTextAndTokenDigestResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitGameAliasTextAndTokenDigestResponse * SOAP_FMAC4 soap_in_tns__submitGameAliasTextAndTokenDigestResponse(struct soap *soap, const char *tag, tns__submitGameAliasTextAndTokenDigestResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitGameAliasTextAndTokenDigestResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitGameAliasTextAndTokenDigestResponse, sizeof(tns__submitGameAliasTextAndTokenDigestResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitGameAliasTextAndTokenDigestResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitGameAliasTextAndTokenDigestResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "return", &(a->tns__submitGameAliasTextAndTokenDigestResponse::return_), "xsd:long"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitGameAliasTextAndTokenDigestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitGameAliasTextAndTokenDigestResponse, 0, sizeof(tns__submitGameAliasTextAndTokenDigestResponse), 0, soap_copy_tns__submitGameAliasTextAndTokenDigestResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitGameAliasTextAndTokenDigestResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitGameAliasTextAndTokenDigestResponse);
	if (this->soap_out(soap, tag?tag:"tns:submitGameAliasTextAndTokenDigestResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitGameAliasTextAndTokenDigestResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitGameAliasTextAndTokenDigestResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitGameAliasTextAndTokenDigestResponse * SOAP_FMAC4 soap_get_tns__submitGameAliasTextAndTokenDigestResponse(struct soap *soap, tns__submitGameAliasTextAndTokenDigestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitGameAliasTextAndTokenDigestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitGameAliasTextAndTokenDigestResponse * SOAP_FMAC2 soap_instantiate_tns__submitGameAliasTextAndTokenDigestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitGameAliasTextAndTokenDigestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitGameAliasTextAndTokenDigestResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitGameAliasTextAndTokenDigestResponse);
		if (size)
			*size = sizeof(tns__submitGameAliasTextAndTokenDigestResponse);
		((tns__submitGameAliasTextAndTokenDigestResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitGameAliasTextAndTokenDigestResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitGameAliasTextAndTokenDigestResponse);
		for (int i = 0; i < n; i++)
			((tns__submitGameAliasTextAndTokenDigestResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitGameAliasTextAndTokenDigestResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitGameAliasTextAndTokenDigestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitGameAliasTextAndTokenDigestResponse %p -> %p\n", q, p));
	*(tns__submitGameAliasTextAndTokenDigestResponse*)p = *(tns__submitGameAliasTextAndTokenDigestResponse*)q;
}

void tns__submitGameAliasTextAndTokenDigest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__submitGameAliasTextAndTokenDigest::arg0 = NULL;
	soap_default_int(soap, &this->tns__submitGameAliasTextAndTokenDigest::arg1);
	this->tns__submitGameAliasTextAndTokenDigest::arg2 = NULL;
	this->tns__submitGameAliasTextAndTokenDigest::userName = NULL;
	this->tns__submitGameAliasTextAndTokenDigest::password = NULL;
	/* transient soap skipped */
}

void tns__submitGameAliasTextAndTokenDigest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__submitGameAliasTextAndTokenDigest::arg0);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitGameAliasTextAndTokenDigest::arg2);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitGameAliasTextAndTokenDigest::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitGameAliasTextAndTokenDigest::password);
	/* transient soap skipped */
}

int tns__submitGameAliasTextAndTokenDigest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitGameAliasTextAndTokenDigest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitGameAliasTextAndTokenDigest(struct soap *soap, const char *tag, int id, const tns__submitGameAliasTextAndTokenDigest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitGameAliasTextAndTokenDigest), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->tns__submitGameAliasTextAndTokenDigest::arg0), ""))
		return soap->error;
	if (soap_out_int(soap, "arg1", -1, &(a->tns__submitGameAliasTextAndTokenDigest::arg1), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg2", -1, &(a->tns__submitGameAliasTextAndTokenDigest::arg2), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__submitGameAliasTextAndTokenDigest::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__submitGameAliasTextAndTokenDigest::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitGameAliasTextAndTokenDigest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitGameAliasTextAndTokenDigest(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitGameAliasTextAndTokenDigest * SOAP_FMAC4 soap_in_tns__submitGameAliasTextAndTokenDigest(struct soap *soap, const char *tag, tns__submitGameAliasTextAndTokenDigest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitGameAliasTextAndTokenDigest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitGameAliasTextAndTokenDigest, sizeof(tns__submitGameAliasTextAndTokenDigest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitGameAliasTextAndTokenDigest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitGameAliasTextAndTokenDigest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->tns__submitGameAliasTextAndTokenDigest::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "arg1", &(a->tns__submitGameAliasTextAndTokenDigest::arg1), "xsd:int"))
				{	soap_flag_arg11--;
					continue;
				}
			if (soap_flag_arg21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg2", &(a->tns__submitGameAliasTextAndTokenDigest::arg2), "xsd:string"))
				{	soap_flag_arg21--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__submitGameAliasTextAndTokenDigest::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__submitGameAliasTextAndTokenDigest::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitGameAliasTextAndTokenDigest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitGameAliasTextAndTokenDigest, 0, sizeof(tns__submitGameAliasTextAndTokenDigest), 0, soap_copy_tns__submitGameAliasTextAndTokenDigest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg11 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitGameAliasTextAndTokenDigest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitGameAliasTextAndTokenDigest);
	if (this->soap_out(soap, tag?tag:"tns:submitGameAliasTextAndTokenDigest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitGameAliasTextAndTokenDigest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitGameAliasTextAndTokenDigest(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitGameAliasTextAndTokenDigest * SOAP_FMAC4 soap_get_tns__submitGameAliasTextAndTokenDigest(struct soap *soap, tns__submitGameAliasTextAndTokenDigest *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitGameAliasTextAndTokenDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitGameAliasTextAndTokenDigest * SOAP_FMAC2 soap_instantiate_tns__submitGameAliasTextAndTokenDigest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitGameAliasTextAndTokenDigest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitGameAliasTextAndTokenDigest, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitGameAliasTextAndTokenDigest);
		if (size)
			*size = sizeof(tns__submitGameAliasTextAndTokenDigest);
		((tns__submitGameAliasTextAndTokenDigest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitGameAliasTextAndTokenDigest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitGameAliasTextAndTokenDigest);
		for (int i = 0; i < n; i++)
			((tns__submitGameAliasTextAndTokenDigest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitGameAliasTextAndTokenDigest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitGameAliasTextAndTokenDigest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitGameAliasTextAndTokenDigest %p -> %p\n", q, p));
	*(tns__submitGameAliasTextAndTokenDigest*)p = *(tns__submitGameAliasTextAndTokenDigest*)q;
}

void tns__submitGameAliasResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__submitGameAliasResponse::return_);
	/* transient soap skipped */
}

void tns__submitGameAliasResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__submitGameAliasResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitGameAliasResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitGameAliasResponse(struct soap *soap, const char *tag, int id, const tns__submitGameAliasResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitGameAliasResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "return", -1, &(a->tns__submitGameAliasResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitGameAliasResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitGameAliasResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitGameAliasResponse * SOAP_FMAC4 soap_in_tns__submitGameAliasResponse(struct soap *soap, const char *tag, tns__submitGameAliasResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitGameAliasResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitGameAliasResponse, sizeof(tns__submitGameAliasResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitGameAliasResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitGameAliasResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "return", &(a->tns__submitGameAliasResponse::return_), "xsd:long"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitGameAliasResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitGameAliasResponse, 0, sizeof(tns__submitGameAliasResponse), 0, soap_copy_tns__submitGameAliasResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitGameAliasResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitGameAliasResponse);
	if (this->soap_out(soap, tag?tag:"tns:submitGameAliasResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitGameAliasResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitGameAliasResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitGameAliasResponse * SOAP_FMAC4 soap_get_tns__submitGameAliasResponse(struct soap *soap, tns__submitGameAliasResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitGameAliasResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitGameAliasResponse * SOAP_FMAC2 soap_instantiate_tns__submitGameAliasResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitGameAliasResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitGameAliasResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitGameAliasResponse);
		if (size)
			*size = sizeof(tns__submitGameAliasResponse);
		((tns__submitGameAliasResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitGameAliasResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitGameAliasResponse);
		for (int i = 0; i < n; i++)
			((tns__submitGameAliasResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitGameAliasResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitGameAliasResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitGameAliasResponse %p -> %p\n", q, p));
	*(tns__submitGameAliasResponse*)p = *(tns__submitGameAliasResponse*)q;
}

void tns__submitGameAlias::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__submitGameAlias::arg0 = NULL;
	this->tns__submitGameAlias::userName = NULL;
	this->tns__submitGameAlias::password = NULL;
	/* transient soap skipped */
}

void tns__submitGameAlias::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__gameAlias(soap, &this->tns__submitGameAlias::arg0);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitGameAlias::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitGameAlias::password);
	/* transient soap skipped */
}

int tns__submitGameAlias::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitGameAlias(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitGameAlias(struct soap *soap, const char *tag, int id, const tns__submitGameAlias *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitGameAlias), type))
		return soap->error;
	if (soap_out_PointerTotns__gameAlias(soap, "arg0", -1, &(a->tns__submitGameAlias::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__submitGameAlias::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__submitGameAlias::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitGameAlias::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitGameAlias(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitGameAlias * SOAP_FMAC4 soap_in_tns__submitGameAlias(struct soap *soap, const char *tag, tns__submitGameAlias *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitGameAlias *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitGameAlias, sizeof(tns__submitGameAlias), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitGameAlias)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitGameAlias *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__gameAlias(soap, "arg0", &(a->tns__submitGameAlias::arg0), "tns:gameAlias"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__submitGameAlias::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__submitGameAlias::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitGameAlias *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitGameAlias, 0, sizeof(tns__submitGameAlias), 0, soap_copy_tns__submitGameAlias);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__submitGameAlias::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitGameAlias);
	if (this->soap_out(soap, tag?tag:"tns:submitGameAlias", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitGameAlias::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitGameAlias(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitGameAlias * SOAP_FMAC4 soap_get_tns__submitGameAlias(struct soap *soap, tns__submitGameAlias *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitGameAlias(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitGameAlias * SOAP_FMAC2 soap_instantiate_tns__submitGameAlias(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitGameAlias(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitGameAlias, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitGameAlias);
		if (size)
			*size = sizeof(tns__submitGameAlias);
		((tns__submitGameAlias*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitGameAlias[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitGameAlias);
		for (int i = 0; i < n; i++)
			((tns__submitGameAlias*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitGameAlias*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitGameAlias(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitGameAlias %p -> %p\n", q, p));
	*(tns__submitGameAlias*)p = *(tns__submitGameAlias*)q;
}

void tns__setUserLanguageResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__setUserLanguageResponse::return_);
	/* transient soap skipped */
}

void tns__setUserLanguageResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__setUserLanguageResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__setUserLanguageResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__setUserLanguageResponse(struct soap *soap, const char *tag, int id, const tns__setUserLanguageResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__setUserLanguageResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__setUserLanguageResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__setUserLanguageResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__setUserLanguageResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__setUserLanguageResponse * SOAP_FMAC4 soap_in_tns__setUserLanguageResponse(struct soap *soap, const char *tag, tns__setUserLanguageResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__setUserLanguageResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__setUserLanguageResponse, sizeof(tns__setUserLanguageResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__setUserLanguageResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__setUserLanguageResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__setUserLanguageResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__setUserLanguageResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__setUserLanguageResponse, 0, sizeof(tns__setUserLanguageResponse), 0, soap_copy_tns__setUserLanguageResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__setUserLanguageResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__setUserLanguageResponse);
	if (this->soap_out(soap, tag?tag:"tns:setUserLanguageResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__setUserLanguageResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__setUserLanguageResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__setUserLanguageResponse * SOAP_FMAC4 soap_get_tns__setUserLanguageResponse(struct soap *soap, tns__setUserLanguageResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__setUserLanguageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__setUserLanguageResponse * SOAP_FMAC2 soap_instantiate_tns__setUserLanguageResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__setUserLanguageResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__setUserLanguageResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__setUserLanguageResponse);
		if (size)
			*size = sizeof(tns__setUserLanguageResponse);
		((tns__setUserLanguageResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__setUserLanguageResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__setUserLanguageResponse);
		for (int i = 0; i < n; i++)
			((tns__setUserLanguageResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__setUserLanguageResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__setUserLanguageResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__setUserLanguageResponse %p -> %p\n", q, p));
	*(tns__setUserLanguageResponse*)p = *(tns__setUserLanguageResponse*)q;
}

void tns__setUserLanguage::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->tns__setUserLanguage::arg0);
	this->tns__setUserLanguage::userName = NULL;
	this->tns__setUserLanguage::password = NULL;
	/* transient soap skipped */
}

void tns__setUserLanguage::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__setUserLanguage::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__setUserLanguage::password);
	/* transient soap skipped */
}

int tns__setUserLanguage::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__setUserLanguage(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__setUserLanguage(struct soap *soap, const char *tag, int id, const tns__setUserLanguage *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__setUserLanguage), type))
		return soap->error;
	if (soap_out_int(soap, "arg0", -1, &(a->tns__setUserLanguage::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__setUserLanguage::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__setUserLanguage::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__setUserLanguage::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__setUserLanguage(soap, tag, this, type);
}

SOAP_FMAC3 tns__setUserLanguage * SOAP_FMAC4 soap_in_tns__setUserLanguage(struct soap *soap, const char *tag, tns__setUserLanguage *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__setUserLanguage *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__setUserLanguage, sizeof(tns__setUserLanguage), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__setUserLanguage)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__setUserLanguage *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "arg0", &(a->tns__setUserLanguage::arg0), "xsd:int"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__setUserLanguage::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__setUserLanguage::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__setUserLanguage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__setUserLanguage, 0, sizeof(tns__setUserLanguage), 0, soap_copy_tns__setUserLanguage);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg01 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__setUserLanguage::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__setUserLanguage);
	if (this->soap_out(soap, tag?tag:"tns:setUserLanguage", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__setUserLanguage::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__setUserLanguage(soap, this, tag, type);
}

SOAP_FMAC3 tns__setUserLanguage * SOAP_FMAC4 soap_get_tns__setUserLanguage(struct soap *soap, tns__setUserLanguage *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__setUserLanguage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__setUserLanguage * SOAP_FMAC2 soap_instantiate_tns__setUserLanguage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__setUserLanguage(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__setUserLanguage, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__setUserLanguage);
		if (size)
			*size = sizeof(tns__setUserLanguage);
		((tns__setUserLanguage*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__setUserLanguage[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__setUserLanguage);
		for (int i = 0; i < n; i++)
			((tns__setUserLanguage*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__setUserLanguage*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__setUserLanguage(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__setUserLanguage %p -> %p\n", q, p));
	*(tns__setUserLanguage*)p = *(tns__setUserLanguage*)q;
}

void tns__setUserAnonymousResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__setUserAnonymousResponse::return_);
	/* transient soap skipped */
}

void tns__setUserAnonymousResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__setUserAnonymousResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__setUserAnonymousResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__setUserAnonymousResponse(struct soap *soap, const char *tag, int id, const tns__setUserAnonymousResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__setUserAnonymousResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__setUserAnonymousResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__setUserAnonymousResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__setUserAnonymousResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__setUserAnonymousResponse * SOAP_FMAC4 soap_in_tns__setUserAnonymousResponse(struct soap *soap, const char *tag, tns__setUserAnonymousResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__setUserAnonymousResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__setUserAnonymousResponse, sizeof(tns__setUserAnonymousResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__setUserAnonymousResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__setUserAnonymousResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__setUserAnonymousResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__setUserAnonymousResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__setUserAnonymousResponse, 0, sizeof(tns__setUserAnonymousResponse), 0, soap_copy_tns__setUserAnonymousResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__setUserAnonymousResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__setUserAnonymousResponse);
	if (this->soap_out(soap, tag?tag:"tns:setUserAnonymousResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__setUserAnonymousResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__setUserAnonymousResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__setUserAnonymousResponse * SOAP_FMAC4 soap_get_tns__setUserAnonymousResponse(struct soap *soap, tns__setUserAnonymousResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__setUserAnonymousResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__setUserAnonymousResponse * SOAP_FMAC2 soap_instantiate_tns__setUserAnonymousResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__setUserAnonymousResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__setUserAnonymousResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__setUserAnonymousResponse);
		if (size)
			*size = sizeof(tns__setUserAnonymousResponse);
		((tns__setUserAnonymousResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__setUserAnonymousResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__setUserAnonymousResponse);
		for (int i = 0; i < n; i++)
			((tns__setUserAnonymousResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__setUserAnonymousResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__setUserAnonymousResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__setUserAnonymousResponse %p -> %p\n", q, p));
	*(tns__setUserAnonymousResponse*)p = *(tns__setUserAnonymousResponse*)q;
}

void tns__setUserAnonymous::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__setUserAnonymous::arg0);
	this->tns__setUserAnonymous::userName = NULL;
	this->tns__setUserAnonymous::password = NULL;
	/* transient soap skipped */
}

void tns__setUserAnonymous::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__setUserAnonymous::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__setUserAnonymous::password);
	/* transient soap skipped */
}

int tns__setUserAnonymous::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__setUserAnonymous(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__setUserAnonymous(struct soap *soap, const char *tag, int id, const tns__setUserAnonymous *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__setUserAnonymous), type))
		return soap->error;
	if (soap_out_bool(soap, "arg0", -1, &(a->tns__setUserAnonymous::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__setUserAnonymous::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__setUserAnonymous::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__setUserAnonymous::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__setUserAnonymous(soap, tag, this, type);
}

SOAP_FMAC3 tns__setUserAnonymous * SOAP_FMAC4 soap_in_tns__setUserAnonymous(struct soap *soap, const char *tag, tns__setUserAnonymous *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__setUserAnonymous *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__setUserAnonymous, sizeof(tns__setUserAnonymous), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__setUserAnonymous)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__setUserAnonymous *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "arg0", &(a->tns__setUserAnonymous::arg0), "xsd:boolean"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__setUserAnonymous::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__setUserAnonymous::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__setUserAnonymous *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__setUserAnonymous, 0, sizeof(tns__setUserAnonymous), 0, soap_copy_tns__setUserAnonymous);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg01 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__setUserAnonymous::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__setUserAnonymous);
	if (this->soap_out(soap, tag?tag:"tns:setUserAnonymous", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__setUserAnonymous::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__setUserAnonymous(soap, this, tag, type);
}

SOAP_FMAC3 tns__setUserAnonymous * SOAP_FMAC4 soap_get_tns__setUserAnonymous(struct soap *soap, tns__setUserAnonymous *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__setUserAnonymous(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__setUserAnonymous * SOAP_FMAC2 soap_instantiate_tns__setUserAnonymous(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__setUserAnonymous(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__setUserAnonymous, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__setUserAnonymous);
		if (size)
			*size = sizeof(tns__setUserAnonymous);
		((tns__setUserAnonymous*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__setUserAnonymous[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__setUserAnonymous);
		for (int i = 0; i < n; i++)
			((tns__setUserAnonymous*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__setUserAnonymous*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__setUserAnonymous(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__setUserAnonymous %p -> %p\n", q, p));
	*(tns__setUserAnonymous*)p = *(tns__setUserAnonymous*)q;
}

void tns__selectUserResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__selectUserResponse::return_ = NULL;
	/* transient soap skipped */
}

void tns__selectUserResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__user(soap, &this->tns__selectUserResponse::return_);
	/* transient soap skipped */
}

int tns__selectUserResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectUserResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectUserResponse(struct soap *soap, const char *tag, int id, const tns__selectUserResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__selectUserResponse), type))
		return soap->error;
	if (soap_out_PointerTotns__user(soap, "return", -1, &(a->tns__selectUserResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectUserResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectUserResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectUserResponse * SOAP_FMAC4 soap_in_tns__selectUserResponse(struct soap *soap, const char *tag, tns__selectUserResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectUserResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__selectUserResponse, sizeof(tns__selectUserResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__selectUserResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectUserResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__user(soap, "return", &(a->tns__selectUserResponse::return_), "tns:user"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__selectUserResponse, 0, sizeof(tns__selectUserResponse), 0, soap_copy_tns__selectUserResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__selectUserResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__selectUserResponse);
	if (this->soap_out(soap, tag?tag:"tns:selectUserResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectUserResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectUserResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectUserResponse * SOAP_FMAC4 soap_get_tns__selectUserResponse(struct soap *soap, tns__selectUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectUserResponse * SOAP_FMAC2 soap_instantiate_tns__selectUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__selectUserResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectUserResponse);
		if (size)
			*size = sizeof(tns__selectUserResponse);
		((tns__selectUserResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectUserResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectUserResponse);
		for (int i = 0; i < n; i++)
			((tns__selectUserResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectUserResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectUserResponse %p -> %p\n", q, p));
	*(tns__selectUserResponse*)p = *(tns__selectUserResponse*)q;
}

void tns__selectUser::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__selectUser::userName = NULL;
	this->tns__selectUser::password = NULL;
	/* transient soap skipped */
}

void tns__selectUser::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__selectUser::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__selectUser::password);
	/* transient soap skipped */
}

int tns__selectUser::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectUser(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectUser(struct soap *soap, const char *tag, int id, const tns__selectUser *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__selectUser), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__selectUser::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__selectUser::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectUser::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectUser(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectUser * SOAP_FMAC4 soap_in_tns__selectUser(struct soap *soap, const char *tag, tns__selectUser *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectUser *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__selectUser, sizeof(tns__selectUser), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__selectUser)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectUser *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__selectUser::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__selectUser::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__selectUser, 0, sizeof(tns__selectUser), 0, soap_copy_tns__selectUser);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__selectUser::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__selectUser);
	if (this->soap_out(soap, tag?tag:"tns:selectUser", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectUser::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectUser(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectUser * SOAP_FMAC4 soap_get_tns__selectUser(struct soap *soap, tns__selectUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectUser * SOAP_FMAC2 soap_instantiate_tns__selectUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__selectUser, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectUser);
		if (size)
			*size = sizeof(tns__selectUser);
		((tns__selectUser*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectUser[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectUser);
		for (int i = 0; i < n; i++)
			((tns__selectUser*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectUser*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectUser %p -> %p\n", q, p));
	*(tns__selectUser*)p = *(tns__selectUser*)q;
}

void tns__selectRelatedMediaAnnotationsWithTokenIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTotns__mediaAnnotation(soap, &this->tns__selectRelatedMediaAnnotationsWithTokenIdResponse::return_);
	/* transient soap skipped */
}

void tns__selectRelatedMediaAnnotationsWithTokenIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTotns__mediaAnnotation(soap, &this->tns__selectRelatedMediaAnnotationsWithTokenIdResponse::return_);
	/* transient soap skipped */
}

int tns__selectRelatedMediaAnnotationsWithTokenIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(struct soap *soap, const char *tag, int id, const tns__selectRelatedMediaAnnotationsWithTokenIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenIdResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTotns__mediaAnnotation(soap, "return", -1, &(a->tns__selectRelatedMediaAnnotationsWithTokenIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectRelatedMediaAnnotationsWithTokenIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectRelatedMediaAnnotationsWithTokenIdResponse * SOAP_FMAC4 soap_in_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(struct soap *soap, const char *tag, tns__selectRelatedMediaAnnotationsWithTokenIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectRelatedMediaAnnotationsWithTokenIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenIdResponse, sizeof(tns__selectRelatedMediaAnnotationsWithTokenIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectRelatedMediaAnnotationsWithTokenIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTotns__mediaAnnotation(soap, "return", &(a->tns__selectRelatedMediaAnnotationsWithTokenIdResponse::return_), "tns:mediaAnnotation"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectRelatedMediaAnnotationsWithTokenIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenIdResponse, 0, sizeof(tns__selectRelatedMediaAnnotationsWithTokenIdResponse), 0, soap_copy_tns__selectRelatedMediaAnnotationsWithTokenIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__selectRelatedMediaAnnotationsWithTokenIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:selectRelatedMediaAnnotationsWithTokenIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectRelatedMediaAnnotationsWithTokenIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectRelatedMediaAnnotationsWithTokenIdResponse * SOAP_FMAC4 soap_get_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(struct soap *soap, tns__selectRelatedMediaAnnotationsWithTokenIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectRelatedMediaAnnotationsWithTokenIdResponse * SOAP_FMAC2 soap_instantiate_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenIdResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectRelatedMediaAnnotationsWithTokenIdResponse);
		if (size)
			*size = sizeof(tns__selectRelatedMediaAnnotationsWithTokenIdResponse);
		((tns__selectRelatedMediaAnnotationsWithTokenIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectRelatedMediaAnnotationsWithTokenIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectRelatedMediaAnnotationsWithTokenIdResponse);
		for (int i = 0; i < n; i++)
			((tns__selectRelatedMediaAnnotationsWithTokenIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectRelatedMediaAnnotationsWithTokenIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectRelatedMediaAnnotationsWithTokenIdResponse %p -> %p\n", q, p));
	*(tns__selectRelatedMediaAnnotationsWithTokenIdResponse*)p = *(tns__selectRelatedMediaAnnotationsWithTokenIdResponse*)q;
}

void tns__selectRelatedMediaAnnotationsWithTokenId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__selectRelatedMediaAnnotationsWithTokenId::arg0);
	/* transient soap skipped */
}

void tns__selectRelatedMediaAnnotationsWithTokenId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__selectRelatedMediaAnnotationsWithTokenId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectRelatedMediaAnnotationsWithTokenId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, const char *tag, int id, const tns__selectRelatedMediaAnnotationsWithTokenId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "arg0", -1, &(a->tns__selectRelatedMediaAnnotationsWithTokenId::arg0), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectRelatedMediaAnnotationsWithTokenId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectRelatedMediaAnnotationsWithTokenId(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectRelatedMediaAnnotationsWithTokenId * SOAP_FMAC4 soap_in_tns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, const char *tag, tns__selectRelatedMediaAnnotationsWithTokenId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectRelatedMediaAnnotationsWithTokenId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenId, sizeof(tns__selectRelatedMediaAnnotationsWithTokenId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectRelatedMediaAnnotationsWithTokenId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "arg0", &(a->tns__selectRelatedMediaAnnotationsWithTokenId::arg0), "xsd:long"))
				{	soap_flag_arg01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectRelatedMediaAnnotationsWithTokenId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenId, 0, sizeof(tns__selectRelatedMediaAnnotationsWithTokenId), 0, soap_copy_tns__selectRelatedMediaAnnotationsWithTokenId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg01 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__selectRelatedMediaAnnotationsWithTokenId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenId);
	if (this->soap_out(soap, tag?tag:"tns:selectRelatedMediaAnnotationsWithTokenId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectRelatedMediaAnnotationsWithTokenId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectRelatedMediaAnnotationsWithTokenId(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectRelatedMediaAnnotationsWithTokenId * SOAP_FMAC4 soap_get_tns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, tns__selectRelatedMediaAnnotationsWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectRelatedMediaAnnotationsWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectRelatedMediaAnnotationsWithTokenId * SOAP_FMAC2 soap_instantiate_tns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectRelatedMediaAnnotationsWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectRelatedMediaAnnotationsWithTokenId);
		if (size)
			*size = sizeof(tns__selectRelatedMediaAnnotationsWithTokenId);
		((tns__selectRelatedMediaAnnotationsWithTokenId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectRelatedMediaAnnotationsWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectRelatedMediaAnnotationsWithTokenId);
		for (int i = 0; i < n; i++)
			((tns__selectRelatedMediaAnnotationsWithTokenId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectRelatedMediaAnnotationsWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectRelatedMediaAnnotationsWithTokenId %p -> %p\n", q, p));
	*(tns__selectRelatedMediaAnnotationsWithTokenId*)p = *(tns__selectRelatedMediaAnnotationsWithTokenId*)q;
}

void tns__selectRelatedGameAnnotationsWithTokenIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTotns__gameAnnotation(soap, &this->tns__selectRelatedGameAnnotationsWithTokenIdResponse::return_);
	/* transient soap skipped */
}

void tns__selectRelatedGameAnnotationsWithTokenIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTotns__gameAnnotation(soap, &this->tns__selectRelatedGameAnnotationsWithTokenIdResponse::return_);
	/* transient soap skipped */
}

int tns__selectRelatedGameAnnotationsWithTokenIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectRelatedGameAnnotationsWithTokenIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectRelatedGameAnnotationsWithTokenIdResponse(struct soap *soap, const char *tag, int id, const tns__selectRelatedGameAnnotationsWithTokenIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__selectRelatedGameAnnotationsWithTokenIdResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTotns__gameAnnotation(soap, "return", -1, &(a->tns__selectRelatedGameAnnotationsWithTokenIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectRelatedGameAnnotationsWithTokenIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectRelatedGameAnnotationsWithTokenIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectRelatedGameAnnotationsWithTokenIdResponse * SOAP_FMAC4 soap_in_tns__selectRelatedGameAnnotationsWithTokenIdResponse(struct soap *soap, const char *tag, tns__selectRelatedGameAnnotationsWithTokenIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectRelatedGameAnnotationsWithTokenIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__selectRelatedGameAnnotationsWithTokenIdResponse, sizeof(tns__selectRelatedGameAnnotationsWithTokenIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__selectRelatedGameAnnotationsWithTokenIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectRelatedGameAnnotationsWithTokenIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTotns__gameAnnotation(soap, "return", &(a->tns__selectRelatedGameAnnotationsWithTokenIdResponse::return_), "tns:gameAnnotation"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectRelatedGameAnnotationsWithTokenIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__selectRelatedGameAnnotationsWithTokenIdResponse, 0, sizeof(tns__selectRelatedGameAnnotationsWithTokenIdResponse), 0, soap_copy_tns__selectRelatedGameAnnotationsWithTokenIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__selectRelatedGameAnnotationsWithTokenIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__selectRelatedGameAnnotationsWithTokenIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:selectRelatedGameAnnotationsWithTokenIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectRelatedGameAnnotationsWithTokenIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectRelatedGameAnnotationsWithTokenIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectRelatedGameAnnotationsWithTokenIdResponse * SOAP_FMAC4 soap_get_tns__selectRelatedGameAnnotationsWithTokenIdResponse(struct soap *soap, tns__selectRelatedGameAnnotationsWithTokenIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectRelatedGameAnnotationsWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectRelatedGameAnnotationsWithTokenIdResponse * SOAP_FMAC2 soap_instantiate_tns__selectRelatedGameAnnotationsWithTokenIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectRelatedGameAnnotationsWithTokenIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__selectRelatedGameAnnotationsWithTokenIdResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectRelatedGameAnnotationsWithTokenIdResponse);
		if (size)
			*size = sizeof(tns__selectRelatedGameAnnotationsWithTokenIdResponse);
		((tns__selectRelatedGameAnnotationsWithTokenIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectRelatedGameAnnotationsWithTokenIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectRelatedGameAnnotationsWithTokenIdResponse);
		for (int i = 0; i < n; i++)
			((tns__selectRelatedGameAnnotationsWithTokenIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectRelatedGameAnnotationsWithTokenIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectRelatedGameAnnotationsWithTokenIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectRelatedGameAnnotationsWithTokenIdResponse %p -> %p\n", q, p));
	*(tns__selectRelatedGameAnnotationsWithTokenIdResponse*)p = *(tns__selectRelatedGameAnnotationsWithTokenIdResponse*)q;
}

void tns__selectRelatedGameAnnotationsWithTokenId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__selectRelatedGameAnnotationsWithTokenId::arg0);
	/* transient soap skipped */
}

void tns__selectRelatedGameAnnotationsWithTokenId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__selectRelatedGameAnnotationsWithTokenId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectRelatedGameAnnotationsWithTokenId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectRelatedGameAnnotationsWithTokenId(struct soap *soap, const char *tag, int id, const tns__selectRelatedGameAnnotationsWithTokenId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__selectRelatedGameAnnotationsWithTokenId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "arg0", -1, &(a->tns__selectRelatedGameAnnotationsWithTokenId::arg0), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectRelatedGameAnnotationsWithTokenId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectRelatedGameAnnotationsWithTokenId(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectRelatedGameAnnotationsWithTokenId * SOAP_FMAC4 soap_in_tns__selectRelatedGameAnnotationsWithTokenId(struct soap *soap, const char *tag, tns__selectRelatedGameAnnotationsWithTokenId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectRelatedGameAnnotationsWithTokenId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__selectRelatedGameAnnotationsWithTokenId, sizeof(tns__selectRelatedGameAnnotationsWithTokenId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__selectRelatedGameAnnotationsWithTokenId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectRelatedGameAnnotationsWithTokenId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "arg0", &(a->tns__selectRelatedGameAnnotationsWithTokenId::arg0), "xsd:long"))
				{	soap_flag_arg01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectRelatedGameAnnotationsWithTokenId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__selectRelatedGameAnnotationsWithTokenId, 0, sizeof(tns__selectRelatedGameAnnotationsWithTokenId), 0, soap_copy_tns__selectRelatedGameAnnotationsWithTokenId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg01 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__selectRelatedGameAnnotationsWithTokenId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__selectRelatedGameAnnotationsWithTokenId);
	if (this->soap_out(soap, tag?tag:"tns:selectRelatedGameAnnotationsWithTokenId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectRelatedGameAnnotationsWithTokenId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectRelatedGameAnnotationsWithTokenId(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectRelatedGameAnnotationsWithTokenId * SOAP_FMAC4 soap_get_tns__selectRelatedGameAnnotationsWithTokenId(struct soap *soap, tns__selectRelatedGameAnnotationsWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectRelatedGameAnnotationsWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectRelatedGameAnnotationsWithTokenId * SOAP_FMAC2 soap_instantiate_tns__selectRelatedGameAnnotationsWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectRelatedGameAnnotationsWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__selectRelatedGameAnnotationsWithTokenId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectRelatedGameAnnotationsWithTokenId);
		if (size)
			*size = sizeof(tns__selectRelatedGameAnnotationsWithTokenId);
		((tns__selectRelatedGameAnnotationsWithTokenId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectRelatedGameAnnotationsWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectRelatedGameAnnotationsWithTokenId);
		for (int i = 0; i < n; i++)
			((tns__selectRelatedGameAnnotationsWithTokenId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectRelatedGameAnnotationsWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectRelatedGameAnnotationsWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectRelatedGameAnnotationsWithTokenId %p -> %p\n", q, p));
	*(tns__selectRelatedGameAnnotationsWithTokenId*)p = *(tns__selectRelatedGameAnnotationsWithTokenId*)q;
}

void tns__selectMediaTokenWithIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__selectMediaTokenWithIdResponse::return_ = NULL;
	/* transient soap skipped */
}

void tns__selectMediaTokenWithIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__mediaToken(soap, &this->tns__selectMediaTokenWithIdResponse::return_);
	/* transient soap skipped */
}

int tns__selectMediaTokenWithIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectMediaTokenWithIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectMediaTokenWithIdResponse(struct soap *soap, const char *tag, int id, const tns__selectMediaTokenWithIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithIdResponse), type))
		return soap->error;
	if (soap_out_PointerTotns__mediaToken(soap, "return", -1, &(a->tns__selectMediaTokenWithIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectMediaTokenWithIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectMediaTokenWithIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectMediaTokenWithIdResponse * SOAP_FMAC4 soap_in_tns__selectMediaTokenWithIdResponse(struct soap *soap, const char *tag, tns__selectMediaTokenWithIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectMediaTokenWithIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithIdResponse, sizeof(tns__selectMediaTokenWithIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectMediaTokenWithIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__mediaToken(soap, "return", &(a->tns__selectMediaTokenWithIdResponse::return_), "tns:mediaToken"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectMediaTokenWithIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithIdResponse, 0, sizeof(tns__selectMediaTokenWithIdResponse), 0, soap_copy_tns__selectMediaTokenWithIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__selectMediaTokenWithIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:selectMediaTokenWithIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectMediaTokenWithIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectMediaTokenWithIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectMediaTokenWithIdResponse * SOAP_FMAC4 soap_get_tns__selectMediaTokenWithIdResponse(struct soap *soap, tns__selectMediaTokenWithIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectMediaTokenWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectMediaTokenWithIdResponse * SOAP_FMAC2 soap_instantiate_tns__selectMediaTokenWithIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectMediaTokenWithIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithIdResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaTokenWithIdResponse);
		if (size)
			*size = sizeof(tns__selectMediaTokenWithIdResponse);
		((tns__selectMediaTokenWithIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaTokenWithIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectMediaTokenWithIdResponse);
		for (int i = 0; i < n; i++)
			((tns__selectMediaTokenWithIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectMediaTokenWithIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectMediaTokenWithIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectMediaTokenWithIdResponse %p -> %p\n", q, p));
	*(tns__selectMediaTokenWithIdResponse*)p = *(tns__selectMediaTokenWithIdResponse*)q;
}

void tns__selectMediaTokenWithId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__selectMediaTokenWithId::arg0);
	/* transient soap skipped */
}

void tns__selectMediaTokenWithId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__selectMediaTokenWithId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectMediaTokenWithId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectMediaTokenWithId(struct soap *soap, const char *tag, int id, const tns__selectMediaTokenWithId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "arg0", -1, &(a->tns__selectMediaTokenWithId::arg0), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectMediaTokenWithId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectMediaTokenWithId(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectMediaTokenWithId * SOAP_FMAC4 soap_in_tns__selectMediaTokenWithId(struct soap *soap, const char *tag, tns__selectMediaTokenWithId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectMediaTokenWithId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithId, sizeof(tns__selectMediaTokenWithId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectMediaTokenWithId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "arg0", &(a->tns__selectMediaTokenWithId::arg0), "xsd:long"))
				{	soap_flag_arg01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectMediaTokenWithId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithId, 0, sizeof(tns__selectMediaTokenWithId), 0, soap_copy_tns__selectMediaTokenWithId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg01 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__selectMediaTokenWithId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithId);
	if (this->soap_out(soap, tag?tag:"tns:selectMediaTokenWithId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectMediaTokenWithId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectMediaTokenWithId(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectMediaTokenWithId * SOAP_FMAC4 soap_get_tns__selectMediaTokenWithId(struct soap *soap, tns__selectMediaTokenWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectMediaTokenWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectMediaTokenWithId * SOAP_FMAC2 soap_instantiate_tns__selectMediaTokenWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectMediaTokenWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaTokenWithId);
		if (size)
			*size = sizeof(tns__selectMediaTokenWithId);
		((tns__selectMediaTokenWithId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaTokenWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectMediaTokenWithId);
		for (int i = 0; i < n; i++)
			((tns__selectMediaTokenWithId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectMediaTokenWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectMediaTokenWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectMediaTokenWithId %p -> %p\n", q, p));
	*(tns__selectMediaTokenWithId*)p = *(tns__selectMediaTokenWithId*)q;
}

void tns__selectMediaTokenWithDigestResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__selectMediaTokenWithDigestResponse::return_ = NULL;
	/* transient soap skipped */
}

void tns__selectMediaTokenWithDigestResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__mediaToken(soap, &this->tns__selectMediaTokenWithDigestResponse::return_);
	/* transient soap skipped */
}

int tns__selectMediaTokenWithDigestResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectMediaTokenWithDigestResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectMediaTokenWithDigestResponse(struct soap *soap, const char *tag, int id, const tns__selectMediaTokenWithDigestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigestResponse), type))
		return soap->error;
	if (soap_out_PointerTotns__mediaToken(soap, "return", -1, &(a->tns__selectMediaTokenWithDigestResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectMediaTokenWithDigestResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectMediaTokenWithDigestResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectMediaTokenWithDigestResponse * SOAP_FMAC4 soap_in_tns__selectMediaTokenWithDigestResponse(struct soap *soap, const char *tag, tns__selectMediaTokenWithDigestResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectMediaTokenWithDigestResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigestResponse, sizeof(tns__selectMediaTokenWithDigestResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigestResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectMediaTokenWithDigestResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__mediaToken(soap, "return", &(a->tns__selectMediaTokenWithDigestResponse::return_), "tns:mediaToken"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectMediaTokenWithDigestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigestResponse, 0, sizeof(tns__selectMediaTokenWithDigestResponse), 0, soap_copy_tns__selectMediaTokenWithDigestResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__selectMediaTokenWithDigestResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigestResponse);
	if (this->soap_out(soap, tag?tag:"tns:selectMediaTokenWithDigestResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectMediaTokenWithDigestResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectMediaTokenWithDigestResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectMediaTokenWithDigestResponse * SOAP_FMAC4 soap_get_tns__selectMediaTokenWithDigestResponse(struct soap *soap, tns__selectMediaTokenWithDigestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectMediaTokenWithDigestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectMediaTokenWithDigestResponse * SOAP_FMAC2 soap_instantiate_tns__selectMediaTokenWithDigestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectMediaTokenWithDigestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigestResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaTokenWithDigestResponse);
		if (size)
			*size = sizeof(tns__selectMediaTokenWithDigestResponse);
		((tns__selectMediaTokenWithDigestResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaTokenWithDigestResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectMediaTokenWithDigestResponse);
		for (int i = 0; i < n; i++)
			((tns__selectMediaTokenWithDigestResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectMediaTokenWithDigestResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectMediaTokenWithDigestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectMediaTokenWithDigestResponse %p -> %p\n", q, p));
	*(tns__selectMediaTokenWithDigestResponse*)p = *(tns__selectMediaTokenWithDigestResponse*)q;
}

void tns__selectMediaTokenWithDigest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__selectMediaTokenWithDigest::arg0 = NULL;
	/* transient soap skipped */
}

void tns__selectMediaTokenWithDigest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__selectMediaTokenWithDigest::arg0);
	/* transient soap skipped */
}

int tns__selectMediaTokenWithDigest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectMediaTokenWithDigest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectMediaTokenWithDigest(struct soap *soap, const char *tag, int id, const tns__selectMediaTokenWithDigest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigest), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->tns__selectMediaTokenWithDigest::arg0), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectMediaTokenWithDigest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectMediaTokenWithDigest(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectMediaTokenWithDigest * SOAP_FMAC4 soap_in_tns__selectMediaTokenWithDigest(struct soap *soap, const char *tag, tns__selectMediaTokenWithDigest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectMediaTokenWithDigest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigest, sizeof(tns__selectMediaTokenWithDigest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectMediaTokenWithDigest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->tns__selectMediaTokenWithDigest::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectMediaTokenWithDigest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigest, 0, sizeof(tns__selectMediaTokenWithDigest), 0, soap_copy_tns__selectMediaTokenWithDigest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__selectMediaTokenWithDigest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigest);
	if (this->soap_out(soap, tag?tag:"tns:selectMediaTokenWithDigest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectMediaTokenWithDigest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectMediaTokenWithDigest(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectMediaTokenWithDigest * SOAP_FMAC4 soap_get_tns__selectMediaTokenWithDigest(struct soap *soap, tns__selectMediaTokenWithDigest *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectMediaTokenWithDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectMediaTokenWithDigest * SOAP_FMAC2 soap_instantiate_tns__selectMediaTokenWithDigest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectMediaTokenWithDigest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigest, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaTokenWithDigest);
		if (size)
			*size = sizeof(tns__selectMediaTokenWithDigest);
		((tns__selectMediaTokenWithDigest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaTokenWithDigest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectMediaTokenWithDigest);
		for (int i = 0; i < n; i++)
			((tns__selectMediaTokenWithDigest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectMediaTokenWithDigest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectMediaTokenWithDigest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectMediaTokenWithDigest %p -> %p\n", q, p));
	*(tns__selectMediaTokenWithDigest*)p = *(tns__selectMediaTokenWithDigest*)q;
}

void tns__selectMediaAnnotationsWithTokenIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTotns__mediaAnnotation(soap, &this->tns__selectMediaAnnotationsWithTokenIdResponse::return_);
	/* transient soap skipped */
}

void tns__selectMediaAnnotationsWithTokenIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTotns__mediaAnnotation(soap, &this->tns__selectMediaAnnotationsWithTokenIdResponse::return_);
	/* transient soap skipped */
}

int tns__selectMediaAnnotationsWithTokenIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectMediaAnnotationsWithTokenIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectMediaAnnotationsWithTokenIdResponse(struct soap *soap, const char *tag, int id, const tns__selectMediaAnnotationsWithTokenIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenIdResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTotns__mediaAnnotation(soap, "return", -1, &(a->tns__selectMediaAnnotationsWithTokenIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectMediaAnnotationsWithTokenIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectMediaAnnotationsWithTokenIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectMediaAnnotationsWithTokenIdResponse * SOAP_FMAC4 soap_in_tns__selectMediaAnnotationsWithTokenIdResponse(struct soap *soap, const char *tag, tns__selectMediaAnnotationsWithTokenIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectMediaAnnotationsWithTokenIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenIdResponse, sizeof(tns__selectMediaAnnotationsWithTokenIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectMediaAnnotationsWithTokenIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTotns__mediaAnnotation(soap, "return", &(a->tns__selectMediaAnnotationsWithTokenIdResponse::return_), "tns:mediaAnnotation"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectMediaAnnotationsWithTokenIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenIdResponse, 0, sizeof(tns__selectMediaAnnotationsWithTokenIdResponse), 0, soap_copy_tns__selectMediaAnnotationsWithTokenIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__selectMediaAnnotationsWithTokenIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:selectMediaAnnotationsWithTokenIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectMediaAnnotationsWithTokenIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectMediaAnnotationsWithTokenIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectMediaAnnotationsWithTokenIdResponse * SOAP_FMAC4 soap_get_tns__selectMediaAnnotationsWithTokenIdResponse(struct soap *soap, tns__selectMediaAnnotationsWithTokenIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectMediaAnnotationsWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectMediaAnnotationsWithTokenIdResponse * SOAP_FMAC2 soap_instantiate_tns__selectMediaAnnotationsWithTokenIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectMediaAnnotationsWithTokenIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenIdResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaAnnotationsWithTokenIdResponse);
		if (size)
			*size = sizeof(tns__selectMediaAnnotationsWithTokenIdResponse);
		((tns__selectMediaAnnotationsWithTokenIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaAnnotationsWithTokenIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectMediaAnnotationsWithTokenIdResponse);
		for (int i = 0; i < n; i++)
			((tns__selectMediaAnnotationsWithTokenIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectMediaAnnotationsWithTokenIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectMediaAnnotationsWithTokenIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectMediaAnnotationsWithTokenIdResponse %p -> %p\n", q, p));
	*(tns__selectMediaAnnotationsWithTokenIdResponse*)p = *(tns__selectMediaAnnotationsWithTokenIdResponse*)q;
}

void tns__selectMediaAnnotationsWithTokenId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__selectMediaAnnotationsWithTokenId::arg0);
	/* transient soap skipped */
}

void tns__selectMediaAnnotationsWithTokenId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__selectMediaAnnotationsWithTokenId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectMediaAnnotationsWithTokenId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectMediaAnnotationsWithTokenId(struct soap *soap, const char *tag, int id, const tns__selectMediaAnnotationsWithTokenId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "arg0", -1, &(a->tns__selectMediaAnnotationsWithTokenId::arg0), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectMediaAnnotationsWithTokenId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectMediaAnnotationsWithTokenId(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectMediaAnnotationsWithTokenId * SOAP_FMAC4 soap_in_tns__selectMediaAnnotationsWithTokenId(struct soap *soap, const char *tag, tns__selectMediaAnnotationsWithTokenId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectMediaAnnotationsWithTokenId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenId, sizeof(tns__selectMediaAnnotationsWithTokenId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectMediaAnnotationsWithTokenId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "arg0", &(a->tns__selectMediaAnnotationsWithTokenId::arg0), "xsd:long"))
				{	soap_flag_arg01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectMediaAnnotationsWithTokenId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenId, 0, sizeof(tns__selectMediaAnnotationsWithTokenId), 0, soap_copy_tns__selectMediaAnnotationsWithTokenId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg01 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__selectMediaAnnotationsWithTokenId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenId);
	if (this->soap_out(soap, tag?tag:"tns:selectMediaAnnotationsWithTokenId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectMediaAnnotationsWithTokenId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectMediaAnnotationsWithTokenId(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectMediaAnnotationsWithTokenId * SOAP_FMAC4 soap_get_tns__selectMediaAnnotationsWithTokenId(struct soap *soap, tns__selectMediaAnnotationsWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectMediaAnnotationsWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectMediaAnnotationsWithTokenId * SOAP_FMAC2 soap_instantiate_tns__selectMediaAnnotationsWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectMediaAnnotationsWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaAnnotationsWithTokenId);
		if (size)
			*size = sizeof(tns__selectMediaAnnotationsWithTokenId);
		((tns__selectMediaAnnotationsWithTokenId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaAnnotationsWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectMediaAnnotationsWithTokenId);
		for (int i = 0; i < n; i++)
			((tns__selectMediaAnnotationsWithTokenId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectMediaAnnotationsWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectMediaAnnotationsWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectMediaAnnotationsWithTokenId %p -> %p\n", q, p));
	*(tns__selectMediaAnnotationsWithTokenId*)p = *(tns__selectMediaAnnotationsWithTokenId*)q;
}

void tns__selectMediaAliasesWithTokenIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTotns__mediaAlias(soap, &this->tns__selectMediaAliasesWithTokenIdResponse::return_);
	/* transient soap skipped */
}

void tns__selectMediaAliasesWithTokenIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTotns__mediaAlias(soap, &this->tns__selectMediaAliasesWithTokenIdResponse::return_);
	/* transient soap skipped */
}

int tns__selectMediaAliasesWithTokenIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectMediaAliasesWithTokenIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectMediaAliasesWithTokenIdResponse(struct soap *soap, const char *tag, int id, const tns__selectMediaAliasesWithTokenIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenIdResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTotns__mediaAlias(soap, "return", -1, &(a->tns__selectMediaAliasesWithTokenIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectMediaAliasesWithTokenIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectMediaAliasesWithTokenIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectMediaAliasesWithTokenIdResponse * SOAP_FMAC4 soap_in_tns__selectMediaAliasesWithTokenIdResponse(struct soap *soap, const char *tag, tns__selectMediaAliasesWithTokenIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectMediaAliasesWithTokenIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenIdResponse, sizeof(tns__selectMediaAliasesWithTokenIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectMediaAliasesWithTokenIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTotns__mediaAlias(soap, "return", &(a->tns__selectMediaAliasesWithTokenIdResponse::return_), "tns:mediaAlias"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectMediaAliasesWithTokenIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenIdResponse, 0, sizeof(tns__selectMediaAliasesWithTokenIdResponse), 0, soap_copy_tns__selectMediaAliasesWithTokenIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__selectMediaAliasesWithTokenIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:selectMediaAliasesWithTokenIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectMediaAliasesWithTokenIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectMediaAliasesWithTokenIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectMediaAliasesWithTokenIdResponse * SOAP_FMAC4 soap_get_tns__selectMediaAliasesWithTokenIdResponse(struct soap *soap, tns__selectMediaAliasesWithTokenIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectMediaAliasesWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectMediaAliasesWithTokenIdResponse * SOAP_FMAC2 soap_instantiate_tns__selectMediaAliasesWithTokenIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectMediaAliasesWithTokenIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenIdResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaAliasesWithTokenIdResponse);
		if (size)
			*size = sizeof(tns__selectMediaAliasesWithTokenIdResponse);
		((tns__selectMediaAliasesWithTokenIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaAliasesWithTokenIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectMediaAliasesWithTokenIdResponse);
		for (int i = 0; i < n; i++)
			((tns__selectMediaAliasesWithTokenIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectMediaAliasesWithTokenIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectMediaAliasesWithTokenIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectMediaAliasesWithTokenIdResponse %p -> %p\n", q, p));
	*(tns__selectMediaAliasesWithTokenIdResponse*)p = *(tns__selectMediaAliasesWithTokenIdResponse*)q;
}

void tns__selectMediaAliasesWithTokenId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__selectMediaAliasesWithTokenId::arg0);
	/* transient soap skipped */
}

void tns__selectMediaAliasesWithTokenId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__selectMediaAliasesWithTokenId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectMediaAliasesWithTokenId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectMediaAliasesWithTokenId(struct soap *soap, const char *tag, int id, const tns__selectMediaAliasesWithTokenId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "arg0", -1, &(a->tns__selectMediaAliasesWithTokenId::arg0), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectMediaAliasesWithTokenId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectMediaAliasesWithTokenId(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectMediaAliasesWithTokenId * SOAP_FMAC4 soap_in_tns__selectMediaAliasesWithTokenId(struct soap *soap, const char *tag, tns__selectMediaAliasesWithTokenId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectMediaAliasesWithTokenId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenId, sizeof(tns__selectMediaAliasesWithTokenId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectMediaAliasesWithTokenId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "arg0", &(a->tns__selectMediaAliasesWithTokenId::arg0), "xsd:long"))
				{	soap_flag_arg01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectMediaAliasesWithTokenId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenId, 0, sizeof(tns__selectMediaAliasesWithTokenId), 0, soap_copy_tns__selectMediaAliasesWithTokenId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg01 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__selectMediaAliasesWithTokenId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenId);
	if (this->soap_out(soap, tag?tag:"tns:selectMediaAliasesWithTokenId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectMediaAliasesWithTokenId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectMediaAliasesWithTokenId(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectMediaAliasesWithTokenId * SOAP_FMAC4 soap_get_tns__selectMediaAliasesWithTokenId(struct soap *soap, tns__selectMediaAliasesWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectMediaAliasesWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectMediaAliasesWithTokenId * SOAP_FMAC2 soap_instantiate_tns__selectMediaAliasesWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectMediaAliasesWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaAliasesWithTokenId);
		if (size)
			*size = sizeof(tns__selectMediaAliasesWithTokenId);
		((tns__selectMediaAliasesWithTokenId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaAliasesWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectMediaAliasesWithTokenId);
		for (int i = 0; i < n; i++)
			((tns__selectMediaAliasesWithTokenId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectMediaAliasesWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectMediaAliasesWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectMediaAliasesWithTokenId %p -> %p\n", q, p));
	*(tns__selectMediaAliasesWithTokenId*)p = *(tns__selectMediaAliasesWithTokenId*)q;
}

void tns__selectGameTokenWithIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__selectGameTokenWithIdResponse::return_ = NULL;
	/* transient soap skipped */
}

void tns__selectGameTokenWithIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__gameToken(soap, &this->tns__selectGameTokenWithIdResponse::return_);
	/* transient soap skipped */
}

int tns__selectGameTokenWithIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectGameTokenWithIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectGameTokenWithIdResponse(struct soap *soap, const char *tag, int id, const tns__selectGameTokenWithIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__selectGameTokenWithIdResponse), type))
		return soap->error;
	if (soap_out_PointerTotns__gameToken(soap, "return", -1, &(a->tns__selectGameTokenWithIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectGameTokenWithIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectGameTokenWithIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectGameTokenWithIdResponse * SOAP_FMAC4 soap_in_tns__selectGameTokenWithIdResponse(struct soap *soap, const char *tag, tns__selectGameTokenWithIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectGameTokenWithIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__selectGameTokenWithIdResponse, sizeof(tns__selectGameTokenWithIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__selectGameTokenWithIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectGameTokenWithIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__gameToken(soap, "return", &(a->tns__selectGameTokenWithIdResponse::return_), "tns:gameToken"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectGameTokenWithIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__selectGameTokenWithIdResponse, 0, sizeof(tns__selectGameTokenWithIdResponse), 0, soap_copy_tns__selectGameTokenWithIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__selectGameTokenWithIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__selectGameTokenWithIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:selectGameTokenWithIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectGameTokenWithIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectGameTokenWithIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectGameTokenWithIdResponse * SOAP_FMAC4 soap_get_tns__selectGameTokenWithIdResponse(struct soap *soap, tns__selectGameTokenWithIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectGameTokenWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectGameTokenWithIdResponse * SOAP_FMAC2 soap_instantiate_tns__selectGameTokenWithIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectGameTokenWithIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__selectGameTokenWithIdResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectGameTokenWithIdResponse);
		if (size)
			*size = sizeof(tns__selectGameTokenWithIdResponse);
		((tns__selectGameTokenWithIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectGameTokenWithIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectGameTokenWithIdResponse);
		for (int i = 0; i < n; i++)
			((tns__selectGameTokenWithIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectGameTokenWithIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectGameTokenWithIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectGameTokenWithIdResponse %p -> %p\n", q, p));
	*(tns__selectGameTokenWithIdResponse*)p = *(tns__selectGameTokenWithIdResponse*)q;
}

void tns__selectGameTokenWithId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__selectGameTokenWithId::arg0);
	/* transient soap skipped */
}

void tns__selectGameTokenWithId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__selectGameTokenWithId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectGameTokenWithId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectGameTokenWithId(struct soap *soap, const char *tag, int id, const tns__selectGameTokenWithId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__selectGameTokenWithId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "arg0", -1, &(a->tns__selectGameTokenWithId::arg0), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectGameTokenWithId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectGameTokenWithId(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectGameTokenWithId * SOAP_FMAC4 soap_in_tns__selectGameTokenWithId(struct soap *soap, const char *tag, tns__selectGameTokenWithId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectGameTokenWithId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__selectGameTokenWithId, sizeof(tns__selectGameTokenWithId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__selectGameTokenWithId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectGameTokenWithId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "arg0", &(a->tns__selectGameTokenWithId::arg0), "xsd:long"))
				{	soap_flag_arg01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectGameTokenWithId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__selectGameTokenWithId, 0, sizeof(tns__selectGameTokenWithId), 0, soap_copy_tns__selectGameTokenWithId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg01 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__selectGameTokenWithId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__selectGameTokenWithId);
	if (this->soap_out(soap, tag?tag:"tns:selectGameTokenWithId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectGameTokenWithId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectGameTokenWithId(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectGameTokenWithId * SOAP_FMAC4 soap_get_tns__selectGameTokenWithId(struct soap *soap, tns__selectGameTokenWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectGameTokenWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectGameTokenWithId * SOAP_FMAC2 soap_instantiate_tns__selectGameTokenWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectGameTokenWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__selectGameTokenWithId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectGameTokenWithId);
		if (size)
			*size = sizeof(tns__selectGameTokenWithId);
		((tns__selectGameTokenWithId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectGameTokenWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectGameTokenWithId);
		for (int i = 0; i < n; i++)
			((tns__selectGameTokenWithId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectGameTokenWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectGameTokenWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectGameTokenWithId %p -> %p\n", q, p));
	*(tns__selectGameTokenWithId*)p = *(tns__selectGameTokenWithId*)q;
}

void tns__selectGameTokenWithDigestResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__selectGameTokenWithDigestResponse::return_ = NULL;
	/* transient soap skipped */
}

void tns__selectGameTokenWithDigestResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__gameToken(soap, &this->tns__selectGameTokenWithDigestResponse::return_);
	/* transient soap skipped */
}

int tns__selectGameTokenWithDigestResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectGameTokenWithDigestResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectGameTokenWithDigestResponse(struct soap *soap, const char *tag, int id, const tns__selectGameTokenWithDigestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__selectGameTokenWithDigestResponse), type))
		return soap->error;
	if (soap_out_PointerTotns__gameToken(soap, "return", -1, &(a->tns__selectGameTokenWithDigestResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectGameTokenWithDigestResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectGameTokenWithDigestResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectGameTokenWithDigestResponse * SOAP_FMAC4 soap_in_tns__selectGameTokenWithDigestResponse(struct soap *soap, const char *tag, tns__selectGameTokenWithDigestResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectGameTokenWithDigestResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__selectGameTokenWithDigestResponse, sizeof(tns__selectGameTokenWithDigestResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__selectGameTokenWithDigestResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectGameTokenWithDigestResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__gameToken(soap, "return", &(a->tns__selectGameTokenWithDigestResponse::return_), "tns:gameToken"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectGameTokenWithDigestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__selectGameTokenWithDigestResponse, 0, sizeof(tns__selectGameTokenWithDigestResponse), 0, soap_copy_tns__selectGameTokenWithDigestResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__selectGameTokenWithDigestResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__selectGameTokenWithDigestResponse);
	if (this->soap_out(soap, tag?tag:"tns:selectGameTokenWithDigestResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectGameTokenWithDigestResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectGameTokenWithDigestResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectGameTokenWithDigestResponse * SOAP_FMAC4 soap_get_tns__selectGameTokenWithDigestResponse(struct soap *soap, tns__selectGameTokenWithDigestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectGameTokenWithDigestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectGameTokenWithDigestResponse * SOAP_FMAC2 soap_instantiate_tns__selectGameTokenWithDigestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectGameTokenWithDigestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__selectGameTokenWithDigestResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectGameTokenWithDigestResponse);
		if (size)
			*size = sizeof(tns__selectGameTokenWithDigestResponse);
		((tns__selectGameTokenWithDigestResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectGameTokenWithDigestResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectGameTokenWithDigestResponse);
		for (int i = 0; i < n; i++)
			((tns__selectGameTokenWithDigestResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectGameTokenWithDigestResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectGameTokenWithDigestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectGameTokenWithDigestResponse %p -> %p\n", q, p));
	*(tns__selectGameTokenWithDigestResponse*)p = *(tns__selectGameTokenWithDigestResponse*)q;
}

void tns__selectGameTokenWithDigest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__selectGameTokenWithDigest::arg0 = NULL;
	/* transient soap skipped */
}

void tns__selectGameTokenWithDigest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__selectGameTokenWithDigest::arg0);
	/* transient soap skipped */
}

int tns__selectGameTokenWithDigest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectGameTokenWithDigest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectGameTokenWithDigest(struct soap *soap, const char *tag, int id, const tns__selectGameTokenWithDigest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__selectGameTokenWithDigest), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->tns__selectGameTokenWithDigest::arg0), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectGameTokenWithDigest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectGameTokenWithDigest(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectGameTokenWithDigest * SOAP_FMAC4 soap_in_tns__selectGameTokenWithDigest(struct soap *soap, const char *tag, tns__selectGameTokenWithDigest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectGameTokenWithDigest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__selectGameTokenWithDigest, sizeof(tns__selectGameTokenWithDigest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__selectGameTokenWithDigest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectGameTokenWithDigest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->tns__selectGameTokenWithDigest::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectGameTokenWithDigest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__selectGameTokenWithDigest, 0, sizeof(tns__selectGameTokenWithDigest), 0, soap_copy_tns__selectGameTokenWithDigest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__selectGameTokenWithDigest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__selectGameTokenWithDigest);
	if (this->soap_out(soap, tag?tag:"tns:selectGameTokenWithDigest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectGameTokenWithDigest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectGameTokenWithDigest(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectGameTokenWithDigest * SOAP_FMAC4 soap_get_tns__selectGameTokenWithDigest(struct soap *soap, tns__selectGameTokenWithDigest *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectGameTokenWithDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectGameTokenWithDigest * SOAP_FMAC2 soap_instantiate_tns__selectGameTokenWithDigest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectGameTokenWithDigest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__selectGameTokenWithDigest, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectGameTokenWithDigest);
		if (size)
			*size = sizeof(tns__selectGameTokenWithDigest);
		((tns__selectGameTokenWithDigest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectGameTokenWithDigest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectGameTokenWithDigest);
		for (int i = 0; i < n; i++)
			((tns__selectGameTokenWithDigest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectGameTokenWithDigest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectGameTokenWithDigest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectGameTokenWithDigest %p -> %p\n", q, p));
	*(tns__selectGameTokenWithDigest*)p = *(tns__selectGameTokenWithDigest*)q;
}

void tns__selectGameAnnotationsWithTokenIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTotns__gameAnnotation(soap, &this->tns__selectGameAnnotationsWithTokenIdResponse::return_);
	/* transient soap skipped */
}

void tns__selectGameAnnotationsWithTokenIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTotns__gameAnnotation(soap, &this->tns__selectGameAnnotationsWithTokenIdResponse::return_);
	/* transient soap skipped */
}

int tns__selectGameAnnotationsWithTokenIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectGameAnnotationsWithTokenIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectGameAnnotationsWithTokenIdResponse(struct soap *soap, const char *tag, int id, const tns__selectGameAnnotationsWithTokenIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__selectGameAnnotationsWithTokenIdResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTotns__gameAnnotation(soap, "return", -1, &(a->tns__selectGameAnnotationsWithTokenIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectGameAnnotationsWithTokenIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectGameAnnotationsWithTokenIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectGameAnnotationsWithTokenIdResponse * SOAP_FMAC4 soap_in_tns__selectGameAnnotationsWithTokenIdResponse(struct soap *soap, const char *tag, tns__selectGameAnnotationsWithTokenIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectGameAnnotationsWithTokenIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__selectGameAnnotationsWithTokenIdResponse, sizeof(tns__selectGameAnnotationsWithTokenIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__selectGameAnnotationsWithTokenIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectGameAnnotationsWithTokenIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTotns__gameAnnotation(soap, "return", &(a->tns__selectGameAnnotationsWithTokenIdResponse::return_), "tns:gameAnnotation"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectGameAnnotationsWithTokenIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__selectGameAnnotationsWithTokenIdResponse, 0, sizeof(tns__selectGameAnnotationsWithTokenIdResponse), 0, soap_copy_tns__selectGameAnnotationsWithTokenIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__selectGameAnnotationsWithTokenIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__selectGameAnnotationsWithTokenIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:selectGameAnnotationsWithTokenIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectGameAnnotationsWithTokenIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectGameAnnotationsWithTokenIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectGameAnnotationsWithTokenIdResponse * SOAP_FMAC4 soap_get_tns__selectGameAnnotationsWithTokenIdResponse(struct soap *soap, tns__selectGameAnnotationsWithTokenIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectGameAnnotationsWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectGameAnnotationsWithTokenIdResponse * SOAP_FMAC2 soap_instantiate_tns__selectGameAnnotationsWithTokenIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectGameAnnotationsWithTokenIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__selectGameAnnotationsWithTokenIdResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectGameAnnotationsWithTokenIdResponse);
		if (size)
			*size = sizeof(tns__selectGameAnnotationsWithTokenIdResponse);
		((tns__selectGameAnnotationsWithTokenIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectGameAnnotationsWithTokenIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectGameAnnotationsWithTokenIdResponse);
		for (int i = 0; i < n; i++)
			((tns__selectGameAnnotationsWithTokenIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectGameAnnotationsWithTokenIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectGameAnnotationsWithTokenIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectGameAnnotationsWithTokenIdResponse %p -> %p\n", q, p));
	*(tns__selectGameAnnotationsWithTokenIdResponse*)p = *(tns__selectGameAnnotationsWithTokenIdResponse*)q;
}

void tns__selectGameAnnotationsWithTokenId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__selectGameAnnotationsWithTokenId::arg0);
	/* transient soap skipped */
}

void tns__selectGameAnnotationsWithTokenId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__selectGameAnnotationsWithTokenId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectGameAnnotationsWithTokenId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectGameAnnotationsWithTokenId(struct soap *soap, const char *tag, int id, const tns__selectGameAnnotationsWithTokenId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__selectGameAnnotationsWithTokenId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "arg0", -1, &(a->tns__selectGameAnnotationsWithTokenId::arg0), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectGameAnnotationsWithTokenId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectGameAnnotationsWithTokenId(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectGameAnnotationsWithTokenId * SOAP_FMAC4 soap_in_tns__selectGameAnnotationsWithTokenId(struct soap *soap, const char *tag, tns__selectGameAnnotationsWithTokenId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectGameAnnotationsWithTokenId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__selectGameAnnotationsWithTokenId, sizeof(tns__selectGameAnnotationsWithTokenId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__selectGameAnnotationsWithTokenId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectGameAnnotationsWithTokenId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "arg0", &(a->tns__selectGameAnnotationsWithTokenId::arg0), "xsd:long"))
				{	soap_flag_arg01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectGameAnnotationsWithTokenId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__selectGameAnnotationsWithTokenId, 0, sizeof(tns__selectGameAnnotationsWithTokenId), 0, soap_copy_tns__selectGameAnnotationsWithTokenId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg01 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__selectGameAnnotationsWithTokenId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__selectGameAnnotationsWithTokenId);
	if (this->soap_out(soap, tag?tag:"tns:selectGameAnnotationsWithTokenId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectGameAnnotationsWithTokenId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectGameAnnotationsWithTokenId(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectGameAnnotationsWithTokenId * SOAP_FMAC4 soap_get_tns__selectGameAnnotationsWithTokenId(struct soap *soap, tns__selectGameAnnotationsWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectGameAnnotationsWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectGameAnnotationsWithTokenId * SOAP_FMAC2 soap_instantiate_tns__selectGameAnnotationsWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectGameAnnotationsWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__selectGameAnnotationsWithTokenId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectGameAnnotationsWithTokenId);
		if (size)
			*size = sizeof(tns__selectGameAnnotationsWithTokenId);
		((tns__selectGameAnnotationsWithTokenId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectGameAnnotationsWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectGameAnnotationsWithTokenId);
		for (int i = 0; i < n; i++)
			((tns__selectGameAnnotationsWithTokenId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectGameAnnotationsWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectGameAnnotationsWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectGameAnnotationsWithTokenId %p -> %p\n", q, p));
	*(tns__selectGameAnnotationsWithTokenId*)p = *(tns__selectGameAnnotationsWithTokenId*)q;
}

void tns__selectGameAliasesWithTokenIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTotns__gameAlias(soap, &this->tns__selectGameAliasesWithTokenIdResponse::return_);
	/* transient soap skipped */
}

void tns__selectGameAliasesWithTokenIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTotns__gameAlias(soap, &this->tns__selectGameAliasesWithTokenIdResponse::return_);
	/* transient soap skipped */
}

int tns__selectGameAliasesWithTokenIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectGameAliasesWithTokenIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectGameAliasesWithTokenIdResponse(struct soap *soap, const char *tag, int id, const tns__selectGameAliasesWithTokenIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__selectGameAliasesWithTokenIdResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTotns__gameAlias(soap, "return", -1, &(a->tns__selectGameAliasesWithTokenIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectGameAliasesWithTokenIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectGameAliasesWithTokenIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectGameAliasesWithTokenIdResponse * SOAP_FMAC4 soap_in_tns__selectGameAliasesWithTokenIdResponse(struct soap *soap, const char *tag, tns__selectGameAliasesWithTokenIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectGameAliasesWithTokenIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__selectGameAliasesWithTokenIdResponse, sizeof(tns__selectGameAliasesWithTokenIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__selectGameAliasesWithTokenIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectGameAliasesWithTokenIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTotns__gameAlias(soap, "return", &(a->tns__selectGameAliasesWithTokenIdResponse::return_), "tns:gameAlias"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectGameAliasesWithTokenIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__selectGameAliasesWithTokenIdResponse, 0, sizeof(tns__selectGameAliasesWithTokenIdResponse), 0, soap_copy_tns__selectGameAliasesWithTokenIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__selectGameAliasesWithTokenIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__selectGameAliasesWithTokenIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:selectGameAliasesWithTokenIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectGameAliasesWithTokenIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectGameAliasesWithTokenIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectGameAliasesWithTokenIdResponse * SOAP_FMAC4 soap_get_tns__selectGameAliasesWithTokenIdResponse(struct soap *soap, tns__selectGameAliasesWithTokenIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectGameAliasesWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectGameAliasesWithTokenIdResponse * SOAP_FMAC2 soap_instantiate_tns__selectGameAliasesWithTokenIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectGameAliasesWithTokenIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__selectGameAliasesWithTokenIdResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectGameAliasesWithTokenIdResponse);
		if (size)
			*size = sizeof(tns__selectGameAliasesWithTokenIdResponse);
		((tns__selectGameAliasesWithTokenIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectGameAliasesWithTokenIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectGameAliasesWithTokenIdResponse);
		for (int i = 0; i < n; i++)
			((tns__selectGameAliasesWithTokenIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectGameAliasesWithTokenIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectGameAliasesWithTokenIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectGameAliasesWithTokenIdResponse %p -> %p\n", q, p));
	*(tns__selectGameAliasesWithTokenIdResponse*)p = *(tns__selectGameAliasesWithTokenIdResponse*)q;
}

void tns__selectGameAliasesWithTokenId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__selectGameAliasesWithTokenId::arg0);
	/* transient soap skipped */
}

void tns__selectGameAliasesWithTokenId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__selectGameAliasesWithTokenId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectGameAliasesWithTokenId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectGameAliasesWithTokenId(struct soap *soap, const char *tag, int id, const tns__selectGameAliasesWithTokenId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__selectGameAliasesWithTokenId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "arg0", -1, &(a->tns__selectGameAliasesWithTokenId::arg0), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectGameAliasesWithTokenId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectGameAliasesWithTokenId(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectGameAliasesWithTokenId * SOAP_FMAC4 soap_in_tns__selectGameAliasesWithTokenId(struct soap *soap, const char *tag, tns__selectGameAliasesWithTokenId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectGameAliasesWithTokenId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__selectGameAliasesWithTokenId, sizeof(tns__selectGameAliasesWithTokenId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__selectGameAliasesWithTokenId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectGameAliasesWithTokenId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "arg0", &(a->tns__selectGameAliasesWithTokenId::arg0), "xsd:long"))
				{	soap_flag_arg01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectGameAliasesWithTokenId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__selectGameAliasesWithTokenId, 0, sizeof(tns__selectGameAliasesWithTokenId), 0, soap_copy_tns__selectGameAliasesWithTokenId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg01 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__selectGameAliasesWithTokenId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__selectGameAliasesWithTokenId);
	if (this->soap_out(soap, tag?tag:"tns:selectGameAliasesWithTokenId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectGameAliasesWithTokenId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectGameAliasesWithTokenId(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectGameAliasesWithTokenId * SOAP_FMAC4 soap_get_tns__selectGameAliasesWithTokenId(struct soap *soap, tns__selectGameAliasesWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectGameAliasesWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectGameAliasesWithTokenId * SOAP_FMAC2 soap_instantiate_tns__selectGameAliasesWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectGameAliasesWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__selectGameAliasesWithTokenId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectGameAliasesWithTokenId);
		if (size)
			*size = sizeof(tns__selectGameAliasesWithTokenId);
		((tns__selectGameAliasesWithTokenId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectGameAliasesWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectGameAliasesWithTokenId);
		for (int i = 0; i < n; i++)
			((tns__selectGameAliasesWithTokenId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectGameAliasesWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectGameAliasesWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectGameAliasesWithTokenId %p -> %p\n", q, p));
	*(tns__selectGameAliasesWithTokenId*)p = *(tns__selectGameAliasesWithTokenId*)q;
}

void tns__isConnectedResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__isConnectedResponse::return_);
	/* transient soap skipped */
}

void tns__isConnectedResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__isConnectedResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__isConnectedResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__isConnectedResponse(struct soap *soap, const char *tag, int id, const tns__isConnectedResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__isConnectedResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__isConnectedResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__isConnectedResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__isConnectedResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__isConnectedResponse * SOAP_FMAC4 soap_in_tns__isConnectedResponse(struct soap *soap, const char *tag, tns__isConnectedResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__isConnectedResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__isConnectedResponse, sizeof(tns__isConnectedResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__isConnectedResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__isConnectedResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__isConnectedResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__isConnectedResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__isConnectedResponse, 0, sizeof(tns__isConnectedResponse), 0, soap_copy_tns__isConnectedResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__isConnectedResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__isConnectedResponse);
	if (this->soap_out(soap, tag?tag:"tns:isConnectedResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__isConnectedResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__isConnectedResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__isConnectedResponse * SOAP_FMAC4 soap_get_tns__isConnectedResponse(struct soap *soap, tns__isConnectedResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__isConnectedResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__isConnectedResponse * SOAP_FMAC2 soap_instantiate_tns__isConnectedResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__isConnectedResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__isConnectedResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__isConnectedResponse);
		if (size)
			*size = sizeof(tns__isConnectedResponse);
		((tns__isConnectedResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__isConnectedResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__isConnectedResponse);
		for (int i = 0; i < n; i++)
			((tns__isConnectedResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__isConnectedResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__isConnectedResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__isConnectedResponse %p -> %p\n", q, p));
	*(tns__isConnectedResponse*)p = *(tns__isConnectedResponse*)q;
}

void tns__isConnected::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void tns__isConnected::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__isConnected::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__isConnected(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__isConnected(struct soap *soap, const char *tag, int id, const tns__isConnected *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__isConnected), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__isConnected::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__isConnected(soap, tag, this, type);
}

SOAP_FMAC3 tns__isConnected * SOAP_FMAC4 soap_in_tns__isConnected(struct soap *soap, const char *tag, tns__isConnected *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__isConnected *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__isConnected, sizeof(tns__isConnected), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__isConnected)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__isConnected *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__isConnected *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__isConnected, 0, sizeof(tns__isConnected), 0, soap_copy_tns__isConnected);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__isConnected::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__isConnected);
	if (this->soap_out(soap, tag?tag:"tns:isConnected", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__isConnected::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__isConnected(soap, this, tag, type);
}

SOAP_FMAC3 tns__isConnected * SOAP_FMAC4 soap_get_tns__isConnected(struct soap *soap, tns__isConnected *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__isConnected(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__isConnected * SOAP_FMAC2 soap_instantiate_tns__isConnected(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__isConnected(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__isConnected, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__isConnected);
		if (size)
			*size = sizeof(tns__isConnected);
		((tns__isConnected*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__isConnected[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__isConnected);
		for (int i = 0; i < n; i++)
			((tns__isConnected*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__isConnected*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__isConnected(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__isConnected %p -> %p\n", q, p));
	*(tns__isConnected*)p = *(tns__isConnected*)q;
}

void tns__isClientUpdatedResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__isClientUpdatedResponse::return_);
	/* transient soap skipped */
}

void tns__isClientUpdatedResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__isClientUpdatedResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__isClientUpdatedResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__isClientUpdatedResponse(struct soap *soap, const char *tag, int id, const tns__isClientUpdatedResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__isClientUpdatedResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__isClientUpdatedResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__isClientUpdatedResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__isClientUpdatedResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__isClientUpdatedResponse * SOAP_FMAC4 soap_in_tns__isClientUpdatedResponse(struct soap *soap, const char *tag, tns__isClientUpdatedResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__isClientUpdatedResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__isClientUpdatedResponse, sizeof(tns__isClientUpdatedResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__isClientUpdatedResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__isClientUpdatedResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__isClientUpdatedResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__isClientUpdatedResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__isClientUpdatedResponse, 0, sizeof(tns__isClientUpdatedResponse), 0, soap_copy_tns__isClientUpdatedResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__isClientUpdatedResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__isClientUpdatedResponse);
	if (this->soap_out(soap, tag?tag:"tns:isClientUpdatedResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__isClientUpdatedResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__isClientUpdatedResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__isClientUpdatedResponse * SOAP_FMAC4 soap_get_tns__isClientUpdatedResponse(struct soap *soap, tns__isClientUpdatedResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__isClientUpdatedResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__isClientUpdatedResponse * SOAP_FMAC2 soap_instantiate_tns__isClientUpdatedResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__isClientUpdatedResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__isClientUpdatedResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__isClientUpdatedResponse);
		if (size)
			*size = sizeof(tns__isClientUpdatedResponse);
		((tns__isClientUpdatedResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__isClientUpdatedResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__isClientUpdatedResponse);
		for (int i = 0; i < n; i++)
			((tns__isClientUpdatedResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__isClientUpdatedResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__isClientUpdatedResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__isClientUpdatedResponse %p -> %p\n", q, p));
	*(tns__isClientUpdatedResponse*)p = *(tns__isClientUpdatedResponse*)q;
}

void tns__isClientUpdated::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__isClientUpdated::arg0 = NULL;
	/* transient soap skipped */
}

void tns__isClientUpdated::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__isClientUpdated::arg0);
	/* transient soap skipped */
}

int tns__isClientUpdated::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__isClientUpdated(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__isClientUpdated(struct soap *soap, const char *tag, int id, const tns__isClientUpdated *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__isClientUpdated), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->tns__isClientUpdated::arg0), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__isClientUpdated::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__isClientUpdated(soap, tag, this, type);
}

SOAP_FMAC3 tns__isClientUpdated * SOAP_FMAC4 soap_in_tns__isClientUpdated(struct soap *soap, const char *tag, tns__isClientUpdated *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__isClientUpdated *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__isClientUpdated, sizeof(tns__isClientUpdated), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__isClientUpdated)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__isClientUpdated *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->tns__isClientUpdated::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__isClientUpdated *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__isClientUpdated, 0, sizeof(tns__isClientUpdated), 0, soap_copy_tns__isClientUpdated);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__isClientUpdated::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__isClientUpdated);
	if (this->soap_out(soap, tag?tag:"tns:isClientUpdated", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__isClientUpdated::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__isClientUpdated(soap, this, tag, type);
}

SOAP_FMAC3 tns__isClientUpdated * SOAP_FMAC4 soap_get_tns__isClientUpdated(struct soap *soap, tns__isClientUpdated *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__isClientUpdated(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__isClientUpdated * SOAP_FMAC2 soap_instantiate_tns__isClientUpdated(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__isClientUpdated(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__isClientUpdated, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__isClientUpdated);
		if (size)
			*size = sizeof(tns__isClientUpdated);
		((tns__isClientUpdated*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__isClientUpdated[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__isClientUpdated);
		for (int i = 0; i < n; i++)
			((tns__isClientUpdated*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__isClientUpdated*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__isClientUpdated(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__isClientUpdated %p -> %p\n", q, p));
	*(tns__isClientUpdated*)p = *(tns__isClientUpdated*)q;
}

void tns__chatResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__chatResponse::return_ = NULL;
	/* transient soap skipped */
}

void tns__chatResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__chatResponse::return_);
	/* transient soap skipped */
}

int tns__chatResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__chatResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__chatResponse(struct soap *soap, const char *tag, int id, const tns__chatResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__chatResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &(a->tns__chatResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__chatResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__chatResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__chatResponse * SOAP_FMAC4 soap_in_tns__chatResponse(struct soap *soap, const char *tag, tns__chatResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__chatResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__chatResponse, sizeof(tns__chatResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__chatResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__chatResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "return", &(a->tns__chatResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__chatResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__chatResponse, 0, sizeof(tns__chatResponse), 0, soap_copy_tns__chatResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__chatResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__chatResponse);
	if (this->soap_out(soap, tag?tag:"tns:chatResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__chatResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__chatResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__chatResponse * SOAP_FMAC4 soap_get_tns__chatResponse(struct soap *soap, tns__chatResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__chatResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__chatResponse * SOAP_FMAC2 soap_instantiate_tns__chatResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__chatResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__chatResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__chatResponse);
		if (size)
			*size = sizeof(tns__chatResponse);
		((tns__chatResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__chatResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__chatResponse);
		for (int i = 0; i < n; i++)
			((tns__chatResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__chatResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__chatResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__chatResponse %p -> %p\n", q, p));
	*(tns__chatResponse*)p = *(tns__chatResponse*)q;
}

void tns__chat::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__chat::arg0 = NULL;
	/* transient soap skipped */
}

void tns__chat::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__chat::arg0);
	/* transient soap skipped */
}

int tns__chat::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__chat(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__chat(struct soap *soap, const char *tag, int id, const tns__chat *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__chat), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->tns__chat::arg0), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__chat::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__chat(soap, tag, this, type);
}

SOAP_FMAC3 tns__chat * SOAP_FMAC4 soap_in_tns__chat(struct soap *soap, const char *tag, tns__chat *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__chat *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__chat, sizeof(tns__chat), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__chat)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__chat *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->tns__chat::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__chat *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__chat, 0, sizeof(tns__chat), 0, soap_copy_tns__chat);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__chat::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__chat);
	if (this->soap_out(soap, tag?tag:"tns:chat", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__chat::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__chat(soap, this, tag, type);
}

SOAP_FMAC3 tns__chat * SOAP_FMAC4 soap_get_tns__chat(struct soap *soap, tns__chat *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__chat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__chat * SOAP_FMAC2 soap_instantiate_tns__chat(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__chat(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__chat, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__chat);
		if (size)
			*size = sizeof(tns__chat);
		((tns__chat*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__chat[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__chat);
		for (int i = 0; i < n; i++)
			((tns__chat*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__chat*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__chat(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__chat %p -> %p\n", q, p));
	*(tns__chat*)p = *(tns__chat*)q;
}

void tns__blessMediaAnnotationWithIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__blessMediaAnnotationWithIdResponse::return_);
	/* transient soap skipped */
}

void tns__blessMediaAnnotationWithIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__blessMediaAnnotationWithIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__blessMediaAnnotationWithIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__blessMediaAnnotationWithIdResponse(struct soap *soap, const char *tag, int id, const tns__blessMediaAnnotationWithIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithIdResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__blessMediaAnnotationWithIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__blessMediaAnnotationWithIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__blessMediaAnnotationWithIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__blessMediaAnnotationWithIdResponse * SOAP_FMAC4 soap_in_tns__blessMediaAnnotationWithIdResponse(struct soap *soap, const char *tag, tns__blessMediaAnnotationWithIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__blessMediaAnnotationWithIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithIdResponse, sizeof(tns__blessMediaAnnotationWithIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__blessMediaAnnotationWithIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__blessMediaAnnotationWithIdResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__blessMediaAnnotationWithIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithIdResponse, 0, sizeof(tns__blessMediaAnnotationWithIdResponse), 0, soap_copy_tns__blessMediaAnnotationWithIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__blessMediaAnnotationWithIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:blessMediaAnnotationWithIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__blessMediaAnnotationWithIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__blessMediaAnnotationWithIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__blessMediaAnnotationWithIdResponse * SOAP_FMAC4 soap_get_tns__blessMediaAnnotationWithIdResponse(struct soap *soap, tns__blessMediaAnnotationWithIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__blessMediaAnnotationWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__blessMediaAnnotationWithIdResponse * SOAP_FMAC2 soap_instantiate_tns__blessMediaAnnotationWithIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__blessMediaAnnotationWithIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithIdResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__blessMediaAnnotationWithIdResponse);
		if (size)
			*size = sizeof(tns__blessMediaAnnotationWithIdResponse);
		((tns__blessMediaAnnotationWithIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__blessMediaAnnotationWithIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__blessMediaAnnotationWithIdResponse);
		for (int i = 0; i < n; i++)
			((tns__blessMediaAnnotationWithIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__blessMediaAnnotationWithIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__blessMediaAnnotationWithIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__blessMediaAnnotationWithIdResponse %p -> %p\n", q, p));
	*(tns__blessMediaAnnotationWithIdResponse*)p = *(tns__blessMediaAnnotationWithIdResponse*)q;
}

void tns__blessMediaAnnotationWithId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__blessMediaAnnotationWithId::arg0);
	this->tns__blessMediaAnnotationWithId::userName = NULL;
	this->tns__blessMediaAnnotationWithId::password = NULL;
	/* transient soap skipped */
}

void tns__blessMediaAnnotationWithId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__blessMediaAnnotationWithId::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__blessMediaAnnotationWithId::password);
	/* transient soap skipped */
}

int tns__blessMediaAnnotationWithId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__blessMediaAnnotationWithId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__blessMediaAnnotationWithId(struct soap *soap, const char *tag, int id, const tns__blessMediaAnnotationWithId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "arg0", -1, &(a->tns__blessMediaAnnotationWithId::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__blessMediaAnnotationWithId::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__blessMediaAnnotationWithId::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__blessMediaAnnotationWithId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__blessMediaAnnotationWithId(soap, tag, this, type);
}

SOAP_FMAC3 tns__blessMediaAnnotationWithId * SOAP_FMAC4 soap_in_tns__blessMediaAnnotationWithId(struct soap *soap, const char *tag, tns__blessMediaAnnotationWithId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__blessMediaAnnotationWithId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithId, sizeof(tns__blessMediaAnnotationWithId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__blessMediaAnnotationWithId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "arg0", &(a->tns__blessMediaAnnotationWithId::arg0), "xsd:long"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__blessMediaAnnotationWithId::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__blessMediaAnnotationWithId::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__blessMediaAnnotationWithId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithId, 0, sizeof(tns__blessMediaAnnotationWithId), 0, soap_copy_tns__blessMediaAnnotationWithId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg01 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__blessMediaAnnotationWithId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithId);
	if (this->soap_out(soap, tag?tag:"tns:blessMediaAnnotationWithId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__blessMediaAnnotationWithId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__blessMediaAnnotationWithId(soap, this, tag, type);
}

SOAP_FMAC3 tns__blessMediaAnnotationWithId * SOAP_FMAC4 soap_get_tns__blessMediaAnnotationWithId(struct soap *soap, tns__blessMediaAnnotationWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__blessMediaAnnotationWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__blessMediaAnnotationWithId * SOAP_FMAC2 soap_instantiate_tns__blessMediaAnnotationWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__blessMediaAnnotationWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__blessMediaAnnotationWithId);
		if (size)
			*size = sizeof(tns__blessMediaAnnotationWithId);
		((tns__blessMediaAnnotationWithId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__blessMediaAnnotationWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__blessMediaAnnotationWithId);
		for (int i = 0; i < n; i++)
			((tns__blessMediaAnnotationWithId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__blessMediaAnnotationWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__blessMediaAnnotationWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__blessMediaAnnotationWithId %p -> %p\n", q, p));
	*(tns__blessMediaAnnotationWithId*)p = *(tns__blessMediaAnnotationWithId*)q;
}

void tns__blessGameAnnotationWithIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__blessGameAnnotationWithIdResponse::return_);
	/* transient soap skipped */
}

void tns__blessGameAnnotationWithIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__blessGameAnnotationWithIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__blessGameAnnotationWithIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__blessGameAnnotationWithIdResponse(struct soap *soap, const char *tag, int id, const tns__blessGameAnnotationWithIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__blessGameAnnotationWithIdResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__blessGameAnnotationWithIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__blessGameAnnotationWithIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__blessGameAnnotationWithIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__blessGameAnnotationWithIdResponse * SOAP_FMAC4 soap_in_tns__blessGameAnnotationWithIdResponse(struct soap *soap, const char *tag, tns__blessGameAnnotationWithIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__blessGameAnnotationWithIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__blessGameAnnotationWithIdResponse, sizeof(tns__blessGameAnnotationWithIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__blessGameAnnotationWithIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__blessGameAnnotationWithIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__blessGameAnnotationWithIdResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__blessGameAnnotationWithIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__blessGameAnnotationWithIdResponse, 0, sizeof(tns__blessGameAnnotationWithIdResponse), 0, soap_copy_tns__blessGameAnnotationWithIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__blessGameAnnotationWithIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__blessGameAnnotationWithIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:blessGameAnnotationWithIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__blessGameAnnotationWithIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__blessGameAnnotationWithIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__blessGameAnnotationWithIdResponse * SOAP_FMAC4 soap_get_tns__blessGameAnnotationWithIdResponse(struct soap *soap, tns__blessGameAnnotationWithIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__blessGameAnnotationWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__blessGameAnnotationWithIdResponse * SOAP_FMAC2 soap_instantiate_tns__blessGameAnnotationWithIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__blessGameAnnotationWithIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__blessGameAnnotationWithIdResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__blessGameAnnotationWithIdResponse);
		if (size)
			*size = sizeof(tns__blessGameAnnotationWithIdResponse);
		((tns__blessGameAnnotationWithIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__blessGameAnnotationWithIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__blessGameAnnotationWithIdResponse);
		for (int i = 0; i < n; i++)
			((tns__blessGameAnnotationWithIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__blessGameAnnotationWithIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__blessGameAnnotationWithIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__blessGameAnnotationWithIdResponse %p -> %p\n", q, p));
	*(tns__blessGameAnnotationWithIdResponse*)p = *(tns__blessGameAnnotationWithIdResponse*)q;
}

void tns__blessGameAnnotationWithId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__blessGameAnnotationWithId::arg0);
	this->tns__blessGameAnnotationWithId::userName = NULL;
	this->tns__blessGameAnnotationWithId::password = NULL;
	/* transient soap skipped */
}

void tns__blessGameAnnotationWithId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__blessGameAnnotationWithId::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__blessGameAnnotationWithId::password);
	/* transient soap skipped */
}

int tns__blessGameAnnotationWithId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__blessGameAnnotationWithId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__blessGameAnnotationWithId(struct soap *soap, const char *tag, int id, const tns__blessGameAnnotationWithId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__blessGameAnnotationWithId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "arg0", -1, &(a->tns__blessGameAnnotationWithId::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__blessGameAnnotationWithId::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__blessGameAnnotationWithId::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__blessGameAnnotationWithId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__blessGameAnnotationWithId(soap, tag, this, type);
}

SOAP_FMAC3 tns__blessGameAnnotationWithId * SOAP_FMAC4 soap_in_tns__blessGameAnnotationWithId(struct soap *soap, const char *tag, tns__blessGameAnnotationWithId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__blessGameAnnotationWithId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__blessGameAnnotationWithId, sizeof(tns__blessGameAnnotationWithId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__blessGameAnnotationWithId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__blessGameAnnotationWithId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "arg0", &(a->tns__blessGameAnnotationWithId::arg0), "xsd:long"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__blessGameAnnotationWithId::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__blessGameAnnotationWithId::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__blessGameAnnotationWithId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__blessGameAnnotationWithId, 0, sizeof(tns__blessGameAnnotationWithId), 0, soap_copy_tns__blessGameAnnotationWithId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg01 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__blessGameAnnotationWithId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__blessGameAnnotationWithId);
	if (this->soap_out(soap, tag?tag:"tns:blessGameAnnotationWithId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__blessGameAnnotationWithId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__blessGameAnnotationWithId(soap, this, tag, type);
}

SOAP_FMAC3 tns__blessGameAnnotationWithId * SOAP_FMAC4 soap_get_tns__blessGameAnnotationWithId(struct soap *soap, tns__blessGameAnnotationWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__blessGameAnnotationWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__blessGameAnnotationWithId * SOAP_FMAC2 soap_instantiate_tns__blessGameAnnotationWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__blessGameAnnotationWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__blessGameAnnotationWithId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__blessGameAnnotationWithId);
		if (size)
			*size = sizeof(tns__blessGameAnnotationWithId);
		((tns__blessGameAnnotationWithId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__blessGameAnnotationWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__blessGameAnnotationWithId);
		for (int i = 0; i < n; i++)
			((tns__blessGameAnnotationWithId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__blessGameAnnotationWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__blessGameAnnotationWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__blessGameAnnotationWithId %p -> %p\n", q, p));
	*(tns__blessGameAnnotationWithId*)p = *(tns__blessGameAnnotationWithId*)q;
}

void tns__user::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->tns__user::blessedCount);
	soap_default_int(soap, &this->tns__user::blockedCount);
	soap_default_LONG64(soap, &this->tns__user::createTime);
	soap_default_int(soap, &this->tns__user::cursedCount);
	this->tns__user::email = NULL;
	soap_default_LONG64(soap, &this->tns__user::flags);
	soap_default_LONG64(soap, &this->tns__user::groupId);
	soap_default_LONG64(soap, &this->tns__user::id);
	soap_default_int(soap, &this->tns__user::language);
	soap_default_LONG64(soap, &this->tns__user::loginTime);
	this->tns__user::name = NULL;
	this->tns__user::nickname = NULL;
	this->tns__user::password = NULL;
	soap_default_int(soap, &this->tns__user::status);
	/* transient soap skipped */
}

void tns__user::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__user::email);
	soap_serialize_PointerTostd__string(soap, &this->tns__user::name);
	soap_serialize_PointerTostd__string(soap, &this->tns__user::nickname);
	soap_serialize_PointerTostd__string(soap, &this->tns__user::password);
	/* transient soap skipped */
}

int tns__user::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__user(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__user(struct soap *soap, const char *tag, int id, const tns__user *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__user), type))
		return soap->error;
	if (soap_out_int(soap, "blessedCount", -1, &(a->tns__user::blessedCount), ""))
		return soap->error;
	if (soap_out_int(soap, "blockedCount", -1, &(a->tns__user::blockedCount), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "createTime", -1, &(a->tns__user::createTime), ""))
		return soap->error;
	if (soap_out_int(soap, "cursedCount", -1, &(a->tns__user::cursedCount), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "email", -1, &(a->tns__user::email), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "flags", -1, &(a->tns__user::flags), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "groupId", -1, &(a->tns__user::groupId), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "id", -1, &(a->tns__user::id), ""))
		return soap->error;
	if (soap_out_int(soap, "language", -1, &(a->tns__user::language), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "loginTime", -1, &(a->tns__user::loginTime), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "name", -1, &(a->tns__user::name), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "nickname", -1, &(a->tns__user::nickname), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__user::password), ""))
		return soap->error;
	if (soap_out_int(soap, "status", -1, &(a->tns__user::status), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__user::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__user(soap, tag, this, type);
}

SOAP_FMAC3 tns__user * SOAP_FMAC4 soap_in_tns__user(struct soap *soap, const char *tag, tns__user *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__user *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__user, sizeof(tns__user), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__user)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__user *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_blessedCount1 = 1;
	size_t soap_flag_blockedCount1 = 1;
	size_t soap_flag_createTime1 = 1;
	size_t soap_flag_cursedCount1 = 1;
	size_t soap_flag_email1 = 1;
	size_t soap_flag_flags1 = 1;
	size_t soap_flag_groupId1 = 1;
	size_t soap_flag_id1 = 1;
	size_t soap_flag_language1 = 1;
	size_t soap_flag_loginTime1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_nickname1 = 1;
	size_t soap_flag_password1 = 1;
	size_t soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_blessedCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "blessedCount", &(a->tns__user::blessedCount), "xsd:int"))
				{	soap_flag_blessedCount1--;
					continue;
				}
			if (soap_flag_blockedCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "blockedCount", &(a->tns__user::blockedCount), "xsd:int"))
				{	soap_flag_blockedCount1--;
					continue;
				}
			if (soap_flag_createTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "createTime", &(a->tns__user::createTime), "xsd:long"))
				{	soap_flag_createTime1--;
					continue;
				}
			if (soap_flag_cursedCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "cursedCount", &(a->tns__user::cursedCount), "xsd:int"))
				{	soap_flag_cursedCount1--;
					continue;
				}
			if (soap_flag_email1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "email", &(a->tns__user::email), "xsd:string"))
				{	soap_flag_email1--;
					continue;
				}
			if (soap_flag_flags1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "flags", &(a->tns__user::flags), "xsd:long"))
				{	soap_flag_flags1--;
					continue;
				}
			if (soap_flag_groupId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "groupId", &(a->tns__user::groupId), "xsd:long"))
				{	soap_flag_groupId1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "id", &(a->tns__user::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_language1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "language", &(a->tns__user::language), "xsd:int"))
				{	soap_flag_language1--;
					continue;
				}
			if (soap_flag_loginTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "loginTime", &(a->tns__user::loginTime), "xsd:long"))
				{	soap_flag_loginTime1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "name", &(a->tns__user::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_nickname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "nickname", &(a->tns__user::nickname), "xsd:string"))
				{	soap_flag_nickname1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__user::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "status", &(a->tns__user::status), "xsd:int"))
				{	soap_flag_status1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__user *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__user, 0, sizeof(tns__user), 0, soap_copy_tns__user);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_blessedCount1 > 0 || soap_flag_blockedCount1 > 0 || soap_flag_createTime1 > 0 || soap_flag_cursedCount1 > 0 || soap_flag_flags1 > 0 || soap_flag_groupId1 > 0 || soap_flag_id1 > 0 || soap_flag_language1 > 0 || soap_flag_loginTime1 > 0 || soap_flag_status1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__user::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__user);
	if (this->soap_out(soap, tag?tag:"tns:user", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__user::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__user(soap, this, tag, type);
}

SOAP_FMAC3 tns__user * SOAP_FMAC4 soap_get_tns__user(struct soap *soap, tns__user *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__user(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__user * SOAP_FMAC2 soap_instantiate_tns__user(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__user(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__user, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__user);
		if (size)
			*size = sizeof(tns__user);
		((tns__user*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__user[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__user);
		for (int i = 0; i < n; i++)
			((tns__user*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__user*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__user(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__user %p -> %p\n", q, p));
	*(tns__user*)p = *(tns__user*)q;
}

void tns__mediaAlias::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->tns__mediaAlias::blessedCount);
	soap_default_int(soap, &this->tns__mediaAlias::blockedCount);
	soap_default_int(soap, &this->tns__mediaAlias::cursedCount);
	this->tns__mediaAlias::digest = NULL;
	soap_default_LONG64(soap, &this->tns__mediaAlias::flags);
	soap_default_LONG64(soap, &this->tns__mediaAlias::id);
	soap_default_int(soap, &this->tns__mediaAlias::language);
	soap_default_LONG64(soap, &this->tns__mediaAlias::userId);
	soap_default_int(soap, &this->tns__mediaAlias::status);
	this->tns__mediaAlias::text = NULL;
	soap_default_LONG64(soap, &this->tns__mediaAlias::tokenId);
	soap_default_int(soap, &this->tns__mediaAlias::type);
	soap_default_LONG64(soap, &this->tns__mediaAlias::updateTime);
	/* transient soap skipped */
}

void tns__mediaAlias::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__mediaAlias::digest);
	soap_serialize_PointerTostd__string(soap, &this->tns__mediaAlias::text);
	/* transient soap skipped */
}

int tns__mediaAlias::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__mediaAlias(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__mediaAlias(struct soap *soap, const char *tag, int id, const tns__mediaAlias *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__mediaAlias), type))
		return soap->error;
	if (soap_out_int(soap, "blessedCount", -1, &(a->tns__mediaAlias::blessedCount), ""))
		return soap->error;
	if (soap_out_int(soap, "blockedCount", -1, &(a->tns__mediaAlias::blockedCount), ""))
		return soap->error;
	if (soap_out_int(soap, "cursedCount", -1, &(a->tns__mediaAlias::cursedCount), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "digest", -1, &(a->tns__mediaAlias::digest), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "flags", -1, &(a->tns__mediaAlias::flags), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "id", -1, &(a->tns__mediaAlias::id), ""))
		return soap->error;
	if (soap_out_int(soap, "language", -1, &(a->tns__mediaAlias::language), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "userId", -1, &(a->tns__mediaAlias::userId), ""))
		return soap->error;
	if (soap_out_int(soap, "status", -1, &(a->tns__mediaAlias::status), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "text", -1, &(a->tns__mediaAlias::text), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "tokenId", -1, &(a->tns__mediaAlias::tokenId), ""))
		return soap->error;
	if (soap_out_int(soap, "type", -1, &(a->tns__mediaAlias::type), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "updateTime", -1, &(a->tns__mediaAlias::updateTime), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__mediaAlias::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__mediaAlias(soap, tag, this, type);
}

SOAP_FMAC3 tns__mediaAlias * SOAP_FMAC4 soap_in_tns__mediaAlias(struct soap *soap, const char *tag, tns__mediaAlias *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__mediaAlias *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__mediaAlias, sizeof(tns__mediaAlias), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__mediaAlias)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__mediaAlias *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_blessedCount1 = 1;
	size_t soap_flag_blockedCount1 = 1;
	size_t soap_flag_cursedCount1 = 1;
	size_t soap_flag_digest1 = 1;
	size_t soap_flag_flags1 = 1;
	size_t soap_flag_id1 = 1;
	size_t soap_flag_language1 = 1;
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_text1 = 1;
	size_t soap_flag_tokenId1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_updateTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_blessedCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "blessedCount", &(a->tns__mediaAlias::blessedCount), "xsd:int"))
				{	soap_flag_blessedCount1--;
					continue;
				}
			if (soap_flag_blockedCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "blockedCount", &(a->tns__mediaAlias::blockedCount), "xsd:int"))
				{	soap_flag_blockedCount1--;
					continue;
				}
			if (soap_flag_cursedCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "cursedCount", &(a->tns__mediaAlias::cursedCount), "xsd:int"))
				{	soap_flag_cursedCount1--;
					continue;
				}
			if (soap_flag_digest1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "digest", &(a->tns__mediaAlias::digest), "xsd:string"))
				{	soap_flag_digest1--;
					continue;
				}
			if (soap_flag_flags1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "flags", &(a->tns__mediaAlias::flags), "xsd:long"))
				{	soap_flag_flags1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "id", &(a->tns__mediaAlias::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_language1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "language", &(a->tns__mediaAlias::language), "xsd:int"))
				{	soap_flag_language1--;
					continue;
				}
			if (soap_flag_userId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "userId", &(a->tns__mediaAlias::userId), "xsd:long"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "status", &(a->tns__mediaAlias::status), "xsd:int"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_text1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "text", &(a->tns__mediaAlias::text), "xsd:string"))
				{	soap_flag_text1--;
					continue;
				}
			if (soap_flag_tokenId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "tokenId", &(a->tns__mediaAlias::tokenId), "xsd:long"))
				{	soap_flag_tokenId1--;
					continue;
				}
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "type", &(a->tns__mediaAlias::type), "xsd:int"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_updateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "updateTime", &(a->tns__mediaAlias::updateTime), "xsd:long"))
				{	soap_flag_updateTime1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__mediaAlias *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__mediaAlias, 0, sizeof(tns__mediaAlias), 0, soap_copy_tns__mediaAlias);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_blessedCount1 > 0 || soap_flag_blockedCount1 > 0 || soap_flag_cursedCount1 > 0 || soap_flag_flags1 > 0 || soap_flag_id1 > 0 || soap_flag_language1 > 0 || soap_flag_userId1 > 0 || soap_flag_status1 > 0 || soap_flag_tokenId1 > 0 || soap_flag_type1 > 0 || soap_flag_updateTime1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__mediaAlias::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__mediaAlias);
	if (this->soap_out(soap, tag?tag:"tns:mediaAlias", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__mediaAlias::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__mediaAlias(soap, this, tag, type);
}

SOAP_FMAC3 tns__mediaAlias * SOAP_FMAC4 soap_get_tns__mediaAlias(struct soap *soap, tns__mediaAlias *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__mediaAlias(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__mediaAlias * SOAP_FMAC2 soap_instantiate_tns__mediaAlias(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__mediaAlias(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__mediaAlias, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__mediaAlias);
		if (size)
			*size = sizeof(tns__mediaAlias);
		((tns__mediaAlias*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__mediaAlias[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__mediaAlias);
		for (int i = 0; i < n; i++)
			((tns__mediaAlias*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__mediaAlias*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__mediaAlias(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__mediaAlias %p -> %p\n", q, p));
	*(tns__mediaAlias*)p = *(tns__mediaAlias*)q;
}

void tns__mediaToken::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->tns__mediaToken::blessedCount);
	soap_default_int(soap, &this->tns__mediaToken::blockedCount);
	soap_default_LONG64(soap, &this->tns__mediaToken::createTime);
	soap_default_int(soap, &this->tns__mediaToken::cursedCount);
	this->tns__mediaToken::digest = NULL;
	soap_default_LONG64(soap, &this->tns__mediaToken::flags);
	soap_default_LONG64(soap, &this->tns__mediaToken::id);
	soap_default_LONG64(soap, &this->tns__mediaToken::userId);
	soap_default_int(soap, &this->tns__mediaToken::status);
	soap_default_int(soap, &this->tns__mediaToken::visitedCount);
	/* transient soap skipped */
}

void tns__mediaToken::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__mediaToken::digest);
	/* transient soap skipped */
}

int tns__mediaToken::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__mediaToken(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__mediaToken(struct soap *soap, const char *tag, int id, const tns__mediaToken *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__mediaToken), type))
		return soap->error;
	if (soap_out_int(soap, "blessedCount", -1, &(a->tns__mediaToken::blessedCount), ""))
		return soap->error;
	if (soap_out_int(soap, "blockedCount", -1, &(a->tns__mediaToken::blockedCount), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "createTime", -1, &(a->tns__mediaToken::createTime), ""))
		return soap->error;
	if (soap_out_int(soap, "cursedCount", -1, &(a->tns__mediaToken::cursedCount), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "digest", -1, &(a->tns__mediaToken::digest), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "flags", -1, &(a->tns__mediaToken::flags), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "id", -1, &(a->tns__mediaToken::id), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "userId", -1, &(a->tns__mediaToken::userId), ""))
		return soap->error;
	if (soap_out_int(soap, "status", -1, &(a->tns__mediaToken::status), ""))
		return soap->error;
	if (soap_out_int(soap, "visitedCount", -1, &(a->tns__mediaToken::visitedCount), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__mediaToken::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__mediaToken(soap, tag, this, type);
}

SOAP_FMAC3 tns__mediaToken * SOAP_FMAC4 soap_in_tns__mediaToken(struct soap *soap, const char *tag, tns__mediaToken *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__mediaToken *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__mediaToken, sizeof(tns__mediaToken), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__mediaToken)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__mediaToken *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_blessedCount1 = 1;
	size_t soap_flag_blockedCount1 = 1;
	size_t soap_flag_createTime1 = 1;
	size_t soap_flag_cursedCount1 = 1;
	size_t soap_flag_digest1 = 1;
	size_t soap_flag_flags1 = 1;
	size_t soap_flag_id1 = 1;
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_visitedCount1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_blessedCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "blessedCount", &(a->tns__mediaToken::blessedCount), "xsd:int"))
				{	soap_flag_blessedCount1--;
					continue;
				}
			if (soap_flag_blockedCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "blockedCount", &(a->tns__mediaToken::blockedCount), "xsd:int"))
				{	soap_flag_blockedCount1--;
					continue;
				}
			if (soap_flag_createTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "createTime", &(a->tns__mediaToken::createTime), "xsd:long"))
				{	soap_flag_createTime1--;
					continue;
				}
			if (soap_flag_cursedCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "cursedCount", &(a->tns__mediaToken::cursedCount), "xsd:int"))
				{	soap_flag_cursedCount1--;
					continue;
				}
			if (soap_flag_digest1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "digest", &(a->tns__mediaToken::digest), "xsd:string"))
				{	soap_flag_digest1--;
					continue;
				}
			if (soap_flag_flags1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "flags", &(a->tns__mediaToken::flags), "xsd:long"))
				{	soap_flag_flags1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "id", &(a->tns__mediaToken::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_userId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "userId", &(a->tns__mediaToken::userId), "xsd:long"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "status", &(a->tns__mediaToken::status), "xsd:int"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_visitedCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "visitedCount", &(a->tns__mediaToken::visitedCount), "xsd:int"))
				{	soap_flag_visitedCount1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__mediaToken *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__mediaToken, 0, sizeof(tns__mediaToken), 0, soap_copy_tns__mediaToken);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_blessedCount1 > 0 || soap_flag_blockedCount1 > 0 || soap_flag_createTime1 > 0 || soap_flag_cursedCount1 > 0 || soap_flag_flags1 > 0 || soap_flag_id1 > 0 || soap_flag_userId1 > 0 || soap_flag_status1 > 0 || soap_flag_visitedCount1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__mediaToken::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__mediaToken);
	if (this->soap_out(soap, tag?tag:"tns:mediaToken", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__mediaToken::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__mediaToken(soap, this, tag, type);
}

SOAP_FMAC3 tns__mediaToken * SOAP_FMAC4 soap_get_tns__mediaToken(struct soap *soap, tns__mediaToken *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__mediaToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__mediaToken * SOAP_FMAC2 soap_instantiate_tns__mediaToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__mediaToken(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__mediaToken, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__mediaToken);
		if (size)
			*size = sizeof(tns__mediaToken);
		((tns__mediaToken*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__mediaToken[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__mediaToken);
		for (int i = 0; i < n; i++)
			((tns__mediaToken*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__mediaToken*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__mediaToken(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__mediaToken %p -> %p\n", q, p));
	*(tns__mediaToken*)p = *(tns__mediaToken*)q;
}

void tns__mediaAnnotation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->tns__mediaAnnotation::blessedCount);
	soap_default_int(soap, &this->tns__mediaAnnotation::blockedCount);
	soap_default_LONG64(soap, &this->tns__mediaAnnotation::createTime);
	soap_default_int(soap, &this->tns__mediaAnnotation::cursedCount);
	soap_default_LONG64(soap, &this->tns__mediaAnnotation::flags);
	soap_default_LONG64(soap, &this->tns__mediaAnnotation::id);
	soap_default_int(soap, &this->tns__mediaAnnotation::language);
	soap_default_LONG64(soap, &this->tns__mediaAnnotation::pos);
	soap_default_int(soap, &this->tns__mediaAnnotation::posType);
	soap_default_LONG64(soap, &this->tns__mediaAnnotation::userId);
	this->tns__mediaAnnotation::userAlias = NULL;
	soap_default_int(soap, &this->tns__mediaAnnotation::status);
	this->tns__mediaAnnotation::text = NULL;
	soap_default_LONG64(soap, &this->tns__mediaAnnotation::tokenId);
	soap_default_LONG64(soap, &this->tns__mediaAnnotation::updateTime);
	/* transient soap skipped */
}

void tns__mediaAnnotation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__mediaAnnotation::userAlias);
	soap_serialize_PointerTostd__string(soap, &this->tns__mediaAnnotation::text);
	/* transient soap skipped */
}

int tns__mediaAnnotation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__mediaAnnotation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__mediaAnnotation(struct soap *soap, const char *tag, int id, const tns__mediaAnnotation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__mediaAnnotation), type))
		return soap->error;
	if (soap_out_int(soap, "blessedCount", -1, &(a->tns__mediaAnnotation::blessedCount), ""))
		return soap->error;
	if (soap_out_int(soap, "blockedCount", -1, &(a->tns__mediaAnnotation::blockedCount), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "createTime", -1, &(a->tns__mediaAnnotation::createTime), ""))
		return soap->error;
	if (soap_out_int(soap, "cursedCount", -1, &(a->tns__mediaAnnotation::cursedCount), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "flags", -1, &(a->tns__mediaAnnotation::flags), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "id", -1, &(a->tns__mediaAnnotation::id), ""))
		return soap->error;
	if (soap_out_int(soap, "language", -1, &(a->tns__mediaAnnotation::language), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "pos", -1, &(a->tns__mediaAnnotation::pos), ""))
		return soap->error;
	if (soap_out_int(soap, "posType", -1, &(a->tns__mediaAnnotation::posType), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "userId", -1, &(a->tns__mediaAnnotation::userId), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userAlias", -1, &(a->tns__mediaAnnotation::userAlias), ""))
		return soap->error;
	if (soap_out_int(soap, "status", -1, &(a->tns__mediaAnnotation::status), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "text", -1, &(a->tns__mediaAnnotation::text), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "tokenId", -1, &(a->tns__mediaAnnotation::tokenId), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "updateTime", -1, &(a->tns__mediaAnnotation::updateTime), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__mediaAnnotation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__mediaAnnotation(soap, tag, this, type);
}

SOAP_FMAC3 tns__mediaAnnotation * SOAP_FMAC4 soap_in_tns__mediaAnnotation(struct soap *soap, const char *tag, tns__mediaAnnotation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__mediaAnnotation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__mediaAnnotation, sizeof(tns__mediaAnnotation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__mediaAnnotation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__mediaAnnotation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_blessedCount1 = 1;
	size_t soap_flag_blockedCount1 = 1;
	size_t soap_flag_createTime1 = 1;
	size_t soap_flag_cursedCount1 = 1;
	size_t soap_flag_flags1 = 1;
	size_t soap_flag_id1 = 1;
	size_t soap_flag_language1 = 1;
	size_t soap_flag_pos1 = 1;
	size_t soap_flag_posType1 = 1;
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_userAlias1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_text1 = 1;
	size_t soap_flag_tokenId1 = 1;
	size_t soap_flag_updateTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_blessedCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "blessedCount", &(a->tns__mediaAnnotation::blessedCount), "xsd:int"))
				{	soap_flag_blessedCount1--;
					continue;
				}
			if (soap_flag_blockedCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "blockedCount", &(a->tns__mediaAnnotation::blockedCount), "xsd:int"))
				{	soap_flag_blockedCount1--;
					continue;
				}
			if (soap_flag_createTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "createTime", &(a->tns__mediaAnnotation::createTime), "xsd:long"))
				{	soap_flag_createTime1--;
					continue;
				}
			if (soap_flag_cursedCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "cursedCount", &(a->tns__mediaAnnotation::cursedCount), "xsd:int"))
				{	soap_flag_cursedCount1--;
					continue;
				}
			if (soap_flag_flags1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "flags", &(a->tns__mediaAnnotation::flags), "xsd:long"))
				{	soap_flag_flags1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "id", &(a->tns__mediaAnnotation::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_language1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "language", &(a->tns__mediaAnnotation::language), "xsd:int"))
				{	soap_flag_language1--;
					continue;
				}
			if (soap_flag_pos1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "pos", &(a->tns__mediaAnnotation::pos), "xsd:long"))
				{	soap_flag_pos1--;
					continue;
				}
			if (soap_flag_posType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "posType", &(a->tns__mediaAnnotation::posType), "xsd:int"))
				{	soap_flag_posType1--;
					continue;
				}
			if (soap_flag_userId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "userId", &(a->tns__mediaAnnotation::userId), "xsd:long"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_userAlias1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userAlias", &(a->tns__mediaAnnotation::userAlias), "xsd:string"))
				{	soap_flag_userAlias1--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "status", &(a->tns__mediaAnnotation::status), "xsd:int"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_text1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "text", &(a->tns__mediaAnnotation::text), "xsd:string"))
				{	soap_flag_text1--;
					continue;
				}
			if (soap_flag_tokenId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "tokenId", &(a->tns__mediaAnnotation::tokenId), "xsd:long"))
				{	soap_flag_tokenId1--;
					continue;
				}
			if (soap_flag_updateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "updateTime", &(a->tns__mediaAnnotation::updateTime), "xsd:long"))
				{	soap_flag_updateTime1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__mediaAnnotation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__mediaAnnotation, 0, sizeof(tns__mediaAnnotation), 0, soap_copy_tns__mediaAnnotation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_blessedCount1 > 0 || soap_flag_blockedCount1 > 0 || soap_flag_createTime1 > 0 || soap_flag_cursedCount1 > 0 || soap_flag_flags1 > 0 || soap_flag_id1 > 0 || soap_flag_language1 > 0 || soap_flag_pos1 > 0 || soap_flag_posType1 > 0 || soap_flag_userId1 > 0 || soap_flag_status1 > 0 || soap_flag_tokenId1 > 0 || soap_flag_updateTime1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__mediaAnnotation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__mediaAnnotation);
	if (this->soap_out(soap, tag?tag:"tns:mediaAnnotation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__mediaAnnotation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__mediaAnnotation(soap, this, tag, type);
}

SOAP_FMAC3 tns__mediaAnnotation * SOAP_FMAC4 soap_get_tns__mediaAnnotation(struct soap *soap, tns__mediaAnnotation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__mediaAnnotation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__mediaAnnotation * SOAP_FMAC2 soap_instantiate_tns__mediaAnnotation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__mediaAnnotation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__mediaAnnotation, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__mediaAnnotation);
		if (size)
			*size = sizeof(tns__mediaAnnotation);
		((tns__mediaAnnotation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__mediaAnnotation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__mediaAnnotation);
		for (int i = 0; i < n; i++)
			((tns__mediaAnnotation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__mediaAnnotation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__mediaAnnotation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__mediaAnnotation %p -> %p\n", q, p));
	*(tns__mediaAnnotation*)p = *(tns__mediaAnnotation*)q;
}

void tns__gameAlias::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->tns__gameAlias::blessedCount);
	soap_default_int(soap, &this->tns__gameAlias::blockedCount);
	soap_default_int(soap, &this->tns__gameAlias::cursedCount);
	this->tns__gameAlias::digest = NULL;
	soap_default_LONG64(soap, &this->tns__gameAlias::flags);
	soap_default_LONG64(soap, &this->tns__gameAlias::id);
	soap_default_int(soap, &this->tns__gameAlias::language);
	soap_default_LONG64(soap, &this->tns__gameAlias::userId);
	soap_default_int(soap, &this->tns__gameAlias::status);
	this->tns__gameAlias::text = NULL;
	soap_default_LONG64(soap, &this->tns__gameAlias::tokenId);
	soap_default_int(soap, &this->tns__gameAlias::type);
	soap_default_LONG64(soap, &this->tns__gameAlias::updateTime);
	/* transient soap skipped */
}

void tns__gameAlias::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__gameAlias::digest);
	soap_serialize_PointerTostd__string(soap, &this->tns__gameAlias::text);
	/* transient soap skipped */
}

int tns__gameAlias::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__gameAlias(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__gameAlias(struct soap *soap, const char *tag, int id, const tns__gameAlias *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__gameAlias), type))
		return soap->error;
	if (soap_out_int(soap, "blessedCount", -1, &(a->tns__gameAlias::blessedCount), ""))
		return soap->error;
	if (soap_out_int(soap, "blockedCount", -1, &(a->tns__gameAlias::blockedCount), ""))
		return soap->error;
	if (soap_out_int(soap, "cursedCount", -1, &(a->tns__gameAlias::cursedCount), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "digest", -1, &(a->tns__gameAlias::digest), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "flags", -1, &(a->tns__gameAlias::flags), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "id", -1, &(a->tns__gameAlias::id), ""))
		return soap->error;
	if (soap_out_int(soap, "language", -1, &(a->tns__gameAlias::language), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "userId", -1, &(a->tns__gameAlias::userId), ""))
		return soap->error;
	if (soap_out_int(soap, "status", -1, &(a->tns__gameAlias::status), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "text", -1, &(a->tns__gameAlias::text), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "tokenId", -1, &(a->tns__gameAlias::tokenId), ""))
		return soap->error;
	if (soap_out_int(soap, "type", -1, &(a->tns__gameAlias::type), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "updateTime", -1, &(a->tns__gameAlias::updateTime), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__gameAlias::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__gameAlias(soap, tag, this, type);
}

SOAP_FMAC3 tns__gameAlias * SOAP_FMAC4 soap_in_tns__gameAlias(struct soap *soap, const char *tag, tns__gameAlias *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__gameAlias *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__gameAlias, sizeof(tns__gameAlias), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__gameAlias)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__gameAlias *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_blessedCount1 = 1;
	size_t soap_flag_blockedCount1 = 1;
	size_t soap_flag_cursedCount1 = 1;
	size_t soap_flag_digest1 = 1;
	size_t soap_flag_flags1 = 1;
	size_t soap_flag_id1 = 1;
	size_t soap_flag_language1 = 1;
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_text1 = 1;
	size_t soap_flag_tokenId1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_updateTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_blessedCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "blessedCount", &(a->tns__gameAlias::blessedCount), "xsd:int"))
				{	soap_flag_blessedCount1--;
					continue;
				}
			if (soap_flag_blockedCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "blockedCount", &(a->tns__gameAlias::blockedCount), "xsd:int"))
				{	soap_flag_blockedCount1--;
					continue;
				}
			if (soap_flag_cursedCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "cursedCount", &(a->tns__gameAlias::cursedCount), "xsd:int"))
				{	soap_flag_cursedCount1--;
					continue;
				}
			if (soap_flag_digest1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "digest", &(a->tns__gameAlias::digest), "xsd:string"))
				{	soap_flag_digest1--;
					continue;
				}
			if (soap_flag_flags1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "flags", &(a->tns__gameAlias::flags), "xsd:long"))
				{	soap_flag_flags1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "id", &(a->tns__gameAlias::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_language1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "language", &(a->tns__gameAlias::language), "xsd:int"))
				{	soap_flag_language1--;
					continue;
				}
			if (soap_flag_userId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "userId", &(a->tns__gameAlias::userId), "xsd:long"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "status", &(a->tns__gameAlias::status), "xsd:int"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_text1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "text", &(a->tns__gameAlias::text), "xsd:string"))
				{	soap_flag_text1--;
					continue;
				}
			if (soap_flag_tokenId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "tokenId", &(a->tns__gameAlias::tokenId), "xsd:long"))
				{	soap_flag_tokenId1--;
					continue;
				}
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "type", &(a->tns__gameAlias::type), "xsd:int"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_updateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "updateTime", &(a->tns__gameAlias::updateTime), "xsd:long"))
				{	soap_flag_updateTime1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__gameAlias *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__gameAlias, 0, sizeof(tns__gameAlias), 0, soap_copy_tns__gameAlias);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_blessedCount1 > 0 || soap_flag_blockedCount1 > 0 || soap_flag_cursedCount1 > 0 || soap_flag_flags1 > 0 || soap_flag_id1 > 0 || soap_flag_language1 > 0 || soap_flag_userId1 > 0 || soap_flag_status1 > 0 || soap_flag_tokenId1 > 0 || soap_flag_type1 > 0 || soap_flag_updateTime1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__gameAlias::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__gameAlias);
	if (this->soap_out(soap, tag?tag:"tns:gameAlias", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__gameAlias::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__gameAlias(soap, this, tag, type);
}

SOAP_FMAC3 tns__gameAlias * SOAP_FMAC4 soap_get_tns__gameAlias(struct soap *soap, tns__gameAlias *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__gameAlias(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__gameAlias * SOAP_FMAC2 soap_instantiate_tns__gameAlias(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__gameAlias(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__gameAlias, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__gameAlias);
		if (size)
			*size = sizeof(tns__gameAlias);
		((tns__gameAlias*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__gameAlias[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__gameAlias);
		for (int i = 0; i < n; i++)
			((tns__gameAlias*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__gameAlias*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__gameAlias(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__gameAlias %p -> %p\n", q, p));
	*(tns__gameAlias*)p = *(tns__gameAlias*)q;
}

void tns__gameToken::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->tns__gameToken::blessedCount);
	soap_default_int(soap, &this->tns__gameToken::blockedCount);
	soap_default_LONG64(soap, &this->tns__gameToken::createTime);
	soap_default_int(soap, &this->tns__gameToken::cursedCount);
	this->tns__gameToken::digest = NULL;
	soap_default_LONG64(soap, &this->tns__gameToken::flags);
	soap_default_LONG64(soap, &this->tns__gameToken::id);
	soap_default_LONG64(soap, &this->tns__gameToken::userId);
	soap_default_int(soap, &this->tns__gameToken::status);
	soap_default_int(soap, &this->tns__gameToken::visitedCount);
	/* transient soap skipped */
}

void tns__gameToken::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__gameToken::digest);
	/* transient soap skipped */
}

int tns__gameToken::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__gameToken(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__gameToken(struct soap *soap, const char *tag, int id, const tns__gameToken *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__gameToken), type))
		return soap->error;
	if (soap_out_int(soap, "blessedCount", -1, &(a->tns__gameToken::blessedCount), ""))
		return soap->error;
	if (soap_out_int(soap, "blockedCount", -1, &(a->tns__gameToken::blockedCount), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "createTime", -1, &(a->tns__gameToken::createTime), ""))
		return soap->error;
	if (soap_out_int(soap, "cursedCount", -1, &(a->tns__gameToken::cursedCount), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "digest", -1, &(a->tns__gameToken::digest), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "flags", -1, &(a->tns__gameToken::flags), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "id", -1, &(a->tns__gameToken::id), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "userId", -1, &(a->tns__gameToken::userId), ""))
		return soap->error;
	if (soap_out_int(soap, "status", -1, &(a->tns__gameToken::status), ""))
		return soap->error;
	if (soap_out_int(soap, "visitedCount", -1, &(a->tns__gameToken::visitedCount), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__gameToken::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__gameToken(soap, tag, this, type);
}

SOAP_FMAC3 tns__gameToken * SOAP_FMAC4 soap_in_tns__gameToken(struct soap *soap, const char *tag, tns__gameToken *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__gameToken *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__gameToken, sizeof(tns__gameToken), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__gameToken)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__gameToken *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_blessedCount1 = 1;
	size_t soap_flag_blockedCount1 = 1;
	size_t soap_flag_createTime1 = 1;
	size_t soap_flag_cursedCount1 = 1;
	size_t soap_flag_digest1 = 1;
	size_t soap_flag_flags1 = 1;
	size_t soap_flag_id1 = 1;
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_visitedCount1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_blessedCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "blessedCount", &(a->tns__gameToken::blessedCount), "xsd:int"))
				{	soap_flag_blessedCount1--;
					continue;
				}
			if (soap_flag_blockedCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "blockedCount", &(a->tns__gameToken::blockedCount), "xsd:int"))
				{	soap_flag_blockedCount1--;
					continue;
				}
			if (soap_flag_createTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "createTime", &(a->tns__gameToken::createTime), "xsd:long"))
				{	soap_flag_createTime1--;
					continue;
				}
			if (soap_flag_cursedCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "cursedCount", &(a->tns__gameToken::cursedCount), "xsd:int"))
				{	soap_flag_cursedCount1--;
					continue;
				}
			if (soap_flag_digest1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "digest", &(a->tns__gameToken::digest), "xsd:string"))
				{	soap_flag_digest1--;
					continue;
				}
			if (soap_flag_flags1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "flags", &(a->tns__gameToken::flags), "xsd:long"))
				{	soap_flag_flags1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "id", &(a->tns__gameToken::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_userId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "userId", &(a->tns__gameToken::userId), "xsd:long"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "status", &(a->tns__gameToken::status), "xsd:int"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_visitedCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "visitedCount", &(a->tns__gameToken::visitedCount), "xsd:int"))
				{	soap_flag_visitedCount1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__gameToken *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__gameToken, 0, sizeof(tns__gameToken), 0, soap_copy_tns__gameToken);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_blessedCount1 > 0 || soap_flag_blockedCount1 > 0 || soap_flag_createTime1 > 0 || soap_flag_cursedCount1 > 0 || soap_flag_flags1 > 0 || soap_flag_id1 > 0 || soap_flag_userId1 > 0 || soap_flag_status1 > 0 || soap_flag_visitedCount1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__gameToken::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__gameToken);
	if (this->soap_out(soap, tag?tag:"tns:gameToken", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__gameToken::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__gameToken(soap, this, tag, type);
}

SOAP_FMAC3 tns__gameToken * SOAP_FMAC4 soap_get_tns__gameToken(struct soap *soap, tns__gameToken *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__gameToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__gameToken * SOAP_FMAC2 soap_instantiate_tns__gameToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__gameToken(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__gameToken, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__gameToken);
		if (size)
			*size = sizeof(tns__gameToken);
		((tns__gameToken*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__gameToken[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__gameToken);
		for (int i = 0; i < n; i++)
			((tns__gameToken*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__gameToken*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__gameToken(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__gameToken %p -> %p\n", q, p));
	*(tns__gameToken*)p = *(tns__gameToken*)q;
}

void tns__gameAnnotation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->tns__gameAnnotation::blessedCount);
	soap_default_int(soap, &this->tns__gameAnnotation::blockedCount);
	soap_default_LONG64(soap, &this->tns__gameAnnotation::createTime);
	soap_default_int(soap, &this->tns__gameAnnotation::cursedCount);
	soap_default_LONG64(soap, &this->tns__gameAnnotation::flags);
	soap_default_LONG64(soap, &this->tns__gameAnnotation::id);
	soap_default_int(soap, &this->tns__gameAnnotation::language);
	soap_default_LONG64(soap, &this->tns__gameAnnotation::pos);
	soap_default_int(soap, &this->tns__gameAnnotation::posType);
	soap_default_LONG64(soap, &this->tns__gameAnnotation::userId);
	this->tns__gameAnnotation::userAlias = NULL;
	soap_default_int(soap, &this->tns__gameAnnotation::status);
	this->tns__gameAnnotation::text = NULL;
	soap_default_LONG64(soap, &this->tns__gameAnnotation::tokenId);
	soap_default_LONG64(soap, &this->tns__gameAnnotation::updateTime);
	/* transient soap skipped */
}

void tns__gameAnnotation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__gameAnnotation::userAlias);
	soap_serialize_PointerTostd__string(soap, &this->tns__gameAnnotation::text);
	/* transient soap skipped */
}

int tns__gameAnnotation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__gameAnnotation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__gameAnnotation(struct soap *soap, const char *tag, int id, const tns__gameAnnotation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__gameAnnotation), type))
		return soap->error;
	if (soap_out_int(soap, "blessedCount", -1, &(a->tns__gameAnnotation::blessedCount), ""))
		return soap->error;
	if (soap_out_int(soap, "blockedCount", -1, &(a->tns__gameAnnotation::blockedCount), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "createTime", -1, &(a->tns__gameAnnotation::createTime), ""))
		return soap->error;
	if (soap_out_int(soap, "cursedCount", -1, &(a->tns__gameAnnotation::cursedCount), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "flags", -1, &(a->tns__gameAnnotation::flags), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "id", -1, &(a->tns__gameAnnotation::id), ""))
		return soap->error;
	if (soap_out_int(soap, "language", -1, &(a->tns__gameAnnotation::language), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "pos", -1, &(a->tns__gameAnnotation::pos), ""))
		return soap->error;
	if (soap_out_int(soap, "posType", -1, &(a->tns__gameAnnotation::posType), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "userId", -1, &(a->tns__gameAnnotation::userId), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userAlias", -1, &(a->tns__gameAnnotation::userAlias), ""))
		return soap->error;
	if (soap_out_int(soap, "status", -1, &(a->tns__gameAnnotation::status), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "text", -1, &(a->tns__gameAnnotation::text), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "tokenId", -1, &(a->tns__gameAnnotation::tokenId), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "updateTime", -1, &(a->tns__gameAnnotation::updateTime), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__gameAnnotation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__gameAnnotation(soap, tag, this, type);
}

SOAP_FMAC3 tns__gameAnnotation * SOAP_FMAC4 soap_in_tns__gameAnnotation(struct soap *soap, const char *tag, tns__gameAnnotation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__gameAnnotation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__gameAnnotation, sizeof(tns__gameAnnotation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__gameAnnotation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__gameAnnotation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_blessedCount1 = 1;
	size_t soap_flag_blockedCount1 = 1;
	size_t soap_flag_createTime1 = 1;
	size_t soap_flag_cursedCount1 = 1;
	size_t soap_flag_flags1 = 1;
	size_t soap_flag_id1 = 1;
	size_t soap_flag_language1 = 1;
	size_t soap_flag_pos1 = 1;
	size_t soap_flag_posType1 = 1;
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_userAlias1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_text1 = 1;
	size_t soap_flag_tokenId1 = 1;
	size_t soap_flag_updateTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_blessedCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "blessedCount", &(a->tns__gameAnnotation::blessedCount), "xsd:int"))
				{	soap_flag_blessedCount1--;
					continue;
				}
			if (soap_flag_blockedCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "blockedCount", &(a->tns__gameAnnotation::blockedCount), "xsd:int"))
				{	soap_flag_blockedCount1--;
					continue;
				}
			if (soap_flag_createTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "createTime", &(a->tns__gameAnnotation::createTime), "xsd:long"))
				{	soap_flag_createTime1--;
					continue;
				}
			if (soap_flag_cursedCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "cursedCount", &(a->tns__gameAnnotation::cursedCount), "xsd:int"))
				{	soap_flag_cursedCount1--;
					continue;
				}
			if (soap_flag_flags1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "flags", &(a->tns__gameAnnotation::flags), "xsd:long"))
				{	soap_flag_flags1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "id", &(a->tns__gameAnnotation::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_language1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "language", &(a->tns__gameAnnotation::language), "xsd:int"))
				{	soap_flag_language1--;
					continue;
				}
			if (soap_flag_pos1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "pos", &(a->tns__gameAnnotation::pos), "xsd:long"))
				{	soap_flag_pos1--;
					continue;
				}
			if (soap_flag_posType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "posType", &(a->tns__gameAnnotation::posType), "xsd:int"))
				{	soap_flag_posType1--;
					continue;
				}
			if (soap_flag_userId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "userId", &(a->tns__gameAnnotation::userId), "xsd:long"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_userAlias1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userAlias", &(a->tns__gameAnnotation::userAlias), "xsd:string"))
				{	soap_flag_userAlias1--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "status", &(a->tns__gameAnnotation::status), "xsd:int"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_text1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "text", &(a->tns__gameAnnotation::text), "xsd:string"))
				{	soap_flag_text1--;
					continue;
				}
			if (soap_flag_tokenId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "tokenId", &(a->tns__gameAnnotation::tokenId), "xsd:long"))
				{	soap_flag_tokenId1--;
					continue;
				}
			if (soap_flag_updateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "updateTime", &(a->tns__gameAnnotation::updateTime), "xsd:long"))
				{	soap_flag_updateTime1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__gameAnnotation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__gameAnnotation, 0, sizeof(tns__gameAnnotation), 0, soap_copy_tns__gameAnnotation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_blessedCount1 > 0 || soap_flag_blockedCount1 > 0 || soap_flag_createTime1 > 0 || soap_flag_cursedCount1 > 0 || soap_flag_flags1 > 0 || soap_flag_id1 > 0 || soap_flag_language1 > 0 || soap_flag_pos1 > 0 || soap_flag_posType1 > 0 || soap_flag_userId1 > 0 || soap_flag_status1 > 0 || soap_flag_tokenId1 > 0 || soap_flag_updateTime1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__gameAnnotation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__gameAnnotation);
	if (this->soap_out(soap, tag?tag:"tns:gameAnnotation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__gameAnnotation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__gameAnnotation(soap, this, tag, type);
}

SOAP_FMAC3 tns__gameAnnotation * SOAP_FMAC4 soap_get_tns__gameAnnotation(struct soap *soap, tns__gameAnnotation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__gameAnnotation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__gameAnnotation * SOAP_FMAC2 soap_instantiate_tns__gameAnnotation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__gameAnnotation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__gameAnnotation, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__gameAnnotation);
		if (size)
			*size = sizeof(tns__gameAnnotation);
		((tns__gameAnnotation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__gameAnnotation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__gameAnnotation);
		for (int i = 0; i < n; i++)
			((tns__gameAnnotation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__gameAnnotation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__gameAnnotation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__gameAnnotation %p -> %p\n", q, p));
	*(tns__gameAnnotation*)p = *(tns__gameAnnotation*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_SOAP_ENV__Fault, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_SOAP_ENV__Reason, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_SOAP_ENV__Detail, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_SOAP_ENV__Code, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_SOAP_ENV__Header, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__updateMediaAnnotationTextWithId(struct soap *soap, struct __tns__updateMediaAnnotationTextWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__updateMediaAnnotationTextWithId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__updateMediaAnnotationTextWithId(struct soap *soap, const struct __tns__updateMediaAnnotationTextWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__updateMediaAnnotationTextWithId(soap, &a->tns__updateMediaAnnotationTextWithId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__updateMediaAnnotationTextWithId(struct soap *soap, const char *tag, int id, const struct __tns__updateMediaAnnotationTextWithId *a, const char *type)
{
	if (soap_out_PointerTotns__updateMediaAnnotationTextWithId(soap, "tns:updateMediaAnnotationTextWithId", -1, &a->tns__updateMediaAnnotationTextWithId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__updateMediaAnnotationTextWithId * SOAP_FMAC4 soap_in___tns__updateMediaAnnotationTextWithId(struct soap *soap, const char *tag, struct __tns__updateMediaAnnotationTextWithId *a, const char *type)
{
	size_t soap_flag_tns__updateMediaAnnotationTextWithId_ = 1;
	short soap_flag;
	a = (struct __tns__updateMediaAnnotationTextWithId *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__updateMediaAnnotationTextWithId, sizeof(struct __tns__updateMediaAnnotationTextWithId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__updateMediaAnnotationTextWithId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__updateMediaAnnotationTextWithId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__updateMediaAnnotationTextWithId(soap, "tns:updateMediaAnnotationTextWithId", &a->tns__updateMediaAnnotationTextWithId_, "tns:updateMediaAnnotationTextWithId"))
				{	soap_flag_tns__updateMediaAnnotationTextWithId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__updateMediaAnnotationTextWithId(struct soap *soap, const struct __tns__updateMediaAnnotationTextWithId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__updateMediaAnnotationTextWithId(soap, tag?tag:"-tns:updateMediaAnnotationTextWithId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__updateMediaAnnotationTextWithId * SOAP_FMAC4 soap_get___tns__updateMediaAnnotationTextWithId(struct soap *soap, struct __tns__updateMediaAnnotationTextWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__updateMediaAnnotationTextWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__updateMediaAnnotationTextWithId * SOAP_FMAC2 soap_instantiate___tns__updateMediaAnnotationTextWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__updateMediaAnnotationTextWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__updateMediaAnnotationTextWithId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__updateMediaAnnotationTextWithId);
		if (size)
			*size = sizeof(struct __tns__updateMediaAnnotationTextWithId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__updateMediaAnnotationTextWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__updateMediaAnnotationTextWithId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__updateMediaAnnotationTextWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__updateMediaAnnotationTextWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__updateMediaAnnotationTextWithId %p -> %p\n", q, p));
	*(struct __tns__updateMediaAnnotationTextWithId*)p = *(struct __tns__updateMediaAnnotationTextWithId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__updateGameAnnotationTextWithId(struct soap *soap, struct __tns__updateGameAnnotationTextWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__updateGameAnnotationTextWithId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__updateGameAnnotationTextWithId(struct soap *soap, const struct __tns__updateGameAnnotationTextWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__updateGameAnnotationTextWithId(soap, &a->tns__updateGameAnnotationTextWithId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__updateGameAnnotationTextWithId(struct soap *soap, const char *tag, int id, const struct __tns__updateGameAnnotationTextWithId *a, const char *type)
{
	if (soap_out_PointerTotns__updateGameAnnotationTextWithId(soap, "tns:updateGameAnnotationTextWithId", -1, &a->tns__updateGameAnnotationTextWithId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__updateGameAnnotationTextWithId * SOAP_FMAC4 soap_in___tns__updateGameAnnotationTextWithId(struct soap *soap, const char *tag, struct __tns__updateGameAnnotationTextWithId *a, const char *type)
{
	size_t soap_flag_tns__updateGameAnnotationTextWithId_ = 1;
	short soap_flag;
	a = (struct __tns__updateGameAnnotationTextWithId *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__updateGameAnnotationTextWithId, sizeof(struct __tns__updateGameAnnotationTextWithId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__updateGameAnnotationTextWithId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__updateGameAnnotationTextWithId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__updateGameAnnotationTextWithId(soap, "tns:updateGameAnnotationTextWithId", &a->tns__updateGameAnnotationTextWithId_, "tns:updateGameAnnotationTextWithId"))
				{	soap_flag_tns__updateGameAnnotationTextWithId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__updateGameAnnotationTextWithId(struct soap *soap, const struct __tns__updateGameAnnotationTextWithId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__updateGameAnnotationTextWithId(soap, tag?tag:"-tns:updateGameAnnotationTextWithId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__updateGameAnnotationTextWithId * SOAP_FMAC4 soap_get___tns__updateGameAnnotationTextWithId(struct soap *soap, struct __tns__updateGameAnnotationTextWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__updateGameAnnotationTextWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__updateGameAnnotationTextWithId * SOAP_FMAC2 soap_instantiate___tns__updateGameAnnotationTextWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__updateGameAnnotationTextWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__updateGameAnnotationTextWithId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__updateGameAnnotationTextWithId);
		if (size)
			*size = sizeof(struct __tns__updateGameAnnotationTextWithId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__updateGameAnnotationTextWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__updateGameAnnotationTextWithId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__updateGameAnnotationTextWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__updateGameAnnotationTextWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__updateGameAnnotationTextWithId %p -> %p\n", q, p));
	*(struct __tns__updateGameAnnotationTextWithId*)p = *(struct __tns__updateGameAnnotationTextWithId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__submitMediaTokenDigest(struct soap *soap, struct __tns__submitMediaTokenDigest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__submitMediaTokenDigest_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__submitMediaTokenDigest(struct soap *soap, const struct __tns__submitMediaTokenDigest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__submitMediaTokenDigest(soap, &a->tns__submitMediaTokenDigest_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__submitMediaTokenDigest(struct soap *soap, const char *tag, int id, const struct __tns__submitMediaTokenDigest *a, const char *type)
{
	if (soap_out_PointerTotns__submitMediaTokenDigest(soap, "tns:submitMediaTokenDigest", -1, &a->tns__submitMediaTokenDigest_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaTokenDigest * SOAP_FMAC4 soap_in___tns__submitMediaTokenDigest(struct soap *soap, const char *tag, struct __tns__submitMediaTokenDigest *a, const char *type)
{
	size_t soap_flag_tns__submitMediaTokenDigest_ = 1;
	short soap_flag;
	a = (struct __tns__submitMediaTokenDigest *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__submitMediaTokenDigest, sizeof(struct __tns__submitMediaTokenDigest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__submitMediaTokenDigest(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__submitMediaTokenDigest_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__submitMediaTokenDigest(soap, "tns:submitMediaTokenDigest", &a->tns__submitMediaTokenDigest_, "tns:submitMediaTokenDigest"))
				{	soap_flag_tns__submitMediaTokenDigest_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__submitMediaTokenDigest(struct soap *soap, const struct __tns__submitMediaTokenDigest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__submitMediaTokenDigest(soap, tag?tag:"-tns:submitMediaTokenDigest", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaTokenDigest * SOAP_FMAC4 soap_get___tns__submitMediaTokenDigest(struct soap *soap, struct __tns__submitMediaTokenDigest *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__submitMediaTokenDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__submitMediaTokenDigest * SOAP_FMAC2 soap_instantiate___tns__submitMediaTokenDigest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__submitMediaTokenDigest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__submitMediaTokenDigest, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaTokenDigest);
		if (size)
			*size = sizeof(struct __tns__submitMediaTokenDigest);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaTokenDigest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__submitMediaTokenDigest);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__submitMediaTokenDigest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__submitMediaTokenDigest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__submitMediaTokenDigest %p -> %p\n", q, p));
	*(struct __tns__submitMediaTokenDigest*)p = *(struct __tns__submitMediaTokenDigest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__submitMediaToken(struct soap *soap, struct __tns__submitMediaToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__submitMediaToken_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__submitMediaToken(struct soap *soap, const struct __tns__submitMediaToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__submitMediaToken(soap, &a->tns__submitMediaToken_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__submitMediaToken(struct soap *soap, const char *tag, int id, const struct __tns__submitMediaToken *a, const char *type)
{
	if (soap_out_PointerTotns__submitMediaToken(soap, "tns:submitMediaToken", -1, &a->tns__submitMediaToken_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaToken * SOAP_FMAC4 soap_in___tns__submitMediaToken(struct soap *soap, const char *tag, struct __tns__submitMediaToken *a, const char *type)
{
	size_t soap_flag_tns__submitMediaToken_ = 1;
	short soap_flag;
	a = (struct __tns__submitMediaToken *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__submitMediaToken, sizeof(struct __tns__submitMediaToken), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__submitMediaToken(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__submitMediaToken_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__submitMediaToken(soap, "tns:submitMediaToken", &a->tns__submitMediaToken_, "tns:submitMediaToken"))
				{	soap_flag_tns__submitMediaToken_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__submitMediaToken(struct soap *soap, const struct __tns__submitMediaToken *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__submitMediaToken(soap, tag?tag:"-tns:submitMediaToken", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaToken * SOAP_FMAC4 soap_get___tns__submitMediaToken(struct soap *soap, struct __tns__submitMediaToken *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__submitMediaToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__submitMediaToken * SOAP_FMAC2 soap_instantiate___tns__submitMediaToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__submitMediaToken(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__submitMediaToken, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaToken);
		if (size)
			*size = sizeof(struct __tns__submitMediaToken);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaToken[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__submitMediaToken);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__submitMediaToken*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__submitMediaToken(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__submitMediaToken %p -> %p\n", q, p));
	*(struct __tns__submitMediaToken*)p = *(struct __tns__submitMediaToken*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__submitMediaAnnotationTextWithTokenId(struct soap *soap, struct __tns__submitMediaAnnotationTextWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__submitMediaAnnotationTextWithTokenId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__submitMediaAnnotationTextWithTokenId(struct soap *soap, const struct __tns__submitMediaAnnotationTextWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__submitMediaAnnotationTextWithTokenId(soap, &a->tns__submitMediaAnnotationTextWithTokenId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__submitMediaAnnotationTextWithTokenId(struct soap *soap, const char *tag, int id, const struct __tns__submitMediaAnnotationTextWithTokenId *a, const char *type)
{
	if (soap_out_PointerTotns__submitMediaAnnotationTextWithTokenId(soap, "tns:submitMediaAnnotationTextWithTokenId", -1, &a->tns__submitMediaAnnotationTextWithTokenId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaAnnotationTextWithTokenId * SOAP_FMAC4 soap_in___tns__submitMediaAnnotationTextWithTokenId(struct soap *soap, const char *tag, struct __tns__submitMediaAnnotationTextWithTokenId *a, const char *type)
{
	size_t soap_flag_tns__submitMediaAnnotationTextWithTokenId_ = 1;
	short soap_flag;
	a = (struct __tns__submitMediaAnnotationTextWithTokenId *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__submitMediaAnnotationTextWithTokenId, sizeof(struct __tns__submitMediaAnnotationTextWithTokenId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__submitMediaAnnotationTextWithTokenId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__submitMediaAnnotationTextWithTokenId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__submitMediaAnnotationTextWithTokenId(soap, "tns:submitMediaAnnotationTextWithTokenId", &a->tns__submitMediaAnnotationTextWithTokenId_, "tns:submitMediaAnnotationTextWithTokenId"))
				{	soap_flag_tns__submitMediaAnnotationTextWithTokenId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__submitMediaAnnotationTextWithTokenId(struct soap *soap, const struct __tns__submitMediaAnnotationTextWithTokenId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__submitMediaAnnotationTextWithTokenId(soap, tag?tag:"-tns:submitMediaAnnotationTextWithTokenId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaAnnotationTextWithTokenId * SOAP_FMAC4 soap_get___tns__submitMediaAnnotationTextWithTokenId(struct soap *soap, struct __tns__submitMediaAnnotationTextWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__submitMediaAnnotationTextWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__submitMediaAnnotationTextWithTokenId * SOAP_FMAC2 soap_instantiate___tns__submitMediaAnnotationTextWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__submitMediaAnnotationTextWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__submitMediaAnnotationTextWithTokenId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaAnnotationTextWithTokenId);
		if (size)
			*size = sizeof(struct __tns__submitMediaAnnotationTextWithTokenId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaAnnotationTextWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__submitMediaAnnotationTextWithTokenId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__submitMediaAnnotationTextWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__submitMediaAnnotationTextWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__submitMediaAnnotationTextWithTokenId %p -> %p\n", q, p));
	*(struct __tns__submitMediaAnnotationTextWithTokenId*)p = *(struct __tns__submitMediaAnnotationTextWithTokenId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, struct __tns__submitMediaAnnotationTextAndTokenDigest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__submitMediaAnnotationTextAndTokenDigest_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, const struct __tns__submitMediaAnnotationTextAndTokenDigest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__submitMediaAnnotationTextAndTokenDigest(soap, &a->tns__submitMediaAnnotationTextAndTokenDigest_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, const char *tag, int id, const struct __tns__submitMediaAnnotationTextAndTokenDigest *a, const char *type)
{
	if (soap_out_PointerTotns__submitMediaAnnotationTextAndTokenDigest(soap, "tns:submitMediaAnnotationTextAndTokenDigest", -1, &a->tns__submitMediaAnnotationTextAndTokenDigest_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaAnnotationTextAndTokenDigest * SOAP_FMAC4 soap_in___tns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, const char *tag, struct __tns__submitMediaAnnotationTextAndTokenDigest *a, const char *type)
{
	size_t soap_flag_tns__submitMediaAnnotationTextAndTokenDigest_ = 1;
	short soap_flag;
	a = (struct __tns__submitMediaAnnotationTextAndTokenDigest *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__submitMediaAnnotationTextAndTokenDigest, sizeof(struct __tns__submitMediaAnnotationTextAndTokenDigest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__submitMediaAnnotationTextAndTokenDigest(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__submitMediaAnnotationTextAndTokenDigest_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__submitMediaAnnotationTextAndTokenDigest(soap, "tns:submitMediaAnnotationTextAndTokenDigest", &a->tns__submitMediaAnnotationTextAndTokenDigest_, "tns:submitMediaAnnotationTextAndTokenDigest"))
				{	soap_flag_tns__submitMediaAnnotationTextAndTokenDigest_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, const struct __tns__submitMediaAnnotationTextAndTokenDigest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__submitMediaAnnotationTextAndTokenDigest(soap, tag?tag:"-tns:submitMediaAnnotationTextAndTokenDigest", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaAnnotationTextAndTokenDigest * SOAP_FMAC4 soap_get___tns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, struct __tns__submitMediaAnnotationTextAndTokenDigest *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__submitMediaAnnotationTextAndTokenDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__submitMediaAnnotationTextAndTokenDigest * SOAP_FMAC2 soap_instantiate___tns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__submitMediaAnnotationTextAndTokenDigest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__submitMediaAnnotationTextAndTokenDigest, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaAnnotationTextAndTokenDigest);
		if (size)
			*size = sizeof(struct __tns__submitMediaAnnotationTextAndTokenDigest);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaAnnotationTextAndTokenDigest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__submitMediaAnnotationTextAndTokenDigest);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__submitMediaAnnotationTextAndTokenDigest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__submitMediaAnnotationTextAndTokenDigest %p -> %p\n", q, p));
	*(struct __tns__submitMediaAnnotationTextAndTokenDigest*)p = *(struct __tns__submitMediaAnnotationTextAndTokenDigest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__submitMediaAnnotation(struct soap *soap, struct __tns__submitMediaAnnotation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__submitMediaAnnotation_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__submitMediaAnnotation(struct soap *soap, const struct __tns__submitMediaAnnotation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__submitMediaAnnotation(soap, &a->tns__submitMediaAnnotation_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__submitMediaAnnotation(struct soap *soap, const char *tag, int id, const struct __tns__submitMediaAnnotation *a, const char *type)
{
	if (soap_out_PointerTotns__submitMediaAnnotation(soap, "tns:submitMediaAnnotation", -1, &a->tns__submitMediaAnnotation_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaAnnotation * SOAP_FMAC4 soap_in___tns__submitMediaAnnotation(struct soap *soap, const char *tag, struct __tns__submitMediaAnnotation *a, const char *type)
{
	size_t soap_flag_tns__submitMediaAnnotation_ = 1;
	short soap_flag;
	a = (struct __tns__submitMediaAnnotation *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__submitMediaAnnotation, sizeof(struct __tns__submitMediaAnnotation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__submitMediaAnnotation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__submitMediaAnnotation_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__submitMediaAnnotation(soap, "tns:submitMediaAnnotation", &a->tns__submitMediaAnnotation_, "tns:submitMediaAnnotation"))
				{	soap_flag_tns__submitMediaAnnotation_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__submitMediaAnnotation(struct soap *soap, const struct __tns__submitMediaAnnotation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__submitMediaAnnotation(soap, tag?tag:"-tns:submitMediaAnnotation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaAnnotation * SOAP_FMAC4 soap_get___tns__submitMediaAnnotation(struct soap *soap, struct __tns__submitMediaAnnotation *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__submitMediaAnnotation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__submitMediaAnnotation * SOAP_FMAC2 soap_instantiate___tns__submitMediaAnnotation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__submitMediaAnnotation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__submitMediaAnnotation, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaAnnotation);
		if (size)
			*size = sizeof(struct __tns__submitMediaAnnotation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaAnnotation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__submitMediaAnnotation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__submitMediaAnnotation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__submitMediaAnnotation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__submitMediaAnnotation %p -> %p\n", q, p));
	*(struct __tns__submitMediaAnnotation*)p = *(struct __tns__submitMediaAnnotation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__submitMediaAliasTextWithTokenId(struct soap *soap, struct __tns__submitMediaAliasTextWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__submitMediaAliasTextWithTokenId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__submitMediaAliasTextWithTokenId(struct soap *soap, const struct __tns__submitMediaAliasTextWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__submitMediaAliasTextWithTokenId(soap, &a->tns__submitMediaAliasTextWithTokenId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__submitMediaAliasTextWithTokenId(struct soap *soap, const char *tag, int id, const struct __tns__submitMediaAliasTextWithTokenId *a, const char *type)
{
	if (soap_out_PointerTotns__submitMediaAliasTextWithTokenId(soap, "tns:submitMediaAliasTextWithTokenId", -1, &a->tns__submitMediaAliasTextWithTokenId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaAliasTextWithTokenId * SOAP_FMAC4 soap_in___tns__submitMediaAliasTextWithTokenId(struct soap *soap, const char *tag, struct __tns__submitMediaAliasTextWithTokenId *a, const char *type)
{
	size_t soap_flag_tns__submitMediaAliasTextWithTokenId_ = 1;
	short soap_flag;
	a = (struct __tns__submitMediaAliasTextWithTokenId *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__submitMediaAliasTextWithTokenId, sizeof(struct __tns__submitMediaAliasTextWithTokenId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__submitMediaAliasTextWithTokenId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__submitMediaAliasTextWithTokenId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__submitMediaAliasTextWithTokenId(soap, "tns:submitMediaAliasTextWithTokenId", &a->tns__submitMediaAliasTextWithTokenId_, "tns:submitMediaAliasTextWithTokenId"))
				{	soap_flag_tns__submitMediaAliasTextWithTokenId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__submitMediaAliasTextWithTokenId(struct soap *soap, const struct __tns__submitMediaAliasTextWithTokenId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__submitMediaAliasTextWithTokenId(soap, tag?tag:"-tns:submitMediaAliasTextWithTokenId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaAliasTextWithTokenId * SOAP_FMAC4 soap_get___tns__submitMediaAliasTextWithTokenId(struct soap *soap, struct __tns__submitMediaAliasTextWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__submitMediaAliasTextWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__submitMediaAliasTextWithTokenId * SOAP_FMAC2 soap_instantiate___tns__submitMediaAliasTextWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__submitMediaAliasTextWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__submitMediaAliasTextWithTokenId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaAliasTextWithTokenId);
		if (size)
			*size = sizeof(struct __tns__submitMediaAliasTextWithTokenId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaAliasTextWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__submitMediaAliasTextWithTokenId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__submitMediaAliasTextWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__submitMediaAliasTextWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__submitMediaAliasTextWithTokenId %p -> %p\n", q, p));
	*(struct __tns__submitMediaAliasTextWithTokenId*)p = *(struct __tns__submitMediaAliasTextWithTokenId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__submitMediaAliasTextAndTokenDigest(struct soap *soap, struct __tns__submitMediaAliasTextAndTokenDigest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__submitMediaAliasTextAndTokenDigest_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__submitMediaAliasTextAndTokenDigest(struct soap *soap, const struct __tns__submitMediaAliasTextAndTokenDigest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__submitMediaAliasTextAndTokenDigest(soap, &a->tns__submitMediaAliasTextAndTokenDigest_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__submitMediaAliasTextAndTokenDigest(struct soap *soap, const char *tag, int id, const struct __tns__submitMediaAliasTextAndTokenDigest *a, const char *type)
{
	if (soap_out_PointerTotns__submitMediaAliasTextAndTokenDigest(soap, "tns:submitMediaAliasTextAndTokenDigest", -1, &a->tns__submitMediaAliasTextAndTokenDigest_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaAliasTextAndTokenDigest * SOAP_FMAC4 soap_in___tns__submitMediaAliasTextAndTokenDigest(struct soap *soap, const char *tag, struct __tns__submitMediaAliasTextAndTokenDigest *a, const char *type)
{
	size_t soap_flag_tns__submitMediaAliasTextAndTokenDigest_ = 1;
	short soap_flag;
	a = (struct __tns__submitMediaAliasTextAndTokenDigest *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__submitMediaAliasTextAndTokenDigest, sizeof(struct __tns__submitMediaAliasTextAndTokenDigest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__submitMediaAliasTextAndTokenDigest(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__submitMediaAliasTextAndTokenDigest_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__submitMediaAliasTextAndTokenDigest(soap, "tns:submitMediaAliasTextAndTokenDigest", &a->tns__submitMediaAliasTextAndTokenDigest_, "tns:submitMediaAliasTextAndTokenDigest"))
				{	soap_flag_tns__submitMediaAliasTextAndTokenDigest_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__submitMediaAliasTextAndTokenDigest(struct soap *soap, const struct __tns__submitMediaAliasTextAndTokenDigest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__submitMediaAliasTextAndTokenDigest(soap, tag?tag:"-tns:submitMediaAliasTextAndTokenDigest", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaAliasTextAndTokenDigest * SOAP_FMAC4 soap_get___tns__submitMediaAliasTextAndTokenDigest(struct soap *soap, struct __tns__submitMediaAliasTextAndTokenDigest *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__submitMediaAliasTextAndTokenDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__submitMediaAliasTextAndTokenDigest * SOAP_FMAC2 soap_instantiate___tns__submitMediaAliasTextAndTokenDigest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__submitMediaAliasTextAndTokenDigest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__submitMediaAliasTextAndTokenDigest, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaAliasTextAndTokenDigest);
		if (size)
			*size = sizeof(struct __tns__submitMediaAliasTextAndTokenDigest);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaAliasTextAndTokenDigest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__submitMediaAliasTextAndTokenDigest);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__submitMediaAliasTextAndTokenDigest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__submitMediaAliasTextAndTokenDigest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__submitMediaAliasTextAndTokenDigest %p -> %p\n", q, p));
	*(struct __tns__submitMediaAliasTextAndTokenDigest*)p = *(struct __tns__submitMediaAliasTextAndTokenDigest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__submitMediaAlias(struct soap *soap, struct __tns__submitMediaAlias *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__submitMediaAlias_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__submitMediaAlias(struct soap *soap, const struct __tns__submitMediaAlias *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__submitMediaAlias(soap, &a->tns__submitMediaAlias_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__submitMediaAlias(struct soap *soap, const char *tag, int id, const struct __tns__submitMediaAlias *a, const char *type)
{
	if (soap_out_PointerTotns__submitMediaAlias(soap, "tns:submitMediaAlias", -1, &a->tns__submitMediaAlias_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaAlias * SOAP_FMAC4 soap_in___tns__submitMediaAlias(struct soap *soap, const char *tag, struct __tns__submitMediaAlias *a, const char *type)
{
	size_t soap_flag_tns__submitMediaAlias_ = 1;
	short soap_flag;
	a = (struct __tns__submitMediaAlias *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__submitMediaAlias, sizeof(struct __tns__submitMediaAlias), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__submitMediaAlias(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__submitMediaAlias_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__submitMediaAlias(soap, "tns:submitMediaAlias", &a->tns__submitMediaAlias_, "tns:submitMediaAlias"))
				{	soap_flag_tns__submitMediaAlias_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__submitMediaAlias(struct soap *soap, const struct __tns__submitMediaAlias *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__submitMediaAlias(soap, tag?tag:"-tns:submitMediaAlias", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaAlias * SOAP_FMAC4 soap_get___tns__submitMediaAlias(struct soap *soap, struct __tns__submitMediaAlias *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__submitMediaAlias(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__submitMediaAlias * SOAP_FMAC2 soap_instantiate___tns__submitMediaAlias(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__submitMediaAlias(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__submitMediaAlias, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaAlias);
		if (size)
			*size = sizeof(struct __tns__submitMediaAlias);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaAlias[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__submitMediaAlias);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__submitMediaAlias*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__submitMediaAlias(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__submitMediaAlias %p -> %p\n", q, p));
	*(struct __tns__submitMediaAlias*)p = *(struct __tns__submitMediaAlias*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__submitGameTokenDigest(struct soap *soap, struct __tns__submitGameTokenDigest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__submitGameTokenDigest_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__submitGameTokenDigest(struct soap *soap, const struct __tns__submitGameTokenDigest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__submitGameTokenDigest(soap, &a->tns__submitGameTokenDigest_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__submitGameTokenDigest(struct soap *soap, const char *tag, int id, const struct __tns__submitGameTokenDigest *a, const char *type)
{
	if (soap_out_PointerTotns__submitGameTokenDigest(soap, "tns:submitGameTokenDigest", -1, &a->tns__submitGameTokenDigest_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitGameTokenDigest * SOAP_FMAC4 soap_in___tns__submitGameTokenDigest(struct soap *soap, const char *tag, struct __tns__submitGameTokenDigest *a, const char *type)
{
	size_t soap_flag_tns__submitGameTokenDigest_ = 1;
	short soap_flag;
	a = (struct __tns__submitGameTokenDigest *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__submitGameTokenDigest, sizeof(struct __tns__submitGameTokenDigest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__submitGameTokenDigest(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__submitGameTokenDigest_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__submitGameTokenDigest(soap, "tns:submitGameTokenDigest", &a->tns__submitGameTokenDigest_, "tns:submitGameTokenDigest"))
				{	soap_flag_tns__submitGameTokenDigest_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__submitGameTokenDigest(struct soap *soap, const struct __tns__submitGameTokenDigest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__submitGameTokenDigest(soap, tag?tag:"-tns:submitGameTokenDigest", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitGameTokenDigest * SOAP_FMAC4 soap_get___tns__submitGameTokenDigest(struct soap *soap, struct __tns__submitGameTokenDigest *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__submitGameTokenDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__submitGameTokenDigest * SOAP_FMAC2 soap_instantiate___tns__submitGameTokenDigest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__submitGameTokenDigest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__submitGameTokenDigest, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitGameTokenDigest);
		if (size)
			*size = sizeof(struct __tns__submitGameTokenDigest);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitGameTokenDigest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__submitGameTokenDigest);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__submitGameTokenDigest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__submitGameTokenDigest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__submitGameTokenDigest %p -> %p\n", q, p));
	*(struct __tns__submitGameTokenDigest*)p = *(struct __tns__submitGameTokenDigest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__submitGameToken(struct soap *soap, struct __tns__submitGameToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__submitGameToken_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__submitGameToken(struct soap *soap, const struct __tns__submitGameToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__submitGameToken(soap, &a->tns__submitGameToken_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__submitGameToken(struct soap *soap, const char *tag, int id, const struct __tns__submitGameToken *a, const char *type)
{
	if (soap_out_PointerTotns__submitGameToken(soap, "tns:submitGameToken", -1, &a->tns__submitGameToken_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitGameToken * SOAP_FMAC4 soap_in___tns__submitGameToken(struct soap *soap, const char *tag, struct __tns__submitGameToken *a, const char *type)
{
	size_t soap_flag_tns__submitGameToken_ = 1;
	short soap_flag;
	a = (struct __tns__submitGameToken *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__submitGameToken, sizeof(struct __tns__submitGameToken), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__submitGameToken(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__submitGameToken_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__submitGameToken(soap, "tns:submitGameToken", &a->tns__submitGameToken_, "tns:submitGameToken"))
				{	soap_flag_tns__submitGameToken_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__submitGameToken(struct soap *soap, const struct __tns__submitGameToken *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__submitGameToken(soap, tag?tag:"-tns:submitGameToken", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitGameToken * SOAP_FMAC4 soap_get___tns__submitGameToken(struct soap *soap, struct __tns__submitGameToken *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__submitGameToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__submitGameToken * SOAP_FMAC2 soap_instantiate___tns__submitGameToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__submitGameToken(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__submitGameToken, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitGameToken);
		if (size)
			*size = sizeof(struct __tns__submitGameToken);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitGameToken[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__submitGameToken);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__submitGameToken*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__submitGameToken(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__submitGameToken %p -> %p\n", q, p));
	*(struct __tns__submitGameToken*)p = *(struct __tns__submitGameToken*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__submitGameAnnotationTextWithTokenId(struct soap *soap, struct __tns__submitGameAnnotationTextWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__submitGameAnnotationTextWithTokenId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__submitGameAnnotationTextWithTokenId(struct soap *soap, const struct __tns__submitGameAnnotationTextWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__submitGameAnnotationTextWithTokenId(soap, &a->tns__submitGameAnnotationTextWithTokenId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__submitGameAnnotationTextWithTokenId(struct soap *soap, const char *tag, int id, const struct __tns__submitGameAnnotationTextWithTokenId *a, const char *type)
{
	if (soap_out_PointerTotns__submitGameAnnotationTextWithTokenId(soap, "tns:submitGameAnnotationTextWithTokenId", -1, &a->tns__submitGameAnnotationTextWithTokenId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitGameAnnotationTextWithTokenId * SOAP_FMAC4 soap_in___tns__submitGameAnnotationTextWithTokenId(struct soap *soap, const char *tag, struct __tns__submitGameAnnotationTextWithTokenId *a, const char *type)
{
	size_t soap_flag_tns__submitGameAnnotationTextWithTokenId_ = 1;
	short soap_flag;
	a = (struct __tns__submitGameAnnotationTextWithTokenId *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__submitGameAnnotationTextWithTokenId, sizeof(struct __tns__submitGameAnnotationTextWithTokenId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__submitGameAnnotationTextWithTokenId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__submitGameAnnotationTextWithTokenId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__submitGameAnnotationTextWithTokenId(soap, "tns:submitGameAnnotationTextWithTokenId", &a->tns__submitGameAnnotationTextWithTokenId_, "tns:submitGameAnnotationTextWithTokenId"))
				{	soap_flag_tns__submitGameAnnotationTextWithTokenId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__submitGameAnnotationTextWithTokenId(struct soap *soap, const struct __tns__submitGameAnnotationTextWithTokenId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__submitGameAnnotationTextWithTokenId(soap, tag?tag:"-tns:submitGameAnnotationTextWithTokenId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitGameAnnotationTextWithTokenId * SOAP_FMAC4 soap_get___tns__submitGameAnnotationTextWithTokenId(struct soap *soap, struct __tns__submitGameAnnotationTextWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__submitGameAnnotationTextWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__submitGameAnnotationTextWithTokenId * SOAP_FMAC2 soap_instantiate___tns__submitGameAnnotationTextWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__submitGameAnnotationTextWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__submitGameAnnotationTextWithTokenId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitGameAnnotationTextWithTokenId);
		if (size)
			*size = sizeof(struct __tns__submitGameAnnotationTextWithTokenId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitGameAnnotationTextWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__submitGameAnnotationTextWithTokenId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__submitGameAnnotationTextWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__submitGameAnnotationTextWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__submitGameAnnotationTextWithTokenId %p -> %p\n", q, p));
	*(struct __tns__submitGameAnnotationTextWithTokenId*)p = *(struct __tns__submitGameAnnotationTextWithTokenId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__submitGameAnnotationTextAndTokenDigest(struct soap *soap, struct __tns__submitGameAnnotationTextAndTokenDigest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__submitGameAnnotationTextAndTokenDigest_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__submitGameAnnotationTextAndTokenDigest(struct soap *soap, const struct __tns__submitGameAnnotationTextAndTokenDigest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__submitGameAnnotationTextAndTokenDigest(soap, &a->tns__submitGameAnnotationTextAndTokenDigest_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__submitGameAnnotationTextAndTokenDigest(struct soap *soap, const char *tag, int id, const struct __tns__submitGameAnnotationTextAndTokenDigest *a, const char *type)
{
	if (soap_out_PointerTotns__submitGameAnnotationTextAndTokenDigest(soap, "tns:submitGameAnnotationTextAndTokenDigest", -1, &a->tns__submitGameAnnotationTextAndTokenDigest_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitGameAnnotationTextAndTokenDigest * SOAP_FMAC4 soap_in___tns__submitGameAnnotationTextAndTokenDigest(struct soap *soap, const char *tag, struct __tns__submitGameAnnotationTextAndTokenDigest *a, const char *type)
{
	size_t soap_flag_tns__submitGameAnnotationTextAndTokenDigest_ = 1;
	short soap_flag;
	a = (struct __tns__submitGameAnnotationTextAndTokenDigest *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__submitGameAnnotationTextAndTokenDigest, sizeof(struct __tns__submitGameAnnotationTextAndTokenDigest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__submitGameAnnotationTextAndTokenDigest(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__submitGameAnnotationTextAndTokenDigest_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__submitGameAnnotationTextAndTokenDigest(soap, "tns:submitGameAnnotationTextAndTokenDigest", &a->tns__submitGameAnnotationTextAndTokenDigest_, "tns:submitGameAnnotationTextAndTokenDigest"))
				{	soap_flag_tns__submitGameAnnotationTextAndTokenDigest_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__submitGameAnnotationTextAndTokenDigest(struct soap *soap, const struct __tns__submitGameAnnotationTextAndTokenDigest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__submitGameAnnotationTextAndTokenDigest(soap, tag?tag:"-tns:submitGameAnnotationTextAndTokenDigest", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitGameAnnotationTextAndTokenDigest * SOAP_FMAC4 soap_get___tns__submitGameAnnotationTextAndTokenDigest(struct soap *soap, struct __tns__submitGameAnnotationTextAndTokenDigest *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__submitGameAnnotationTextAndTokenDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__submitGameAnnotationTextAndTokenDigest * SOAP_FMAC2 soap_instantiate___tns__submitGameAnnotationTextAndTokenDigest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__submitGameAnnotationTextAndTokenDigest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__submitGameAnnotationTextAndTokenDigest, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitGameAnnotationTextAndTokenDigest);
		if (size)
			*size = sizeof(struct __tns__submitGameAnnotationTextAndTokenDigest);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitGameAnnotationTextAndTokenDigest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__submitGameAnnotationTextAndTokenDigest);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__submitGameAnnotationTextAndTokenDigest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__submitGameAnnotationTextAndTokenDigest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__submitGameAnnotationTextAndTokenDigest %p -> %p\n", q, p));
	*(struct __tns__submitGameAnnotationTextAndTokenDigest*)p = *(struct __tns__submitGameAnnotationTextAndTokenDigest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__submitGameAnnotation(struct soap *soap, struct __tns__submitGameAnnotation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__submitGameAnnotation_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__submitGameAnnotation(struct soap *soap, const struct __tns__submitGameAnnotation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__submitGameAnnotation(soap, &a->tns__submitGameAnnotation_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__submitGameAnnotation(struct soap *soap, const char *tag, int id, const struct __tns__submitGameAnnotation *a, const char *type)
{
	if (soap_out_PointerTotns__submitGameAnnotation(soap, "tns:submitGameAnnotation", -1, &a->tns__submitGameAnnotation_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitGameAnnotation * SOAP_FMAC4 soap_in___tns__submitGameAnnotation(struct soap *soap, const char *tag, struct __tns__submitGameAnnotation *a, const char *type)
{
	size_t soap_flag_tns__submitGameAnnotation_ = 1;
	short soap_flag;
	a = (struct __tns__submitGameAnnotation *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__submitGameAnnotation, sizeof(struct __tns__submitGameAnnotation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__submitGameAnnotation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__submitGameAnnotation_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__submitGameAnnotation(soap, "tns:submitGameAnnotation", &a->tns__submitGameAnnotation_, "tns:submitGameAnnotation"))
				{	soap_flag_tns__submitGameAnnotation_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__submitGameAnnotation(struct soap *soap, const struct __tns__submitGameAnnotation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__submitGameAnnotation(soap, tag?tag:"-tns:submitGameAnnotation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitGameAnnotation * SOAP_FMAC4 soap_get___tns__submitGameAnnotation(struct soap *soap, struct __tns__submitGameAnnotation *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__submitGameAnnotation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__submitGameAnnotation * SOAP_FMAC2 soap_instantiate___tns__submitGameAnnotation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__submitGameAnnotation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__submitGameAnnotation, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitGameAnnotation);
		if (size)
			*size = sizeof(struct __tns__submitGameAnnotation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitGameAnnotation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__submitGameAnnotation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__submitGameAnnotation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__submitGameAnnotation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__submitGameAnnotation %p -> %p\n", q, p));
	*(struct __tns__submitGameAnnotation*)p = *(struct __tns__submitGameAnnotation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__submitGameAliasTextWithTokenId(struct soap *soap, struct __tns__submitGameAliasTextWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__submitGameAliasTextWithTokenId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__submitGameAliasTextWithTokenId(struct soap *soap, const struct __tns__submitGameAliasTextWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__submitGameAliasTextWithTokenId(soap, &a->tns__submitGameAliasTextWithTokenId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__submitGameAliasTextWithTokenId(struct soap *soap, const char *tag, int id, const struct __tns__submitGameAliasTextWithTokenId *a, const char *type)
{
	if (soap_out_PointerTotns__submitGameAliasTextWithTokenId(soap, "tns:submitGameAliasTextWithTokenId", -1, &a->tns__submitGameAliasTextWithTokenId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitGameAliasTextWithTokenId * SOAP_FMAC4 soap_in___tns__submitGameAliasTextWithTokenId(struct soap *soap, const char *tag, struct __tns__submitGameAliasTextWithTokenId *a, const char *type)
{
	size_t soap_flag_tns__submitGameAliasTextWithTokenId_ = 1;
	short soap_flag;
	a = (struct __tns__submitGameAliasTextWithTokenId *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__submitGameAliasTextWithTokenId, sizeof(struct __tns__submitGameAliasTextWithTokenId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__submitGameAliasTextWithTokenId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__submitGameAliasTextWithTokenId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__submitGameAliasTextWithTokenId(soap, "tns:submitGameAliasTextWithTokenId", &a->tns__submitGameAliasTextWithTokenId_, "tns:submitGameAliasTextWithTokenId"))
				{	soap_flag_tns__submitGameAliasTextWithTokenId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__submitGameAliasTextWithTokenId(struct soap *soap, const struct __tns__submitGameAliasTextWithTokenId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__submitGameAliasTextWithTokenId(soap, tag?tag:"-tns:submitGameAliasTextWithTokenId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitGameAliasTextWithTokenId * SOAP_FMAC4 soap_get___tns__submitGameAliasTextWithTokenId(struct soap *soap, struct __tns__submitGameAliasTextWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__submitGameAliasTextWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__submitGameAliasTextWithTokenId * SOAP_FMAC2 soap_instantiate___tns__submitGameAliasTextWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__submitGameAliasTextWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__submitGameAliasTextWithTokenId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitGameAliasTextWithTokenId);
		if (size)
			*size = sizeof(struct __tns__submitGameAliasTextWithTokenId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitGameAliasTextWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__submitGameAliasTextWithTokenId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__submitGameAliasTextWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__submitGameAliasTextWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__submitGameAliasTextWithTokenId %p -> %p\n", q, p));
	*(struct __tns__submitGameAliasTextWithTokenId*)p = *(struct __tns__submitGameAliasTextWithTokenId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__submitGameAliasTextAndTokenDigest(struct soap *soap, struct __tns__submitGameAliasTextAndTokenDigest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__submitGameAliasTextAndTokenDigest_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__submitGameAliasTextAndTokenDigest(struct soap *soap, const struct __tns__submitGameAliasTextAndTokenDigest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__submitGameAliasTextAndTokenDigest(soap, &a->tns__submitGameAliasTextAndTokenDigest_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__submitGameAliasTextAndTokenDigest(struct soap *soap, const char *tag, int id, const struct __tns__submitGameAliasTextAndTokenDigest *a, const char *type)
{
	if (soap_out_PointerTotns__submitGameAliasTextAndTokenDigest(soap, "tns:submitGameAliasTextAndTokenDigest", -1, &a->tns__submitGameAliasTextAndTokenDigest_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitGameAliasTextAndTokenDigest * SOAP_FMAC4 soap_in___tns__submitGameAliasTextAndTokenDigest(struct soap *soap, const char *tag, struct __tns__submitGameAliasTextAndTokenDigest *a, const char *type)
{
	size_t soap_flag_tns__submitGameAliasTextAndTokenDigest_ = 1;
	short soap_flag;
	a = (struct __tns__submitGameAliasTextAndTokenDigest *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__submitGameAliasTextAndTokenDigest, sizeof(struct __tns__submitGameAliasTextAndTokenDigest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__submitGameAliasTextAndTokenDigest(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__submitGameAliasTextAndTokenDigest_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__submitGameAliasTextAndTokenDigest(soap, "tns:submitGameAliasTextAndTokenDigest", &a->tns__submitGameAliasTextAndTokenDigest_, "tns:submitGameAliasTextAndTokenDigest"))
				{	soap_flag_tns__submitGameAliasTextAndTokenDigest_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__submitGameAliasTextAndTokenDigest(struct soap *soap, const struct __tns__submitGameAliasTextAndTokenDigest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__submitGameAliasTextAndTokenDigest(soap, tag?tag:"-tns:submitGameAliasTextAndTokenDigest", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitGameAliasTextAndTokenDigest * SOAP_FMAC4 soap_get___tns__submitGameAliasTextAndTokenDigest(struct soap *soap, struct __tns__submitGameAliasTextAndTokenDigest *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__submitGameAliasTextAndTokenDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__submitGameAliasTextAndTokenDigest * SOAP_FMAC2 soap_instantiate___tns__submitGameAliasTextAndTokenDigest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__submitGameAliasTextAndTokenDigest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__submitGameAliasTextAndTokenDigest, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitGameAliasTextAndTokenDigest);
		if (size)
			*size = sizeof(struct __tns__submitGameAliasTextAndTokenDigest);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitGameAliasTextAndTokenDigest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__submitGameAliasTextAndTokenDigest);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__submitGameAliasTextAndTokenDigest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__submitGameAliasTextAndTokenDigest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__submitGameAliasTextAndTokenDigest %p -> %p\n", q, p));
	*(struct __tns__submitGameAliasTextAndTokenDigest*)p = *(struct __tns__submitGameAliasTextAndTokenDigest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__submitGameAlias(struct soap *soap, struct __tns__submitGameAlias *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__submitGameAlias_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__submitGameAlias(struct soap *soap, const struct __tns__submitGameAlias *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__submitGameAlias(soap, &a->tns__submitGameAlias_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__submitGameAlias(struct soap *soap, const char *tag, int id, const struct __tns__submitGameAlias *a, const char *type)
{
	if (soap_out_PointerTotns__submitGameAlias(soap, "tns:submitGameAlias", -1, &a->tns__submitGameAlias_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitGameAlias * SOAP_FMAC4 soap_in___tns__submitGameAlias(struct soap *soap, const char *tag, struct __tns__submitGameAlias *a, const char *type)
{
	size_t soap_flag_tns__submitGameAlias_ = 1;
	short soap_flag;
	a = (struct __tns__submitGameAlias *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__submitGameAlias, sizeof(struct __tns__submitGameAlias), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__submitGameAlias(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__submitGameAlias_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__submitGameAlias(soap, "tns:submitGameAlias", &a->tns__submitGameAlias_, "tns:submitGameAlias"))
				{	soap_flag_tns__submitGameAlias_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__submitGameAlias(struct soap *soap, const struct __tns__submitGameAlias *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__submitGameAlias(soap, tag?tag:"-tns:submitGameAlias", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitGameAlias * SOAP_FMAC4 soap_get___tns__submitGameAlias(struct soap *soap, struct __tns__submitGameAlias *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__submitGameAlias(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__submitGameAlias * SOAP_FMAC2 soap_instantiate___tns__submitGameAlias(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__submitGameAlias(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__submitGameAlias, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitGameAlias);
		if (size)
			*size = sizeof(struct __tns__submitGameAlias);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitGameAlias[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__submitGameAlias);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__submitGameAlias*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__submitGameAlias(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__submitGameAlias %p -> %p\n", q, p));
	*(struct __tns__submitGameAlias*)p = *(struct __tns__submitGameAlias*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__setUserLanguage(struct soap *soap, struct __tns__setUserLanguage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__setUserLanguage_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__setUserLanguage(struct soap *soap, const struct __tns__setUserLanguage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__setUserLanguage(soap, &a->tns__setUserLanguage_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__setUserLanguage(struct soap *soap, const char *tag, int id, const struct __tns__setUserLanguage *a, const char *type)
{
	if (soap_out_PointerTotns__setUserLanguage(soap, "tns:setUserLanguage", -1, &a->tns__setUserLanguage_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__setUserLanguage * SOAP_FMAC4 soap_in___tns__setUserLanguage(struct soap *soap, const char *tag, struct __tns__setUserLanguage *a, const char *type)
{
	size_t soap_flag_tns__setUserLanguage_ = 1;
	short soap_flag;
	a = (struct __tns__setUserLanguage *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__setUserLanguage, sizeof(struct __tns__setUserLanguage), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__setUserLanguage(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__setUserLanguage_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__setUserLanguage(soap, "tns:setUserLanguage", &a->tns__setUserLanguage_, "tns:setUserLanguage"))
				{	soap_flag_tns__setUserLanguage_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__setUserLanguage(struct soap *soap, const struct __tns__setUserLanguage *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__setUserLanguage(soap, tag?tag:"-tns:setUserLanguage", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__setUserLanguage * SOAP_FMAC4 soap_get___tns__setUserLanguage(struct soap *soap, struct __tns__setUserLanguage *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__setUserLanguage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__setUserLanguage * SOAP_FMAC2 soap_instantiate___tns__setUserLanguage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__setUserLanguage(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__setUserLanguage, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__setUserLanguage);
		if (size)
			*size = sizeof(struct __tns__setUserLanguage);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__setUserLanguage[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__setUserLanguage);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__setUserLanguage*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__setUserLanguage(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__setUserLanguage %p -> %p\n", q, p));
	*(struct __tns__setUserLanguage*)p = *(struct __tns__setUserLanguage*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__setUserAnonymous(struct soap *soap, struct __tns__setUserAnonymous *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__setUserAnonymous_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__setUserAnonymous(struct soap *soap, const struct __tns__setUserAnonymous *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__setUserAnonymous(soap, &a->tns__setUserAnonymous_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__setUserAnonymous(struct soap *soap, const char *tag, int id, const struct __tns__setUserAnonymous *a, const char *type)
{
	if (soap_out_PointerTotns__setUserAnonymous(soap, "tns:setUserAnonymous", -1, &a->tns__setUserAnonymous_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__setUserAnonymous * SOAP_FMAC4 soap_in___tns__setUserAnonymous(struct soap *soap, const char *tag, struct __tns__setUserAnonymous *a, const char *type)
{
	size_t soap_flag_tns__setUserAnonymous_ = 1;
	short soap_flag;
	a = (struct __tns__setUserAnonymous *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__setUserAnonymous, sizeof(struct __tns__setUserAnonymous), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__setUserAnonymous(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__setUserAnonymous_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__setUserAnonymous(soap, "tns:setUserAnonymous", &a->tns__setUserAnonymous_, "tns:setUserAnonymous"))
				{	soap_flag_tns__setUserAnonymous_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__setUserAnonymous(struct soap *soap, const struct __tns__setUserAnonymous *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__setUserAnonymous(soap, tag?tag:"-tns:setUserAnonymous", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__setUserAnonymous * SOAP_FMAC4 soap_get___tns__setUserAnonymous(struct soap *soap, struct __tns__setUserAnonymous *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__setUserAnonymous(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__setUserAnonymous * SOAP_FMAC2 soap_instantiate___tns__setUserAnonymous(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__setUserAnonymous(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__setUserAnonymous, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__setUserAnonymous);
		if (size)
			*size = sizeof(struct __tns__setUserAnonymous);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__setUserAnonymous[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__setUserAnonymous);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__setUserAnonymous*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__setUserAnonymous(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__setUserAnonymous %p -> %p\n", q, p));
	*(struct __tns__setUserAnonymous*)p = *(struct __tns__setUserAnonymous*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__selectUser(struct soap *soap, struct __tns__selectUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__selectUser_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__selectUser(struct soap *soap, const struct __tns__selectUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__selectUser(soap, &a->tns__selectUser_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__selectUser(struct soap *soap, const char *tag, int id, const struct __tns__selectUser *a, const char *type)
{
	if (soap_out_PointerTotns__selectUser(soap, "tns:selectUser", -1, &a->tns__selectUser_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectUser * SOAP_FMAC4 soap_in___tns__selectUser(struct soap *soap, const char *tag, struct __tns__selectUser *a, const char *type)
{
	size_t soap_flag_tns__selectUser_ = 1;
	short soap_flag;
	a = (struct __tns__selectUser *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__selectUser, sizeof(struct __tns__selectUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__selectUser(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__selectUser_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__selectUser(soap, "tns:selectUser", &a->tns__selectUser_, "tns:selectUser"))
				{	soap_flag_tns__selectUser_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__selectUser(struct soap *soap, const struct __tns__selectUser *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__selectUser(soap, tag?tag:"-tns:selectUser", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectUser * SOAP_FMAC4 soap_get___tns__selectUser(struct soap *soap, struct __tns__selectUser *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__selectUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__selectUser * SOAP_FMAC2 soap_instantiate___tns__selectUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__selectUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__selectUser, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectUser);
		if (size)
			*size = sizeof(struct __tns__selectUser);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectUser[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__selectUser);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__selectUser*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__selectUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__selectUser %p -> %p\n", q, p));
	*(struct __tns__selectUser*)p = *(struct __tns__selectUser*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, struct __tns__selectRelatedMediaAnnotationsWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__selectRelatedMediaAnnotationsWithTokenId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, const struct __tns__selectRelatedMediaAnnotationsWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__selectRelatedMediaAnnotationsWithTokenId(soap, &a->tns__selectRelatedMediaAnnotationsWithTokenId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, const char *tag, int id, const struct __tns__selectRelatedMediaAnnotationsWithTokenId *a, const char *type)
{
	if (soap_out_PointerTotns__selectRelatedMediaAnnotationsWithTokenId(soap, "tns:selectRelatedMediaAnnotationsWithTokenId", -1, &a->tns__selectRelatedMediaAnnotationsWithTokenId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectRelatedMediaAnnotationsWithTokenId * SOAP_FMAC4 soap_in___tns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, const char *tag, struct __tns__selectRelatedMediaAnnotationsWithTokenId *a, const char *type)
{
	size_t soap_flag_tns__selectRelatedMediaAnnotationsWithTokenId_ = 1;
	short soap_flag;
	a = (struct __tns__selectRelatedMediaAnnotationsWithTokenId *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__selectRelatedMediaAnnotationsWithTokenId, sizeof(struct __tns__selectRelatedMediaAnnotationsWithTokenId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__selectRelatedMediaAnnotationsWithTokenId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__selectRelatedMediaAnnotationsWithTokenId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__selectRelatedMediaAnnotationsWithTokenId(soap, "tns:selectRelatedMediaAnnotationsWithTokenId", &a->tns__selectRelatedMediaAnnotationsWithTokenId_, "tns:selectRelatedMediaAnnotationsWithTokenId"))
				{	soap_flag_tns__selectRelatedMediaAnnotationsWithTokenId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, const struct __tns__selectRelatedMediaAnnotationsWithTokenId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__selectRelatedMediaAnnotationsWithTokenId(soap, tag?tag:"-tns:selectRelatedMediaAnnotationsWithTokenId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectRelatedMediaAnnotationsWithTokenId * SOAP_FMAC4 soap_get___tns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, struct __tns__selectRelatedMediaAnnotationsWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__selectRelatedMediaAnnotationsWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__selectRelatedMediaAnnotationsWithTokenId * SOAP_FMAC2 soap_instantiate___tns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__selectRelatedMediaAnnotationsWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__selectRelatedMediaAnnotationsWithTokenId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectRelatedMediaAnnotationsWithTokenId);
		if (size)
			*size = sizeof(struct __tns__selectRelatedMediaAnnotationsWithTokenId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectRelatedMediaAnnotationsWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__selectRelatedMediaAnnotationsWithTokenId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__selectRelatedMediaAnnotationsWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__selectRelatedMediaAnnotationsWithTokenId %p -> %p\n", q, p));
	*(struct __tns__selectRelatedMediaAnnotationsWithTokenId*)p = *(struct __tns__selectRelatedMediaAnnotationsWithTokenId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__selectRelatedGameAnnotationsWithTokenId(struct soap *soap, struct __tns__selectRelatedGameAnnotationsWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__selectRelatedGameAnnotationsWithTokenId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__selectRelatedGameAnnotationsWithTokenId(struct soap *soap, const struct __tns__selectRelatedGameAnnotationsWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__selectRelatedGameAnnotationsWithTokenId(soap, &a->tns__selectRelatedGameAnnotationsWithTokenId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__selectRelatedGameAnnotationsWithTokenId(struct soap *soap, const char *tag, int id, const struct __tns__selectRelatedGameAnnotationsWithTokenId *a, const char *type)
{
	if (soap_out_PointerTotns__selectRelatedGameAnnotationsWithTokenId(soap, "tns:selectRelatedGameAnnotationsWithTokenId", -1, &a->tns__selectRelatedGameAnnotationsWithTokenId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectRelatedGameAnnotationsWithTokenId * SOAP_FMAC4 soap_in___tns__selectRelatedGameAnnotationsWithTokenId(struct soap *soap, const char *tag, struct __tns__selectRelatedGameAnnotationsWithTokenId *a, const char *type)
{
	size_t soap_flag_tns__selectRelatedGameAnnotationsWithTokenId_ = 1;
	short soap_flag;
	a = (struct __tns__selectRelatedGameAnnotationsWithTokenId *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__selectRelatedGameAnnotationsWithTokenId, sizeof(struct __tns__selectRelatedGameAnnotationsWithTokenId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__selectRelatedGameAnnotationsWithTokenId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__selectRelatedGameAnnotationsWithTokenId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__selectRelatedGameAnnotationsWithTokenId(soap, "tns:selectRelatedGameAnnotationsWithTokenId", &a->tns__selectRelatedGameAnnotationsWithTokenId_, "tns:selectRelatedGameAnnotationsWithTokenId"))
				{	soap_flag_tns__selectRelatedGameAnnotationsWithTokenId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__selectRelatedGameAnnotationsWithTokenId(struct soap *soap, const struct __tns__selectRelatedGameAnnotationsWithTokenId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__selectRelatedGameAnnotationsWithTokenId(soap, tag?tag:"-tns:selectRelatedGameAnnotationsWithTokenId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectRelatedGameAnnotationsWithTokenId * SOAP_FMAC4 soap_get___tns__selectRelatedGameAnnotationsWithTokenId(struct soap *soap, struct __tns__selectRelatedGameAnnotationsWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__selectRelatedGameAnnotationsWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__selectRelatedGameAnnotationsWithTokenId * SOAP_FMAC2 soap_instantiate___tns__selectRelatedGameAnnotationsWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__selectRelatedGameAnnotationsWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__selectRelatedGameAnnotationsWithTokenId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectRelatedGameAnnotationsWithTokenId);
		if (size)
			*size = sizeof(struct __tns__selectRelatedGameAnnotationsWithTokenId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectRelatedGameAnnotationsWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__selectRelatedGameAnnotationsWithTokenId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__selectRelatedGameAnnotationsWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__selectRelatedGameAnnotationsWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__selectRelatedGameAnnotationsWithTokenId %p -> %p\n", q, p));
	*(struct __tns__selectRelatedGameAnnotationsWithTokenId*)p = *(struct __tns__selectRelatedGameAnnotationsWithTokenId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__selectMediaTokenWithId(struct soap *soap, struct __tns__selectMediaTokenWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__selectMediaTokenWithId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__selectMediaTokenWithId(struct soap *soap, const struct __tns__selectMediaTokenWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__selectMediaTokenWithId(soap, &a->tns__selectMediaTokenWithId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__selectMediaTokenWithId(struct soap *soap, const char *tag, int id, const struct __tns__selectMediaTokenWithId *a, const char *type)
{
	if (soap_out_PointerTotns__selectMediaTokenWithId(soap, "tns:selectMediaTokenWithId", -1, &a->tns__selectMediaTokenWithId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectMediaTokenWithId * SOAP_FMAC4 soap_in___tns__selectMediaTokenWithId(struct soap *soap, const char *tag, struct __tns__selectMediaTokenWithId *a, const char *type)
{
	size_t soap_flag_tns__selectMediaTokenWithId_ = 1;
	short soap_flag;
	a = (struct __tns__selectMediaTokenWithId *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__selectMediaTokenWithId, sizeof(struct __tns__selectMediaTokenWithId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__selectMediaTokenWithId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__selectMediaTokenWithId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__selectMediaTokenWithId(soap, "tns:selectMediaTokenWithId", &a->tns__selectMediaTokenWithId_, "tns:selectMediaTokenWithId"))
				{	soap_flag_tns__selectMediaTokenWithId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__selectMediaTokenWithId(struct soap *soap, const struct __tns__selectMediaTokenWithId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__selectMediaTokenWithId(soap, tag?tag:"-tns:selectMediaTokenWithId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectMediaTokenWithId * SOAP_FMAC4 soap_get___tns__selectMediaTokenWithId(struct soap *soap, struct __tns__selectMediaTokenWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__selectMediaTokenWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__selectMediaTokenWithId * SOAP_FMAC2 soap_instantiate___tns__selectMediaTokenWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__selectMediaTokenWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__selectMediaTokenWithId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectMediaTokenWithId);
		if (size)
			*size = sizeof(struct __tns__selectMediaTokenWithId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectMediaTokenWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__selectMediaTokenWithId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__selectMediaTokenWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__selectMediaTokenWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__selectMediaTokenWithId %p -> %p\n", q, p));
	*(struct __tns__selectMediaTokenWithId*)p = *(struct __tns__selectMediaTokenWithId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__selectMediaTokenWithDigest(struct soap *soap, struct __tns__selectMediaTokenWithDigest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__selectMediaTokenWithDigest_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__selectMediaTokenWithDigest(struct soap *soap, const struct __tns__selectMediaTokenWithDigest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__selectMediaTokenWithDigest(soap, &a->tns__selectMediaTokenWithDigest_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__selectMediaTokenWithDigest(struct soap *soap, const char *tag, int id, const struct __tns__selectMediaTokenWithDigest *a, const char *type)
{
	if (soap_out_PointerTotns__selectMediaTokenWithDigest(soap, "tns:selectMediaTokenWithDigest", -1, &a->tns__selectMediaTokenWithDigest_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectMediaTokenWithDigest * SOAP_FMAC4 soap_in___tns__selectMediaTokenWithDigest(struct soap *soap, const char *tag, struct __tns__selectMediaTokenWithDigest *a, const char *type)
{
	size_t soap_flag_tns__selectMediaTokenWithDigest_ = 1;
	short soap_flag;
	a = (struct __tns__selectMediaTokenWithDigest *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__selectMediaTokenWithDigest, sizeof(struct __tns__selectMediaTokenWithDigest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__selectMediaTokenWithDigest(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__selectMediaTokenWithDigest_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__selectMediaTokenWithDigest(soap, "tns:selectMediaTokenWithDigest", &a->tns__selectMediaTokenWithDigest_, "tns:selectMediaTokenWithDigest"))
				{	soap_flag_tns__selectMediaTokenWithDigest_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__selectMediaTokenWithDigest(struct soap *soap, const struct __tns__selectMediaTokenWithDigest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__selectMediaTokenWithDigest(soap, tag?tag:"-tns:selectMediaTokenWithDigest", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectMediaTokenWithDigest * SOAP_FMAC4 soap_get___tns__selectMediaTokenWithDigest(struct soap *soap, struct __tns__selectMediaTokenWithDigest *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__selectMediaTokenWithDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__selectMediaTokenWithDigest * SOAP_FMAC2 soap_instantiate___tns__selectMediaTokenWithDigest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__selectMediaTokenWithDigest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__selectMediaTokenWithDigest, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectMediaTokenWithDigest);
		if (size)
			*size = sizeof(struct __tns__selectMediaTokenWithDigest);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectMediaTokenWithDigest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__selectMediaTokenWithDigest);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__selectMediaTokenWithDigest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__selectMediaTokenWithDigest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__selectMediaTokenWithDigest %p -> %p\n", q, p));
	*(struct __tns__selectMediaTokenWithDigest*)p = *(struct __tns__selectMediaTokenWithDigest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__selectMediaAnnotationsWithTokenId(struct soap *soap, struct __tns__selectMediaAnnotationsWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__selectMediaAnnotationsWithTokenId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__selectMediaAnnotationsWithTokenId(struct soap *soap, const struct __tns__selectMediaAnnotationsWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__selectMediaAnnotationsWithTokenId(soap, &a->tns__selectMediaAnnotationsWithTokenId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__selectMediaAnnotationsWithTokenId(struct soap *soap, const char *tag, int id, const struct __tns__selectMediaAnnotationsWithTokenId *a, const char *type)
{
	if (soap_out_PointerTotns__selectMediaAnnotationsWithTokenId(soap, "tns:selectMediaAnnotationsWithTokenId", -1, &a->tns__selectMediaAnnotationsWithTokenId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectMediaAnnotationsWithTokenId * SOAP_FMAC4 soap_in___tns__selectMediaAnnotationsWithTokenId(struct soap *soap, const char *tag, struct __tns__selectMediaAnnotationsWithTokenId *a, const char *type)
{
	size_t soap_flag_tns__selectMediaAnnotationsWithTokenId_ = 1;
	short soap_flag;
	a = (struct __tns__selectMediaAnnotationsWithTokenId *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__selectMediaAnnotationsWithTokenId, sizeof(struct __tns__selectMediaAnnotationsWithTokenId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__selectMediaAnnotationsWithTokenId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__selectMediaAnnotationsWithTokenId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__selectMediaAnnotationsWithTokenId(soap, "tns:selectMediaAnnotationsWithTokenId", &a->tns__selectMediaAnnotationsWithTokenId_, "tns:selectMediaAnnotationsWithTokenId"))
				{	soap_flag_tns__selectMediaAnnotationsWithTokenId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__selectMediaAnnotationsWithTokenId(struct soap *soap, const struct __tns__selectMediaAnnotationsWithTokenId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__selectMediaAnnotationsWithTokenId(soap, tag?tag:"-tns:selectMediaAnnotationsWithTokenId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectMediaAnnotationsWithTokenId * SOAP_FMAC4 soap_get___tns__selectMediaAnnotationsWithTokenId(struct soap *soap, struct __tns__selectMediaAnnotationsWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__selectMediaAnnotationsWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__selectMediaAnnotationsWithTokenId * SOAP_FMAC2 soap_instantiate___tns__selectMediaAnnotationsWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__selectMediaAnnotationsWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__selectMediaAnnotationsWithTokenId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectMediaAnnotationsWithTokenId);
		if (size)
			*size = sizeof(struct __tns__selectMediaAnnotationsWithTokenId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectMediaAnnotationsWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__selectMediaAnnotationsWithTokenId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__selectMediaAnnotationsWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__selectMediaAnnotationsWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__selectMediaAnnotationsWithTokenId %p -> %p\n", q, p));
	*(struct __tns__selectMediaAnnotationsWithTokenId*)p = *(struct __tns__selectMediaAnnotationsWithTokenId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__selectMediaAliasesWithTokenId(struct soap *soap, struct __tns__selectMediaAliasesWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__selectMediaAliasesWithTokenId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__selectMediaAliasesWithTokenId(struct soap *soap, const struct __tns__selectMediaAliasesWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__selectMediaAliasesWithTokenId(soap, &a->tns__selectMediaAliasesWithTokenId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__selectMediaAliasesWithTokenId(struct soap *soap, const char *tag, int id, const struct __tns__selectMediaAliasesWithTokenId *a, const char *type)
{
	if (soap_out_PointerTotns__selectMediaAliasesWithTokenId(soap, "tns:selectMediaAliasesWithTokenId", -1, &a->tns__selectMediaAliasesWithTokenId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectMediaAliasesWithTokenId * SOAP_FMAC4 soap_in___tns__selectMediaAliasesWithTokenId(struct soap *soap, const char *tag, struct __tns__selectMediaAliasesWithTokenId *a, const char *type)
{
	size_t soap_flag_tns__selectMediaAliasesWithTokenId_ = 1;
	short soap_flag;
	a = (struct __tns__selectMediaAliasesWithTokenId *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__selectMediaAliasesWithTokenId, sizeof(struct __tns__selectMediaAliasesWithTokenId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__selectMediaAliasesWithTokenId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__selectMediaAliasesWithTokenId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__selectMediaAliasesWithTokenId(soap, "tns:selectMediaAliasesWithTokenId", &a->tns__selectMediaAliasesWithTokenId_, "tns:selectMediaAliasesWithTokenId"))
				{	soap_flag_tns__selectMediaAliasesWithTokenId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__selectMediaAliasesWithTokenId(struct soap *soap, const struct __tns__selectMediaAliasesWithTokenId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__selectMediaAliasesWithTokenId(soap, tag?tag:"-tns:selectMediaAliasesWithTokenId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectMediaAliasesWithTokenId * SOAP_FMAC4 soap_get___tns__selectMediaAliasesWithTokenId(struct soap *soap, struct __tns__selectMediaAliasesWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__selectMediaAliasesWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__selectMediaAliasesWithTokenId * SOAP_FMAC2 soap_instantiate___tns__selectMediaAliasesWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__selectMediaAliasesWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__selectMediaAliasesWithTokenId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectMediaAliasesWithTokenId);
		if (size)
			*size = sizeof(struct __tns__selectMediaAliasesWithTokenId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectMediaAliasesWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__selectMediaAliasesWithTokenId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__selectMediaAliasesWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__selectMediaAliasesWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__selectMediaAliasesWithTokenId %p -> %p\n", q, p));
	*(struct __tns__selectMediaAliasesWithTokenId*)p = *(struct __tns__selectMediaAliasesWithTokenId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__selectGameTokenWithId(struct soap *soap, struct __tns__selectGameTokenWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__selectGameTokenWithId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__selectGameTokenWithId(struct soap *soap, const struct __tns__selectGameTokenWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__selectGameTokenWithId(soap, &a->tns__selectGameTokenWithId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__selectGameTokenWithId(struct soap *soap, const char *tag, int id, const struct __tns__selectGameTokenWithId *a, const char *type)
{
	if (soap_out_PointerTotns__selectGameTokenWithId(soap, "tns:selectGameTokenWithId", -1, &a->tns__selectGameTokenWithId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectGameTokenWithId * SOAP_FMAC4 soap_in___tns__selectGameTokenWithId(struct soap *soap, const char *tag, struct __tns__selectGameTokenWithId *a, const char *type)
{
	size_t soap_flag_tns__selectGameTokenWithId_ = 1;
	short soap_flag;
	a = (struct __tns__selectGameTokenWithId *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__selectGameTokenWithId, sizeof(struct __tns__selectGameTokenWithId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__selectGameTokenWithId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__selectGameTokenWithId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__selectGameTokenWithId(soap, "tns:selectGameTokenWithId", &a->tns__selectGameTokenWithId_, "tns:selectGameTokenWithId"))
				{	soap_flag_tns__selectGameTokenWithId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__selectGameTokenWithId(struct soap *soap, const struct __tns__selectGameTokenWithId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__selectGameTokenWithId(soap, tag?tag:"-tns:selectGameTokenWithId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectGameTokenWithId * SOAP_FMAC4 soap_get___tns__selectGameTokenWithId(struct soap *soap, struct __tns__selectGameTokenWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__selectGameTokenWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__selectGameTokenWithId * SOAP_FMAC2 soap_instantiate___tns__selectGameTokenWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__selectGameTokenWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__selectGameTokenWithId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectGameTokenWithId);
		if (size)
			*size = sizeof(struct __tns__selectGameTokenWithId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectGameTokenWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__selectGameTokenWithId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__selectGameTokenWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__selectGameTokenWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__selectGameTokenWithId %p -> %p\n", q, p));
	*(struct __tns__selectGameTokenWithId*)p = *(struct __tns__selectGameTokenWithId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__selectGameTokenWithDigest(struct soap *soap, struct __tns__selectGameTokenWithDigest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__selectGameTokenWithDigest_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__selectGameTokenWithDigest(struct soap *soap, const struct __tns__selectGameTokenWithDigest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__selectGameTokenWithDigest(soap, &a->tns__selectGameTokenWithDigest_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__selectGameTokenWithDigest(struct soap *soap, const char *tag, int id, const struct __tns__selectGameTokenWithDigest *a, const char *type)
{
	if (soap_out_PointerTotns__selectGameTokenWithDigest(soap, "tns:selectGameTokenWithDigest", -1, &a->tns__selectGameTokenWithDigest_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectGameTokenWithDigest * SOAP_FMAC4 soap_in___tns__selectGameTokenWithDigest(struct soap *soap, const char *tag, struct __tns__selectGameTokenWithDigest *a, const char *type)
{
	size_t soap_flag_tns__selectGameTokenWithDigest_ = 1;
	short soap_flag;
	a = (struct __tns__selectGameTokenWithDigest *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__selectGameTokenWithDigest, sizeof(struct __tns__selectGameTokenWithDigest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__selectGameTokenWithDigest(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__selectGameTokenWithDigest_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__selectGameTokenWithDigest(soap, "tns:selectGameTokenWithDigest", &a->tns__selectGameTokenWithDigest_, "tns:selectGameTokenWithDigest"))
				{	soap_flag_tns__selectGameTokenWithDigest_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__selectGameTokenWithDigest(struct soap *soap, const struct __tns__selectGameTokenWithDigest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__selectGameTokenWithDigest(soap, tag?tag:"-tns:selectGameTokenWithDigest", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectGameTokenWithDigest * SOAP_FMAC4 soap_get___tns__selectGameTokenWithDigest(struct soap *soap, struct __tns__selectGameTokenWithDigest *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__selectGameTokenWithDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__selectGameTokenWithDigest * SOAP_FMAC2 soap_instantiate___tns__selectGameTokenWithDigest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__selectGameTokenWithDigest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__selectGameTokenWithDigest, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectGameTokenWithDigest);
		if (size)
			*size = sizeof(struct __tns__selectGameTokenWithDigest);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectGameTokenWithDigest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__selectGameTokenWithDigest);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__selectGameTokenWithDigest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__selectGameTokenWithDigest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__selectGameTokenWithDigest %p -> %p\n", q, p));
	*(struct __tns__selectGameTokenWithDigest*)p = *(struct __tns__selectGameTokenWithDigest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__selectGameAnnotationsWithTokenId(struct soap *soap, struct __tns__selectGameAnnotationsWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__selectGameAnnotationsWithTokenId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__selectGameAnnotationsWithTokenId(struct soap *soap, const struct __tns__selectGameAnnotationsWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__selectGameAnnotationsWithTokenId(soap, &a->tns__selectGameAnnotationsWithTokenId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__selectGameAnnotationsWithTokenId(struct soap *soap, const char *tag, int id, const struct __tns__selectGameAnnotationsWithTokenId *a, const char *type)
{
	if (soap_out_PointerTotns__selectGameAnnotationsWithTokenId(soap, "tns:selectGameAnnotationsWithTokenId", -1, &a->tns__selectGameAnnotationsWithTokenId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectGameAnnotationsWithTokenId * SOAP_FMAC4 soap_in___tns__selectGameAnnotationsWithTokenId(struct soap *soap, const char *tag, struct __tns__selectGameAnnotationsWithTokenId *a, const char *type)
{
	size_t soap_flag_tns__selectGameAnnotationsWithTokenId_ = 1;
	short soap_flag;
	a = (struct __tns__selectGameAnnotationsWithTokenId *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__selectGameAnnotationsWithTokenId, sizeof(struct __tns__selectGameAnnotationsWithTokenId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__selectGameAnnotationsWithTokenId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__selectGameAnnotationsWithTokenId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__selectGameAnnotationsWithTokenId(soap, "tns:selectGameAnnotationsWithTokenId", &a->tns__selectGameAnnotationsWithTokenId_, "tns:selectGameAnnotationsWithTokenId"))
				{	soap_flag_tns__selectGameAnnotationsWithTokenId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__selectGameAnnotationsWithTokenId(struct soap *soap, const struct __tns__selectGameAnnotationsWithTokenId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__selectGameAnnotationsWithTokenId(soap, tag?tag:"-tns:selectGameAnnotationsWithTokenId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectGameAnnotationsWithTokenId * SOAP_FMAC4 soap_get___tns__selectGameAnnotationsWithTokenId(struct soap *soap, struct __tns__selectGameAnnotationsWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__selectGameAnnotationsWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__selectGameAnnotationsWithTokenId * SOAP_FMAC2 soap_instantiate___tns__selectGameAnnotationsWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__selectGameAnnotationsWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__selectGameAnnotationsWithTokenId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectGameAnnotationsWithTokenId);
		if (size)
			*size = sizeof(struct __tns__selectGameAnnotationsWithTokenId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectGameAnnotationsWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__selectGameAnnotationsWithTokenId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__selectGameAnnotationsWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__selectGameAnnotationsWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__selectGameAnnotationsWithTokenId %p -> %p\n", q, p));
	*(struct __tns__selectGameAnnotationsWithTokenId*)p = *(struct __tns__selectGameAnnotationsWithTokenId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__selectGameAliasesWithTokenId(struct soap *soap, struct __tns__selectGameAliasesWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__selectGameAliasesWithTokenId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__selectGameAliasesWithTokenId(struct soap *soap, const struct __tns__selectGameAliasesWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__selectGameAliasesWithTokenId(soap, &a->tns__selectGameAliasesWithTokenId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__selectGameAliasesWithTokenId(struct soap *soap, const char *tag, int id, const struct __tns__selectGameAliasesWithTokenId *a, const char *type)
{
	if (soap_out_PointerTotns__selectGameAliasesWithTokenId(soap, "tns:selectGameAliasesWithTokenId", -1, &a->tns__selectGameAliasesWithTokenId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectGameAliasesWithTokenId * SOAP_FMAC4 soap_in___tns__selectGameAliasesWithTokenId(struct soap *soap, const char *tag, struct __tns__selectGameAliasesWithTokenId *a, const char *type)
{
	size_t soap_flag_tns__selectGameAliasesWithTokenId_ = 1;
	short soap_flag;
	a = (struct __tns__selectGameAliasesWithTokenId *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__selectGameAliasesWithTokenId, sizeof(struct __tns__selectGameAliasesWithTokenId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__selectGameAliasesWithTokenId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__selectGameAliasesWithTokenId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__selectGameAliasesWithTokenId(soap, "tns:selectGameAliasesWithTokenId", &a->tns__selectGameAliasesWithTokenId_, "tns:selectGameAliasesWithTokenId"))
				{	soap_flag_tns__selectGameAliasesWithTokenId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__selectGameAliasesWithTokenId(struct soap *soap, const struct __tns__selectGameAliasesWithTokenId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__selectGameAliasesWithTokenId(soap, tag?tag:"-tns:selectGameAliasesWithTokenId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectGameAliasesWithTokenId * SOAP_FMAC4 soap_get___tns__selectGameAliasesWithTokenId(struct soap *soap, struct __tns__selectGameAliasesWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__selectGameAliasesWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__selectGameAliasesWithTokenId * SOAP_FMAC2 soap_instantiate___tns__selectGameAliasesWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__selectGameAliasesWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__selectGameAliasesWithTokenId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectGameAliasesWithTokenId);
		if (size)
			*size = sizeof(struct __tns__selectGameAliasesWithTokenId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectGameAliasesWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__selectGameAliasesWithTokenId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__selectGameAliasesWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__selectGameAliasesWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__selectGameAliasesWithTokenId %p -> %p\n", q, p));
	*(struct __tns__selectGameAliasesWithTokenId*)p = *(struct __tns__selectGameAliasesWithTokenId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__isConnected(struct soap *soap, struct __tns__isConnected *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__isConnected_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__isConnected(struct soap *soap, const struct __tns__isConnected *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__isConnected(soap, &a->tns__isConnected_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__isConnected(struct soap *soap, const char *tag, int id, const struct __tns__isConnected *a, const char *type)
{
	if (soap_out_PointerTotns__isConnected(soap, "tns:isConnected", -1, &a->tns__isConnected_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__isConnected * SOAP_FMAC4 soap_in___tns__isConnected(struct soap *soap, const char *tag, struct __tns__isConnected *a, const char *type)
{
	size_t soap_flag_tns__isConnected_ = 1;
	short soap_flag;
	a = (struct __tns__isConnected *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__isConnected, sizeof(struct __tns__isConnected), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__isConnected(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__isConnected_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__isConnected(soap, "tns:isConnected", &a->tns__isConnected_, "tns:isConnected"))
				{	soap_flag_tns__isConnected_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__isConnected(struct soap *soap, const struct __tns__isConnected *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__isConnected(soap, tag?tag:"-tns:isConnected", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__isConnected * SOAP_FMAC4 soap_get___tns__isConnected(struct soap *soap, struct __tns__isConnected *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__isConnected(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__isConnected * SOAP_FMAC2 soap_instantiate___tns__isConnected(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__isConnected(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__isConnected, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__isConnected);
		if (size)
			*size = sizeof(struct __tns__isConnected);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__isConnected[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__isConnected);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__isConnected*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__isConnected(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__isConnected %p -> %p\n", q, p));
	*(struct __tns__isConnected*)p = *(struct __tns__isConnected*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__isClientUpdated(struct soap *soap, struct __tns__isClientUpdated *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__isClientUpdated_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__isClientUpdated(struct soap *soap, const struct __tns__isClientUpdated *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__isClientUpdated(soap, &a->tns__isClientUpdated_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__isClientUpdated(struct soap *soap, const char *tag, int id, const struct __tns__isClientUpdated *a, const char *type)
{
	if (soap_out_PointerTotns__isClientUpdated(soap, "tns:isClientUpdated", -1, &a->tns__isClientUpdated_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__isClientUpdated * SOAP_FMAC4 soap_in___tns__isClientUpdated(struct soap *soap, const char *tag, struct __tns__isClientUpdated *a, const char *type)
{
	size_t soap_flag_tns__isClientUpdated_ = 1;
	short soap_flag;
	a = (struct __tns__isClientUpdated *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__isClientUpdated, sizeof(struct __tns__isClientUpdated), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__isClientUpdated(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__isClientUpdated_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__isClientUpdated(soap, "tns:isClientUpdated", &a->tns__isClientUpdated_, "tns:isClientUpdated"))
				{	soap_flag_tns__isClientUpdated_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__isClientUpdated(struct soap *soap, const struct __tns__isClientUpdated *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__isClientUpdated(soap, tag?tag:"-tns:isClientUpdated", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__isClientUpdated * SOAP_FMAC4 soap_get___tns__isClientUpdated(struct soap *soap, struct __tns__isClientUpdated *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__isClientUpdated(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__isClientUpdated * SOAP_FMAC2 soap_instantiate___tns__isClientUpdated(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__isClientUpdated(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__isClientUpdated, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__isClientUpdated);
		if (size)
			*size = sizeof(struct __tns__isClientUpdated);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__isClientUpdated[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__isClientUpdated);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__isClientUpdated*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__isClientUpdated(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__isClientUpdated %p -> %p\n", q, p));
	*(struct __tns__isClientUpdated*)p = *(struct __tns__isClientUpdated*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__chat(struct soap *soap, struct __tns__chat *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__chat_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__chat(struct soap *soap, const struct __tns__chat *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__chat(soap, &a->tns__chat_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__chat(struct soap *soap, const char *tag, int id, const struct __tns__chat *a, const char *type)
{
	if (soap_out_PointerTotns__chat(soap, "tns:chat", -1, &a->tns__chat_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__chat * SOAP_FMAC4 soap_in___tns__chat(struct soap *soap, const char *tag, struct __tns__chat *a, const char *type)
{
	size_t soap_flag_tns__chat_ = 1;
	short soap_flag;
	a = (struct __tns__chat *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__chat, sizeof(struct __tns__chat), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__chat(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__chat_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__chat(soap, "tns:chat", &a->tns__chat_, "tns:chat"))
				{	soap_flag_tns__chat_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__chat(struct soap *soap, const struct __tns__chat *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__chat(soap, tag?tag:"-tns:chat", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__chat * SOAP_FMAC4 soap_get___tns__chat(struct soap *soap, struct __tns__chat *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__chat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__chat * SOAP_FMAC2 soap_instantiate___tns__chat(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__chat(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__chat, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__chat);
		if (size)
			*size = sizeof(struct __tns__chat);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__chat[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__chat);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__chat*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__chat(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__chat %p -> %p\n", q, p));
	*(struct __tns__chat*)p = *(struct __tns__chat*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__blessMediaAnnotationWithId(struct soap *soap, struct __tns__blessMediaAnnotationWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__blessMediaAnnotationWithId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__blessMediaAnnotationWithId(struct soap *soap, const struct __tns__blessMediaAnnotationWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__blessMediaAnnotationWithId(soap, &a->tns__blessMediaAnnotationWithId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__blessMediaAnnotationWithId(struct soap *soap, const char *tag, int id, const struct __tns__blessMediaAnnotationWithId *a, const char *type)
{
	if (soap_out_PointerTotns__blessMediaAnnotationWithId(soap, "tns:blessMediaAnnotationWithId", -1, &a->tns__blessMediaAnnotationWithId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__blessMediaAnnotationWithId * SOAP_FMAC4 soap_in___tns__blessMediaAnnotationWithId(struct soap *soap, const char *tag, struct __tns__blessMediaAnnotationWithId *a, const char *type)
{
	size_t soap_flag_tns__blessMediaAnnotationWithId_ = 1;
	short soap_flag;
	a = (struct __tns__blessMediaAnnotationWithId *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__blessMediaAnnotationWithId, sizeof(struct __tns__blessMediaAnnotationWithId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__blessMediaAnnotationWithId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__blessMediaAnnotationWithId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__blessMediaAnnotationWithId(soap, "tns:blessMediaAnnotationWithId", &a->tns__blessMediaAnnotationWithId_, "tns:blessMediaAnnotationWithId"))
				{	soap_flag_tns__blessMediaAnnotationWithId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__blessMediaAnnotationWithId(struct soap *soap, const struct __tns__blessMediaAnnotationWithId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__blessMediaAnnotationWithId(soap, tag?tag:"-tns:blessMediaAnnotationWithId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__blessMediaAnnotationWithId * SOAP_FMAC4 soap_get___tns__blessMediaAnnotationWithId(struct soap *soap, struct __tns__blessMediaAnnotationWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__blessMediaAnnotationWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__blessMediaAnnotationWithId * SOAP_FMAC2 soap_instantiate___tns__blessMediaAnnotationWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__blessMediaAnnotationWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__blessMediaAnnotationWithId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__blessMediaAnnotationWithId);
		if (size)
			*size = sizeof(struct __tns__blessMediaAnnotationWithId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__blessMediaAnnotationWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__blessMediaAnnotationWithId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__blessMediaAnnotationWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__blessMediaAnnotationWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__blessMediaAnnotationWithId %p -> %p\n", q, p));
	*(struct __tns__blessMediaAnnotationWithId*)p = *(struct __tns__blessMediaAnnotationWithId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__blessGameAnnotationWithId(struct soap *soap, struct __tns__blessGameAnnotationWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__blessGameAnnotationWithId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__blessGameAnnotationWithId(struct soap *soap, const struct __tns__blessGameAnnotationWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__blessGameAnnotationWithId(soap, &a->tns__blessGameAnnotationWithId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__blessGameAnnotationWithId(struct soap *soap, const char *tag, int id, const struct __tns__blessGameAnnotationWithId *a, const char *type)
{
	if (soap_out_PointerTotns__blessGameAnnotationWithId(soap, "tns:blessGameAnnotationWithId", -1, &a->tns__blessGameAnnotationWithId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__blessGameAnnotationWithId * SOAP_FMAC4 soap_in___tns__blessGameAnnotationWithId(struct soap *soap, const char *tag, struct __tns__blessGameAnnotationWithId *a, const char *type)
{
	size_t soap_flag_tns__blessGameAnnotationWithId_ = 1;
	short soap_flag;
	a = (struct __tns__blessGameAnnotationWithId *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__blessGameAnnotationWithId, sizeof(struct __tns__blessGameAnnotationWithId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__blessGameAnnotationWithId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__blessGameAnnotationWithId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__blessGameAnnotationWithId(soap, "tns:blessGameAnnotationWithId", &a->tns__blessGameAnnotationWithId_, "tns:blessGameAnnotationWithId"))
				{	soap_flag_tns__blessGameAnnotationWithId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__blessGameAnnotationWithId(struct soap *soap, const struct __tns__blessGameAnnotationWithId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__blessGameAnnotationWithId(soap, tag?tag:"-tns:blessGameAnnotationWithId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__blessGameAnnotationWithId * SOAP_FMAC4 soap_get___tns__blessGameAnnotationWithId(struct soap *soap, struct __tns__blessGameAnnotationWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__blessGameAnnotationWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__blessGameAnnotationWithId * SOAP_FMAC2 soap_instantiate___tns__blessGameAnnotationWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__blessGameAnnotationWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__blessGameAnnotationWithId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__blessGameAnnotationWithId);
		if (size)
			*size = sizeof(struct __tns__blessGameAnnotationWithId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__blessGameAnnotationWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__blessGameAnnotationWithId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__blessGameAnnotationWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__blessGameAnnotationWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__blessGameAnnotationWithId %p -> %p\n", q, p));
	*(struct __tns__blessGameAnnotationWithId*)p = *(struct __tns__blessGameAnnotationWithId*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__updateMediaAnnotationTextWithIdResponse(struct soap *soap, tns__updateMediaAnnotationTextWithIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__updateMediaAnnotationTextWithIdResponse(struct soap *soap, const char *tag, int id, tns__updateMediaAnnotationTextWithIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__updateMediaAnnotationTextWithIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__updateMediaAnnotationTextWithIdResponse(struct soap *soap, const char *tag, tns__updateMediaAnnotationTextWithIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__updateMediaAnnotationTextWithIdResponse **)soap_malloc(soap, sizeof(tns__updateMediaAnnotationTextWithIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__updateMediaAnnotationTextWithIdResponse *)soap_instantiate_tns__updateMediaAnnotationTextWithIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__updateMediaAnnotationTextWithIdResponse ** p = (tns__updateMediaAnnotationTextWithIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithIdResponse, sizeof(tns__updateMediaAnnotationTextWithIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__updateMediaAnnotationTextWithIdResponse(struct soap *soap, tns__updateMediaAnnotationTextWithIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__updateMediaAnnotationTextWithIdResponse);
	if (soap_out_PointerTotns__updateMediaAnnotationTextWithIdResponse(soap, tag?tag:"tns:updateMediaAnnotationTextWithIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__updateMediaAnnotationTextWithIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__updateMediaAnnotationTextWithIdResponse(struct soap *soap, tns__updateMediaAnnotationTextWithIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__updateMediaAnnotationTextWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__updateMediaAnnotationTextWithId(struct soap *soap, tns__updateMediaAnnotationTextWithId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__updateMediaAnnotationTextWithId(struct soap *soap, const char *tag, int id, tns__updateMediaAnnotationTextWithId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__updateMediaAnnotationTextWithId ** SOAP_FMAC4 soap_in_PointerTotns__updateMediaAnnotationTextWithId(struct soap *soap, const char *tag, tns__updateMediaAnnotationTextWithId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__updateMediaAnnotationTextWithId **)soap_malloc(soap, sizeof(tns__updateMediaAnnotationTextWithId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__updateMediaAnnotationTextWithId *)soap_instantiate_tns__updateMediaAnnotationTextWithId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__updateMediaAnnotationTextWithId ** p = (tns__updateMediaAnnotationTextWithId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithId, sizeof(tns__updateMediaAnnotationTextWithId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__updateMediaAnnotationTextWithId(struct soap *soap, tns__updateMediaAnnotationTextWithId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__updateMediaAnnotationTextWithId);
	if (soap_out_PointerTotns__updateMediaAnnotationTextWithId(soap, tag?tag:"tns:updateMediaAnnotationTextWithId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__updateMediaAnnotationTextWithId ** SOAP_FMAC4 soap_get_PointerTotns__updateMediaAnnotationTextWithId(struct soap *soap, tns__updateMediaAnnotationTextWithId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__updateMediaAnnotationTextWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__updateGameAnnotationTextWithIdResponse(struct soap *soap, tns__updateGameAnnotationTextWithIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__updateGameAnnotationTextWithIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__updateGameAnnotationTextWithIdResponse(struct soap *soap, const char *tag, int id, tns__updateGameAnnotationTextWithIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__updateGameAnnotationTextWithIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__updateGameAnnotationTextWithIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__updateGameAnnotationTextWithIdResponse(struct soap *soap, const char *tag, tns__updateGameAnnotationTextWithIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__updateGameAnnotationTextWithIdResponse **)soap_malloc(soap, sizeof(tns__updateGameAnnotationTextWithIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__updateGameAnnotationTextWithIdResponse *)soap_instantiate_tns__updateGameAnnotationTextWithIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__updateGameAnnotationTextWithIdResponse ** p = (tns__updateGameAnnotationTextWithIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__updateGameAnnotationTextWithIdResponse, sizeof(tns__updateGameAnnotationTextWithIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__updateGameAnnotationTextWithIdResponse(struct soap *soap, tns__updateGameAnnotationTextWithIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__updateGameAnnotationTextWithIdResponse);
	if (soap_out_PointerTotns__updateGameAnnotationTextWithIdResponse(soap, tag?tag:"tns:updateGameAnnotationTextWithIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__updateGameAnnotationTextWithIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__updateGameAnnotationTextWithIdResponse(struct soap *soap, tns__updateGameAnnotationTextWithIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__updateGameAnnotationTextWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__updateGameAnnotationTextWithId(struct soap *soap, tns__updateGameAnnotationTextWithId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__updateGameAnnotationTextWithId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__updateGameAnnotationTextWithId(struct soap *soap, const char *tag, int id, tns__updateGameAnnotationTextWithId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__updateGameAnnotationTextWithId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__updateGameAnnotationTextWithId ** SOAP_FMAC4 soap_in_PointerTotns__updateGameAnnotationTextWithId(struct soap *soap, const char *tag, tns__updateGameAnnotationTextWithId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__updateGameAnnotationTextWithId **)soap_malloc(soap, sizeof(tns__updateGameAnnotationTextWithId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__updateGameAnnotationTextWithId *)soap_instantiate_tns__updateGameAnnotationTextWithId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__updateGameAnnotationTextWithId ** p = (tns__updateGameAnnotationTextWithId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__updateGameAnnotationTextWithId, sizeof(tns__updateGameAnnotationTextWithId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__updateGameAnnotationTextWithId(struct soap *soap, tns__updateGameAnnotationTextWithId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__updateGameAnnotationTextWithId);
	if (soap_out_PointerTotns__updateGameAnnotationTextWithId(soap, tag?tag:"tns:updateGameAnnotationTextWithId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__updateGameAnnotationTextWithId ** SOAP_FMAC4 soap_get_PointerTotns__updateGameAnnotationTextWithId(struct soap *soap, tns__updateGameAnnotationTextWithId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__updateGameAnnotationTextWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaTokenDigestResponse(struct soap *soap, tns__submitMediaTokenDigestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigestResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaTokenDigestResponse(struct soap *soap, const char *tag, int id, tns__submitMediaTokenDigestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigestResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaTokenDigestResponse ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaTokenDigestResponse(struct soap *soap, const char *tag, tns__submitMediaTokenDigestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaTokenDigestResponse **)soap_malloc(soap, sizeof(tns__submitMediaTokenDigestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaTokenDigestResponse *)soap_instantiate_tns__submitMediaTokenDigestResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaTokenDigestResponse ** p = (tns__submitMediaTokenDigestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigestResponse, sizeof(tns__submitMediaTokenDigestResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaTokenDigestResponse(struct soap *soap, tns__submitMediaTokenDigestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitMediaTokenDigestResponse);
	if (soap_out_PointerTotns__submitMediaTokenDigestResponse(soap, tag?tag:"tns:submitMediaTokenDigestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaTokenDigestResponse ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaTokenDigestResponse(struct soap *soap, tns__submitMediaTokenDigestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaTokenDigestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaTokenDigest(struct soap *soap, tns__submitMediaTokenDigest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaTokenDigest(struct soap *soap, const char *tag, int id, tns__submitMediaTokenDigest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaTokenDigest ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaTokenDigest(struct soap *soap, const char *tag, tns__submitMediaTokenDigest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaTokenDigest **)soap_malloc(soap, sizeof(tns__submitMediaTokenDigest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaTokenDigest *)soap_instantiate_tns__submitMediaTokenDigest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaTokenDigest ** p = (tns__submitMediaTokenDigest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigest, sizeof(tns__submitMediaTokenDigest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaTokenDigest(struct soap *soap, tns__submitMediaTokenDigest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitMediaTokenDigest);
	if (soap_out_PointerTotns__submitMediaTokenDigest(soap, tag?tag:"tns:submitMediaTokenDigest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaTokenDigest ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaTokenDigest(struct soap *soap, tns__submitMediaTokenDigest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaTokenDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaTokenResponse(struct soap *soap, tns__submitMediaTokenResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitMediaTokenResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaTokenResponse(struct soap *soap, const char *tag, int id, tns__submitMediaTokenResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitMediaTokenResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaTokenResponse ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaTokenResponse(struct soap *soap, const char *tag, tns__submitMediaTokenResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaTokenResponse **)soap_malloc(soap, sizeof(tns__submitMediaTokenResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaTokenResponse *)soap_instantiate_tns__submitMediaTokenResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaTokenResponse ** p = (tns__submitMediaTokenResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitMediaTokenResponse, sizeof(tns__submitMediaTokenResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaTokenResponse(struct soap *soap, tns__submitMediaTokenResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitMediaTokenResponse);
	if (soap_out_PointerTotns__submitMediaTokenResponse(soap, tag?tag:"tns:submitMediaTokenResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaTokenResponse ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaTokenResponse(struct soap *soap, tns__submitMediaTokenResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaTokenResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaToken(struct soap *soap, tns__submitMediaToken *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitMediaToken))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaToken(struct soap *soap, const char *tag, int id, tns__submitMediaToken *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitMediaToken);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaToken ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaToken(struct soap *soap, const char *tag, tns__submitMediaToken **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaToken **)soap_malloc(soap, sizeof(tns__submitMediaToken *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaToken *)soap_instantiate_tns__submitMediaToken(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaToken ** p = (tns__submitMediaToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitMediaToken, sizeof(tns__submitMediaToken), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaToken(struct soap *soap, tns__submitMediaToken *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitMediaToken);
	if (soap_out_PointerTotns__submitMediaToken(soap, tag?tag:"tns:submitMediaToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaToken ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaToken(struct soap *soap, tns__submitMediaToken **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse(struct soap *soap, tns__submitMediaAnnotationTextWithTokenIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse(struct soap *soap, const char *tag, int id, tns__submitMediaAnnotationTextWithTokenIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextWithTokenIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse(struct soap *soap, const char *tag, tns__submitMediaAnnotationTextWithTokenIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaAnnotationTextWithTokenIdResponse **)soap_malloc(soap, sizeof(tns__submitMediaAnnotationTextWithTokenIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaAnnotationTextWithTokenIdResponse *)soap_instantiate_tns__submitMediaAnnotationTextWithTokenIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaAnnotationTextWithTokenIdResponse ** p = (tns__submitMediaAnnotationTextWithTokenIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenIdResponse, sizeof(tns__submitMediaAnnotationTextWithTokenIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse(struct soap *soap, tns__submitMediaAnnotationTextWithTokenIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse);
	if (soap_out_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse(soap, tag?tag:"tns:submitMediaAnnotationTextWithTokenIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextWithTokenIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse(struct soap *soap, tns__submitMediaAnnotationTextWithTokenIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaAnnotationTextWithTokenId(struct soap *soap, tns__submitMediaAnnotationTextWithTokenId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaAnnotationTextWithTokenId(struct soap *soap, const char *tag, int id, tns__submitMediaAnnotationTextWithTokenId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextWithTokenId ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaAnnotationTextWithTokenId(struct soap *soap, const char *tag, tns__submitMediaAnnotationTextWithTokenId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaAnnotationTextWithTokenId **)soap_malloc(soap, sizeof(tns__submitMediaAnnotationTextWithTokenId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaAnnotationTextWithTokenId *)soap_instantiate_tns__submitMediaAnnotationTextWithTokenId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaAnnotationTextWithTokenId ** p = (tns__submitMediaAnnotationTextWithTokenId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenId, sizeof(tns__submitMediaAnnotationTextWithTokenId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaAnnotationTextWithTokenId(struct soap *soap, tns__submitMediaAnnotationTextWithTokenId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotationTextWithTokenId);
	if (soap_out_PointerTotns__submitMediaAnnotationTextWithTokenId(soap, tag?tag:"tns:submitMediaAnnotationTextWithTokenId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextWithTokenId ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaAnnotationTextWithTokenId(struct soap *soap, tns__submitMediaAnnotationTextWithTokenId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaAnnotationTextWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse(struct soap *soap, tns__submitMediaAnnotationTextAndTokenDigestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigestResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse(struct soap *soap, const char *tag, int id, tns__submitMediaAnnotationTextAndTokenDigestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigestResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextAndTokenDigestResponse ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse(struct soap *soap, const char *tag, tns__submitMediaAnnotationTextAndTokenDigestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaAnnotationTextAndTokenDigestResponse **)soap_malloc(soap, sizeof(tns__submitMediaAnnotationTextAndTokenDigestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaAnnotationTextAndTokenDigestResponse *)soap_instantiate_tns__submitMediaAnnotationTextAndTokenDigestResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaAnnotationTextAndTokenDigestResponse ** p = (tns__submitMediaAnnotationTextAndTokenDigestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigestResponse, sizeof(tns__submitMediaAnnotationTextAndTokenDigestResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse(struct soap *soap, tns__submitMediaAnnotationTextAndTokenDigestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse);
	if (soap_out_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse(soap, tag?tag:"tns:submitMediaAnnotationTextAndTokenDigestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextAndTokenDigestResponse ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse(struct soap *soap, tns__submitMediaAnnotationTextAndTokenDigestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, tns__submitMediaAnnotationTextAndTokenDigest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, const char *tag, int id, tns__submitMediaAnnotationTextAndTokenDigest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextAndTokenDigest ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, const char *tag, tns__submitMediaAnnotationTextAndTokenDigest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaAnnotationTextAndTokenDigest **)soap_malloc(soap, sizeof(tns__submitMediaAnnotationTextAndTokenDigest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaAnnotationTextAndTokenDigest *)soap_instantiate_tns__submitMediaAnnotationTextAndTokenDigest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaAnnotationTextAndTokenDigest ** p = (tns__submitMediaAnnotationTextAndTokenDigest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigest, sizeof(tns__submitMediaAnnotationTextAndTokenDigest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, tns__submitMediaAnnotationTextAndTokenDigest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotationTextAndTokenDigest);
	if (soap_out_PointerTotns__submitMediaAnnotationTextAndTokenDigest(soap, tag?tag:"tns:submitMediaAnnotationTextAndTokenDigest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextAndTokenDigest ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, tns__submitMediaAnnotationTextAndTokenDigest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaAnnotationTextAndTokenDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaAnnotationResponse(struct soap *soap, tns__submitMediaAnnotationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaAnnotationResponse(struct soap *soap, const char *tag, int id, tns__submitMediaAnnotationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationResponse ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaAnnotationResponse(struct soap *soap, const char *tag, tns__submitMediaAnnotationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaAnnotationResponse **)soap_malloc(soap, sizeof(tns__submitMediaAnnotationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaAnnotationResponse *)soap_instantiate_tns__submitMediaAnnotationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaAnnotationResponse ** p = (tns__submitMediaAnnotationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationResponse, sizeof(tns__submitMediaAnnotationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaAnnotationResponse(struct soap *soap, tns__submitMediaAnnotationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotationResponse);
	if (soap_out_PointerTotns__submitMediaAnnotationResponse(soap, tag?tag:"tns:submitMediaAnnotationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaAnnotationResponse ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaAnnotationResponse(struct soap *soap, tns__submitMediaAnnotationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaAnnotationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaAnnotation(struct soap *soap, tns__submitMediaAnnotation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaAnnotation(struct soap *soap, const char *tag, int id, tns__submitMediaAnnotation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaAnnotation ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaAnnotation(struct soap *soap, const char *tag, tns__submitMediaAnnotation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaAnnotation **)soap_malloc(soap, sizeof(tns__submitMediaAnnotation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaAnnotation *)soap_instantiate_tns__submitMediaAnnotation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaAnnotation ** p = (tns__submitMediaAnnotation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotation, sizeof(tns__submitMediaAnnotation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaAnnotation(struct soap *soap, tns__submitMediaAnnotation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotation);
	if (soap_out_PointerTotns__submitMediaAnnotation(soap, tag?tag:"tns:submitMediaAnnotation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaAnnotation ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaAnnotation(struct soap *soap, tns__submitMediaAnnotation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaAnnotation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaAliasTextWithTokenIdResponse(struct soap *soap, tns__submitMediaAliasTextWithTokenIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaAliasTextWithTokenIdResponse(struct soap *soap, const char *tag, int id, tns__submitMediaAliasTextWithTokenIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaAliasTextWithTokenIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaAliasTextWithTokenIdResponse(struct soap *soap, const char *tag, tns__submitMediaAliasTextWithTokenIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaAliasTextWithTokenIdResponse **)soap_malloc(soap, sizeof(tns__submitMediaAliasTextWithTokenIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaAliasTextWithTokenIdResponse *)soap_instantiate_tns__submitMediaAliasTextWithTokenIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaAliasTextWithTokenIdResponse ** p = (tns__submitMediaAliasTextWithTokenIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenIdResponse, sizeof(tns__submitMediaAliasTextWithTokenIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaAliasTextWithTokenIdResponse(struct soap *soap, tns__submitMediaAliasTextWithTokenIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAliasTextWithTokenIdResponse);
	if (soap_out_PointerTotns__submitMediaAliasTextWithTokenIdResponse(soap, tag?tag:"tns:submitMediaAliasTextWithTokenIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaAliasTextWithTokenIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaAliasTextWithTokenIdResponse(struct soap *soap, tns__submitMediaAliasTextWithTokenIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaAliasTextWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaAliasTextWithTokenId(struct soap *soap, tns__submitMediaAliasTextWithTokenId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaAliasTextWithTokenId(struct soap *soap, const char *tag, int id, tns__submitMediaAliasTextWithTokenId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaAliasTextWithTokenId ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaAliasTextWithTokenId(struct soap *soap, const char *tag, tns__submitMediaAliasTextWithTokenId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaAliasTextWithTokenId **)soap_malloc(soap, sizeof(tns__submitMediaAliasTextWithTokenId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaAliasTextWithTokenId *)soap_instantiate_tns__submitMediaAliasTextWithTokenId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaAliasTextWithTokenId ** p = (tns__submitMediaAliasTextWithTokenId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenId, sizeof(tns__submitMediaAliasTextWithTokenId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaAliasTextWithTokenId(struct soap *soap, tns__submitMediaAliasTextWithTokenId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAliasTextWithTokenId);
	if (soap_out_PointerTotns__submitMediaAliasTextWithTokenId(soap, tag?tag:"tns:submitMediaAliasTextWithTokenId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaAliasTextWithTokenId ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaAliasTextWithTokenId(struct soap *soap, tns__submitMediaAliasTextWithTokenId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaAliasTextWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaAliasTextAndTokenDigestResponse(struct soap *soap, tns__submitMediaAliasTextAndTokenDigestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigestResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaAliasTextAndTokenDigestResponse(struct soap *soap, const char *tag, int id, tns__submitMediaAliasTextAndTokenDigestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigestResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaAliasTextAndTokenDigestResponse ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaAliasTextAndTokenDigestResponse(struct soap *soap, const char *tag, tns__submitMediaAliasTextAndTokenDigestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaAliasTextAndTokenDigestResponse **)soap_malloc(soap, sizeof(tns__submitMediaAliasTextAndTokenDigestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaAliasTextAndTokenDigestResponse *)soap_instantiate_tns__submitMediaAliasTextAndTokenDigestResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaAliasTextAndTokenDigestResponse ** p = (tns__submitMediaAliasTextAndTokenDigestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigestResponse, sizeof(tns__submitMediaAliasTextAndTokenDigestResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaAliasTextAndTokenDigestResponse(struct soap *soap, tns__submitMediaAliasTextAndTokenDigestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAliasTextAndTokenDigestResponse);
	if (soap_out_PointerTotns__submitMediaAliasTextAndTokenDigestResponse(soap, tag?tag:"tns:submitMediaAliasTextAndTokenDigestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaAliasTextAndTokenDigestResponse ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaAliasTextAndTokenDigestResponse(struct soap *soap, tns__submitMediaAliasTextAndTokenDigestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaAliasTextAndTokenDigestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaAliasTextAndTokenDigest(struct soap *soap, tns__submitMediaAliasTextAndTokenDigest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaAliasTextAndTokenDigest(struct soap *soap, const char *tag, int id, tns__submitMediaAliasTextAndTokenDigest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaAliasTextAndTokenDigest ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaAliasTextAndTokenDigest(struct soap *soap, const char *tag, tns__submitMediaAliasTextAndTokenDigest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaAliasTextAndTokenDigest **)soap_malloc(soap, sizeof(tns__submitMediaAliasTextAndTokenDigest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaAliasTextAndTokenDigest *)soap_instantiate_tns__submitMediaAliasTextAndTokenDigest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaAliasTextAndTokenDigest ** p = (tns__submitMediaAliasTextAndTokenDigest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigest, sizeof(tns__submitMediaAliasTextAndTokenDigest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaAliasTextAndTokenDigest(struct soap *soap, tns__submitMediaAliasTextAndTokenDigest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAliasTextAndTokenDigest);
	if (soap_out_PointerTotns__submitMediaAliasTextAndTokenDigest(soap, tag?tag:"tns:submitMediaAliasTextAndTokenDigest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaAliasTextAndTokenDigest ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaAliasTextAndTokenDigest(struct soap *soap, tns__submitMediaAliasTextAndTokenDigest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaAliasTextAndTokenDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaAliasResponse(struct soap *soap, tns__submitMediaAliasResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitMediaAliasResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaAliasResponse(struct soap *soap, const char *tag, int id, tns__submitMediaAliasResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitMediaAliasResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaAliasResponse ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaAliasResponse(struct soap *soap, const char *tag, tns__submitMediaAliasResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaAliasResponse **)soap_malloc(soap, sizeof(tns__submitMediaAliasResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaAliasResponse *)soap_instantiate_tns__submitMediaAliasResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaAliasResponse ** p = (tns__submitMediaAliasResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitMediaAliasResponse, sizeof(tns__submitMediaAliasResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaAliasResponse(struct soap *soap, tns__submitMediaAliasResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAliasResponse);
	if (soap_out_PointerTotns__submitMediaAliasResponse(soap, tag?tag:"tns:submitMediaAliasResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaAliasResponse ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaAliasResponse(struct soap *soap, tns__submitMediaAliasResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaAliasResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaAlias(struct soap *soap, tns__submitMediaAlias *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitMediaAlias))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaAlias(struct soap *soap, const char *tag, int id, tns__submitMediaAlias *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitMediaAlias);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaAlias ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaAlias(struct soap *soap, const char *tag, tns__submitMediaAlias **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaAlias **)soap_malloc(soap, sizeof(tns__submitMediaAlias *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaAlias *)soap_instantiate_tns__submitMediaAlias(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaAlias ** p = (tns__submitMediaAlias **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitMediaAlias, sizeof(tns__submitMediaAlias), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaAlias(struct soap *soap, tns__submitMediaAlias *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAlias);
	if (soap_out_PointerTotns__submitMediaAlias(soap, tag?tag:"tns:submitMediaAlias", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaAlias ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaAlias(struct soap *soap, tns__submitMediaAlias **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaAlias(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitGameTokenDigestResponse(struct soap *soap, tns__submitGameTokenDigestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitGameTokenDigestResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitGameTokenDigestResponse(struct soap *soap, const char *tag, int id, tns__submitGameTokenDigestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitGameTokenDigestResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitGameTokenDigestResponse ** SOAP_FMAC4 soap_in_PointerTotns__submitGameTokenDigestResponse(struct soap *soap, const char *tag, tns__submitGameTokenDigestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitGameTokenDigestResponse **)soap_malloc(soap, sizeof(tns__submitGameTokenDigestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitGameTokenDigestResponse *)soap_instantiate_tns__submitGameTokenDigestResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitGameTokenDigestResponse ** p = (tns__submitGameTokenDigestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitGameTokenDigestResponse, sizeof(tns__submitGameTokenDigestResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitGameTokenDigestResponse(struct soap *soap, tns__submitGameTokenDigestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitGameTokenDigestResponse);
	if (soap_out_PointerTotns__submitGameTokenDigestResponse(soap, tag?tag:"tns:submitGameTokenDigestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitGameTokenDigestResponse ** SOAP_FMAC4 soap_get_PointerTotns__submitGameTokenDigestResponse(struct soap *soap, tns__submitGameTokenDigestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitGameTokenDigestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitGameTokenDigest(struct soap *soap, tns__submitGameTokenDigest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitGameTokenDigest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitGameTokenDigest(struct soap *soap, const char *tag, int id, tns__submitGameTokenDigest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitGameTokenDigest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitGameTokenDigest ** SOAP_FMAC4 soap_in_PointerTotns__submitGameTokenDigest(struct soap *soap, const char *tag, tns__submitGameTokenDigest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitGameTokenDigest **)soap_malloc(soap, sizeof(tns__submitGameTokenDigest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitGameTokenDigest *)soap_instantiate_tns__submitGameTokenDigest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitGameTokenDigest ** p = (tns__submitGameTokenDigest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitGameTokenDigest, sizeof(tns__submitGameTokenDigest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitGameTokenDigest(struct soap *soap, tns__submitGameTokenDigest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitGameTokenDigest);
	if (soap_out_PointerTotns__submitGameTokenDigest(soap, tag?tag:"tns:submitGameTokenDigest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitGameTokenDigest ** SOAP_FMAC4 soap_get_PointerTotns__submitGameTokenDigest(struct soap *soap, tns__submitGameTokenDigest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitGameTokenDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitGameTokenResponse(struct soap *soap, tns__submitGameTokenResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitGameTokenResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitGameTokenResponse(struct soap *soap, const char *tag, int id, tns__submitGameTokenResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitGameTokenResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitGameTokenResponse ** SOAP_FMAC4 soap_in_PointerTotns__submitGameTokenResponse(struct soap *soap, const char *tag, tns__submitGameTokenResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitGameTokenResponse **)soap_malloc(soap, sizeof(tns__submitGameTokenResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitGameTokenResponse *)soap_instantiate_tns__submitGameTokenResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitGameTokenResponse ** p = (tns__submitGameTokenResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitGameTokenResponse, sizeof(tns__submitGameTokenResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitGameTokenResponse(struct soap *soap, tns__submitGameTokenResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitGameTokenResponse);
	if (soap_out_PointerTotns__submitGameTokenResponse(soap, tag?tag:"tns:submitGameTokenResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitGameTokenResponse ** SOAP_FMAC4 soap_get_PointerTotns__submitGameTokenResponse(struct soap *soap, tns__submitGameTokenResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitGameTokenResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitGameToken(struct soap *soap, tns__submitGameToken *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitGameToken))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitGameToken(struct soap *soap, const char *tag, int id, tns__submitGameToken *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitGameToken);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitGameToken ** SOAP_FMAC4 soap_in_PointerTotns__submitGameToken(struct soap *soap, const char *tag, tns__submitGameToken **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitGameToken **)soap_malloc(soap, sizeof(tns__submitGameToken *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitGameToken *)soap_instantiate_tns__submitGameToken(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitGameToken ** p = (tns__submitGameToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitGameToken, sizeof(tns__submitGameToken), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitGameToken(struct soap *soap, tns__submitGameToken *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitGameToken);
	if (soap_out_PointerTotns__submitGameToken(soap, tag?tag:"tns:submitGameToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitGameToken ** SOAP_FMAC4 soap_get_PointerTotns__submitGameToken(struct soap *soap, tns__submitGameToken **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitGameToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitGameAnnotationTextWithTokenIdResponse(struct soap *soap, tns__submitGameAnnotationTextWithTokenIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextWithTokenIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitGameAnnotationTextWithTokenIdResponse(struct soap *soap, const char *tag, int id, tns__submitGameAnnotationTextWithTokenIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextWithTokenIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitGameAnnotationTextWithTokenIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__submitGameAnnotationTextWithTokenIdResponse(struct soap *soap, const char *tag, tns__submitGameAnnotationTextWithTokenIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitGameAnnotationTextWithTokenIdResponse **)soap_malloc(soap, sizeof(tns__submitGameAnnotationTextWithTokenIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitGameAnnotationTextWithTokenIdResponse *)soap_instantiate_tns__submitGameAnnotationTextWithTokenIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitGameAnnotationTextWithTokenIdResponse ** p = (tns__submitGameAnnotationTextWithTokenIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextWithTokenIdResponse, sizeof(tns__submitGameAnnotationTextWithTokenIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitGameAnnotationTextWithTokenIdResponse(struct soap *soap, tns__submitGameAnnotationTextWithTokenIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitGameAnnotationTextWithTokenIdResponse);
	if (soap_out_PointerTotns__submitGameAnnotationTextWithTokenIdResponse(soap, tag?tag:"tns:submitGameAnnotationTextWithTokenIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitGameAnnotationTextWithTokenIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__submitGameAnnotationTextWithTokenIdResponse(struct soap *soap, tns__submitGameAnnotationTextWithTokenIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitGameAnnotationTextWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitGameAnnotationTextWithTokenId(struct soap *soap, tns__submitGameAnnotationTextWithTokenId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextWithTokenId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitGameAnnotationTextWithTokenId(struct soap *soap, const char *tag, int id, tns__submitGameAnnotationTextWithTokenId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextWithTokenId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitGameAnnotationTextWithTokenId ** SOAP_FMAC4 soap_in_PointerTotns__submitGameAnnotationTextWithTokenId(struct soap *soap, const char *tag, tns__submitGameAnnotationTextWithTokenId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitGameAnnotationTextWithTokenId **)soap_malloc(soap, sizeof(tns__submitGameAnnotationTextWithTokenId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitGameAnnotationTextWithTokenId *)soap_instantiate_tns__submitGameAnnotationTextWithTokenId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitGameAnnotationTextWithTokenId ** p = (tns__submitGameAnnotationTextWithTokenId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextWithTokenId, sizeof(tns__submitGameAnnotationTextWithTokenId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitGameAnnotationTextWithTokenId(struct soap *soap, tns__submitGameAnnotationTextWithTokenId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitGameAnnotationTextWithTokenId);
	if (soap_out_PointerTotns__submitGameAnnotationTextWithTokenId(soap, tag?tag:"tns:submitGameAnnotationTextWithTokenId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitGameAnnotationTextWithTokenId ** SOAP_FMAC4 soap_get_PointerTotns__submitGameAnnotationTextWithTokenId(struct soap *soap, tns__submitGameAnnotationTextWithTokenId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitGameAnnotationTextWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitGameAnnotationTextAndTokenDigestResponse(struct soap *soap, tns__submitGameAnnotationTextAndTokenDigestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextAndTokenDigestResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitGameAnnotationTextAndTokenDigestResponse(struct soap *soap, const char *tag, int id, tns__submitGameAnnotationTextAndTokenDigestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextAndTokenDigestResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitGameAnnotationTextAndTokenDigestResponse ** SOAP_FMAC4 soap_in_PointerTotns__submitGameAnnotationTextAndTokenDigestResponse(struct soap *soap, const char *tag, tns__submitGameAnnotationTextAndTokenDigestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitGameAnnotationTextAndTokenDigestResponse **)soap_malloc(soap, sizeof(tns__submitGameAnnotationTextAndTokenDigestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitGameAnnotationTextAndTokenDigestResponse *)soap_instantiate_tns__submitGameAnnotationTextAndTokenDigestResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitGameAnnotationTextAndTokenDigestResponse ** p = (tns__submitGameAnnotationTextAndTokenDigestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextAndTokenDigestResponse, sizeof(tns__submitGameAnnotationTextAndTokenDigestResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitGameAnnotationTextAndTokenDigestResponse(struct soap *soap, tns__submitGameAnnotationTextAndTokenDigestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitGameAnnotationTextAndTokenDigestResponse);
	if (soap_out_PointerTotns__submitGameAnnotationTextAndTokenDigestResponse(soap, tag?tag:"tns:submitGameAnnotationTextAndTokenDigestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitGameAnnotationTextAndTokenDigestResponse ** SOAP_FMAC4 soap_get_PointerTotns__submitGameAnnotationTextAndTokenDigestResponse(struct soap *soap, tns__submitGameAnnotationTextAndTokenDigestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitGameAnnotationTextAndTokenDigestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitGameAnnotationTextAndTokenDigest(struct soap *soap, tns__submitGameAnnotationTextAndTokenDigest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextAndTokenDigest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitGameAnnotationTextAndTokenDigest(struct soap *soap, const char *tag, int id, tns__submitGameAnnotationTextAndTokenDigest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextAndTokenDigest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitGameAnnotationTextAndTokenDigest ** SOAP_FMAC4 soap_in_PointerTotns__submitGameAnnotationTextAndTokenDigest(struct soap *soap, const char *tag, tns__submitGameAnnotationTextAndTokenDigest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitGameAnnotationTextAndTokenDigest **)soap_malloc(soap, sizeof(tns__submitGameAnnotationTextAndTokenDigest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitGameAnnotationTextAndTokenDigest *)soap_instantiate_tns__submitGameAnnotationTextAndTokenDigest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitGameAnnotationTextAndTokenDigest ** p = (tns__submitGameAnnotationTextAndTokenDigest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitGameAnnotationTextAndTokenDigest, sizeof(tns__submitGameAnnotationTextAndTokenDigest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitGameAnnotationTextAndTokenDigest(struct soap *soap, tns__submitGameAnnotationTextAndTokenDigest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitGameAnnotationTextAndTokenDigest);
	if (soap_out_PointerTotns__submitGameAnnotationTextAndTokenDigest(soap, tag?tag:"tns:submitGameAnnotationTextAndTokenDigest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitGameAnnotationTextAndTokenDigest ** SOAP_FMAC4 soap_get_PointerTotns__submitGameAnnotationTextAndTokenDigest(struct soap *soap, tns__submitGameAnnotationTextAndTokenDigest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitGameAnnotationTextAndTokenDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitGameAnnotationResponse(struct soap *soap, tns__submitGameAnnotationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitGameAnnotationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitGameAnnotationResponse(struct soap *soap, const char *tag, int id, tns__submitGameAnnotationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitGameAnnotationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitGameAnnotationResponse ** SOAP_FMAC4 soap_in_PointerTotns__submitGameAnnotationResponse(struct soap *soap, const char *tag, tns__submitGameAnnotationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitGameAnnotationResponse **)soap_malloc(soap, sizeof(tns__submitGameAnnotationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitGameAnnotationResponse *)soap_instantiate_tns__submitGameAnnotationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitGameAnnotationResponse ** p = (tns__submitGameAnnotationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitGameAnnotationResponse, sizeof(tns__submitGameAnnotationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitGameAnnotationResponse(struct soap *soap, tns__submitGameAnnotationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitGameAnnotationResponse);
	if (soap_out_PointerTotns__submitGameAnnotationResponse(soap, tag?tag:"tns:submitGameAnnotationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitGameAnnotationResponse ** SOAP_FMAC4 soap_get_PointerTotns__submitGameAnnotationResponse(struct soap *soap, tns__submitGameAnnotationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitGameAnnotationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitGameAnnotation(struct soap *soap, tns__submitGameAnnotation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitGameAnnotation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitGameAnnotation(struct soap *soap, const char *tag, int id, tns__submitGameAnnotation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitGameAnnotation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitGameAnnotation ** SOAP_FMAC4 soap_in_PointerTotns__submitGameAnnotation(struct soap *soap, const char *tag, tns__submitGameAnnotation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitGameAnnotation **)soap_malloc(soap, sizeof(tns__submitGameAnnotation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitGameAnnotation *)soap_instantiate_tns__submitGameAnnotation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitGameAnnotation ** p = (tns__submitGameAnnotation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitGameAnnotation, sizeof(tns__submitGameAnnotation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitGameAnnotation(struct soap *soap, tns__submitGameAnnotation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitGameAnnotation);
	if (soap_out_PointerTotns__submitGameAnnotation(soap, tag?tag:"tns:submitGameAnnotation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitGameAnnotation ** SOAP_FMAC4 soap_get_PointerTotns__submitGameAnnotation(struct soap *soap, tns__submitGameAnnotation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitGameAnnotation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitGameAliasTextWithTokenIdResponse(struct soap *soap, tns__submitGameAliasTextWithTokenIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitGameAliasTextWithTokenIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitGameAliasTextWithTokenIdResponse(struct soap *soap, const char *tag, int id, tns__submitGameAliasTextWithTokenIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitGameAliasTextWithTokenIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitGameAliasTextWithTokenIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__submitGameAliasTextWithTokenIdResponse(struct soap *soap, const char *tag, tns__submitGameAliasTextWithTokenIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitGameAliasTextWithTokenIdResponse **)soap_malloc(soap, sizeof(tns__submitGameAliasTextWithTokenIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitGameAliasTextWithTokenIdResponse *)soap_instantiate_tns__submitGameAliasTextWithTokenIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitGameAliasTextWithTokenIdResponse ** p = (tns__submitGameAliasTextWithTokenIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitGameAliasTextWithTokenIdResponse, sizeof(tns__submitGameAliasTextWithTokenIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitGameAliasTextWithTokenIdResponse(struct soap *soap, tns__submitGameAliasTextWithTokenIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitGameAliasTextWithTokenIdResponse);
	if (soap_out_PointerTotns__submitGameAliasTextWithTokenIdResponse(soap, tag?tag:"tns:submitGameAliasTextWithTokenIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitGameAliasTextWithTokenIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__submitGameAliasTextWithTokenIdResponse(struct soap *soap, tns__submitGameAliasTextWithTokenIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitGameAliasTextWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitGameAliasTextWithTokenId(struct soap *soap, tns__submitGameAliasTextWithTokenId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitGameAliasTextWithTokenId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitGameAliasTextWithTokenId(struct soap *soap, const char *tag, int id, tns__submitGameAliasTextWithTokenId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitGameAliasTextWithTokenId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitGameAliasTextWithTokenId ** SOAP_FMAC4 soap_in_PointerTotns__submitGameAliasTextWithTokenId(struct soap *soap, const char *tag, tns__submitGameAliasTextWithTokenId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitGameAliasTextWithTokenId **)soap_malloc(soap, sizeof(tns__submitGameAliasTextWithTokenId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitGameAliasTextWithTokenId *)soap_instantiate_tns__submitGameAliasTextWithTokenId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitGameAliasTextWithTokenId ** p = (tns__submitGameAliasTextWithTokenId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitGameAliasTextWithTokenId, sizeof(tns__submitGameAliasTextWithTokenId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitGameAliasTextWithTokenId(struct soap *soap, tns__submitGameAliasTextWithTokenId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitGameAliasTextWithTokenId);
	if (soap_out_PointerTotns__submitGameAliasTextWithTokenId(soap, tag?tag:"tns:submitGameAliasTextWithTokenId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitGameAliasTextWithTokenId ** SOAP_FMAC4 soap_get_PointerTotns__submitGameAliasTextWithTokenId(struct soap *soap, tns__submitGameAliasTextWithTokenId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitGameAliasTextWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitGameAliasTextAndTokenDigestResponse(struct soap *soap, tns__submitGameAliasTextAndTokenDigestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitGameAliasTextAndTokenDigestResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitGameAliasTextAndTokenDigestResponse(struct soap *soap, const char *tag, int id, tns__submitGameAliasTextAndTokenDigestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitGameAliasTextAndTokenDigestResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitGameAliasTextAndTokenDigestResponse ** SOAP_FMAC4 soap_in_PointerTotns__submitGameAliasTextAndTokenDigestResponse(struct soap *soap, const char *tag, tns__submitGameAliasTextAndTokenDigestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitGameAliasTextAndTokenDigestResponse **)soap_malloc(soap, sizeof(tns__submitGameAliasTextAndTokenDigestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitGameAliasTextAndTokenDigestResponse *)soap_instantiate_tns__submitGameAliasTextAndTokenDigestResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitGameAliasTextAndTokenDigestResponse ** p = (tns__submitGameAliasTextAndTokenDigestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitGameAliasTextAndTokenDigestResponse, sizeof(tns__submitGameAliasTextAndTokenDigestResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitGameAliasTextAndTokenDigestResponse(struct soap *soap, tns__submitGameAliasTextAndTokenDigestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitGameAliasTextAndTokenDigestResponse);
	if (soap_out_PointerTotns__submitGameAliasTextAndTokenDigestResponse(soap, tag?tag:"tns:submitGameAliasTextAndTokenDigestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitGameAliasTextAndTokenDigestResponse ** SOAP_FMAC4 soap_get_PointerTotns__submitGameAliasTextAndTokenDigestResponse(struct soap *soap, tns__submitGameAliasTextAndTokenDigestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitGameAliasTextAndTokenDigestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitGameAliasTextAndTokenDigest(struct soap *soap, tns__submitGameAliasTextAndTokenDigest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitGameAliasTextAndTokenDigest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitGameAliasTextAndTokenDigest(struct soap *soap, const char *tag, int id, tns__submitGameAliasTextAndTokenDigest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitGameAliasTextAndTokenDigest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitGameAliasTextAndTokenDigest ** SOAP_FMAC4 soap_in_PointerTotns__submitGameAliasTextAndTokenDigest(struct soap *soap, const char *tag, tns__submitGameAliasTextAndTokenDigest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitGameAliasTextAndTokenDigest **)soap_malloc(soap, sizeof(tns__submitGameAliasTextAndTokenDigest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitGameAliasTextAndTokenDigest *)soap_instantiate_tns__submitGameAliasTextAndTokenDigest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitGameAliasTextAndTokenDigest ** p = (tns__submitGameAliasTextAndTokenDigest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitGameAliasTextAndTokenDigest, sizeof(tns__submitGameAliasTextAndTokenDigest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitGameAliasTextAndTokenDigest(struct soap *soap, tns__submitGameAliasTextAndTokenDigest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitGameAliasTextAndTokenDigest);
	if (soap_out_PointerTotns__submitGameAliasTextAndTokenDigest(soap, tag?tag:"tns:submitGameAliasTextAndTokenDigest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitGameAliasTextAndTokenDigest ** SOAP_FMAC4 soap_get_PointerTotns__submitGameAliasTextAndTokenDigest(struct soap *soap, tns__submitGameAliasTextAndTokenDigest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitGameAliasTextAndTokenDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitGameAliasResponse(struct soap *soap, tns__submitGameAliasResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitGameAliasResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitGameAliasResponse(struct soap *soap, const char *tag, int id, tns__submitGameAliasResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitGameAliasResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitGameAliasResponse ** SOAP_FMAC4 soap_in_PointerTotns__submitGameAliasResponse(struct soap *soap, const char *tag, tns__submitGameAliasResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitGameAliasResponse **)soap_malloc(soap, sizeof(tns__submitGameAliasResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitGameAliasResponse *)soap_instantiate_tns__submitGameAliasResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitGameAliasResponse ** p = (tns__submitGameAliasResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitGameAliasResponse, sizeof(tns__submitGameAliasResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitGameAliasResponse(struct soap *soap, tns__submitGameAliasResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitGameAliasResponse);
	if (soap_out_PointerTotns__submitGameAliasResponse(soap, tag?tag:"tns:submitGameAliasResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitGameAliasResponse ** SOAP_FMAC4 soap_get_PointerTotns__submitGameAliasResponse(struct soap *soap, tns__submitGameAliasResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitGameAliasResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitGameAlias(struct soap *soap, tns__submitGameAlias *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitGameAlias))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitGameAlias(struct soap *soap, const char *tag, int id, tns__submitGameAlias *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitGameAlias);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitGameAlias ** SOAP_FMAC4 soap_in_PointerTotns__submitGameAlias(struct soap *soap, const char *tag, tns__submitGameAlias **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitGameAlias **)soap_malloc(soap, sizeof(tns__submitGameAlias *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitGameAlias *)soap_instantiate_tns__submitGameAlias(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitGameAlias ** p = (tns__submitGameAlias **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitGameAlias, sizeof(tns__submitGameAlias), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitGameAlias(struct soap *soap, tns__submitGameAlias *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitGameAlias);
	if (soap_out_PointerTotns__submitGameAlias(soap, tag?tag:"tns:submitGameAlias", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitGameAlias ** SOAP_FMAC4 soap_get_PointerTotns__submitGameAlias(struct soap *soap, tns__submitGameAlias **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitGameAlias(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__setUserLanguageResponse(struct soap *soap, tns__setUserLanguageResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__setUserLanguageResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__setUserLanguageResponse(struct soap *soap, const char *tag, int id, tns__setUserLanguageResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__setUserLanguageResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__setUserLanguageResponse ** SOAP_FMAC4 soap_in_PointerTotns__setUserLanguageResponse(struct soap *soap, const char *tag, tns__setUserLanguageResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__setUserLanguageResponse **)soap_malloc(soap, sizeof(tns__setUserLanguageResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__setUserLanguageResponse *)soap_instantiate_tns__setUserLanguageResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__setUserLanguageResponse ** p = (tns__setUserLanguageResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__setUserLanguageResponse, sizeof(tns__setUserLanguageResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__setUserLanguageResponse(struct soap *soap, tns__setUserLanguageResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__setUserLanguageResponse);
	if (soap_out_PointerTotns__setUserLanguageResponse(soap, tag?tag:"tns:setUserLanguageResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__setUserLanguageResponse ** SOAP_FMAC4 soap_get_PointerTotns__setUserLanguageResponse(struct soap *soap, tns__setUserLanguageResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__setUserLanguageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__setUserLanguage(struct soap *soap, tns__setUserLanguage *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__setUserLanguage))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__setUserLanguage(struct soap *soap, const char *tag, int id, tns__setUserLanguage *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__setUserLanguage);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__setUserLanguage ** SOAP_FMAC4 soap_in_PointerTotns__setUserLanguage(struct soap *soap, const char *tag, tns__setUserLanguage **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__setUserLanguage **)soap_malloc(soap, sizeof(tns__setUserLanguage *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__setUserLanguage *)soap_instantiate_tns__setUserLanguage(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__setUserLanguage ** p = (tns__setUserLanguage **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__setUserLanguage, sizeof(tns__setUserLanguage), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__setUserLanguage(struct soap *soap, tns__setUserLanguage *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__setUserLanguage);
	if (soap_out_PointerTotns__setUserLanguage(soap, tag?tag:"tns:setUserLanguage", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__setUserLanguage ** SOAP_FMAC4 soap_get_PointerTotns__setUserLanguage(struct soap *soap, tns__setUserLanguage **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__setUserLanguage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__setUserAnonymousResponse(struct soap *soap, tns__setUserAnonymousResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__setUserAnonymousResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__setUserAnonymousResponse(struct soap *soap, const char *tag, int id, tns__setUserAnonymousResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__setUserAnonymousResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__setUserAnonymousResponse ** SOAP_FMAC4 soap_in_PointerTotns__setUserAnonymousResponse(struct soap *soap, const char *tag, tns__setUserAnonymousResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__setUserAnonymousResponse **)soap_malloc(soap, sizeof(tns__setUserAnonymousResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__setUserAnonymousResponse *)soap_instantiate_tns__setUserAnonymousResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__setUserAnonymousResponse ** p = (tns__setUserAnonymousResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__setUserAnonymousResponse, sizeof(tns__setUserAnonymousResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__setUserAnonymousResponse(struct soap *soap, tns__setUserAnonymousResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__setUserAnonymousResponse);
	if (soap_out_PointerTotns__setUserAnonymousResponse(soap, tag?tag:"tns:setUserAnonymousResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__setUserAnonymousResponse ** SOAP_FMAC4 soap_get_PointerTotns__setUserAnonymousResponse(struct soap *soap, tns__setUserAnonymousResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__setUserAnonymousResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__setUserAnonymous(struct soap *soap, tns__setUserAnonymous *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__setUserAnonymous))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__setUserAnonymous(struct soap *soap, const char *tag, int id, tns__setUserAnonymous *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__setUserAnonymous);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__setUserAnonymous ** SOAP_FMAC4 soap_in_PointerTotns__setUserAnonymous(struct soap *soap, const char *tag, tns__setUserAnonymous **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__setUserAnonymous **)soap_malloc(soap, sizeof(tns__setUserAnonymous *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__setUserAnonymous *)soap_instantiate_tns__setUserAnonymous(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__setUserAnonymous ** p = (tns__setUserAnonymous **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__setUserAnonymous, sizeof(tns__setUserAnonymous), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__setUserAnonymous(struct soap *soap, tns__setUserAnonymous *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__setUserAnonymous);
	if (soap_out_PointerTotns__setUserAnonymous(soap, tag?tag:"tns:setUserAnonymous", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__setUserAnonymous ** SOAP_FMAC4 soap_get_PointerTotns__setUserAnonymous(struct soap *soap, tns__setUserAnonymous **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__setUserAnonymous(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectUserResponse(struct soap *soap, tns__selectUserResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__selectUserResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectUserResponse(struct soap *soap, const char *tag, int id, tns__selectUserResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__selectUserResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectUserResponse ** SOAP_FMAC4 soap_in_PointerTotns__selectUserResponse(struct soap *soap, const char *tag, tns__selectUserResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectUserResponse **)soap_malloc(soap, sizeof(tns__selectUserResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectUserResponse *)soap_instantiate_tns__selectUserResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectUserResponse ** p = (tns__selectUserResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__selectUserResponse, sizeof(tns__selectUserResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectUserResponse(struct soap *soap, tns__selectUserResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__selectUserResponse);
	if (soap_out_PointerTotns__selectUserResponse(soap, tag?tag:"tns:selectUserResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectUserResponse ** SOAP_FMAC4 soap_get_PointerTotns__selectUserResponse(struct soap *soap, tns__selectUserResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectUser(struct soap *soap, tns__selectUser *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__selectUser))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectUser(struct soap *soap, const char *tag, int id, tns__selectUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__selectUser);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectUser ** SOAP_FMAC4 soap_in_PointerTotns__selectUser(struct soap *soap, const char *tag, tns__selectUser **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectUser **)soap_malloc(soap, sizeof(tns__selectUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectUser *)soap_instantiate_tns__selectUser(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectUser ** p = (tns__selectUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__selectUser, sizeof(tns__selectUser), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectUser(struct soap *soap, tns__selectUser *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__selectUser);
	if (soap_out_PointerTotns__selectUser(soap, tag?tag:"tns:selectUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectUser ** SOAP_FMAC4 soap_get_PointerTotns__selectUser(struct soap *soap, tns__selectUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse(struct soap *soap, tns__selectRelatedMediaAnnotationsWithTokenIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse(struct soap *soap, const char *tag, int id, tns__selectRelatedMediaAnnotationsWithTokenIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectRelatedMediaAnnotationsWithTokenIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse(struct soap *soap, const char *tag, tns__selectRelatedMediaAnnotationsWithTokenIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectRelatedMediaAnnotationsWithTokenIdResponse **)soap_malloc(soap, sizeof(tns__selectRelatedMediaAnnotationsWithTokenIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectRelatedMediaAnnotationsWithTokenIdResponse *)soap_instantiate_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectRelatedMediaAnnotationsWithTokenIdResponse ** p = (tns__selectRelatedMediaAnnotationsWithTokenIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenIdResponse, sizeof(tns__selectRelatedMediaAnnotationsWithTokenIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse(struct soap *soap, tns__selectRelatedMediaAnnotationsWithTokenIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse);
	if (soap_out_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse(soap, tag?tag:"tns:selectRelatedMediaAnnotationsWithTokenIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectRelatedMediaAnnotationsWithTokenIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse(struct soap *soap, tns__selectRelatedMediaAnnotationsWithTokenIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, tns__selectRelatedMediaAnnotationsWithTokenId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, const char *tag, int id, tns__selectRelatedMediaAnnotationsWithTokenId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectRelatedMediaAnnotationsWithTokenId ** SOAP_FMAC4 soap_in_PointerTotns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, const char *tag, tns__selectRelatedMediaAnnotationsWithTokenId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectRelatedMediaAnnotationsWithTokenId **)soap_malloc(soap, sizeof(tns__selectRelatedMediaAnnotationsWithTokenId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectRelatedMediaAnnotationsWithTokenId *)soap_instantiate_tns__selectRelatedMediaAnnotationsWithTokenId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectRelatedMediaAnnotationsWithTokenId ** p = (tns__selectRelatedMediaAnnotationsWithTokenId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenId, sizeof(tns__selectRelatedMediaAnnotationsWithTokenId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, tns__selectRelatedMediaAnnotationsWithTokenId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__selectRelatedMediaAnnotationsWithTokenId);
	if (soap_out_PointerTotns__selectRelatedMediaAnnotationsWithTokenId(soap, tag?tag:"tns:selectRelatedMediaAnnotationsWithTokenId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectRelatedMediaAnnotationsWithTokenId ** SOAP_FMAC4 soap_get_PointerTotns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, tns__selectRelatedMediaAnnotationsWithTokenId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectRelatedMediaAnnotationsWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectRelatedGameAnnotationsWithTokenIdResponse(struct soap *soap, tns__selectRelatedGameAnnotationsWithTokenIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__selectRelatedGameAnnotationsWithTokenIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectRelatedGameAnnotationsWithTokenIdResponse(struct soap *soap, const char *tag, int id, tns__selectRelatedGameAnnotationsWithTokenIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__selectRelatedGameAnnotationsWithTokenIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectRelatedGameAnnotationsWithTokenIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__selectRelatedGameAnnotationsWithTokenIdResponse(struct soap *soap, const char *tag, tns__selectRelatedGameAnnotationsWithTokenIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectRelatedGameAnnotationsWithTokenIdResponse **)soap_malloc(soap, sizeof(tns__selectRelatedGameAnnotationsWithTokenIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectRelatedGameAnnotationsWithTokenIdResponse *)soap_instantiate_tns__selectRelatedGameAnnotationsWithTokenIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectRelatedGameAnnotationsWithTokenIdResponse ** p = (tns__selectRelatedGameAnnotationsWithTokenIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__selectRelatedGameAnnotationsWithTokenIdResponse, sizeof(tns__selectRelatedGameAnnotationsWithTokenIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectRelatedGameAnnotationsWithTokenIdResponse(struct soap *soap, tns__selectRelatedGameAnnotationsWithTokenIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__selectRelatedGameAnnotationsWithTokenIdResponse);
	if (soap_out_PointerTotns__selectRelatedGameAnnotationsWithTokenIdResponse(soap, tag?tag:"tns:selectRelatedGameAnnotationsWithTokenIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectRelatedGameAnnotationsWithTokenIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__selectRelatedGameAnnotationsWithTokenIdResponse(struct soap *soap, tns__selectRelatedGameAnnotationsWithTokenIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectRelatedGameAnnotationsWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectRelatedGameAnnotationsWithTokenId(struct soap *soap, tns__selectRelatedGameAnnotationsWithTokenId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__selectRelatedGameAnnotationsWithTokenId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectRelatedGameAnnotationsWithTokenId(struct soap *soap, const char *tag, int id, tns__selectRelatedGameAnnotationsWithTokenId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__selectRelatedGameAnnotationsWithTokenId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectRelatedGameAnnotationsWithTokenId ** SOAP_FMAC4 soap_in_PointerTotns__selectRelatedGameAnnotationsWithTokenId(struct soap *soap, const char *tag, tns__selectRelatedGameAnnotationsWithTokenId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectRelatedGameAnnotationsWithTokenId **)soap_malloc(soap, sizeof(tns__selectRelatedGameAnnotationsWithTokenId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectRelatedGameAnnotationsWithTokenId *)soap_instantiate_tns__selectRelatedGameAnnotationsWithTokenId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectRelatedGameAnnotationsWithTokenId ** p = (tns__selectRelatedGameAnnotationsWithTokenId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__selectRelatedGameAnnotationsWithTokenId, sizeof(tns__selectRelatedGameAnnotationsWithTokenId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectRelatedGameAnnotationsWithTokenId(struct soap *soap, tns__selectRelatedGameAnnotationsWithTokenId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__selectRelatedGameAnnotationsWithTokenId);
	if (soap_out_PointerTotns__selectRelatedGameAnnotationsWithTokenId(soap, tag?tag:"tns:selectRelatedGameAnnotationsWithTokenId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectRelatedGameAnnotationsWithTokenId ** SOAP_FMAC4 soap_get_PointerTotns__selectRelatedGameAnnotationsWithTokenId(struct soap *soap, tns__selectRelatedGameAnnotationsWithTokenId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectRelatedGameAnnotationsWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectMediaTokenWithIdResponse(struct soap *soap, tns__selectMediaTokenWithIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectMediaTokenWithIdResponse(struct soap *soap, const char *tag, int id, tns__selectMediaTokenWithIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectMediaTokenWithIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__selectMediaTokenWithIdResponse(struct soap *soap, const char *tag, tns__selectMediaTokenWithIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectMediaTokenWithIdResponse **)soap_malloc(soap, sizeof(tns__selectMediaTokenWithIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectMediaTokenWithIdResponse *)soap_instantiate_tns__selectMediaTokenWithIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectMediaTokenWithIdResponse ** p = (tns__selectMediaTokenWithIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithIdResponse, sizeof(tns__selectMediaTokenWithIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectMediaTokenWithIdResponse(struct soap *soap, tns__selectMediaTokenWithIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__selectMediaTokenWithIdResponse);
	if (soap_out_PointerTotns__selectMediaTokenWithIdResponse(soap, tag?tag:"tns:selectMediaTokenWithIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectMediaTokenWithIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__selectMediaTokenWithIdResponse(struct soap *soap, tns__selectMediaTokenWithIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectMediaTokenWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectMediaTokenWithId(struct soap *soap, tns__selectMediaTokenWithId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectMediaTokenWithId(struct soap *soap, const char *tag, int id, tns__selectMediaTokenWithId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectMediaTokenWithId ** SOAP_FMAC4 soap_in_PointerTotns__selectMediaTokenWithId(struct soap *soap, const char *tag, tns__selectMediaTokenWithId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectMediaTokenWithId **)soap_malloc(soap, sizeof(tns__selectMediaTokenWithId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectMediaTokenWithId *)soap_instantiate_tns__selectMediaTokenWithId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectMediaTokenWithId ** p = (tns__selectMediaTokenWithId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithId, sizeof(tns__selectMediaTokenWithId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectMediaTokenWithId(struct soap *soap, tns__selectMediaTokenWithId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__selectMediaTokenWithId);
	if (soap_out_PointerTotns__selectMediaTokenWithId(soap, tag?tag:"tns:selectMediaTokenWithId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectMediaTokenWithId ** SOAP_FMAC4 soap_get_PointerTotns__selectMediaTokenWithId(struct soap *soap, tns__selectMediaTokenWithId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectMediaTokenWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectMediaTokenWithDigestResponse(struct soap *soap, tns__selectMediaTokenWithDigestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigestResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectMediaTokenWithDigestResponse(struct soap *soap, const char *tag, int id, tns__selectMediaTokenWithDigestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigestResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectMediaTokenWithDigestResponse ** SOAP_FMAC4 soap_in_PointerTotns__selectMediaTokenWithDigestResponse(struct soap *soap, const char *tag, tns__selectMediaTokenWithDigestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectMediaTokenWithDigestResponse **)soap_malloc(soap, sizeof(tns__selectMediaTokenWithDigestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectMediaTokenWithDigestResponse *)soap_instantiate_tns__selectMediaTokenWithDigestResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectMediaTokenWithDigestResponse ** p = (tns__selectMediaTokenWithDigestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigestResponse, sizeof(tns__selectMediaTokenWithDigestResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectMediaTokenWithDigestResponse(struct soap *soap, tns__selectMediaTokenWithDigestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__selectMediaTokenWithDigestResponse);
	if (soap_out_PointerTotns__selectMediaTokenWithDigestResponse(soap, tag?tag:"tns:selectMediaTokenWithDigestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectMediaTokenWithDigestResponse ** SOAP_FMAC4 soap_get_PointerTotns__selectMediaTokenWithDigestResponse(struct soap *soap, tns__selectMediaTokenWithDigestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectMediaTokenWithDigestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectMediaTokenWithDigest(struct soap *soap, tns__selectMediaTokenWithDigest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectMediaTokenWithDigest(struct soap *soap, const char *tag, int id, tns__selectMediaTokenWithDigest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectMediaTokenWithDigest ** SOAP_FMAC4 soap_in_PointerTotns__selectMediaTokenWithDigest(struct soap *soap, const char *tag, tns__selectMediaTokenWithDigest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectMediaTokenWithDigest **)soap_malloc(soap, sizeof(tns__selectMediaTokenWithDigest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectMediaTokenWithDigest *)soap_instantiate_tns__selectMediaTokenWithDigest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectMediaTokenWithDigest ** p = (tns__selectMediaTokenWithDigest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigest, sizeof(tns__selectMediaTokenWithDigest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectMediaTokenWithDigest(struct soap *soap, tns__selectMediaTokenWithDigest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__selectMediaTokenWithDigest);
	if (soap_out_PointerTotns__selectMediaTokenWithDigest(soap, tag?tag:"tns:selectMediaTokenWithDigest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectMediaTokenWithDigest ** SOAP_FMAC4 soap_get_PointerTotns__selectMediaTokenWithDigest(struct soap *soap, tns__selectMediaTokenWithDigest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectMediaTokenWithDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectMediaAnnotationsWithTokenIdResponse(struct soap *soap, tns__selectMediaAnnotationsWithTokenIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectMediaAnnotationsWithTokenIdResponse(struct soap *soap, const char *tag, int id, tns__selectMediaAnnotationsWithTokenIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectMediaAnnotationsWithTokenIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__selectMediaAnnotationsWithTokenIdResponse(struct soap *soap, const char *tag, tns__selectMediaAnnotationsWithTokenIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectMediaAnnotationsWithTokenIdResponse **)soap_malloc(soap, sizeof(tns__selectMediaAnnotationsWithTokenIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectMediaAnnotationsWithTokenIdResponse *)soap_instantiate_tns__selectMediaAnnotationsWithTokenIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectMediaAnnotationsWithTokenIdResponse ** p = (tns__selectMediaAnnotationsWithTokenIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenIdResponse, sizeof(tns__selectMediaAnnotationsWithTokenIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectMediaAnnotationsWithTokenIdResponse(struct soap *soap, tns__selectMediaAnnotationsWithTokenIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__selectMediaAnnotationsWithTokenIdResponse);
	if (soap_out_PointerTotns__selectMediaAnnotationsWithTokenIdResponse(soap, tag?tag:"tns:selectMediaAnnotationsWithTokenIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectMediaAnnotationsWithTokenIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__selectMediaAnnotationsWithTokenIdResponse(struct soap *soap, tns__selectMediaAnnotationsWithTokenIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectMediaAnnotationsWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectMediaAnnotationsWithTokenId(struct soap *soap, tns__selectMediaAnnotationsWithTokenId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectMediaAnnotationsWithTokenId(struct soap *soap, const char *tag, int id, tns__selectMediaAnnotationsWithTokenId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectMediaAnnotationsWithTokenId ** SOAP_FMAC4 soap_in_PointerTotns__selectMediaAnnotationsWithTokenId(struct soap *soap, const char *tag, tns__selectMediaAnnotationsWithTokenId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectMediaAnnotationsWithTokenId **)soap_malloc(soap, sizeof(tns__selectMediaAnnotationsWithTokenId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectMediaAnnotationsWithTokenId *)soap_instantiate_tns__selectMediaAnnotationsWithTokenId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectMediaAnnotationsWithTokenId ** p = (tns__selectMediaAnnotationsWithTokenId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenId, sizeof(tns__selectMediaAnnotationsWithTokenId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectMediaAnnotationsWithTokenId(struct soap *soap, tns__selectMediaAnnotationsWithTokenId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__selectMediaAnnotationsWithTokenId);
	if (soap_out_PointerTotns__selectMediaAnnotationsWithTokenId(soap, tag?tag:"tns:selectMediaAnnotationsWithTokenId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectMediaAnnotationsWithTokenId ** SOAP_FMAC4 soap_get_PointerTotns__selectMediaAnnotationsWithTokenId(struct soap *soap, tns__selectMediaAnnotationsWithTokenId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectMediaAnnotationsWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectMediaAliasesWithTokenIdResponse(struct soap *soap, tns__selectMediaAliasesWithTokenIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectMediaAliasesWithTokenIdResponse(struct soap *soap, const char *tag, int id, tns__selectMediaAliasesWithTokenIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectMediaAliasesWithTokenIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__selectMediaAliasesWithTokenIdResponse(struct soap *soap, const char *tag, tns__selectMediaAliasesWithTokenIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectMediaAliasesWithTokenIdResponse **)soap_malloc(soap, sizeof(tns__selectMediaAliasesWithTokenIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectMediaAliasesWithTokenIdResponse *)soap_instantiate_tns__selectMediaAliasesWithTokenIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectMediaAliasesWithTokenIdResponse ** p = (tns__selectMediaAliasesWithTokenIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenIdResponse, sizeof(tns__selectMediaAliasesWithTokenIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectMediaAliasesWithTokenIdResponse(struct soap *soap, tns__selectMediaAliasesWithTokenIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__selectMediaAliasesWithTokenIdResponse);
	if (soap_out_PointerTotns__selectMediaAliasesWithTokenIdResponse(soap, tag?tag:"tns:selectMediaAliasesWithTokenIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectMediaAliasesWithTokenIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__selectMediaAliasesWithTokenIdResponse(struct soap *soap, tns__selectMediaAliasesWithTokenIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectMediaAliasesWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectMediaAliasesWithTokenId(struct soap *soap, tns__selectMediaAliasesWithTokenId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectMediaAliasesWithTokenId(struct soap *soap, const char *tag, int id, tns__selectMediaAliasesWithTokenId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectMediaAliasesWithTokenId ** SOAP_FMAC4 soap_in_PointerTotns__selectMediaAliasesWithTokenId(struct soap *soap, const char *tag, tns__selectMediaAliasesWithTokenId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectMediaAliasesWithTokenId **)soap_malloc(soap, sizeof(tns__selectMediaAliasesWithTokenId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectMediaAliasesWithTokenId *)soap_instantiate_tns__selectMediaAliasesWithTokenId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectMediaAliasesWithTokenId ** p = (tns__selectMediaAliasesWithTokenId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenId, sizeof(tns__selectMediaAliasesWithTokenId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectMediaAliasesWithTokenId(struct soap *soap, tns__selectMediaAliasesWithTokenId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__selectMediaAliasesWithTokenId);
	if (soap_out_PointerTotns__selectMediaAliasesWithTokenId(soap, tag?tag:"tns:selectMediaAliasesWithTokenId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectMediaAliasesWithTokenId ** SOAP_FMAC4 soap_get_PointerTotns__selectMediaAliasesWithTokenId(struct soap *soap, tns__selectMediaAliasesWithTokenId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectMediaAliasesWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectGameTokenWithIdResponse(struct soap *soap, tns__selectGameTokenWithIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__selectGameTokenWithIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectGameTokenWithIdResponse(struct soap *soap, const char *tag, int id, tns__selectGameTokenWithIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__selectGameTokenWithIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectGameTokenWithIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__selectGameTokenWithIdResponse(struct soap *soap, const char *tag, tns__selectGameTokenWithIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectGameTokenWithIdResponse **)soap_malloc(soap, sizeof(tns__selectGameTokenWithIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectGameTokenWithIdResponse *)soap_instantiate_tns__selectGameTokenWithIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectGameTokenWithIdResponse ** p = (tns__selectGameTokenWithIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__selectGameTokenWithIdResponse, sizeof(tns__selectGameTokenWithIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectGameTokenWithIdResponse(struct soap *soap, tns__selectGameTokenWithIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__selectGameTokenWithIdResponse);
	if (soap_out_PointerTotns__selectGameTokenWithIdResponse(soap, tag?tag:"tns:selectGameTokenWithIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectGameTokenWithIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__selectGameTokenWithIdResponse(struct soap *soap, tns__selectGameTokenWithIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectGameTokenWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectGameTokenWithId(struct soap *soap, tns__selectGameTokenWithId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__selectGameTokenWithId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectGameTokenWithId(struct soap *soap, const char *tag, int id, tns__selectGameTokenWithId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__selectGameTokenWithId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectGameTokenWithId ** SOAP_FMAC4 soap_in_PointerTotns__selectGameTokenWithId(struct soap *soap, const char *tag, tns__selectGameTokenWithId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectGameTokenWithId **)soap_malloc(soap, sizeof(tns__selectGameTokenWithId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectGameTokenWithId *)soap_instantiate_tns__selectGameTokenWithId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectGameTokenWithId ** p = (tns__selectGameTokenWithId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__selectGameTokenWithId, sizeof(tns__selectGameTokenWithId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectGameTokenWithId(struct soap *soap, tns__selectGameTokenWithId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__selectGameTokenWithId);
	if (soap_out_PointerTotns__selectGameTokenWithId(soap, tag?tag:"tns:selectGameTokenWithId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectGameTokenWithId ** SOAP_FMAC4 soap_get_PointerTotns__selectGameTokenWithId(struct soap *soap, tns__selectGameTokenWithId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectGameTokenWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectGameTokenWithDigestResponse(struct soap *soap, tns__selectGameTokenWithDigestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__selectGameTokenWithDigestResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectGameTokenWithDigestResponse(struct soap *soap, const char *tag, int id, tns__selectGameTokenWithDigestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__selectGameTokenWithDigestResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectGameTokenWithDigestResponse ** SOAP_FMAC4 soap_in_PointerTotns__selectGameTokenWithDigestResponse(struct soap *soap, const char *tag, tns__selectGameTokenWithDigestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectGameTokenWithDigestResponse **)soap_malloc(soap, sizeof(tns__selectGameTokenWithDigestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectGameTokenWithDigestResponse *)soap_instantiate_tns__selectGameTokenWithDigestResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectGameTokenWithDigestResponse ** p = (tns__selectGameTokenWithDigestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__selectGameTokenWithDigestResponse, sizeof(tns__selectGameTokenWithDigestResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectGameTokenWithDigestResponse(struct soap *soap, tns__selectGameTokenWithDigestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__selectGameTokenWithDigestResponse);
	if (soap_out_PointerTotns__selectGameTokenWithDigestResponse(soap, tag?tag:"tns:selectGameTokenWithDigestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectGameTokenWithDigestResponse ** SOAP_FMAC4 soap_get_PointerTotns__selectGameTokenWithDigestResponse(struct soap *soap, tns__selectGameTokenWithDigestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectGameTokenWithDigestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectGameTokenWithDigest(struct soap *soap, tns__selectGameTokenWithDigest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__selectGameTokenWithDigest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectGameTokenWithDigest(struct soap *soap, const char *tag, int id, tns__selectGameTokenWithDigest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__selectGameTokenWithDigest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectGameTokenWithDigest ** SOAP_FMAC4 soap_in_PointerTotns__selectGameTokenWithDigest(struct soap *soap, const char *tag, tns__selectGameTokenWithDigest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectGameTokenWithDigest **)soap_malloc(soap, sizeof(tns__selectGameTokenWithDigest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectGameTokenWithDigest *)soap_instantiate_tns__selectGameTokenWithDigest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectGameTokenWithDigest ** p = (tns__selectGameTokenWithDigest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__selectGameTokenWithDigest, sizeof(tns__selectGameTokenWithDigest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectGameTokenWithDigest(struct soap *soap, tns__selectGameTokenWithDigest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__selectGameTokenWithDigest);
	if (soap_out_PointerTotns__selectGameTokenWithDigest(soap, tag?tag:"tns:selectGameTokenWithDigest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectGameTokenWithDigest ** SOAP_FMAC4 soap_get_PointerTotns__selectGameTokenWithDigest(struct soap *soap, tns__selectGameTokenWithDigest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectGameTokenWithDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectGameAnnotationsWithTokenIdResponse(struct soap *soap, tns__selectGameAnnotationsWithTokenIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__selectGameAnnotationsWithTokenIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectGameAnnotationsWithTokenIdResponse(struct soap *soap, const char *tag, int id, tns__selectGameAnnotationsWithTokenIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__selectGameAnnotationsWithTokenIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectGameAnnotationsWithTokenIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__selectGameAnnotationsWithTokenIdResponse(struct soap *soap, const char *tag, tns__selectGameAnnotationsWithTokenIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectGameAnnotationsWithTokenIdResponse **)soap_malloc(soap, sizeof(tns__selectGameAnnotationsWithTokenIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectGameAnnotationsWithTokenIdResponse *)soap_instantiate_tns__selectGameAnnotationsWithTokenIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectGameAnnotationsWithTokenIdResponse ** p = (tns__selectGameAnnotationsWithTokenIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__selectGameAnnotationsWithTokenIdResponse, sizeof(tns__selectGameAnnotationsWithTokenIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectGameAnnotationsWithTokenIdResponse(struct soap *soap, tns__selectGameAnnotationsWithTokenIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__selectGameAnnotationsWithTokenIdResponse);
	if (soap_out_PointerTotns__selectGameAnnotationsWithTokenIdResponse(soap, tag?tag:"tns:selectGameAnnotationsWithTokenIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectGameAnnotationsWithTokenIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__selectGameAnnotationsWithTokenIdResponse(struct soap *soap, tns__selectGameAnnotationsWithTokenIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectGameAnnotationsWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectGameAnnotationsWithTokenId(struct soap *soap, tns__selectGameAnnotationsWithTokenId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__selectGameAnnotationsWithTokenId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectGameAnnotationsWithTokenId(struct soap *soap, const char *tag, int id, tns__selectGameAnnotationsWithTokenId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__selectGameAnnotationsWithTokenId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectGameAnnotationsWithTokenId ** SOAP_FMAC4 soap_in_PointerTotns__selectGameAnnotationsWithTokenId(struct soap *soap, const char *tag, tns__selectGameAnnotationsWithTokenId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectGameAnnotationsWithTokenId **)soap_malloc(soap, sizeof(tns__selectGameAnnotationsWithTokenId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectGameAnnotationsWithTokenId *)soap_instantiate_tns__selectGameAnnotationsWithTokenId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectGameAnnotationsWithTokenId ** p = (tns__selectGameAnnotationsWithTokenId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__selectGameAnnotationsWithTokenId, sizeof(tns__selectGameAnnotationsWithTokenId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectGameAnnotationsWithTokenId(struct soap *soap, tns__selectGameAnnotationsWithTokenId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__selectGameAnnotationsWithTokenId);
	if (soap_out_PointerTotns__selectGameAnnotationsWithTokenId(soap, tag?tag:"tns:selectGameAnnotationsWithTokenId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectGameAnnotationsWithTokenId ** SOAP_FMAC4 soap_get_PointerTotns__selectGameAnnotationsWithTokenId(struct soap *soap, tns__selectGameAnnotationsWithTokenId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectGameAnnotationsWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectGameAliasesWithTokenIdResponse(struct soap *soap, tns__selectGameAliasesWithTokenIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__selectGameAliasesWithTokenIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectGameAliasesWithTokenIdResponse(struct soap *soap, const char *tag, int id, tns__selectGameAliasesWithTokenIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__selectGameAliasesWithTokenIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectGameAliasesWithTokenIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__selectGameAliasesWithTokenIdResponse(struct soap *soap, const char *tag, tns__selectGameAliasesWithTokenIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectGameAliasesWithTokenIdResponse **)soap_malloc(soap, sizeof(tns__selectGameAliasesWithTokenIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectGameAliasesWithTokenIdResponse *)soap_instantiate_tns__selectGameAliasesWithTokenIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectGameAliasesWithTokenIdResponse ** p = (tns__selectGameAliasesWithTokenIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__selectGameAliasesWithTokenIdResponse, sizeof(tns__selectGameAliasesWithTokenIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectGameAliasesWithTokenIdResponse(struct soap *soap, tns__selectGameAliasesWithTokenIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__selectGameAliasesWithTokenIdResponse);
	if (soap_out_PointerTotns__selectGameAliasesWithTokenIdResponse(soap, tag?tag:"tns:selectGameAliasesWithTokenIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectGameAliasesWithTokenIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__selectGameAliasesWithTokenIdResponse(struct soap *soap, tns__selectGameAliasesWithTokenIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectGameAliasesWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectGameAliasesWithTokenId(struct soap *soap, tns__selectGameAliasesWithTokenId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__selectGameAliasesWithTokenId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectGameAliasesWithTokenId(struct soap *soap, const char *tag, int id, tns__selectGameAliasesWithTokenId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__selectGameAliasesWithTokenId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectGameAliasesWithTokenId ** SOAP_FMAC4 soap_in_PointerTotns__selectGameAliasesWithTokenId(struct soap *soap, const char *tag, tns__selectGameAliasesWithTokenId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectGameAliasesWithTokenId **)soap_malloc(soap, sizeof(tns__selectGameAliasesWithTokenId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectGameAliasesWithTokenId *)soap_instantiate_tns__selectGameAliasesWithTokenId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectGameAliasesWithTokenId ** p = (tns__selectGameAliasesWithTokenId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__selectGameAliasesWithTokenId, sizeof(tns__selectGameAliasesWithTokenId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectGameAliasesWithTokenId(struct soap *soap, tns__selectGameAliasesWithTokenId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__selectGameAliasesWithTokenId);
	if (soap_out_PointerTotns__selectGameAliasesWithTokenId(soap, tag?tag:"tns:selectGameAliasesWithTokenId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectGameAliasesWithTokenId ** SOAP_FMAC4 soap_get_PointerTotns__selectGameAliasesWithTokenId(struct soap *soap, tns__selectGameAliasesWithTokenId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectGameAliasesWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__isConnectedResponse(struct soap *soap, tns__isConnectedResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__isConnectedResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__isConnectedResponse(struct soap *soap, const char *tag, int id, tns__isConnectedResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__isConnectedResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__isConnectedResponse ** SOAP_FMAC4 soap_in_PointerTotns__isConnectedResponse(struct soap *soap, const char *tag, tns__isConnectedResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__isConnectedResponse **)soap_malloc(soap, sizeof(tns__isConnectedResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__isConnectedResponse *)soap_instantiate_tns__isConnectedResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__isConnectedResponse ** p = (tns__isConnectedResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__isConnectedResponse, sizeof(tns__isConnectedResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__isConnectedResponse(struct soap *soap, tns__isConnectedResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__isConnectedResponse);
	if (soap_out_PointerTotns__isConnectedResponse(soap, tag?tag:"tns:isConnectedResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__isConnectedResponse ** SOAP_FMAC4 soap_get_PointerTotns__isConnectedResponse(struct soap *soap, tns__isConnectedResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__isConnectedResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__isConnected(struct soap *soap, tns__isConnected *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__isConnected))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__isConnected(struct soap *soap, const char *tag, int id, tns__isConnected *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__isConnected);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__isConnected ** SOAP_FMAC4 soap_in_PointerTotns__isConnected(struct soap *soap, const char *tag, tns__isConnected **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__isConnected **)soap_malloc(soap, sizeof(tns__isConnected *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__isConnected *)soap_instantiate_tns__isConnected(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__isConnected ** p = (tns__isConnected **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__isConnected, sizeof(tns__isConnected), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__isConnected(struct soap *soap, tns__isConnected *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__isConnected);
	if (soap_out_PointerTotns__isConnected(soap, tag?tag:"tns:isConnected", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__isConnected ** SOAP_FMAC4 soap_get_PointerTotns__isConnected(struct soap *soap, tns__isConnected **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__isConnected(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__isClientUpdatedResponse(struct soap *soap, tns__isClientUpdatedResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__isClientUpdatedResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__isClientUpdatedResponse(struct soap *soap, const char *tag, int id, tns__isClientUpdatedResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__isClientUpdatedResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__isClientUpdatedResponse ** SOAP_FMAC4 soap_in_PointerTotns__isClientUpdatedResponse(struct soap *soap, const char *tag, tns__isClientUpdatedResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__isClientUpdatedResponse **)soap_malloc(soap, sizeof(tns__isClientUpdatedResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__isClientUpdatedResponse *)soap_instantiate_tns__isClientUpdatedResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__isClientUpdatedResponse ** p = (tns__isClientUpdatedResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__isClientUpdatedResponse, sizeof(tns__isClientUpdatedResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__isClientUpdatedResponse(struct soap *soap, tns__isClientUpdatedResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__isClientUpdatedResponse);
	if (soap_out_PointerTotns__isClientUpdatedResponse(soap, tag?tag:"tns:isClientUpdatedResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__isClientUpdatedResponse ** SOAP_FMAC4 soap_get_PointerTotns__isClientUpdatedResponse(struct soap *soap, tns__isClientUpdatedResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__isClientUpdatedResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__isClientUpdated(struct soap *soap, tns__isClientUpdated *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__isClientUpdated))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__isClientUpdated(struct soap *soap, const char *tag, int id, tns__isClientUpdated *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__isClientUpdated);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__isClientUpdated ** SOAP_FMAC4 soap_in_PointerTotns__isClientUpdated(struct soap *soap, const char *tag, tns__isClientUpdated **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__isClientUpdated **)soap_malloc(soap, sizeof(tns__isClientUpdated *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__isClientUpdated *)soap_instantiate_tns__isClientUpdated(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__isClientUpdated ** p = (tns__isClientUpdated **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__isClientUpdated, sizeof(tns__isClientUpdated), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__isClientUpdated(struct soap *soap, tns__isClientUpdated *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__isClientUpdated);
	if (soap_out_PointerTotns__isClientUpdated(soap, tag?tag:"tns:isClientUpdated", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__isClientUpdated ** SOAP_FMAC4 soap_get_PointerTotns__isClientUpdated(struct soap *soap, tns__isClientUpdated **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__isClientUpdated(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__chatResponse(struct soap *soap, tns__chatResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__chatResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__chatResponse(struct soap *soap, const char *tag, int id, tns__chatResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__chatResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__chatResponse ** SOAP_FMAC4 soap_in_PointerTotns__chatResponse(struct soap *soap, const char *tag, tns__chatResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__chatResponse **)soap_malloc(soap, sizeof(tns__chatResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__chatResponse *)soap_instantiate_tns__chatResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__chatResponse ** p = (tns__chatResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__chatResponse, sizeof(tns__chatResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__chatResponse(struct soap *soap, tns__chatResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__chatResponse);
	if (soap_out_PointerTotns__chatResponse(soap, tag?tag:"tns:chatResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__chatResponse ** SOAP_FMAC4 soap_get_PointerTotns__chatResponse(struct soap *soap, tns__chatResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__chatResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__chat(struct soap *soap, tns__chat *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__chat))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__chat(struct soap *soap, const char *tag, int id, tns__chat *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__chat);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__chat ** SOAP_FMAC4 soap_in_PointerTotns__chat(struct soap *soap, const char *tag, tns__chat **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__chat **)soap_malloc(soap, sizeof(tns__chat *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__chat *)soap_instantiate_tns__chat(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__chat ** p = (tns__chat **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__chat, sizeof(tns__chat), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__chat(struct soap *soap, tns__chat *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__chat);
	if (soap_out_PointerTotns__chat(soap, tag?tag:"tns:chat", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__chat ** SOAP_FMAC4 soap_get_PointerTotns__chat(struct soap *soap, tns__chat **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__chat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__blessMediaAnnotationWithIdResponse(struct soap *soap, tns__blessMediaAnnotationWithIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__blessMediaAnnotationWithIdResponse(struct soap *soap, const char *tag, int id, tns__blessMediaAnnotationWithIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__blessMediaAnnotationWithIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__blessMediaAnnotationWithIdResponse(struct soap *soap, const char *tag, tns__blessMediaAnnotationWithIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__blessMediaAnnotationWithIdResponse **)soap_malloc(soap, sizeof(tns__blessMediaAnnotationWithIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__blessMediaAnnotationWithIdResponse *)soap_instantiate_tns__blessMediaAnnotationWithIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__blessMediaAnnotationWithIdResponse ** p = (tns__blessMediaAnnotationWithIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithIdResponse, sizeof(tns__blessMediaAnnotationWithIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__blessMediaAnnotationWithIdResponse(struct soap *soap, tns__blessMediaAnnotationWithIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__blessMediaAnnotationWithIdResponse);
	if (soap_out_PointerTotns__blessMediaAnnotationWithIdResponse(soap, tag?tag:"tns:blessMediaAnnotationWithIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__blessMediaAnnotationWithIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__blessMediaAnnotationWithIdResponse(struct soap *soap, tns__blessMediaAnnotationWithIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__blessMediaAnnotationWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__blessMediaAnnotationWithId(struct soap *soap, tns__blessMediaAnnotationWithId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__blessMediaAnnotationWithId(struct soap *soap, const char *tag, int id, tns__blessMediaAnnotationWithId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__blessMediaAnnotationWithId ** SOAP_FMAC4 soap_in_PointerTotns__blessMediaAnnotationWithId(struct soap *soap, const char *tag, tns__blessMediaAnnotationWithId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__blessMediaAnnotationWithId **)soap_malloc(soap, sizeof(tns__blessMediaAnnotationWithId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__blessMediaAnnotationWithId *)soap_instantiate_tns__blessMediaAnnotationWithId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__blessMediaAnnotationWithId ** p = (tns__blessMediaAnnotationWithId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithId, sizeof(tns__blessMediaAnnotationWithId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__blessMediaAnnotationWithId(struct soap *soap, tns__blessMediaAnnotationWithId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__blessMediaAnnotationWithId);
	if (soap_out_PointerTotns__blessMediaAnnotationWithId(soap, tag?tag:"tns:blessMediaAnnotationWithId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__blessMediaAnnotationWithId ** SOAP_FMAC4 soap_get_PointerTotns__blessMediaAnnotationWithId(struct soap *soap, tns__blessMediaAnnotationWithId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__blessMediaAnnotationWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__blessGameAnnotationWithIdResponse(struct soap *soap, tns__blessGameAnnotationWithIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__blessGameAnnotationWithIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__blessGameAnnotationWithIdResponse(struct soap *soap, const char *tag, int id, tns__blessGameAnnotationWithIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__blessGameAnnotationWithIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__blessGameAnnotationWithIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__blessGameAnnotationWithIdResponse(struct soap *soap, const char *tag, tns__blessGameAnnotationWithIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__blessGameAnnotationWithIdResponse **)soap_malloc(soap, sizeof(tns__blessGameAnnotationWithIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__blessGameAnnotationWithIdResponse *)soap_instantiate_tns__blessGameAnnotationWithIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__blessGameAnnotationWithIdResponse ** p = (tns__blessGameAnnotationWithIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__blessGameAnnotationWithIdResponse, sizeof(tns__blessGameAnnotationWithIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__blessGameAnnotationWithIdResponse(struct soap *soap, tns__blessGameAnnotationWithIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__blessGameAnnotationWithIdResponse);
	if (soap_out_PointerTotns__blessGameAnnotationWithIdResponse(soap, tag?tag:"tns:blessGameAnnotationWithIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__blessGameAnnotationWithIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__blessGameAnnotationWithIdResponse(struct soap *soap, tns__blessGameAnnotationWithIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__blessGameAnnotationWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__blessGameAnnotationWithId(struct soap *soap, tns__blessGameAnnotationWithId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__blessGameAnnotationWithId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__blessGameAnnotationWithId(struct soap *soap, const char *tag, int id, tns__blessGameAnnotationWithId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__blessGameAnnotationWithId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__blessGameAnnotationWithId ** SOAP_FMAC4 soap_in_PointerTotns__blessGameAnnotationWithId(struct soap *soap, const char *tag, tns__blessGameAnnotationWithId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__blessGameAnnotationWithId **)soap_malloc(soap, sizeof(tns__blessGameAnnotationWithId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__blessGameAnnotationWithId *)soap_instantiate_tns__blessGameAnnotationWithId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__blessGameAnnotationWithId ** p = (tns__blessGameAnnotationWithId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__blessGameAnnotationWithId, sizeof(tns__blessGameAnnotationWithId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__blessGameAnnotationWithId(struct soap *soap, tns__blessGameAnnotationWithId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__blessGameAnnotationWithId);
	if (soap_out_PointerTotns__blessGameAnnotationWithId(soap, tag?tag:"tns:blessGameAnnotationWithId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__blessGameAnnotationWithId ** SOAP_FMAC4 soap_get_PointerTotns__blessGameAnnotationWithId(struct soap *soap, tns__blessGameAnnotationWithId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__blessGameAnnotationWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__user(struct soap *soap, tns__user *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__user))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__user(struct soap *soap, const char *tag, int id, tns__user *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__user);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__user ** SOAP_FMAC4 soap_in_PointerTotns__user(struct soap *soap, const char *tag, tns__user **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__user **)soap_malloc(soap, sizeof(tns__user *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__user *)soap_instantiate_tns__user(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__user ** p = (tns__user **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__user, sizeof(tns__user), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__user(struct soap *soap, tns__user *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__user);
	if (soap_out_PointerTotns__user(soap, tag?tag:"tns:user", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__user ** SOAP_FMAC4 soap_get_PointerTotns__user(struct soap *soap, tns__user **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__user(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__mediaToken(struct soap *soap, tns__mediaToken *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__mediaToken))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__mediaToken(struct soap *soap, const char *tag, int id, tns__mediaToken *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__mediaToken);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__mediaToken ** SOAP_FMAC4 soap_in_PointerTotns__mediaToken(struct soap *soap, const char *tag, tns__mediaToken **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__mediaToken **)soap_malloc(soap, sizeof(tns__mediaToken *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__mediaToken *)soap_instantiate_tns__mediaToken(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__mediaToken ** p = (tns__mediaToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__mediaToken, sizeof(tns__mediaToken), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__mediaToken(struct soap *soap, tns__mediaToken *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__mediaToken);
	if (soap_out_PointerTotns__mediaToken(soap, tag?tag:"tns:mediaToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__mediaToken ** SOAP_FMAC4 soap_get_PointerTotns__mediaToken(struct soap *soap, tns__mediaToken **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__mediaToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__mediaAnnotation(struct soap *soap, tns__mediaAnnotation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__mediaAnnotation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__mediaAnnotation(struct soap *soap, const char *tag, int id, tns__mediaAnnotation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__mediaAnnotation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__mediaAnnotation ** SOAP_FMAC4 soap_in_PointerTotns__mediaAnnotation(struct soap *soap, const char *tag, tns__mediaAnnotation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__mediaAnnotation **)soap_malloc(soap, sizeof(tns__mediaAnnotation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__mediaAnnotation *)soap_instantiate_tns__mediaAnnotation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__mediaAnnotation ** p = (tns__mediaAnnotation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__mediaAnnotation, sizeof(tns__mediaAnnotation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__mediaAnnotation(struct soap *soap, tns__mediaAnnotation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__mediaAnnotation);
	if (soap_out_PointerTotns__mediaAnnotation(soap, tag?tag:"tns:mediaAnnotation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__mediaAnnotation ** SOAP_FMAC4 soap_get_PointerTotns__mediaAnnotation(struct soap *soap, tns__mediaAnnotation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__mediaAnnotation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__mediaAlias(struct soap *soap, tns__mediaAlias *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__mediaAlias))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__mediaAlias(struct soap *soap, const char *tag, int id, tns__mediaAlias *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__mediaAlias);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__mediaAlias ** SOAP_FMAC4 soap_in_PointerTotns__mediaAlias(struct soap *soap, const char *tag, tns__mediaAlias **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__mediaAlias **)soap_malloc(soap, sizeof(tns__mediaAlias *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__mediaAlias *)soap_instantiate_tns__mediaAlias(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__mediaAlias ** p = (tns__mediaAlias **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__mediaAlias, sizeof(tns__mediaAlias), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__mediaAlias(struct soap *soap, tns__mediaAlias *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__mediaAlias);
	if (soap_out_PointerTotns__mediaAlias(soap, tag?tag:"tns:mediaAlias", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__mediaAlias ** SOAP_FMAC4 soap_get_PointerTotns__mediaAlias(struct soap *soap, tns__mediaAlias **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__mediaAlias(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__gameToken(struct soap *soap, tns__gameToken *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__gameToken))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__gameToken(struct soap *soap, const char *tag, int id, tns__gameToken *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__gameToken);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__gameToken ** SOAP_FMAC4 soap_in_PointerTotns__gameToken(struct soap *soap, const char *tag, tns__gameToken **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__gameToken **)soap_malloc(soap, sizeof(tns__gameToken *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__gameToken *)soap_instantiate_tns__gameToken(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__gameToken ** p = (tns__gameToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__gameToken, sizeof(tns__gameToken), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__gameToken(struct soap *soap, tns__gameToken *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__gameToken);
	if (soap_out_PointerTotns__gameToken(soap, tag?tag:"tns:gameToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__gameToken ** SOAP_FMAC4 soap_get_PointerTotns__gameToken(struct soap *soap, tns__gameToken **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__gameToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__gameAnnotation(struct soap *soap, tns__gameAnnotation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__gameAnnotation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__gameAnnotation(struct soap *soap, const char *tag, int id, tns__gameAnnotation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__gameAnnotation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__gameAnnotation ** SOAP_FMAC4 soap_in_PointerTotns__gameAnnotation(struct soap *soap, const char *tag, tns__gameAnnotation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__gameAnnotation **)soap_malloc(soap, sizeof(tns__gameAnnotation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__gameAnnotation *)soap_instantiate_tns__gameAnnotation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__gameAnnotation ** p = (tns__gameAnnotation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__gameAnnotation, sizeof(tns__gameAnnotation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__gameAnnotation(struct soap *soap, tns__gameAnnotation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__gameAnnotation);
	if (soap_out_PointerTotns__gameAnnotation(soap, tag?tag:"tns:gameAnnotation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__gameAnnotation ** SOAP_FMAC4 soap_get_PointerTotns__gameAnnotation(struct soap *soap, tns__gameAnnotation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__gameAnnotation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__gameAlias(struct soap *soap, tns__gameAlias *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__gameAlias))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__gameAlias(struct soap *soap, const char *tag, int id, tns__gameAlias *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__gameAlias);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__gameAlias ** SOAP_FMAC4 soap_in_PointerTotns__gameAlias(struct soap *soap, const char *tag, tns__gameAlias **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__gameAlias **)soap_malloc(soap, sizeof(tns__gameAlias *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__gameAlias *)soap_instantiate_tns__gameAlias(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__gameAlias ** p = (tns__gameAlias **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__gameAlias, sizeof(tns__gameAlias), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__gameAlias(struct soap *soap, tns__gameAlias *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__gameAlias);
	if (soap_out_PointerTotns__gameAlias(soap, tag?tag:"tns:gameAlias", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__gameAlias ** SOAP_FMAC4 soap_get_PointerTotns__gameAlias(struct soap *soap, tns__gameAlias **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__gameAlias(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ServerSoap__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_ServerSoap__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ServerSoap_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ServerSoap_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_ServerSoap_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTotns__mediaAnnotation(struct soap *soap, std::vector<tns__mediaAnnotation * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTotns__mediaAnnotation(struct soap *soap, const std::vector<tns__mediaAnnotation * >*a)
{
	for (std::vector<tns__mediaAnnotation * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTotns__mediaAnnotation(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTotns__mediaAnnotation(struct soap *soap, const char *tag, int id, const std::vector<tns__mediaAnnotation * >*a, const char *type)
{
	for (std::vector<tns__mediaAnnotation * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTotns__mediaAnnotation(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tns__mediaAnnotation * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTotns__mediaAnnotation(struct soap *soap, const char *tag, std::vector<tns__mediaAnnotation * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTotns__mediaAnnotation(soap, -1)))
		return NULL;
	tns__mediaAnnotation *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ServerSoap_tns__mediaAnnotation, SOAP_TYPE_ServerSoap_std__vectorTemplateOfPointerTotns__mediaAnnotation, sizeof(tns__mediaAnnotation), 1))
				break;
			if (!soap_in_PointerTotns__mediaAnnotation(soap, tag, NULL, "tns:mediaAnnotation"))
				break;
		}
		else
		{
			if (!soap_in_PointerTotns__mediaAnnotation(soap, tag, &n, "tns:mediaAnnotation"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tns__mediaAnnotation * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTotns__mediaAnnotation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTotns__mediaAnnotation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_std__vectorTemplateOfPointerTotns__mediaAnnotation, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tns__mediaAnnotation * >);
		if (size)
			*size = sizeof(std::vector<tns__mediaAnnotation * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tns__mediaAnnotation * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<tns__mediaAnnotation * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<tns__mediaAnnotation * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTotns__mediaAnnotation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<tns__mediaAnnotation * > %p -> %p\n", q, p));
	*(std::vector<tns__mediaAnnotation * >*)p = *(std::vector<tns__mediaAnnotation * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTotns__mediaAlias(struct soap *soap, std::vector<tns__mediaAlias * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTotns__mediaAlias(struct soap *soap, const std::vector<tns__mediaAlias * >*a)
{
	for (std::vector<tns__mediaAlias * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTotns__mediaAlias(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTotns__mediaAlias(struct soap *soap, const char *tag, int id, const std::vector<tns__mediaAlias * >*a, const char *type)
{
	for (std::vector<tns__mediaAlias * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTotns__mediaAlias(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tns__mediaAlias * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTotns__mediaAlias(struct soap *soap, const char *tag, std::vector<tns__mediaAlias * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTotns__mediaAlias(soap, -1)))
		return NULL;
	tns__mediaAlias *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ServerSoap_tns__mediaAlias, SOAP_TYPE_ServerSoap_std__vectorTemplateOfPointerTotns__mediaAlias, sizeof(tns__mediaAlias), 1))
				break;
			if (!soap_in_PointerTotns__mediaAlias(soap, tag, NULL, "tns:mediaAlias"))
				break;
		}
		else
		{
			if (!soap_in_PointerTotns__mediaAlias(soap, tag, &n, "tns:mediaAlias"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tns__mediaAlias * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTotns__mediaAlias(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTotns__mediaAlias(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_std__vectorTemplateOfPointerTotns__mediaAlias, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tns__mediaAlias * >);
		if (size)
			*size = sizeof(std::vector<tns__mediaAlias * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tns__mediaAlias * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<tns__mediaAlias * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<tns__mediaAlias * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTotns__mediaAlias(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<tns__mediaAlias * > %p -> %p\n", q, p));
	*(std::vector<tns__mediaAlias * >*)p = *(std::vector<tns__mediaAlias * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTotns__gameAnnotation(struct soap *soap, std::vector<tns__gameAnnotation * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTotns__gameAnnotation(struct soap *soap, const std::vector<tns__gameAnnotation * >*a)
{
	for (std::vector<tns__gameAnnotation * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTotns__gameAnnotation(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTotns__gameAnnotation(struct soap *soap, const char *tag, int id, const std::vector<tns__gameAnnotation * >*a, const char *type)
{
	for (std::vector<tns__gameAnnotation * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTotns__gameAnnotation(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tns__gameAnnotation * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTotns__gameAnnotation(struct soap *soap, const char *tag, std::vector<tns__gameAnnotation * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTotns__gameAnnotation(soap, -1)))
		return NULL;
	tns__gameAnnotation *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ServerSoap_tns__gameAnnotation, SOAP_TYPE_ServerSoap_std__vectorTemplateOfPointerTotns__gameAnnotation, sizeof(tns__gameAnnotation), 1))
				break;
			if (!soap_in_PointerTotns__gameAnnotation(soap, tag, NULL, "tns:gameAnnotation"))
				break;
		}
		else
		{
			if (!soap_in_PointerTotns__gameAnnotation(soap, tag, &n, "tns:gameAnnotation"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tns__gameAnnotation * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTotns__gameAnnotation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTotns__gameAnnotation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_std__vectorTemplateOfPointerTotns__gameAnnotation, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tns__gameAnnotation * >);
		if (size)
			*size = sizeof(std::vector<tns__gameAnnotation * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tns__gameAnnotation * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<tns__gameAnnotation * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<tns__gameAnnotation * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTotns__gameAnnotation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<tns__gameAnnotation * > %p -> %p\n", q, p));
	*(std::vector<tns__gameAnnotation * >*)p = *(std::vector<tns__gameAnnotation * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTotns__gameAlias(struct soap *soap, std::vector<tns__gameAlias * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTotns__gameAlias(struct soap *soap, const std::vector<tns__gameAlias * >*a)
{
	for (std::vector<tns__gameAlias * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTotns__gameAlias(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTotns__gameAlias(struct soap *soap, const char *tag, int id, const std::vector<tns__gameAlias * >*a, const char *type)
{
	for (std::vector<tns__gameAlias * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTotns__gameAlias(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tns__gameAlias * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTotns__gameAlias(struct soap *soap, const char *tag, std::vector<tns__gameAlias * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTotns__gameAlias(soap, -1)))
		return NULL;
	tns__gameAlias *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ServerSoap_tns__gameAlias, SOAP_TYPE_ServerSoap_std__vectorTemplateOfPointerTotns__gameAlias, sizeof(tns__gameAlias), 1))
				break;
			if (!soap_in_PointerTotns__gameAlias(soap, tag, NULL, "tns:gameAlias"))
				break;
		}
		else
		{
			if (!soap_in_PointerTotns__gameAlias(soap, tag, &n, "tns:gameAlias"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tns__gameAlias * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTotns__gameAlias(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTotns__gameAlias(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_std__vectorTemplateOfPointerTotns__gameAlias, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tns__gameAlias * >);
		if (size)
			*size = sizeof(std::vector<tns__gameAlias * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tns__gameAlias * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<tns__gameAlias * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<tns__gameAlias * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTotns__gameAlias(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<tns__gameAlias * > %p -> %p\n", q, p));
	*(std::vector<tns__gameAlias * >*)p = *(std::vector<tns__gameAlias * >*)q;
}

} // namespace ServerSoap


#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of ServerSoapC.cpp */
