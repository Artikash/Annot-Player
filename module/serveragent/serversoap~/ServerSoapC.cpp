/* ServerSoapC.cpp
   Generated by gSOAP 2.8.5 from _serversoap.h

Copyright(C) 2000-2011, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
1) GPL or 2) Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "ServerSoapH.h"

namespace ServerSoap {

SOAP_SOURCE_STAMP("@(#) ServerSoapC.cpp ver 2.8.5 2011-12-11 03:27:03 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_ServerSoap_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_ServerSoap_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_ServerSoap_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_ServerSoap_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ServerSoap_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithIdResponse:
		return soap_in_tns__updateMediaAnnotationTextWithIdResponse(soap, NULL, NULL, "tns:updateMediaAnnotationTextWithIdResponse");
	case SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithId:
		return soap_in_tns__updateMediaAnnotationTextWithId(soap, NULL, NULL, "tns:updateMediaAnnotationTextWithId");
	case SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigestResponse:
		return soap_in_tns__submitMediaTokenDigestResponse(soap, NULL, NULL, "tns:submitMediaTokenDigestResponse");
	case SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigest:
		return soap_in_tns__submitMediaTokenDigest(soap, NULL, NULL, "tns:submitMediaTokenDigest");
	case SOAP_TYPE_ServerSoap_tns__submitMediaTokenResponse:
		return soap_in_tns__submitMediaTokenResponse(soap, NULL, NULL, "tns:submitMediaTokenResponse");
	case SOAP_TYPE_ServerSoap_tns__submitMediaToken:
		return soap_in_tns__submitMediaToken(soap, NULL, NULL, "tns:submitMediaToken");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenIdResponse:
		return soap_in_tns__submitMediaAnnotationTextWithTokenIdResponse(soap, NULL, NULL, "tns:submitMediaAnnotationTextWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenId:
		return soap_in_tns__submitMediaAnnotationTextWithTokenId(soap, NULL, NULL, "tns:submitMediaAnnotationTextWithTokenId");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigestResponse:
		return soap_in_tns__submitMediaAnnotationTextAndTokenDigestResponse(soap, NULL, NULL, "tns:submitMediaAnnotationTextAndTokenDigestResponse");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigest:
		return soap_in_tns__submitMediaAnnotationTextAndTokenDigest(soap, NULL, NULL, "tns:submitMediaAnnotationTextAndTokenDigest");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationResponse:
		return soap_in_tns__submitMediaAnnotationResponse(soap, NULL, NULL, "tns:submitMediaAnnotationResponse");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotation:
		return soap_in_tns__submitMediaAnnotation(soap, NULL, NULL, "tns:submitMediaAnnotation");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenIdResponse:
		return soap_in_tns__submitMediaAliasTextWithTokenIdResponse(soap, NULL, NULL, "tns:submitMediaAliasTextWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenId:
		return soap_in_tns__submitMediaAliasTextWithTokenId(soap, NULL, NULL, "tns:submitMediaAliasTextWithTokenId");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigestResponse:
		return soap_in_tns__submitMediaAliasTextAndTokenDigestResponse(soap, NULL, NULL, "tns:submitMediaAliasTextAndTokenDigestResponse");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigest:
		return soap_in_tns__submitMediaAliasTextAndTokenDigest(soap, NULL, NULL, "tns:submitMediaAliasTextAndTokenDigest");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasResponse:
		return soap_in_tns__submitMediaAliasResponse(soap, NULL, NULL, "tns:submitMediaAliasResponse");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAlias:
		return soap_in_tns__submitMediaAlias(soap, NULL, NULL, "tns:submitMediaAlias");
	case SOAP_TYPE_ServerSoap_tns__setUserLanguageResponse:
		return soap_in_tns__setUserLanguageResponse(soap, NULL, NULL, "tns:setUserLanguageResponse");
	case SOAP_TYPE_ServerSoap_tns__setUserLanguage:
		return soap_in_tns__setUserLanguage(soap, NULL, NULL, "tns:setUserLanguage");
	case SOAP_TYPE_ServerSoap_tns__setUserAnonymousResponse:
		return soap_in_tns__setUserAnonymousResponse(soap, NULL, NULL, "tns:setUserAnonymousResponse");
	case SOAP_TYPE_ServerSoap_tns__setUserAnonymous:
		return soap_in_tns__setUserAnonymous(soap, NULL, NULL, "tns:setUserAnonymous");
	case SOAP_TYPE_ServerSoap_tns__selectUserResponse:
		return soap_in_tns__selectUserResponse(soap, NULL, NULL, "tns:selectUserResponse");
	case SOAP_TYPE_ServerSoap_tns__selectUser:
		return soap_in_tns__selectUser(soap, NULL, NULL, "tns:selectUser");
	case SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenIdResponse:
		return soap_in_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(soap, NULL, NULL, "tns:selectRelatedMediaAnnotationsWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenId:
		return soap_in_tns__selectRelatedMediaAnnotationsWithTokenId(soap, NULL, NULL, "tns:selectRelatedMediaAnnotationsWithTokenId");
	case SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithIdResponse:
		return soap_in_tns__selectMediaTokenWithIdResponse(soap, NULL, NULL, "tns:selectMediaTokenWithIdResponse");
	case SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithId:
		return soap_in_tns__selectMediaTokenWithId(soap, NULL, NULL, "tns:selectMediaTokenWithId");
	case SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigestResponse:
		return soap_in_tns__selectMediaTokenWithDigestResponse(soap, NULL, NULL, "tns:selectMediaTokenWithDigestResponse");
	case SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigest:
		return soap_in_tns__selectMediaTokenWithDigest(soap, NULL, NULL, "tns:selectMediaTokenWithDigest");
	case SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenIdResponse:
		return soap_in_tns__selectMediaAnnotationsWithTokenIdResponse(soap, NULL, NULL, "tns:selectMediaAnnotationsWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenId:
		return soap_in_tns__selectMediaAnnotationsWithTokenId(soap, NULL, NULL, "tns:selectMediaAnnotationsWithTokenId");
	case SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenIdResponse:
		return soap_in_tns__selectMediaAliasesWithTokenIdResponse(soap, NULL, NULL, "tns:selectMediaAliasesWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenId:
		return soap_in_tns__selectMediaAliasesWithTokenId(soap, NULL, NULL, "tns:selectMediaAliasesWithTokenId");
	case SOAP_TYPE_ServerSoap_tns__isConnectedResponse:
		return soap_in_tns__isConnectedResponse(soap, NULL, NULL, "tns:isConnectedResponse");
	case SOAP_TYPE_ServerSoap_tns__isConnected:
		return soap_in_tns__isConnected(soap, NULL, NULL, "tns:isConnected");
	case SOAP_TYPE_ServerSoap_tns__isClientUpdatedResponse:
		return soap_in_tns__isClientUpdatedResponse(soap, NULL, NULL, "tns:isClientUpdatedResponse");
	case SOAP_TYPE_ServerSoap_tns__isClientUpdated:
		return soap_in_tns__isClientUpdated(soap, NULL, NULL, "tns:isClientUpdated");
	case SOAP_TYPE_ServerSoap_tns__curseMediaTokenWithIdResponse:
		return soap_in_tns__curseMediaTokenWithIdResponse(soap, NULL, NULL, "tns:curseMediaTokenWithIdResponse");
	case SOAP_TYPE_ServerSoap_tns__curseMediaTokenWithId:
		return soap_in_tns__curseMediaTokenWithId(soap, NULL, NULL, "tns:curseMediaTokenWithId");
	case SOAP_TYPE_ServerSoap_tns__curseMediaAnnotationWithIdResponse:
		return soap_in_tns__curseMediaAnnotationWithIdResponse(soap, NULL, NULL, "tns:curseMediaAnnotationWithIdResponse");
	case SOAP_TYPE_ServerSoap_tns__curseMediaAnnotationWithId:
		return soap_in_tns__curseMediaAnnotationWithId(soap, NULL, NULL, "tns:curseMediaAnnotationWithId");
	case SOAP_TYPE_ServerSoap_tns__curseMediaAliasWithIdResponse:
		return soap_in_tns__curseMediaAliasWithIdResponse(soap, NULL, NULL, "tns:curseMediaAliasWithIdResponse");
	case SOAP_TYPE_ServerSoap_tns__curseMediaAliasWithId:
		return soap_in_tns__curseMediaAliasWithId(soap, NULL, NULL, "tns:curseMediaAliasWithId");
	case SOAP_TYPE_ServerSoap_tns__chatResponse:
		return soap_in_tns__chatResponse(soap, NULL, NULL, "tns:chatResponse");
	case SOAP_TYPE_ServerSoap_tns__chat:
		return soap_in_tns__chat(soap, NULL, NULL, "tns:chat");
	case SOAP_TYPE_ServerSoap_tns__blockUserWithIdResponse:
		return soap_in_tns__blockUserWithIdResponse(soap, NULL, NULL, "tns:blockUserWithIdResponse");
	case SOAP_TYPE_ServerSoap_tns__blockUserWithId:
		return soap_in_tns__blockUserWithId(soap, NULL, NULL, "tns:blockUserWithId");
	case SOAP_TYPE_ServerSoap_tns__blockMediaAnnotationWithIdResponse:
		return soap_in_tns__blockMediaAnnotationWithIdResponse(soap, NULL, NULL, "tns:blockMediaAnnotationWithIdResponse");
	case SOAP_TYPE_ServerSoap_tns__blockMediaAnnotationWithId:
		return soap_in_tns__blockMediaAnnotationWithId(soap, NULL, NULL, "tns:blockMediaAnnotationWithId");
	case SOAP_TYPE_ServerSoap_tns__blockMediaAliasWithIdResponse:
		return soap_in_tns__blockMediaAliasWithIdResponse(soap, NULL, NULL, "tns:blockMediaAliasWithIdResponse");
	case SOAP_TYPE_ServerSoap_tns__blockMediaAliasWithId:
		return soap_in_tns__blockMediaAliasWithId(soap, NULL, NULL, "tns:blockMediaAliasWithId");
	case SOAP_TYPE_ServerSoap_tns__blessMediaTokenWithIdResponse:
		return soap_in_tns__blessMediaTokenWithIdResponse(soap, NULL, NULL, "tns:blessMediaTokenWithIdResponse");
	case SOAP_TYPE_ServerSoap_tns__blessMediaTokenWithId:
		return soap_in_tns__blessMediaTokenWithId(soap, NULL, NULL, "tns:blessMediaTokenWithId");
	case SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithIdResponse:
		return soap_in_tns__blessMediaAnnotationWithIdResponse(soap, NULL, NULL, "tns:blessMediaAnnotationWithIdResponse");
	case SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithId:
		return soap_in_tns__blessMediaAnnotationWithId(soap, NULL, NULL, "tns:blessMediaAnnotationWithId");
	case SOAP_TYPE_ServerSoap_tns__blessMediaAliasWithIdResponse:
		return soap_in_tns__blessMediaAliasWithIdResponse(soap, NULL, NULL, "tns:blessMediaAliasWithIdResponse");
	case SOAP_TYPE_ServerSoap_tns__blessMediaAliasWithId:
		return soap_in_tns__blessMediaAliasWithId(soap, NULL, NULL, "tns:blessMediaAliasWithId");
	case SOAP_TYPE_ServerSoap_tns__user:
		return soap_in_tns__user(soap, NULL, NULL, "tns:user");
	case SOAP_TYPE_ServerSoap_tns__mediaAlias:
		return soap_in_tns__mediaAlias(soap, NULL, NULL, "tns:mediaAlias");
	case SOAP_TYPE_ServerSoap_tns__mediaToken:
		return soap_in_tns__mediaToken(soap, NULL, NULL, "tns:mediaToken");
	case SOAP_TYPE_ServerSoap_tns__mediaAnnotation:
		return soap_in_tns__mediaAnnotation(soap, NULL, NULL, "tns:mediaAnnotation");
	case SOAP_TYPE_ServerSoap_PointerTotns__updateMediaAnnotationTextWithIdResponse:
		return soap_in_PointerTotns__updateMediaAnnotationTextWithIdResponse(soap, NULL, NULL, "tns:updateMediaAnnotationTextWithIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__updateMediaAnnotationTextWithId:
		return soap_in_PointerTotns__updateMediaAnnotationTextWithId(soap, NULL, NULL, "tns:updateMediaAnnotationTextWithId");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaTokenDigestResponse:
		return soap_in_PointerTotns__submitMediaTokenDigestResponse(soap, NULL, NULL, "tns:submitMediaTokenDigestResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaTokenDigest:
		return soap_in_PointerTotns__submitMediaTokenDigest(soap, NULL, NULL, "tns:submitMediaTokenDigest");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaTokenResponse:
		return soap_in_PointerTotns__submitMediaTokenResponse(soap, NULL, NULL, "tns:submitMediaTokenResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaToken:
		return soap_in_PointerTotns__submitMediaToken(soap, NULL, NULL, "tns:submitMediaToken");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse:
		return soap_in_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse(soap, NULL, NULL, "tns:submitMediaAnnotationTextWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotationTextWithTokenId:
		return soap_in_PointerTotns__submitMediaAnnotationTextWithTokenId(soap, NULL, NULL, "tns:submitMediaAnnotationTextWithTokenId");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse:
		return soap_in_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse(soap, NULL, NULL, "tns:submitMediaAnnotationTextAndTokenDigestResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotationTextAndTokenDigest:
		return soap_in_PointerTotns__submitMediaAnnotationTextAndTokenDigest(soap, NULL, NULL, "tns:submitMediaAnnotationTextAndTokenDigest");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotationResponse:
		return soap_in_PointerTotns__submitMediaAnnotationResponse(soap, NULL, NULL, "tns:submitMediaAnnotationResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotation:
		return soap_in_PointerTotns__submitMediaAnnotation(soap, NULL, NULL, "tns:submitMediaAnnotation");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAliasTextWithTokenIdResponse:
		return soap_in_PointerTotns__submitMediaAliasTextWithTokenIdResponse(soap, NULL, NULL, "tns:submitMediaAliasTextWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAliasTextWithTokenId:
		return soap_in_PointerTotns__submitMediaAliasTextWithTokenId(soap, NULL, NULL, "tns:submitMediaAliasTextWithTokenId");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAliasTextAndTokenDigestResponse:
		return soap_in_PointerTotns__submitMediaAliasTextAndTokenDigestResponse(soap, NULL, NULL, "tns:submitMediaAliasTextAndTokenDigestResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAliasTextAndTokenDigest:
		return soap_in_PointerTotns__submitMediaAliasTextAndTokenDigest(soap, NULL, NULL, "tns:submitMediaAliasTextAndTokenDigest");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAliasResponse:
		return soap_in_PointerTotns__submitMediaAliasResponse(soap, NULL, NULL, "tns:submitMediaAliasResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAlias:
		return soap_in_PointerTotns__submitMediaAlias(soap, NULL, NULL, "tns:submitMediaAlias");
	case SOAP_TYPE_ServerSoap_PointerTotns__setUserLanguageResponse:
		return soap_in_PointerTotns__setUserLanguageResponse(soap, NULL, NULL, "tns:setUserLanguageResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__setUserLanguage:
		return soap_in_PointerTotns__setUserLanguage(soap, NULL, NULL, "tns:setUserLanguage");
	case SOAP_TYPE_ServerSoap_PointerTotns__setUserAnonymousResponse:
		return soap_in_PointerTotns__setUserAnonymousResponse(soap, NULL, NULL, "tns:setUserAnonymousResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__setUserAnonymous:
		return soap_in_PointerTotns__setUserAnonymous(soap, NULL, NULL, "tns:setUserAnonymous");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectUserResponse:
		return soap_in_PointerTotns__selectUserResponse(soap, NULL, NULL, "tns:selectUserResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectUser:
		return soap_in_PointerTotns__selectUser(soap, NULL, NULL, "tns:selectUser");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse:
		return soap_in_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse(soap, NULL, NULL, "tns:selectRelatedMediaAnnotationsWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectRelatedMediaAnnotationsWithTokenId:
		return soap_in_PointerTotns__selectRelatedMediaAnnotationsWithTokenId(soap, NULL, NULL, "tns:selectRelatedMediaAnnotationsWithTokenId");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaTokenWithIdResponse:
		return soap_in_PointerTotns__selectMediaTokenWithIdResponse(soap, NULL, NULL, "tns:selectMediaTokenWithIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaTokenWithId:
		return soap_in_PointerTotns__selectMediaTokenWithId(soap, NULL, NULL, "tns:selectMediaTokenWithId");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaTokenWithDigestResponse:
		return soap_in_PointerTotns__selectMediaTokenWithDigestResponse(soap, NULL, NULL, "tns:selectMediaTokenWithDigestResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaTokenWithDigest:
		return soap_in_PointerTotns__selectMediaTokenWithDigest(soap, NULL, NULL, "tns:selectMediaTokenWithDigest");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaAnnotationsWithTokenIdResponse:
		return soap_in_PointerTotns__selectMediaAnnotationsWithTokenIdResponse(soap, NULL, NULL, "tns:selectMediaAnnotationsWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaAnnotationsWithTokenId:
		return soap_in_PointerTotns__selectMediaAnnotationsWithTokenId(soap, NULL, NULL, "tns:selectMediaAnnotationsWithTokenId");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaAliasesWithTokenIdResponse:
		return soap_in_PointerTotns__selectMediaAliasesWithTokenIdResponse(soap, NULL, NULL, "tns:selectMediaAliasesWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaAliasesWithTokenId:
		return soap_in_PointerTotns__selectMediaAliasesWithTokenId(soap, NULL, NULL, "tns:selectMediaAliasesWithTokenId");
	case SOAP_TYPE_ServerSoap_PointerTotns__isConnectedResponse:
		return soap_in_PointerTotns__isConnectedResponse(soap, NULL, NULL, "tns:isConnectedResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__isConnected:
		return soap_in_PointerTotns__isConnected(soap, NULL, NULL, "tns:isConnected");
	case SOAP_TYPE_ServerSoap_PointerTotns__isClientUpdatedResponse:
		return soap_in_PointerTotns__isClientUpdatedResponse(soap, NULL, NULL, "tns:isClientUpdatedResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__isClientUpdated:
		return soap_in_PointerTotns__isClientUpdated(soap, NULL, NULL, "tns:isClientUpdated");
	case SOAP_TYPE_ServerSoap_PointerTotns__curseMediaTokenWithIdResponse:
		return soap_in_PointerTotns__curseMediaTokenWithIdResponse(soap, NULL, NULL, "tns:curseMediaTokenWithIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__curseMediaTokenWithId:
		return soap_in_PointerTotns__curseMediaTokenWithId(soap, NULL, NULL, "tns:curseMediaTokenWithId");
	case SOAP_TYPE_ServerSoap_PointerTotns__curseMediaAnnotationWithIdResponse:
		return soap_in_PointerTotns__curseMediaAnnotationWithIdResponse(soap, NULL, NULL, "tns:curseMediaAnnotationWithIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__curseMediaAnnotationWithId:
		return soap_in_PointerTotns__curseMediaAnnotationWithId(soap, NULL, NULL, "tns:curseMediaAnnotationWithId");
	case SOAP_TYPE_ServerSoap_PointerTotns__curseMediaAliasWithIdResponse:
		return soap_in_PointerTotns__curseMediaAliasWithIdResponse(soap, NULL, NULL, "tns:curseMediaAliasWithIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__curseMediaAliasWithId:
		return soap_in_PointerTotns__curseMediaAliasWithId(soap, NULL, NULL, "tns:curseMediaAliasWithId");
	case SOAP_TYPE_ServerSoap_PointerTotns__chatResponse:
		return soap_in_PointerTotns__chatResponse(soap, NULL, NULL, "tns:chatResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__chat:
		return soap_in_PointerTotns__chat(soap, NULL, NULL, "tns:chat");
	case SOAP_TYPE_ServerSoap_PointerTotns__blockUserWithIdResponse:
		return soap_in_PointerTotns__blockUserWithIdResponse(soap, NULL, NULL, "tns:blockUserWithIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__blockUserWithId:
		return soap_in_PointerTotns__blockUserWithId(soap, NULL, NULL, "tns:blockUserWithId");
	case SOAP_TYPE_ServerSoap_PointerTotns__blockMediaAnnotationWithIdResponse:
		return soap_in_PointerTotns__blockMediaAnnotationWithIdResponse(soap, NULL, NULL, "tns:blockMediaAnnotationWithIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__blockMediaAnnotationWithId:
		return soap_in_PointerTotns__blockMediaAnnotationWithId(soap, NULL, NULL, "tns:blockMediaAnnotationWithId");
	case SOAP_TYPE_ServerSoap_PointerTotns__blockMediaAliasWithIdResponse:
		return soap_in_PointerTotns__blockMediaAliasWithIdResponse(soap, NULL, NULL, "tns:blockMediaAliasWithIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__blockMediaAliasWithId:
		return soap_in_PointerTotns__blockMediaAliasWithId(soap, NULL, NULL, "tns:blockMediaAliasWithId");
	case SOAP_TYPE_ServerSoap_PointerTotns__blessMediaTokenWithIdResponse:
		return soap_in_PointerTotns__blessMediaTokenWithIdResponse(soap, NULL, NULL, "tns:blessMediaTokenWithIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__blessMediaTokenWithId:
		return soap_in_PointerTotns__blessMediaTokenWithId(soap, NULL, NULL, "tns:blessMediaTokenWithId");
	case SOAP_TYPE_ServerSoap_PointerTotns__blessMediaAnnotationWithIdResponse:
		return soap_in_PointerTotns__blessMediaAnnotationWithIdResponse(soap, NULL, NULL, "tns:blessMediaAnnotationWithIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__blessMediaAnnotationWithId:
		return soap_in_PointerTotns__blessMediaAnnotationWithId(soap, NULL, NULL, "tns:blessMediaAnnotationWithId");
	case SOAP_TYPE_ServerSoap_PointerTotns__blessMediaAliasWithIdResponse:
		return soap_in_PointerTotns__blessMediaAliasWithIdResponse(soap, NULL, NULL, "tns:blessMediaAliasWithIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__blessMediaAliasWithId:
		return soap_in_PointerTotns__blessMediaAliasWithId(soap, NULL, NULL, "tns:blessMediaAliasWithId");
	case SOAP_TYPE_ServerSoap_PointerTotns__user:
		return soap_in_PointerTotns__user(soap, NULL, NULL, "tns:user");
	case SOAP_TYPE_ServerSoap_PointerTotns__mediaToken:
		return soap_in_PointerTotns__mediaToken(soap, NULL, NULL, "tns:mediaToken");
	case SOAP_TYPE_ServerSoap_PointerTotns__mediaAnnotation:
		return soap_in_PointerTotns__mediaAnnotation(soap, NULL, NULL, "tns:mediaAnnotation");
	case SOAP_TYPE_ServerSoap_PointerTotns__mediaAlias:
		return soap_in_PointerTotns__mediaAlias(soap, NULL, NULL, "tns:mediaAlias");
	case SOAP_TYPE_ServerSoap_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ServerSoap__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_ServerSoap_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_ServerSoap_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:updateMediaAnnotationTextWithIdResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithIdResponse;
			return soap_in_tns__updateMediaAnnotationTextWithIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:updateMediaAnnotationTextWithId"))
		{	*type = SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithId;
			return soap_in_tns__updateMediaAnnotationTextWithId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaTokenDigestResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigestResponse;
			return soap_in_tns__submitMediaTokenDigestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaTokenDigest"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigest;
			return soap_in_tns__submitMediaTokenDigest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaTokenResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitMediaTokenResponse;
			return soap_in_tns__submitMediaTokenResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaToken"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitMediaToken;
			return soap_in_tns__submitMediaToken(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaAnnotationTextWithTokenIdResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenIdResponse;
			return soap_in_tns__submitMediaAnnotationTextWithTokenIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaAnnotationTextWithTokenId"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenId;
			return soap_in_tns__submitMediaAnnotationTextWithTokenId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaAnnotationTextAndTokenDigestResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigestResponse;
			return soap_in_tns__submitMediaAnnotationTextAndTokenDigestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaAnnotationTextAndTokenDigest"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigest;
			return soap_in_tns__submitMediaAnnotationTextAndTokenDigest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaAnnotationResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationResponse;
			return soap_in_tns__submitMediaAnnotationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaAnnotation"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitMediaAnnotation;
			return soap_in_tns__submitMediaAnnotation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaAliasTextWithTokenIdResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenIdResponse;
			return soap_in_tns__submitMediaAliasTextWithTokenIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaAliasTextWithTokenId"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenId;
			return soap_in_tns__submitMediaAliasTextWithTokenId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaAliasTextAndTokenDigestResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigestResponse;
			return soap_in_tns__submitMediaAliasTextAndTokenDigestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaAliasTextAndTokenDigest"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigest;
			return soap_in_tns__submitMediaAliasTextAndTokenDigest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaAliasResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitMediaAliasResponse;
			return soap_in_tns__submitMediaAliasResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:submitMediaAlias"))
		{	*type = SOAP_TYPE_ServerSoap_tns__submitMediaAlias;
			return soap_in_tns__submitMediaAlias(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:setUserLanguageResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__setUserLanguageResponse;
			return soap_in_tns__setUserLanguageResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:setUserLanguage"))
		{	*type = SOAP_TYPE_ServerSoap_tns__setUserLanguage;
			return soap_in_tns__setUserLanguage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:setUserAnonymousResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__setUserAnonymousResponse;
			return soap_in_tns__setUserAnonymousResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:setUserAnonymous"))
		{	*type = SOAP_TYPE_ServerSoap_tns__setUserAnonymous;
			return soap_in_tns__setUserAnonymous(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectUserResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__selectUserResponse;
			return soap_in_tns__selectUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectUser"))
		{	*type = SOAP_TYPE_ServerSoap_tns__selectUser;
			return soap_in_tns__selectUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectRelatedMediaAnnotationsWithTokenIdResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenIdResponse;
			return soap_in_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectRelatedMediaAnnotationsWithTokenId"))
		{	*type = SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenId;
			return soap_in_tns__selectRelatedMediaAnnotationsWithTokenId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectMediaTokenWithIdResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithIdResponse;
			return soap_in_tns__selectMediaTokenWithIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectMediaTokenWithId"))
		{	*type = SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithId;
			return soap_in_tns__selectMediaTokenWithId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectMediaTokenWithDigestResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigestResponse;
			return soap_in_tns__selectMediaTokenWithDigestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectMediaTokenWithDigest"))
		{	*type = SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigest;
			return soap_in_tns__selectMediaTokenWithDigest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectMediaAnnotationsWithTokenIdResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenIdResponse;
			return soap_in_tns__selectMediaAnnotationsWithTokenIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectMediaAnnotationsWithTokenId"))
		{	*type = SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenId;
			return soap_in_tns__selectMediaAnnotationsWithTokenId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectMediaAliasesWithTokenIdResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenIdResponse;
			return soap_in_tns__selectMediaAliasesWithTokenIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:selectMediaAliasesWithTokenId"))
		{	*type = SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenId;
			return soap_in_tns__selectMediaAliasesWithTokenId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:isConnectedResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__isConnectedResponse;
			return soap_in_tns__isConnectedResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:isConnected"))
		{	*type = SOAP_TYPE_ServerSoap_tns__isConnected;
			return soap_in_tns__isConnected(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:isClientUpdatedResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__isClientUpdatedResponse;
			return soap_in_tns__isClientUpdatedResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:isClientUpdated"))
		{	*type = SOAP_TYPE_ServerSoap_tns__isClientUpdated;
			return soap_in_tns__isClientUpdated(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:curseMediaTokenWithIdResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__curseMediaTokenWithIdResponse;
			return soap_in_tns__curseMediaTokenWithIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:curseMediaTokenWithId"))
		{	*type = SOAP_TYPE_ServerSoap_tns__curseMediaTokenWithId;
			return soap_in_tns__curseMediaTokenWithId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:curseMediaAnnotationWithIdResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__curseMediaAnnotationWithIdResponse;
			return soap_in_tns__curseMediaAnnotationWithIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:curseMediaAnnotationWithId"))
		{	*type = SOAP_TYPE_ServerSoap_tns__curseMediaAnnotationWithId;
			return soap_in_tns__curseMediaAnnotationWithId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:curseMediaAliasWithIdResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__curseMediaAliasWithIdResponse;
			return soap_in_tns__curseMediaAliasWithIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:curseMediaAliasWithId"))
		{	*type = SOAP_TYPE_ServerSoap_tns__curseMediaAliasWithId;
			return soap_in_tns__curseMediaAliasWithId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:chatResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__chatResponse;
			return soap_in_tns__chatResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:chat"))
		{	*type = SOAP_TYPE_ServerSoap_tns__chat;
			return soap_in_tns__chat(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:blockUserWithIdResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__blockUserWithIdResponse;
			return soap_in_tns__blockUserWithIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:blockUserWithId"))
		{	*type = SOAP_TYPE_ServerSoap_tns__blockUserWithId;
			return soap_in_tns__blockUserWithId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:blockMediaAnnotationWithIdResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__blockMediaAnnotationWithIdResponse;
			return soap_in_tns__blockMediaAnnotationWithIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:blockMediaAnnotationWithId"))
		{	*type = SOAP_TYPE_ServerSoap_tns__blockMediaAnnotationWithId;
			return soap_in_tns__blockMediaAnnotationWithId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:blockMediaAliasWithIdResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__blockMediaAliasWithIdResponse;
			return soap_in_tns__blockMediaAliasWithIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:blockMediaAliasWithId"))
		{	*type = SOAP_TYPE_ServerSoap_tns__blockMediaAliasWithId;
			return soap_in_tns__blockMediaAliasWithId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:blessMediaTokenWithIdResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__blessMediaTokenWithIdResponse;
			return soap_in_tns__blessMediaTokenWithIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:blessMediaTokenWithId"))
		{	*type = SOAP_TYPE_ServerSoap_tns__blessMediaTokenWithId;
			return soap_in_tns__blessMediaTokenWithId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:blessMediaAnnotationWithIdResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithIdResponse;
			return soap_in_tns__blessMediaAnnotationWithIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:blessMediaAnnotationWithId"))
		{	*type = SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithId;
			return soap_in_tns__blessMediaAnnotationWithId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:blessMediaAliasWithIdResponse"))
		{	*type = SOAP_TYPE_ServerSoap_tns__blessMediaAliasWithIdResponse;
			return soap_in_tns__blessMediaAliasWithIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:blessMediaAliasWithId"))
		{	*type = SOAP_TYPE_ServerSoap_tns__blessMediaAliasWithId;
			return soap_in_tns__blessMediaAliasWithId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:user"))
		{	*type = SOAP_TYPE_ServerSoap_tns__user;
			return soap_in_tns__user(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:mediaAlias"))
		{	*type = SOAP_TYPE_ServerSoap_tns__mediaAlias;
			return soap_in_tns__mediaAlias(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:mediaToken"))
		{	*type = SOAP_TYPE_ServerSoap_tns__mediaToken;
			return soap_in_tns__mediaToken(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tns:mediaAnnotation"))
		{	*type = SOAP_TYPE_ServerSoap_tns__mediaAnnotation;
			return soap_in_tns__mediaAnnotation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_ServerSoap_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_ServerSoap_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_ServerSoap_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_ServerSoap_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE_ServerSoap__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_ServerSoap_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_ServerSoap_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_ServerSoap_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_ServerSoap_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_ServerSoap_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_ServerSoap_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithIdResponse:
		return ((tns__updateMediaAnnotationTextWithIdResponse *)ptr)->soap_out(soap, tag, id, "tns:updateMediaAnnotationTextWithIdResponse");
	case SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithId:
		return ((tns__updateMediaAnnotationTextWithId *)ptr)->soap_out(soap, tag, id, "tns:updateMediaAnnotationTextWithId");
	case SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigestResponse:
		return ((tns__submitMediaTokenDigestResponse *)ptr)->soap_out(soap, tag, id, "tns:submitMediaTokenDigestResponse");
	case SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigest:
		return ((tns__submitMediaTokenDigest *)ptr)->soap_out(soap, tag, id, "tns:submitMediaTokenDigest");
	case SOAP_TYPE_ServerSoap_tns__submitMediaTokenResponse:
		return ((tns__submitMediaTokenResponse *)ptr)->soap_out(soap, tag, id, "tns:submitMediaTokenResponse");
	case SOAP_TYPE_ServerSoap_tns__submitMediaToken:
		return ((tns__submitMediaToken *)ptr)->soap_out(soap, tag, id, "tns:submitMediaToken");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenIdResponse:
		return ((tns__submitMediaAnnotationTextWithTokenIdResponse *)ptr)->soap_out(soap, tag, id, "tns:submitMediaAnnotationTextWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenId:
		return ((tns__submitMediaAnnotationTextWithTokenId *)ptr)->soap_out(soap, tag, id, "tns:submitMediaAnnotationTextWithTokenId");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigestResponse:
		return ((tns__submitMediaAnnotationTextAndTokenDigestResponse *)ptr)->soap_out(soap, tag, id, "tns:submitMediaAnnotationTextAndTokenDigestResponse");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigest:
		return ((tns__submitMediaAnnotationTextAndTokenDigest *)ptr)->soap_out(soap, tag, id, "tns:submitMediaAnnotationTextAndTokenDigest");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationResponse:
		return ((tns__submitMediaAnnotationResponse *)ptr)->soap_out(soap, tag, id, "tns:submitMediaAnnotationResponse");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotation:
		return ((tns__submitMediaAnnotation *)ptr)->soap_out(soap, tag, id, "tns:submitMediaAnnotation");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenIdResponse:
		return ((tns__submitMediaAliasTextWithTokenIdResponse *)ptr)->soap_out(soap, tag, id, "tns:submitMediaAliasTextWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenId:
		return ((tns__submitMediaAliasTextWithTokenId *)ptr)->soap_out(soap, tag, id, "tns:submitMediaAliasTextWithTokenId");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigestResponse:
		return ((tns__submitMediaAliasTextAndTokenDigestResponse *)ptr)->soap_out(soap, tag, id, "tns:submitMediaAliasTextAndTokenDigestResponse");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigest:
		return ((tns__submitMediaAliasTextAndTokenDigest *)ptr)->soap_out(soap, tag, id, "tns:submitMediaAliasTextAndTokenDigest");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasResponse:
		return ((tns__submitMediaAliasResponse *)ptr)->soap_out(soap, tag, id, "tns:submitMediaAliasResponse");
	case SOAP_TYPE_ServerSoap_tns__submitMediaAlias:
		return ((tns__submitMediaAlias *)ptr)->soap_out(soap, tag, id, "tns:submitMediaAlias");
	case SOAP_TYPE_ServerSoap_tns__setUserLanguageResponse:
		return ((tns__setUserLanguageResponse *)ptr)->soap_out(soap, tag, id, "tns:setUserLanguageResponse");
	case SOAP_TYPE_ServerSoap_tns__setUserLanguage:
		return ((tns__setUserLanguage *)ptr)->soap_out(soap, tag, id, "tns:setUserLanguage");
	case SOAP_TYPE_ServerSoap_tns__setUserAnonymousResponse:
		return ((tns__setUserAnonymousResponse *)ptr)->soap_out(soap, tag, id, "tns:setUserAnonymousResponse");
	case SOAP_TYPE_ServerSoap_tns__setUserAnonymous:
		return ((tns__setUserAnonymous *)ptr)->soap_out(soap, tag, id, "tns:setUserAnonymous");
	case SOAP_TYPE_ServerSoap_tns__selectUserResponse:
		return ((tns__selectUserResponse *)ptr)->soap_out(soap, tag, id, "tns:selectUserResponse");
	case SOAP_TYPE_ServerSoap_tns__selectUser:
		return ((tns__selectUser *)ptr)->soap_out(soap, tag, id, "tns:selectUser");
	case SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenIdResponse:
		return ((tns__selectRelatedMediaAnnotationsWithTokenIdResponse *)ptr)->soap_out(soap, tag, id, "tns:selectRelatedMediaAnnotationsWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenId:
		return ((tns__selectRelatedMediaAnnotationsWithTokenId *)ptr)->soap_out(soap, tag, id, "tns:selectRelatedMediaAnnotationsWithTokenId");
	case SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithIdResponse:
		return ((tns__selectMediaTokenWithIdResponse *)ptr)->soap_out(soap, tag, id, "tns:selectMediaTokenWithIdResponse");
	case SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithId:
		return ((tns__selectMediaTokenWithId *)ptr)->soap_out(soap, tag, id, "tns:selectMediaTokenWithId");
	case SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigestResponse:
		return ((tns__selectMediaTokenWithDigestResponse *)ptr)->soap_out(soap, tag, id, "tns:selectMediaTokenWithDigestResponse");
	case SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigest:
		return ((tns__selectMediaTokenWithDigest *)ptr)->soap_out(soap, tag, id, "tns:selectMediaTokenWithDigest");
	case SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenIdResponse:
		return ((tns__selectMediaAnnotationsWithTokenIdResponse *)ptr)->soap_out(soap, tag, id, "tns:selectMediaAnnotationsWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenId:
		return ((tns__selectMediaAnnotationsWithTokenId *)ptr)->soap_out(soap, tag, id, "tns:selectMediaAnnotationsWithTokenId");
	case SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenIdResponse:
		return ((tns__selectMediaAliasesWithTokenIdResponse *)ptr)->soap_out(soap, tag, id, "tns:selectMediaAliasesWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenId:
		return ((tns__selectMediaAliasesWithTokenId *)ptr)->soap_out(soap, tag, id, "tns:selectMediaAliasesWithTokenId");
	case SOAP_TYPE_ServerSoap_tns__isConnectedResponse:
		return ((tns__isConnectedResponse *)ptr)->soap_out(soap, tag, id, "tns:isConnectedResponse");
	case SOAP_TYPE_ServerSoap_tns__isConnected:
		return ((tns__isConnected *)ptr)->soap_out(soap, tag, id, "tns:isConnected");
	case SOAP_TYPE_ServerSoap_tns__isClientUpdatedResponse:
		return ((tns__isClientUpdatedResponse *)ptr)->soap_out(soap, tag, id, "tns:isClientUpdatedResponse");
	case SOAP_TYPE_ServerSoap_tns__isClientUpdated:
		return ((tns__isClientUpdated *)ptr)->soap_out(soap, tag, id, "tns:isClientUpdated");
	case SOAP_TYPE_ServerSoap_tns__curseMediaTokenWithIdResponse:
		return ((tns__curseMediaTokenWithIdResponse *)ptr)->soap_out(soap, tag, id, "tns:curseMediaTokenWithIdResponse");
	case SOAP_TYPE_ServerSoap_tns__curseMediaTokenWithId:
		return ((tns__curseMediaTokenWithId *)ptr)->soap_out(soap, tag, id, "tns:curseMediaTokenWithId");
	case SOAP_TYPE_ServerSoap_tns__curseMediaAnnotationWithIdResponse:
		return ((tns__curseMediaAnnotationWithIdResponse *)ptr)->soap_out(soap, tag, id, "tns:curseMediaAnnotationWithIdResponse");
	case SOAP_TYPE_ServerSoap_tns__curseMediaAnnotationWithId:
		return ((tns__curseMediaAnnotationWithId *)ptr)->soap_out(soap, tag, id, "tns:curseMediaAnnotationWithId");
	case SOAP_TYPE_ServerSoap_tns__curseMediaAliasWithIdResponse:
		return ((tns__curseMediaAliasWithIdResponse *)ptr)->soap_out(soap, tag, id, "tns:curseMediaAliasWithIdResponse");
	case SOAP_TYPE_ServerSoap_tns__curseMediaAliasWithId:
		return ((tns__curseMediaAliasWithId *)ptr)->soap_out(soap, tag, id, "tns:curseMediaAliasWithId");
	case SOAP_TYPE_ServerSoap_tns__chatResponse:
		return ((tns__chatResponse *)ptr)->soap_out(soap, tag, id, "tns:chatResponse");
	case SOAP_TYPE_ServerSoap_tns__chat:
		return ((tns__chat *)ptr)->soap_out(soap, tag, id, "tns:chat");
	case SOAP_TYPE_ServerSoap_tns__blockUserWithIdResponse:
		return ((tns__blockUserWithIdResponse *)ptr)->soap_out(soap, tag, id, "tns:blockUserWithIdResponse");
	case SOAP_TYPE_ServerSoap_tns__blockUserWithId:
		return ((tns__blockUserWithId *)ptr)->soap_out(soap, tag, id, "tns:blockUserWithId");
	case SOAP_TYPE_ServerSoap_tns__blockMediaAnnotationWithIdResponse:
		return ((tns__blockMediaAnnotationWithIdResponse *)ptr)->soap_out(soap, tag, id, "tns:blockMediaAnnotationWithIdResponse");
	case SOAP_TYPE_ServerSoap_tns__blockMediaAnnotationWithId:
		return ((tns__blockMediaAnnotationWithId *)ptr)->soap_out(soap, tag, id, "tns:blockMediaAnnotationWithId");
	case SOAP_TYPE_ServerSoap_tns__blockMediaAliasWithIdResponse:
		return ((tns__blockMediaAliasWithIdResponse *)ptr)->soap_out(soap, tag, id, "tns:blockMediaAliasWithIdResponse");
	case SOAP_TYPE_ServerSoap_tns__blockMediaAliasWithId:
		return ((tns__blockMediaAliasWithId *)ptr)->soap_out(soap, tag, id, "tns:blockMediaAliasWithId");
	case SOAP_TYPE_ServerSoap_tns__blessMediaTokenWithIdResponse:
		return ((tns__blessMediaTokenWithIdResponse *)ptr)->soap_out(soap, tag, id, "tns:blessMediaTokenWithIdResponse");
	case SOAP_TYPE_ServerSoap_tns__blessMediaTokenWithId:
		return ((tns__blessMediaTokenWithId *)ptr)->soap_out(soap, tag, id, "tns:blessMediaTokenWithId");
	case SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithIdResponse:
		return ((tns__blessMediaAnnotationWithIdResponse *)ptr)->soap_out(soap, tag, id, "tns:blessMediaAnnotationWithIdResponse");
	case SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithId:
		return ((tns__blessMediaAnnotationWithId *)ptr)->soap_out(soap, tag, id, "tns:blessMediaAnnotationWithId");
	case SOAP_TYPE_ServerSoap_tns__blessMediaAliasWithIdResponse:
		return ((tns__blessMediaAliasWithIdResponse *)ptr)->soap_out(soap, tag, id, "tns:blessMediaAliasWithIdResponse");
	case SOAP_TYPE_ServerSoap_tns__blessMediaAliasWithId:
		return ((tns__blessMediaAliasWithId *)ptr)->soap_out(soap, tag, id, "tns:blessMediaAliasWithId");
	case SOAP_TYPE_ServerSoap_tns__user:
		return ((tns__user *)ptr)->soap_out(soap, tag, id, "tns:user");
	case SOAP_TYPE_ServerSoap_tns__mediaAlias:
		return ((tns__mediaAlias *)ptr)->soap_out(soap, tag, id, "tns:mediaAlias");
	case SOAP_TYPE_ServerSoap_tns__mediaToken:
		return ((tns__mediaToken *)ptr)->soap_out(soap, tag, id, "tns:mediaToken");
	case SOAP_TYPE_ServerSoap_tns__mediaAnnotation:
		return ((tns__mediaAnnotation *)ptr)->soap_out(soap, tag, id, "tns:mediaAnnotation");
	case SOAP_TYPE_ServerSoap_PointerTotns__updateMediaAnnotationTextWithIdResponse:
		return soap_out_PointerTotns__updateMediaAnnotationTextWithIdResponse(soap, tag, id, (tns__updateMediaAnnotationTextWithIdResponse *const*)ptr, "tns:updateMediaAnnotationTextWithIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__updateMediaAnnotationTextWithId:
		return soap_out_PointerTotns__updateMediaAnnotationTextWithId(soap, tag, id, (tns__updateMediaAnnotationTextWithId *const*)ptr, "tns:updateMediaAnnotationTextWithId");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaTokenDigestResponse:
		return soap_out_PointerTotns__submitMediaTokenDigestResponse(soap, tag, id, (tns__submitMediaTokenDigestResponse *const*)ptr, "tns:submitMediaTokenDigestResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaTokenDigest:
		return soap_out_PointerTotns__submitMediaTokenDigest(soap, tag, id, (tns__submitMediaTokenDigest *const*)ptr, "tns:submitMediaTokenDigest");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaTokenResponse:
		return soap_out_PointerTotns__submitMediaTokenResponse(soap, tag, id, (tns__submitMediaTokenResponse *const*)ptr, "tns:submitMediaTokenResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaToken:
		return soap_out_PointerTotns__submitMediaToken(soap, tag, id, (tns__submitMediaToken *const*)ptr, "tns:submitMediaToken");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse:
		return soap_out_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse(soap, tag, id, (tns__submitMediaAnnotationTextWithTokenIdResponse *const*)ptr, "tns:submitMediaAnnotationTextWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotationTextWithTokenId:
		return soap_out_PointerTotns__submitMediaAnnotationTextWithTokenId(soap, tag, id, (tns__submitMediaAnnotationTextWithTokenId *const*)ptr, "tns:submitMediaAnnotationTextWithTokenId");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse:
		return soap_out_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse(soap, tag, id, (tns__submitMediaAnnotationTextAndTokenDigestResponse *const*)ptr, "tns:submitMediaAnnotationTextAndTokenDigestResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotationTextAndTokenDigest:
		return soap_out_PointerTotns__submitMediaAnnotationTextAndTokenDigest(soap, tag, id, (tns__submitMediaAnnotationTextAndTokenDigest *const*)ptr, "tns:submitMediaAnnotationTextAndTokenDigest");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotationResponse:
		return soap_out_PointerTotns__submitMediaAnnotationResponse(soap, tag, id, (tns__submitMediaAnnotationResponse *const*)ptr, "tns:submitMediaAnnotationResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotation:
		return soap_out_PointerTotns__submitMediaAnnotation(soap, tag, id, (tns__submitMediaAnnotation *const*)ptr, "tns:submitMediaAnnotation");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAliasTextWithTokenIdResponse:
		return soap_out_PointerTotns__submitMediaAliasTextWithTokenIdResponse(soap, tag, id, (tns__submitMediaAliasTextWithTokenIdResponse *const*)ptr, "tns:submitMediaAliasTextWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAliasTextWithTokenId:
		return soap_out_PointerTotns__submitMediaAliasTextWithTokenId(soap, tag, id, (tns__submitMediaAliasTextWithTokenId *const*)ptr, "tns:submitMediaAliasTextWithTokenId");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAliasTextAndTokenDigestResponse:
		return soap_out_PointerTotns__submitMediaAliasTextAndTokenDigestResponse(soap, tag, id, (tns__submitMediaAliasTextAndTokenDigestResponse *const*)ptr, "tns:submitMediaAliasTextAndTokenDigestResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAliasTextAndTokenDigest:
		return soap_out_PointerTotns__submitMediaAliasTextAndTokenDigest(soap, tag, id, (tns__submitMediaAliasTextAndTokenDigest *const*)ptr, "tns:submitMediaAliasTextAndTokenDigest");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAliasResponse:
		return soap_out_PointerTotns__submitMediaAliasResponse(soap, tag, id, (tns__submitMediaAliasResponse *const*)ptr, "tns:submitMediaAliasResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAlias:
		return soap_out_PointerTotns__submitMediaAlias(soap, tag, id, (tns__submitMediaAlias *const*)ptr, "tns:submitMediaAlias");
	case SOAP_TYPE_ServerSoap_PointerTotns__setUserLanguageResponse:
		return soap_out_PointerTotns__setUserLanguageResponse(soap, tag, id, (tns__setUserLanguageResponse *const*)ptr, "tns:setUserLanguageResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__setUserLanguage:
		return soap_out_PointerTotns__setUserLanguage(soap, tag, id, (tns__setUserLanguage *const*)ptr, "tns:setUserLanguage");
	case SOAP_TYPE_ServerSoap_PointerTotns__setUserAnonymousResponse:
		return soap_out_PointerTotns__setUserAnonymousResponse(soap, tag, id, (tns__setUserAnonymousResponse *const*)ptr, "tns:setUserAnonymousResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__setUserAnonymous:
		return soap_out_PointerTotns__setUserAnonymous(soap, tag, id, (tns__setUserAnonymous *const*)ptr, "tns:setUserAnonymous");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectUserResponse:
		return soap_out_PointerTotns__selectUserResponse(soap, tag, id, (tns__selectUserResponse *const*)ptr, "tns:selectUserResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectUser:
		return soap_out_PointerTotns__selectUser(soap, tag, id, (tns__selectUser *const*)ptr, "tns:selectUser");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse:
		return soap_out_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse(soap, tag, id, (tns__selectRelatedMediaAnnotationsWithTokenIdResponse *const*)ptr, "tns:selectRelatedMediaAnnotationsWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectRelatedMediaAnnotationsWithTokenId:
		return soap_out_PointerTotns__selectRelatedMediaAnnotationsWithTokenId(soap, tag, id, (tns__selectRelatedMediaAnnotationsWithTokenId *const*)ptr, "tns:selectRelatedMediaAnnotationsWithTokenId");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaTokenWithIdResponse:
		return soap_out_PointerTotns__selectMediaTokenWithIdResponse(soap, tag, id, (tns__selectMediaTokenWithIdResponse *const*)ptr, "tns:selectMediaTokenWithIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaTokenWithId:
		return soap_out_PointerTotns__selectMediaTokenWithId(soap, tag, id, (tns__selectMediaTokenWithId *const*)ptr, "tns:selectMediaTokenWithId");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaTokenWithDigestResponse:
		return soap_out_PointerTotns__selectMediaTokenWithDigestResponse(soap, tag, id, (tns__selectMediaTokenWithDigestResponse *const*)ptr, "tns:selectMediaTokenWithDigestResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaTokenWithDigest:
		return soap_out_PointerTotns__selectMediaTokenWithDigest(soap, tag, id, (tns__selectMediaTokenWithDigest *const*)ptr, "tns:selectMediaTokenWithDigest");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaAnnotationsWithTokenIdResponse:
		return soap_out_PointerTotns__selectMediaAnnotationsWithTokenIdResponse(soap, tag, id, (tns__selectMediaAnnotationsWithTokenIdResponse *const*)ptr, "tns:selectMediaAnnotationsWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaAnnotationsWithTokenId:
		return soap_out_PointerTotns__selectMediaAnnotationsWithTokenId(soap, tag, id, (tns__selectMediaAnnotationsWithTokenId *const*)ptr, "tns:selectMediaAnnotationsWithTokenId");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaAliasesWithTokenIdResponse:
		return soap_out_PointerTotns__selectMediaAliasesWithTokenIdResponse(soap, tag, id, (tns__selectMediaAliasesWithTokenIdResponse *const*)ptr, "tns:selectMediaAliasesWithTokenIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaAliasesWithTokenId:
		return soap_out_PointerTotns__selectMediaAliasesWithTokenId(soap, tag, id, (tns__selectMediaAliasesWithTokenId *const*)ptr, "tns:selectMediaAliasesWithTokenId");
	case SOAP_TYPE_ServerSoap_PointerTotns__isConnectedResponse:
		return soap_out_PointerTotns__isConnectedResponse(soap, tag, id, (tns__isConnectedResponse *const*)ptr, "tns:isConnectedResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__isConnected:
		return soap_out_PointerTotns__isConnected(soap, tag, id, (tns__isConnected *const*)ptr, "tns:isConnected");
	case SOAP_TYPE_ServerSoap_PointerTotns__isClientUpdatedResponse:
		return soap_out_PointerTotns__isClientUpdatedResponse(soap, tag, id, (tns__isClientUpdatedResponse *const*)ptr, "tns:isClientUpdatedResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__isClientUpdated:
		return soap_out_PointerTotns__isClientUpdated(soap, tag, id, (tns__isClientUpdated *const*)ptr, "tns:isClientUpdated");
	case SOAP_TYPE_ServerSoap_PointerTotns__curseMediaTokenWithIdResponse:
		return soap_out_PointerTotns__curseMediaTokenWithIdResponse(soap, tag, id, (tns__curseMediaTokenWithIdResponse *const*)ptr, "tns:curseMediaTokenWithIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__curseMediaTokenWithId:
		return soap_out_PointerTotns__curseMediaTokenWithId(soap, tag, id, (tns__curseMediaTokenWithId *const*)ptr, "tns:curseMediaTokenWithId");
	case SOAP_TYPE_ServerSoap_PointerTotns__curseMediaAnnotationWithIdResponse:
		return soap_out_PointerTotns__curseMediaAnnotationWithIdResponse(soap, tag, id, (tns__curseMediaAnnotationWithIdResponse *const*)ptr, "tns:curseMediaAnnotationWithIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__curseMediaAnnotationWithId:
		return soap_out_PointerTotns__curseMediaAnnotationWithId(soap, tag, id, (tns__curseMediaAnnotationWithId *const*)ptr, "tns:curseMediaAnnotationWithId");
	case SOAP_TYPE_ServerSoap_PointerTotns__curseMediaAliasWithIdResponse:
		return soap_out_PointerTotns__curseMediaAliasWithIdResponse(soap, tag, id, (tns__curseMediaAliasWithIdResponse *const*)ptr, "tns:curseMediaAliasWithIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__curseMediaAliasWithId:
		return soap_out_PointerTotns__curseMediaAliasWithId(soap, tag, id, (tns__curseMediaAliasWithId *const*)ptr, "tns:curseMediaAliasWithId");
	case SOAP_TYPE_ServerSoap_PointerTotns__chatResponse:
		return soap_out_PointerTotns__chatResponse(soap, tag, id, (tns__chatResponse *const*)ptr, "tns:chatResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__chat:
		return soap_out_PointerTotns__chat(soap, tag, id, (tns__chat *const*)ptr, "tns:chat");
	case SOAP_TYPE_ServerSoap_PointerTotns__blockUserWithIdResponse:
		return soap_out_PointerTotns__blockUserWithIdResponse(soap, tag, id, (tns__blockUserWithIdResponse *const*)ptr, "tns:blockUserWithIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__blockUserWithId:
		return soap_out_PointerTotns__blockUserWithId(soap, tag, id, (tns__blockUserWithId *const*)ptr, "tns:blockUserWithId");
	case SOAP_TYPE_ServerSoap_PointerTotns__blockMediaAnnotationWithIdResponse:
		return soap_out_PointerTotns__blockMediaAnnotationWithIdResponse(soap, tag, id, (tns__blockMediaAnnotationWithIdResponse *const*)ptr, "tns:blockMediaAnnotationWithIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__blockMediaAnnotationWithId:
		return soap_out_PointerTotns__blockMediaAnnotationWithId(soap, tag, id, (tns__blockMediaAnnotationWithId *const*)ptr, "tns:blockMediaAnnotationWithId");
	case SOAP_TYPE_ServerSoap_PointerTotns__blockMediaAliasWithIdResponse:
		return soap_out_PointerTotns__blockMediaAliasWithIdResponse(soap, tag, id, (tns__blockMediaAliasWithIdResponse *const*)ptr, "tns:blockMediaAliasWithIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__blockMediaAliasWithId:
		return soap_out_PointerTotns__blockMediaAliasWithId(soap, tag, id, (tns__blockMediaAliasWithId *const*)ptr, "tns:blockMediaAliasWithId");
	case SOAP_TYPE_ServerSoap_PointerTotns__blessMediaTokenWithIdResponse:
		return soap_out_PointerTotns__blessMediaTokenWithIdResponse(soap, tag, id, (tns__blessMediaTokenWithIdResponse *const*)ptr, "tns:blessMediaTokenWithIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__blessMediaTokenWithId:
		return soap_out_PointerTotns__blessMediaTokenWithId(soap, tag, id, (tns__blessMediaTokenWithId *const*)ptr, "tns:blessMediaTokenWithId");
	case SOAP_TYPE_ServerSoap_PointerTotns__blessMediaAnnotationWithIdResponse:
		return soap_out_PointerTotns__blessMediaAnnotationWithIdResponse(soap, tag, id, (tns__blessMediaAnnotationWithIdResponse *const*)ptr, "tns:blessMediaAnnotationWithIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__blessMediaAnnotationWithId:
		return soap_out_PointerTotns__blessMediaAnnotationWithId(soap, tag, id, (tns__blessMediaAnnotationWithId *const*)ptr, "tns:blessMediaAnnotationWithId");
	case SOAP_TYPE_ServerSoap_PointerTotns__blessMediaAliasWithIdResponse:
		return soap_out_PointerTotns__blessMediaAliasWithIdResponse(soap, tag, id, (tns__blessMediaAliasWithIdResponse *const*)ptr, "tns:blessMediaAliasWithIdResponse");
	case SOAP_TYPE_ServerSoap_PointerTotns__blessMediaAliasWithId:
		return soap_out_PointerTotns__blessMediaAliasWithId(soap, tag, id, (tns__blessMediaAliasWithId *const*)ptr, "tns:blessMediaAliasWithId");
	case SOAP_TYPE_ServerSoap_PointerTotns__user:
		return soap_out_PointerTotns__user(soap, tag, id, (tns__user *const*)ptr, "tns:user");
	case SOAP_TYPE_ServerSoap_PointerTotns__mediaToken:
		return soap_out_PointerTotns__mediaToken(soap, tag, id, (tns__mediaToken *const*)ptr, "tns:mediaToken");
	case SOAP_TYPE_ServerSoap_PointerTotns__mediaAnnotation:
		return soap_out_PointerTotns__mediaAnnotation(soap, tag, id, (tns__mediaAnnotation *const*)ptr, "tns:mediaAnnotation");
	case SOAP_TYPE_ServerSoap_PointerTotns__mediaAlias:
		return soap_out_PointerTotns__mediaAlias(soap, tag, id, (tns__mediaAlias *const*)ptr, "tns:mediaAlias");
	case SOAP_TYPE_ServerSoap_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_ServerSoap__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_ServerSoap_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_ServerSoap_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithIdResponse:
		((tns__updateMediaAnnotationTextWithIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithId:
		((tns__updateMediaAnnotationTextWithId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigestResponse:
		((tns__submitMediaTokenDigestResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigest:
		((tns__submitMediaTokenDigest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaTokenResponse:
		((tns__submitMediaTokenResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaToken:
		((tns__submitMediaToken *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenIdResponse:
		((tns__submitMediaAnnotationTextWithTokenIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenId:
		((tns__submitMediaAnnotationTextWithTokenId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigestResponse:
		((tns__submitMediaAnnotationTextAndTokenDigestResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigest:
		((tns__submitMediaAnnotationTextAndTokenDigest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationResponse:
		((tns__submitMediaAnnotationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotation:
		((tns__submitMediaAnnotation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenIdResponse:
		((tns__submitMediaAliasTextWithTokenIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenId:
		((tns__submitMediaAliasTextWithTokenId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigestResponse:
		((tns__submitMediaAliasTextAndTokenDigestResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigest:
		((tns__submitMediaAliasTextAndTokenDigest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasResponse:
		((tns__submitMediaAliasResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAlias:
		((tns__submitMediaAlias *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__setUserLanguageResponse:
		((tns__setUserLanguageResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__setUserLanguage:
		((tns__setUserLanguage *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__setUserAnonymousResponse:
		((tns__setUserAnonymousResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__setUserAnonymous:
		((tns__setUserAnonymous *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectUserResponse:
		((tns__selectUserResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectUser:
		((tns__selectUser *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenIdResponse:
		((tns__selectRelatedMediaAnnotationsWithTokenIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenId:
		((tns__selectRelatedMediaAnnotationsWithTokenId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithIdResponse:
		((tns__selectMediaTokenWithIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithId:
		((tns__selectMediaTokenWithId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigestResponse:
		((tns__selectMediaTokenWithDigestResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigest:
		((tns__selectMediaTokenWithDigest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenIdResponse:
		((tns__selectMediaAnnotationsWithTokenIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenId:
		((tns__selectMediaAnnotationsWithTokenId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenIdResponse:
		((tns__selectMediaAliasesWithTokenIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenId:
		((tns__selectMediaAliasesWithTokenId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__isConnectedResponse:
		((tns__isConnectedResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__isConnected:
		((tns__isConnected *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__isClientUpdatedResponse:
		((tns__isClientUpdatedResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__isClientUpdated:
		((tns__isClientUpdated *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__curseMediaTokenWithIdResponse:
		((tns__curseMediaTokenWithIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__curseMediaTokenWithId:
		((tns__curseMediaTokenWithId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__curseMediaAnnotationWithIdResponse:
		((tns__curseMediaAnnotationWithIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__curseMediaAnnotationWithId:
		((tns__curseMediaAnnotationWithId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__curseMediaAliasWithIdResponse:
		((tns__curseMediaAliasWithIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__curseMediaAliasWithId:
		((tns__curseMediaAliasWithId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__chatResponse:
		((tns__chatResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__chat:
		((tns__chat *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__blockUserWithIdResponse:
		((tns__blockUserWithIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__blockUserWithId:
		((tns__blockUserWithId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__blockMediaAnnotationWithIdResponse:
		((tns__blockMediaAnnotationWithIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__blockMediaAnnotationWithId:
		((tns__blockMediaAnnotationWithId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__blockMediaAliasWithIdResponse:
		((tns__blockMediaAliasWithIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__blockMediaAliasWithId:
		((tns__blockMediaAliasWithId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__blessMediaTokenWithIdResponse:
		((tns__blessMediaTokenWithIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__blessMediaTokenWithId:
		((tns__blessMediaTokenWithId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithIdResponse:
		((tns__blessMediaAnnotationWithIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithId:
		((tns__blessMediaAnnotationWithId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__blessMediaAliasWithIdResponse:
		((tns__blessMediaAliasWithIdResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__blessMediaAliasWithId:
		((tns__blessMediaAliasWithId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__user:
		((tns__user *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__mediaAlias:
		((tns__mediaAlias *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__mediaToken:
		((tns__mediaToken *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap_tns__mediaAnnotation:
		((tns__mediaAnnotation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ServerSoap___tns__updateMediaAnnotationTextWithId:
		soap_serialize___tns__updateMediaAnnotationTextWithId(soap, (const struct __tns__updateMediaAnnotationTextWithId *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitMediaTokenDigest:
		soap_serialize___tns__submitMediaTokenDigest(soap, (const struct __tns__submitMediaTokenDigest *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitMediaToken:
		soap_serialize___tns__submitMediaToken(soap, (const struct __tns__submitMediaToken *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitMediaAnnotationTextWithTokenId:
		soap_serialize___tns__submitMediaAnnotationTextWithTokenId(soap, (const struct __tns__submitMediaAnnotationTextWithTokenId *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitMediaAnnotationTextAndTokenDigest:
		soap_serialize___tns__submitMediaAnnotationTextAndTokenDigest(soap, (const struct __tns__submitMediaAnnotationTextAndTokenDigest *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitMediaAnnotation:
		soap_serialize___tns__submitMediaAnnotation(soap, (const struct __tns__submitMediaAnnotation *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitMediaAliasTextWithTokenId:
		soap_serialize___tns__submitMediaAliasTextWithTokenId(soap, (const struct __tns__submitMediaAliasTextWithTokenId *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitMediaAliasTextAndTokenDigest:
		soap_serialize___tns__submitMediaAliasTextAndTokenDigest(soap, (const struct __tns__submitMediaAliasTextAndTokenDigest *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitMediaAlias:
		soap_serialize___tns__submitMediaAlias(soap, (const struct __tns__submitMediaAlias *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__setUserLanguage:
		soap_serialize___tns__setUserLanguage(soap, (const struct __tns__setUserLanguage *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__setUserAnonymous:
		soap_serialize___tns__setUserAnonymous(soap, (const struct __tns__setUserAnonymous *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__selectUser:
		soap_serialize___tns__selectUser(soap, (const struct __tns__selectUser *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__selectRelatedMediaAnnotationsWithTokenId:
		soap_serialize___tns__selectRelatedMediaAnnotationsWithTokenId(soap, (const struct __tns__selectRelatedMediaAnnotationsWithTokenId *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__selectMediaTokenWithId:
		soap_serialize___tns__selectMediaTokenWithId(soap, (const struct __tns__selectMediaTokenWithId *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__selectMediaTokenWithDigest:
		soap_serialize___tns__selectMediaTokenWithDigest(soap, (const struct __tns__selectMediaTokenWithDigest *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__selectMediaAnnotationsWithTokenId:
		soap_serialize___tns__selectMediaAnnotationsWithTokenId(soap, (const struct __tns__selectMediaAnnotationsWithTokenId *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__selectMediaAliasesWithTokenId:
		soap_serialize___tns__selectMediaAliasesWithTokenId(soap, (const struct __tns__selectMediaAliasesWithTokenId *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__isConnected:
		soap_serialize___tns__isConnected(soap, (const struct __tns__isConnected *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__isClientUpdated:
		soap_serialize___tns__isClientUpdated(soap, (const struct __tns__isClientUpdated *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__curseMediaTokenWithId:
		soap_serialize___tns__curseMediaTokenWithId(soap, (const struct __tns__curseMediaTokenWithId *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__curseMediaAnnotationWithId:
		soap_serialize___tns__curseMediaAnnotationWithId(soap, (const struct __tns__curseMediaAnnotationWithId *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__curseMediaAliasWithId:
		soap_serialize___tns__curseMediaAliasWithId(soap, (const struct __tns__curseMediaAliasWithId *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__chat:
		soap_serialize___tns__chat(soap, (const struct __tns__chat *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__blockUserWithId:
		soap_serialize___tns__blockUserWithId(soap, (const struct __tns__blockUserWithId *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__blockMediaAnnotationWithId:
		soap_serialize___tns__blockMediaAnnotationWithId(soap, (const struct __tns__blockMediaAnnotationWithId *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__blockMediaAliasWithId:
		soap_serialize___tns__blockMediaAliasWithId(soap, (const struct __tns__blockMediaAliasWithId *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__blessMediaTokenWithId:
		soap_serialize___tns__blessMediaTokenWithId(soap, (const struct __tns__blessMediaTokenWithId *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__blessMediaAnnotationWithId:
		soap_serialize___tns__blessMediaAnnotationWithId(soap, (const struct __tns__blessMediaAnnotationWithId *)ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__blessMediaAliasWithId:
		soap_serialize___tns__blessMediaAliasWithId(soap, (const struct __tns__blessMediaAliasWithId *)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__updateMediaAnnotationTextWithIdResponse:
		soap_serialize_PointerTotns__updateMediaAnnotationTextWithIdResponse(soap, (tns__updateMediaAnnotationTextWithIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__updateMediaAnnotationTextWithId:
		soap_serialize_PointerTotns__updateMediaAnnotationTextWithId(soap, (tns__updateMediaAnnotationTextWithId *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaTokenDigestResponse:
		soap_serialize_PointerTotns__submitMediaTokenDigestResponse(soap, (tns__submitMediaTokenDigestResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaTokenDigest:
		soap_serialize_PointerTotns__submitMediaTokenDigest(soap, (tns__submitMediaTokenDigest *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaTokenResponse:
		soap_serialize_PointerTotns__submitMediaTokenResponse(soap, (tns__submitMediaTokenResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaToken:
		soap_serialize_PointerTotns__submitMediaToken(soap, (tns__submitMediaToken *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse:
		soap_serialize_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse(soap, (tns__submitMediaAnnotationTextWithTokenIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotationTextWithTokenId:
		soap_serialize_PointerTotns__submitMediaAnnotationTextWithTokenId(soap, (tns__submitMediaAnnotationTextWithTokenId *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse:
		soap_serialize_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse(soap, (tns__submitMediaAnnotationTextAndTokenDigestResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotationTextAndTokenDigest:
		soap_serialize_PointerTotns__submitMediaAnnotationTextAndTokenDigest(soap, (tns__submitMediaAnnotationTextAndTokenDigest *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotationResponse:
		soap_serialize_PointerTotns__submitMediaAnnotationResponse(soap, (tns__submitMediaAnnotationResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotation:
		soap_serialize_PointerTotns__submitMediaAnnotation(soap, (tns__submitMediaAnnotation *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAliasTextWithTokenIdResponse:
		soap_serialize_PointerTotns__submitMediaAliasTextWithTokenIdResponse(soap, (tns__submitMediaAliasTextWithTokenIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAliasTextWithTokenId:
		soap_serialize_PointerTotns__submitMediaAliasTextWithTokenId(soap, (tns__submitMediaAliasTextWithTokenId *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAliasTextAndTokenDigestResponse:
		soap_serialize_PointerTotns__submitMediaAliasTextAndTokenDigestResponse(soap, (tns__submitMediaAliasTextAndTokenDigestResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAliasTextAndTokenDigest:
		soap_serialize_PointerTotns__submitMediaAliasTextAndTokenDigest(soap, (tns__submitMediaAliasTextAndTokenDigest *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAliasResponse:
		soap_serialize_PointerTotns__submitMediaAliasResponse(soap, (tns__submitMediaAliasResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAlias:
		soap_serialize_PointerTotns__submitMediaAlias(soap, (tns__submitMediaAlias *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__setUserLanguageResponse:
		soap_serialize_PointerTotns__setUserLanguageResponse(soap, (tns__setUserLanguageResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__setUserLanguage:
		soap_serialize_PointerTotns__setUserLanguage(soap, (tns__setUserLanguage *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__setUserAnonymousResponse:
		soap_serialize_PointerTotns__setUserAnonymousResponse(soap, (tns__setUserAnonymousResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__setUserAnonymous:
		soap_serialize_PointerTotns__setUserAnonymous(soap, (tns__setUserAnonymous *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__selectUserResponse:
		soap_serialize_PointerTotns__selectUserResponse(soap, (tns__selectUserResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__selectUser:
		soap_serialize_PointerTotns__selectUser(soap, (tns__selectUser *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse:
		soap_serialize_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse(soap, (tns__selectRelatedMediaAnnotationsWithTokenIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__selectRelatedMediaAnnotationsWithTokenId:
		soap_serialize_PointerTotns__selectRelatedMediaAnnotationsWithTokenId(soap, (tns__selectRelatedMediaAnnotationsWithTokenId *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaTokenWithIdResponse:
		soap_serialize_PointerTotns__selectMediaTokenWithIdResponse(soap, (tns__selectMediaTokenWithIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaTokenWithId:
		soap_serialize_PointerTotns__selectMediaTokenWithId(soap, (tns__selectMediaTokenWithId *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaTokenWithDigestResponse:
		soap_serialize_PointerTotns__selectMediaTokenWithDigestResponse(soap, (tns__selectMediaTokenWithDigestResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaTokenWithDigest:
		soap_serialize_PointerTotns__selectMediaTokenWithDigest(soap, (tns__selectMediaTokenWithDigest *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaAnnotationsWithTokenIdResponse:
		soap_serialize_PointerTotns__selectMediaAnnotationsWithTokenIdResponse(soap, (tns__selectMediaAnnotationsWithTokenIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaAnnotationsWithTokenId:
		soap_serialize_PointerTotns__selectMediaAnnotationsWithTokenId(soap, (tns__selectMediaAnnotationsWithTokenId *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaAliasesWithTokenIdResponse:
		soap_serialize_PointerTotns__selectMediaAliasesWithTokenIdResponse(soap, (tns__selectMediaAliasesWithTokenIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__selectMediaAliasesWithTokenId:
		soap_serialize_PointerTotns__selectMediaAliasesWithTokenId(soap, (tns__selectMediaAliasesWithTokenId *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__isConnectedResponse:
		soap_serialize_PointerTotns__isConnectedResponse(soap, (tns__isConnectedResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__isConnected:
		soap_serialize_PointerTotns__isConnected(soap, (tns__isConnected *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__isClientUpdatedResponse:
		soap_serialize_PointerTotns__isClientUpdatedResponse(soap, (tns__isClientUpdatedResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__isClientUpdated:
		soap_serialize_PointerTotns__isClientUpdated(soap, (tns__isClientUpdated *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__curseMediaTokenWithIdResponse:
		soap_serialize_PointerTotns__curseMediaTokenWithIdResponse(soap, (tns__curseMediaTokenWithIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__curseMediaTokenWithId:
		soap_serialize_PointerTotns__curseMediaTokenWithId(soap, (tns__curseMediaTokenWithId *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__curseMediaAnnotationWithIdResponse:
		soap_serialize_PointerTotns__curseMediaAnnotationWithIdResponse(soap, (tns__curseMediaAnnotationWithIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__curseMediaAnnotationWithId:
		soap_serialize_PointerTotns__curseMediaAnnotationWithId(soap, (tns__curseMediaAnnotationWithId *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__curseMediaAliasWithIdResponse:
		soap_serialize_PointerTotns__curseMediaAliasWithIdResponse(soap, (tns__curseMediaAliasWithIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__curseMediaAliasWithId:
		soap_serialize_PointerTotns__curseMediaAliasWithId(soap, (tns__curseMediaAliasWithId *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__chatResponse:
		soap_serialize_PointerTotns__chatResponse(soap, (tns__chatResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__chat:
		soap_serialize_PointerTotns__chat(soap, (tns__chat *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__blockUserWithIdResponse:
		soap_serialize_PointerTotns__blockUserWithIdResponse(soap, (tns__blockUserWithIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__blockUserWithId:
		soap_serialize_PointerTotns__blockUserWithId(soap, (tns__blockUserWithId *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__blockMediaAnnotationWithIdResponse:
		soap_serialize_PointerTotns__blockMediaAnnotationWithIdResponse(soap, (tns__blockMediaAnnotationWithIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__blockMediaAnnotationWithId:
		soap_serialize_PointerTotns__blockMediaAnnotationWithId(soap, (tns__blockMediaAnnotationWithId *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__blockMediaAliasWithIdResponse:
		soap_serialize_PointerTotns__blockMediaAliasWithIdResponse(soap, (tns__blockMediaAliasWithIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__blockMediaAliasWithId:
		soap_serialize_PointerTotns__blockMediaAliasWithId(soap, (tns__blockMediaAliasWithId *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__blessMediaTokenWithIdResponse:
		soap_serialize_PointerTotns__blessMediaTokenWithIdResponse(soap, (tns__blessMediaTokenWithIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__blessMediaTokenWithId:
		soap_serialize_PointerTotns__blessMediaTokenWithId(soap, (tns__blessMediaTokenWithId *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__blessMediaAnnotationWithIdResponse:
		soap_serialize_PointerTotns__blessMediaAnnotationWithIdResponse(soap, (tns__blessMediaAnnotationWithIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__blessMediaAnnotationWithId:
		soap_serialize_PointerTotns__blessMediaAnnotationWithId(soap, (tns__blessMediaAnnotationWithId *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__blessMediaAliasWithIdResponse:
		soap_serialize_PointerTotns__blessMediaAliasWithIdResponse(soap, (tns__blessMediaAliasWithIdResponse *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__blessMediaAliasWithId:
		soap_serialize_PointerTotns__blessMediaAliasWithId(soap, (tns__blessMediaAliasWithId *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__user:
		soap_serialize_PointerTotns__user(soap, (tns__user *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__mediaToken:
		soap_serialize_PointerTotns__mediaToken(soap, (tns__mediaToken *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__mediaAnnotation:
		soap_serialize_PointerTotns__mediaAnnotation(soap, (tns__mediaAnnotation *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTotns__mediaAlias:
		soap_serialize_PointerTotns__mediaAlias(soap, (tns__mediaAlias *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_ServerSoap__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_ServerSoap_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 ServerSoap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_ServerSoap_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__mediaAnnotation:
		return (void*)soap_instantiate_tns__mediaAnnotation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__mediaToken:
		return (void*)soap_instantiate_tns__mediaToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__mediaAlias:
		return (void*)soap_instantiate_tns__mediaAlias(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__user:
		return (void*)soap_instantiate_tns__user(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__blessMediaAliasWithId:
		return (void*)soap_instantiate_tns__blessMediaAliasWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__blessMediaAliasWithIdResponse:
		return (void*)soap_instantiate_tns__blessMediaAliasWithIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithId:
		return (void*)soap_instantiate_tns__blessMediaAnnotationWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithIdResponse:
		return (void*)soap_instantiate_tns__blessMediaAnnotationWithIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__blessMediaTokenWithId:
		return (void*)soap_instantiate_tns__blessMediaTokenWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__blessMediaTokenWithIdResponse:
		return (void*)soap_instantiate_tns__blessMediaTokenWithIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__blockMediaAliasWithId:
		return (void*)soap_instantiate_tns__blockMediaAliasWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__blockMediaAliasWithIdResponse:
		return (void*)soap_instantiate_tns__blockMediaAliasWithIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__blockMediaAnnotationWithId:
		return (void*)soap_instantiate_tns__blockMediaAnnotationWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__blockMediaAnnotationWithIdResponse:
		return (void*)soap_instantiate_tns__blockMediaAnnotationWithIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__blockUserWithId:
		return (void*)soap_instantiate_tns__blockUserWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__blockUserWithIdResponse:
		return (void*)soap_instantiate_tns__blockUserWithIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__chat:
		return (void*)soap_instantiate_tns__chat(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__chatResponse:
		return (void*)soap_instantiate_tns__chatResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__curseMediaAliasWithId:
		return (void*)soap_instantiate_tns__curseMediaAliasWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__curseMediaAliasWithIdResponse:
		return (void*)soap_instantiate_tns__curseMediaAliasWithIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__curseMediaAnnotationWithId:
		return (void*)soap_instantiate_tns__curseMediaAnnotationWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__curseMediaAnnotationWithIdResponse:
		return (void*)soap_instantiate_tns__curseMediaAnnotationWithIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__curseMediaTokenWithId:
		return (void*)soap_instantiate_tns__curseMediaTokenWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__curseMediaTokenWithIdResponse:
		return (void*)soap_instantiate_tns__curseMediaTokenWithIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__isClientUpdated:
		return (void*)soap_instantiate_tns__isClientUpdated(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__isClientUpdatedResponse:
		return (void*)soap_instantiate_tns__isClientUpdatedResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__isConnected:
		return (void*)soap_instantiate_tns__isConnected(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__isConnectedResponse:
		return (void*)soap_instantiate_tns__isConnectedResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenId:
		return (void*)soap_instantiate_tns__selectMediaAliasesWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenIdResponse:
		return (void*)soap_instantiate_tns__selectMediaAliasesWithTokenIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenId:
		return (void*)soap_instantiate_tns__selectMediaAnnotationsWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenIdResponse:
		return (void*)soap_instantiate_tns__selectMediaAnnotationsWithTokenIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigest:
		return (void*)soap_instantiate_tns__selectMediaTokenWithDigest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigestResponse:
		return (void*)soap_instantiate_tns__selectMediaTokenWithDigestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithId:
		return (void*)soap_instantiate_tns__selectMediaTokenWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithIdResponse:
		return (void*)soap_instantiate_tns__selectMediaTokenWithIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenId:
		return (void*)soap_instantiate_tns__selectRelatedMediaAnnotationsWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenIdResponse:
		return (void*)soap_instantiate_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__selectUser:
		return (void*)soap_instantiate_tns__selectUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__selectUserResponse:
		return (void*)soap_instantiate_tns__selectUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__setUserAnonymous:
		return (void*)soap_instantiate_tns__setUserAnonymous(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__setUserAnonymousResponse:
		return (void*)soap_instantiate_tns__setUserAnonymousResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__setUserLanguage:
		return (void*)soap_instantiate_tns__setUserLanguage(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__setUserLanguageResponse:
		return (void*)soap_instantiate_tns__setUserLanguageResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitMediaAlias:
		return (void*)soap_instantiate_tns__submitMediaAlias(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasResponse:
		return (void*)soap_instantiate_tns__submitMediaAliasResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigest:
		return (void*)soap_instantiate_tns__submitMediaAliasTextAndTokenDigest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigestResponse:
		return (void*)soap_instantiate_tns__submitMediaAliasTextAndTokenDigestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenId:
		return (void*)soap_instantiate_tns__submitMediaAliasTextWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenIdResponse:
		return (void*)soap_instantiate_tns__submitMediaAliasTextWithTokenIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotation:
		return (void*)soap_instantiate_tns__submitMediaAnnotation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationResponse:
		return (void*)soap_instantiate_tns__submitMediaAnnotationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigest:
		return (void*)soap_instantiate_tns__submitMediaAnnotationTextAndTokenDigest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigestResponse:
		return (void*)soap_instantiate_tns__submitMediaAnnotationTextAndTokenDigestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenId:
		return (void*)soap_instantiate_tns__submitMediaAnnotationTextWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenIdResponse:
		return (void*)soap_instantiate_tns__submitMediaAnnotationTextWithTokenIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitMediaToken:
		return (void*)soap_instantiate_tns__submitMediaToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitMediaTokenResponse:
		return (void*)soap_instantiate_tns__submitMediaTokenResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigest:
		return (void*)soap_instantiate_tns__submitMediaTokenDigest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigestResponse:
		return (void*)soap_instantiate_tns__submitMediaTokenDigestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithId:
		return (void*)soap_instantiate_tns__updateMediaAnnotationTextWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithIdResponse:
		return (void*)soap_instantiate_tns__updateMediaAnnotationTextWithIdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__blessMediaAliasWithId:
		return (void*)soap_instantiate___tns__blessMediaAliasWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__blessMediaAnnotationWithId:
		return (void*)soap_instantiate___tns__blessMediaAnnotationWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__blessMediaTokenWithId:
		return (void*)soap_instantiate___tns__blessMediaTokenWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__blockMediaAliasWithId:
		return (void*)soap_instantiate___tns__blockMediaAliasWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__blockMediaAnnotationWithId:
		return (void*)soap_instantiate___tns__blockMediaAnnotationWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__blockUserWithId:
		return (void*)soap_instantiate___tns__blockUserWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__chat:
		return (void*)soap_instantiate___tns__chat(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__curseMediaAliasWithId:
		return (void*)soap_instantiate___tns__curseMediaAliasWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__curseMediaAnnotationWithId:
		return (void*)soap_instantiate___tns__curseMediaAnnotationWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__curseMediaTokenWithId:
		return (void*)soap_instantiate___tns__curseMediaTokenWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__isClientUpdated:
		return (void*)soap_instantiate___tns__isClientUpdated(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__isConnected:
		return (void*)soap_instantiate___tns__isConnected(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__selectMediaAliasesWithTokenId:
		return (void*)soap_instantiate___tns__selectMediaAliasesWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__selectMediaAnnotationsWithTokenId:
		return (void*)soap_instantiate___tns__selectMediaAnnotationsWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__selectMediaTokenWithDigest:
		return (void*)soap_instantiate___tns__selectMediaTokenWithDigest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__selectMediaTokenWithId:
		return (void*)soap_instantiate___tns__selectMediaTokenWithId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__selectRelatedMediaAnnotationsWithTokenId:
		return (void*)soap_instantiate___tns__selectRelatedMediaAnnotationsWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__selectUser:
		return (void*)soap_instantiate___tns__selectUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__setUserAnonymous:
		return (void*)soap_instantiate___tns__setUserAnonymous(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__setUserLanguage:
		return (void*)soap_instantiate___tns__setUserLanguage(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__submitMediaAlias:
		return (void*)soap_instantiate___tns__submitMediaAlias(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__submitMediaAliasTextAndTokenDigest:
		return (void*)soap_instantiate___tns__submitMediaAliasTextAndTokenDigest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__submitMediaAliasTextWithTokenId:
		return (void*)soap_instantiate___tns__submitMediaAliasTextWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__submitMediaAnnotation:
		return (void*)soap_instantiate___tns__submitMediaAnnotation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__submitMediaAnnotationTextAndTokenDigest:
		return (void*)soap_instantiate___tns__submitMediaAnnotationTextAndTokenDigest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__submitMediaAnnotationTextWithTokenId:
		return (void*)soap_instantiate___tns__submitMediaAnnotationTextWithTokenId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__submitMediaToken:
		return (void*)soap_instantiate___tns__submitMediaToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__submitMediaTokenDigest:
		return (void*)soap_instantiate___tns__submitMediaTokenDigest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap___tns__updateMediaAnnotationTextWithId:
		return (void*)soap_instantiate___tns__updateMediaAnnotationTextWithId(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_ServerSoap_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_ServerSoap_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_ServerSoap_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_ServerSoap_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_ServerSoap_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_ServerSoap_std__vectorTemplateOfPointerTotns__mediaAnnotation:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTotns__mediaAnnotation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ServerSoap_std__vectorTemplateOfPointerTotns__mediaAlias:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTotns__mediaAlias(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 ServerSoap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_ServerSoap_std__string:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__mediaAnnotation:
		if (p->size < 0)
			SOAP_DELETE((tns__mediaAnnotation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__mediaAnnotation*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__mediaToken:
		if (p->size < 0)
			SOAP_DELETE((tns__mediaToken*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__mediaToken*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__mediaAlias:
		if (p->size < 0)
			SOAP_DELETE((tns__mediaAlias*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__mediaAlias*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__user:
		if (p->size < 0)
			SOAP_DELETE((tns__user*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__user*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__blessMediaAliasWithId:
		if (p->size < 0)
			SOAP_DELETE((tns__blessMediaAliasWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__blessMediaAliasWithId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__blessMediaAliasWithIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__blessMediaAliasWithIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__blessMediaAliasWithIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithId:
		if (p->size < 0)
			SOAP_DELETE((tns__blessMediaAnnotationWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__blessMediaAnnotationWithId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__blessMediaAnnotationWithIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__blessMediaAnnotationWithIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__blessMediaTokenWithId:
		if (p->size < 0)
			SOAP_DELETE((tns__blessMediaTokenWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__blessMediaTokenWithId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__blessMediaTokenWithIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__blessMediaTokenWithIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__blessMediaTokenWithIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__blockMediaAliasWithId:
		if (p->size < 0)
			SOAP_DELETE((tns__blockMediaAliasWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__blockMediaAliasWithId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__blockMediaAliasWithIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__blockMediaAliasWithIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__blockMediaAliasWithIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__blockMediaAnnotationWithId:
		if (p->size < 0)
			SOAP_DELETE((tns__blockMediaAnnotationWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__blockMediaAnnotationWithId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__blockMediaAnnotationWithIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__blockMediaAnnotationWithIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__blockMediaAnnotationWithIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__blockUserWithId:
		if (p->size < 0)
			SOAP_DELETE((tns__blockUserWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__blockUserWithId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__blockUserWithIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__blockUserWithIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__blockUserWithIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__chat:
		if (p->size < 0)
			SOAP_DELETE((tns__chat*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__chat*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__chatResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__chatResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__chatResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__curseMediaAliasWithId:
		if (p->size < 0)
			SOAP_DELETE((tns__curseMediaAliasWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__curseMediaAliasWithId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__curseMediaAliasWithIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__curseMediaAliasWithIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__curseMediaAliasWithIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__curseMediaAnnotationWithId:
		if (p->size < 0)
			SOAP_DELETE((tns__curseMediaAnnotationWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__curseMediaAnnotationWithId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__curseMediaAnnotationWithIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__curseMediaAnnotationWithIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__curseMediaAnnotationWithIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__curseMediaTokenWithId:
		if (p->size < 0)
			SOAP_DELETE((tns__curseMediaTokenWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__curseMediaTokenWithId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__curseMediaTokenWithIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__curseMediaTokenWithIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__curseMediaTokenWithIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__isClientUpdated:
		if (p->size < 0)
			SOAP_DELETE((tns__isClientUpdated*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__isClientUpdated*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__isClientUpdatedResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__isClientUpdatedResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__isClientUpdatedResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__isConnected:
		if (p->size < 0)
			SOAP_DELETE((tns__isConnected*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__isConnected*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__isConnectedResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__isConnectedResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__isConnectedResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((tns__selectMediaAliasesWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectMediaAliasesWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__selectMediaAliasesWithTokenIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectMediaAliasesWithTokenIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((tns__selectMediaAnnotationsWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectMediaAnnotationsWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__selectMediaAnnotationsWithTokenIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectMediaAnnotationsWithTokenIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigest:
		if (p->size < 0)
			SOAP_DELETE((tns__selectMediaTokenWithDigest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectMediaTokenWithDigest*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigestResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__selectMediaTokenWithDigestResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectMediaTokenWithDigestResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithId:
		if (p->size < 0)
			SOAP_DELETE((tns__selectMediaTokenWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectMediaTokenWithId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__selectMediaTokenWithIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectMediaTokenWithIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((tns__selectRelatedMediaAnnotationsWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectRelatedMediaAnnotationsWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__selectRelatedMediaAnnotationsWithTokenIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectRelatedMediaAnnotationsWithTokenIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectUser:
		if (p->size < 0)
			SOAP_DELETE((tns__selectUser*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectUser*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__selectUserResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__selectUserResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__selectUserResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__setUserAnonymous:
		if (p->size < 0)
			SOAP_DELETE((tns__setUserAnonymous*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__setUserAnonymous*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__setUserAnonymousResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__setUserAnonymousResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__setUserAnonymousResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__setUserLanguage:
		if (p->size < 0)
			SOAP_DELETE((tns__setUserLanguage*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__setUserLanguage*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__setUserLanguageResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__setUserLanguageResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__setUserLanguageResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAlias:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaAlias*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaAlias*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaAliasResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaAliasResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigest:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaAliasTextAndTokenDigest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaAliasTextAndTokenDigest*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigestResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaAliasTextAndTokenDigestResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaAliasTextAndTokenDigestResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaAliasTextWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaAliasTextWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaAliasTextWithTokenIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaAliasTextWithTokenIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotation:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaAnnotation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaAnnotation*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaAnnotationResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaAnnotationResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigest:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaAnnotationTextAndTokenDigest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaAnnotationTextAndTokenDigest*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigestResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaAnnotationTextAndTokenDigestResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaAnnotationTextAndTokenDigestResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaAnnotationTextWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaAnnotationTextWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaAnnotationTextWithTokenIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaAnnotationTextWithTokenIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaToken:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaToken*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaToken*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaTokenResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaTokenResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaTokenResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigest:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaTokenDigest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaTokenDigest*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigestResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__submitMediaTokenDigestResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__submitMediaTokenDigestResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithId:
		if (p->size < 0)
			SOAP_DELETE((tns__updateMediaAnnotationTextWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__updateMediaAnnotationTextWithId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithIdResponse:
		if (p->size < 0)
			SOAP_DELETE((tns__updateMediaAnnotationTextWithIdResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((tns__updateMediaAnnotationTextWithIdResponse*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__blessMediaAliasWithId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__blessMediaAliasWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__blessMediaAliasWithId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__blessMediaAnnotationWithId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__blessMediaAnnotationWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__blessMediaAnnotationWithId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__blessMediaTokenWithId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__blessMediaTokenWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__blessMediaTokenWithId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__blockMediaAliasWithId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__blockMediaAliasWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__blockMediaAliasWithId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__blockMediaAnnotationWithId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__blockMediaAnnotationWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__blockMediaAnnotationWithId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__blockUserWithId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__blockUserWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__blockUserWithId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__chat:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__chat*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__chat*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__curseMediaAliasWithId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__curseMediaAliasWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__curseMediaAliasWithId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__curseMediaAnnotationWithId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__curseMediaAnnotationWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__curseMediaAnnotationWithId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__curseMediaTokenWithId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__curseMediaTokenWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__curseMediaTokenWithId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__isClientUpdated:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__isClientUpdated*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__isClientUpdated*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__isConnected:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__isConnected*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__isConnected*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__selectMediaAliasesWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__selectMediaAliasesWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__selectMediaAliasesWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__selectMediaAnnotationsWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__selectMediaAnnotationsWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__selectMediaAnnotationsWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__selectMediaTokenWithDigest:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__selectMediaTokenWithDigest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__selectMediaTokenWithDigest*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__selectMediaTokenWithId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__selectMediaTokenWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__selectMediaTokenWithId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__selectRelatedMediaAnnotationsWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__selectRelatedMediaAnnotationsWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__selectRelatedMediaAnnotationsWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__selectUser:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__selectUser*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__selectUser*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__setUserAnonymous:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__setUserAnonymous*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__setUserAnonymous*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__setUserLanguage:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__setUserLanguage*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__setUserLanguage*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitMediaAlias:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__submitMediaAlias*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__submitMediaAlias*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitMediaAliasTextAndTokenDigest:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__submitMediaAliasTextAndTokenDigest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__submitMediaAliasTextAndTokenDigest*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitMediaAliasTextWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__submitMediaAliasTextWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__submitMediaAliasTextWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitMediaAnnotation:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__submitMediaAnnotation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__submitMediaAnnotation*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitMediaAnnotationTextAndTokenDigest:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__submitMediaAnnotationTextAndTokenDigest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__submitMediaAnnotationTextAndTokenDigest*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitMediaAnnotationTextWithTokenId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__submitMediaAnnotationTextWithTokenId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__submitMediaAnnotationTextWithTokenId*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitMediaToken:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__submitMediaToken*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__submitMediaToken*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__submitMediaTokenDigest:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__submitMediaTokenDigest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__submitMediaTokenDigest*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap___tns__updateMediaAnnotationTextWithId:
		if (p->size < 0)
			SOAP_DELETE((struct __tns__updateMediaAnnotationTextWithId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __tns__updateMediaAnnotationTextWithId*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_ServerSoap_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_ServerSoap_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_ServerSoap_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_ServerSoap_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_ServerSoap_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	case SOAP_TYPE_ServerSoap_std__vectorTemplateOfPointerTotns__mediaAnnotation:
		if (p->size < 0)
			SOAP_DELETE((std::vector<tns__mediaAnnotation * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<tns__mediaAnnotation * >*)p->ptr);
		break;
	case SOAP_TYPE_ServerSoap_std__vectorTemplateOfPointerTotns__mediaAlias:
		if (p->size < 0)
			SOAP_DELETE((std::vector<tns__mediaAlias * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<tns__mediaAlias * >*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, ServerSoap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, ServerSoap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 ServerSoap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_ServerSoap_std__vectorTemplateOfPointerTotns__mediaAnnotation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container ServerSoap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<tns__mediaAnnotation * >*)p)[len] = *(tns__mediaAnnotation **)q;
		break;
	case SOAP_TYPE_ServerSoap_std__vectorTemplateOfPointerTotns__mediaAlias:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container ServerSoap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<tns__mediaAlias * >*)p)[len] = *(tns__mediaAlias **)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_ServerSoap_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_ServerSoap_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_ServerSoap_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_ServerSoap_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_ServerSoap_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{	LONG64 *p;
	p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_ServerSoap_LONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_LONG64);
	if (soap_out_LONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_ServerSoap_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ServerSoap_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_ServerSoap_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_ServerSoap_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_std__string, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::string[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void tns__updateMediaAnnotationTextWithIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__updateMediaAnnotationTextWithIdResponse::return_);
	/* transient soap skipped */
}

void tns__updateMediaAnnotationTextWithIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__updateMediaAnnotationTextWithIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__updateMediaAnnotationTextWithIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__updateMediaAnnotationTextWithIdResponse(struct soap *soap, const char *tag, int id, const tns__updateMediaAnnotationTextWithIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithIdResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__updateMediaAnnotationTextWithIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__updateMediaAnnotationTextWithIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__updateMediaAnnotationTextWithIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__updateMediaAnnotationTextWithIdResponse * SOAP_FMAC4 soap_in_tns__updateMediaAnnotationTextWithIdResponse(struct soap *soap, const char *tag, tns__updateMediaAnnotationTextWithIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__updateMediaAnnotationTextWithIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithIdResponse, sizeof(tns__updateMediaAnnotationTextWithIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__updateMediaAnnotationTextWithIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__updateMediaAnnotationTextWithIdResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__updateMediaAnnotationTextWithIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithIdResponse, 0, sizeof(tns__updateMediaAnnotationTextWithIdResponse), 0, soap_copy_tns__updateMediaAnnotationTextWithIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__updateMediaAnnotationTextWithIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:updateMediaAnnotationTextWithIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__updateMediaAnnotationTextWithIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__updateMediaAnnotationTextWithIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__updateMediaAnnotationTextWithIdResponse * SOAP_FMAC4 soap_get_tns__updateMediaAnnotationTextWithIdResponse(struct soap *soap, tns__updateMediaAnnotationTextWithIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__updateMediaAnnotationTextWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__updateMediaAnnotationTextWithIdResponse * SOAP_FMAC2 soap_instantiate_tns__updateMediaAnnotationTextWithIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__updateMediaAnnotationTextWithIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithIdResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__updateMediaAnnotationTextWithIdResponse);
		if (size)
			*size = sizeof(tns__updateMediaAnnotationTextWithIdResponse);
		((tns__updateMediaAnnotationTextWithIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__updateMediaAnnotationTextWithIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__updateMediaAnnotationTextWithIdResponse);
		for (int i = 0; i < n; i++)
			((tns__updateMediaAnnotationTextWithIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__updateMediaAnnotationTextWithIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__updateMediaAnnotationTextWithIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__updateMediaAnnotationTextWithIdResponse %p -> %p\n", q, p));
	*(tns__updateMediaAnnotationTextWithIdResponse*)p = *(tns__updateMediaAnnotationTextWithIdResponse*)q;
}

void tns__updateMediaAnnotationTextWithId::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__updateMediaAnnotationTextWithId::arg0 = NULL;
	soap_default_LONG64(soap, &this->tns__updateMediaAnnotationTextWithId::arg1);
	this->tns__updateMediaAnnotationTextWithId::userName = NULL;
	this->tns__updateMediaAnnotationTextWithId::password = NULL;
	/* transient soap skipped */
}

void tns__updateMediaAnnotationTextWithId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__updateMediaAnnotationTextWithId::arg0);
	soap_serialize_PointerTostd__string(soap, &this->tns__updateMediaAnnotationTextWithId::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__updateMediaAnnotationTextWithId::password);
	/* transient soap skipped */
}

int tns__updateMediaAnnotationTextWithId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__updateMediaAnnotationTextWithId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__updateMediaAnnotationTextWithId(struct soap *soap, const char *tag, int id, const tns__updateMediaAnnotationTextWithId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithId), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->tns__updateMediaAnnotationTextWithId::arg0), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "arg1", -1, &(a->tns__updateMediaAnnotationTextWithId::arg1), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__updateMediaAnnotationTextWithId::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__updateMediaAnnotationTextWithId::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__updateMediaAnnotationTextWithId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__updateMediaAnnotationTextWithId(soap, tag, this, type);
}

SOAP_FMAC3 tns__updateMediaAnnotationTextWithId * SOAP_FMAC4 soap_in_tns__updateMediaAnnotationTextWithId(struct soap *soap, const char *tag, tns__updateMediaAnnotationTextWithId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__updateMediaAnnotationTextWithId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithId, sizeof(tns__updateMediaAnnotationTextWithId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__updateMediaAnnotationTextWithId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->tns__updateMediaAnnotationTextWithId::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "arg1", &(a->tns__updateMediaAnnotationTextWithId::arg1), "xsd:long"))
				{	soap_flag_arg11--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__updateMediaAnnotationTextWithId::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__updateMediaAnnotationTextWithId::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__updateMediaAnnotationTextWithId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithId, 0, sizeof(tns__updateMediaAnnotationTextWithId), 0, soap_copy_tns__updateMediaAnnotationTextWithId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg11 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__updateMediaAnnotationTextWithId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithId);
	if (this->soap_out(soap, tag?tag:"tns:updateMediaAnnotationTextWithId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__updateMediaAnnotationTextWithId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__updateMediaAnnotationTextWithId(soap, this, tag, type);
}

SOAP_FMAC3 tns__updateMediaAnnotationTextWithId * SOAP_FMAC4 soap_get_tns__updateMediaAnnotationTextWithId(struct soap *soap, tns__updateMediaAnnotationTextWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__updateMediaAnnotationTextWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__updateMediaAnnotationTextWithId * SOAP_FMAC2 soap_instantiate_tns__updateMediaAnnotationTextWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__updateMediaAnnotationTextWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__updateMediaAnnotationTextWithId);
		if (size)
			*size = sizeof(tns__updateMediaAnnotationTextWithId);
		((tns__updateMediaAnnotationTextWithId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__updateMediaAnnotationTextWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__updateMediaAnnotationTextWithId);
		for (int i = 0; i < n; i++)
			((tns__updateMediaAnnotationTextWithId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__updateMediaAnnotationTextWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__updateMediaAnnotationTextWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__updateMediaAnnotationTextWithId %p -> %p\n", q, p));
	*(tns__updateMediaAnnotationTextWithId*)p = *(tns__updateMediaAnnotationTextWithId*)q;
}

void tns__submitMediaTokenDigestResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__submitMediaTokenDigestResponse::return_);
	/* transient soap skipped */
}

void tns__submitMediaTokenDigestResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__submitMediaTokenDigestResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaTokenDigestResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaTokenDigestResponse(struct soap *soap, const char *tag, int id, const tns__submitMediaTokenDigestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigestResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "return", -1, &(a->tns__submitMediaTokenDigestResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaTokenDigestResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaTokenDigestResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaTokenDigestResponse * SOAP_FMAC4 soap_in_tns__submitMediaTokenDigestResponse(struct soap *soap, const char *tag, tns__submitMediaTokenDigestResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaTokenDigestResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigestResponse, sizeof(tns__submitMediaTokenDigestResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigestResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaTokenDigestResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "return", &(a->tns__submitMediaTokenDigestResponse::return_), "xsd:long"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaTokenDigestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigestResponse, 0, sizeof(tns__submitMediaTokenDigestResponse), 0, soap_copy_tns__submitMediaTokenDigestResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitMediaTokenDigestResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigestResponse);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaTokenDigestResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaTokenDigestResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaTokenDigestResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaTokenDigestResponse * SOAP_FMAC4 soap_get_tns__submitMediaTokenDigestResponse(struct soap *soap, tns__submitMediaTokenDigestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaTokenDigestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaTokenDigestResponse * SOAP_FMAC2 soap_instantiate_tns__submitMediaTokenDigestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaTokenDigestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigestResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaTokenDigestResponse);
		if (size)
			*size = sizeof(tns__submitMediaTokenDigestResponse);
		((tns__submitMediaTokenDigestResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaTokenDigestResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaTokenDigestResponse);
		for (int i = 0; i < n; i++)
			((tns__submitMediaTokenDigestResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaTokenDigestResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaTokenDigestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaTokenDigestResponse %p -> %p\n", q, p));
	*(tns__submitMediaTokenDigestResponse*)p = *(tns__submitMediaTokenDigestResponse*)q;
}

void tns__submitMediaTokenDigest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__submitMediaTokenDigest::arg0 = NULL;
	soap_default_int(soap, &this->tns__submitMediaTokenDigest::arg1);
	soap_default_int(soap, &this->tns__submitMediaTokenDigest::arg2);
	this->tns__submitMediaTokenDigest::userName = NULL;
	this->tns__submitMediaTokenDigest::password = NULL;
	/* transient soap skipped */
}

void tns__submitMediaTokenDigest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaTokenDigest::arg0);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaTokenDigest::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaTokenDigest::password);
	/* transient soap skipped */
}

int tns__submitMediaTokenDigest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaTokenDigest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaTokenDigest(struct soap *soap, const char *tag, int id, const tns__submitMediaTokenDigest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigest), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->tns__submitMediaTokenDigest::arg0), ""))
		return soap->error;
	if (soap_out_int(soap, "arg1", -1, &(a->tns__submitMediaTokenDigest::arg1), ""))
		return soap->error;
	if (soap_out_int(soap, "arg2", -1, &(a->tns__submitMediaTokenDigest::arg2), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__submitMediaTokenDigest::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__submitMediaTokenDigest::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaTokenDigest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaTokenDigest(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaTokenDigest * SOAP_FMAC4 soap_in_tns__submitMediaTokenDigest(struct soap *soap, const char *tag, tns__submitMediaTokenDigest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaTokenDigest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigest, sizeof(tns__submitMediaTokenDigest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaTokenDigest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->tns__submitMediaTokenDigest::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "arg1", &(a->tns__submitMediaTokenDigest::arg1), "xsd:int"))
				{	soap_flag_arg11--;
					continue;
				}
			if (soap_flag_arg21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "arg2", &(a->tns__submitMediaTokenDigest::arg2), "xsd:int"))
				{	soap_flag_arg21--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__submitMediaTokenDigest::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__submitMediaTokenDigest::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaTokenDigest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigest, 0, sizeof(tns__submitMediaTokenDigest), 0, soap_copy_tns__submitMediaTokenDigest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg11 > 0 || soap_flag_arg21 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitMediaTokenDigest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigest);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaTokenDigest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaTokenDigest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaTokenDigest(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaTokenDigest * SOAP_FMAC4 soap_get_tns__submitMediaTokenDigest(struct soap *soap, tns__submitMediaTokenDigest *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaTokenDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaTokenDigest * SOAP_FMAC2 soap_instantiate_tns__submitMediaTokenDigest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaTokenDigest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigest, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaTokenDigest);
		if (size)
			*size = sizeof(tns__submitMediaTokenDigest);
		((tns__submitMediaTokenDigest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaTokenDigest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaTokenDigest);
		for (int i = 0; i < n; i++)
			((tns__submitMediaTokenDigest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaTokenDigest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaTokenDigest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaTokenDigest %p -> %p\n", q, p));
	*(tns__submitMediaTokenDigest*)p = *(tns__submitMediaTokenDigest*)q;
}

void tns__submitMediaTokenResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__submitMediaTokenResponse::return_);
	/* transient soap skipped */
}

void tns__submitMediaTokenResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__submitMediaTokenResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaTokenResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaTokenResponse(struct soap *soap, const char *tag, int id, const tns__submitMediaTokenResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitMediaTokenResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "return", -1, &(a->tns__submitMediaTokenResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaTokenResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaTokenResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaTokenResponse * SOAP_FMAC4 soap_in_tns__submitMediaTokenResponse(struct soap *soap, const char *tag, tns__submitMediaTokenResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaTokenResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitMediaTokenResponse, sizeof(tns__submitMediaTokenResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitMediaTokenResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaTokenResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "return", &(a->tns__submitMediaTokenResponse::return_), "xsd:long"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaTokenResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitMediaTokenResponse, 0, sizeof(tns__submitMediaTokenResponse), 0, soap_copy_tns__submitMediaTokenResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitMediaTokenResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitMediaTokenResponse);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaTokenResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaTokenResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaTokenResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaTokenResponse * SOAP_FMAC4 soap_get_tns__submitMediaTokenResponse(struct soap *soap, tns__submitMediaTokenResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaTokenResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaTokenResponse * SOAP_FMAC2 soap_instantiate_tns__submitMediaTokenResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaTokenResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitMediaTokenResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaTokenResponse);
		if (size)
			*size = sizeof(tns__submitMediaTokenResponse);
		((tns__submitMediaTokenResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaTokenResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaTokenResponse);
		for (int i = 0; i < n; i++)
			((tns__submitMediaTokenResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaTokenResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaTokenResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaTokenResponse %p -> %p\n", q, p));
	*(tns__submitMediaTokenResponse*)p = *(tns__submitMediaTokenResponse*)q;
}

void tns__submitMediaToken::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__submitMediaToken::arg0 = NULL;
	this->tns__submitMediaToken::userName = NULL;
	this->tns__submitMediaToken::password = NULL;
	/* transient soap skipped */
}

void tns__submitMediaToken::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__mediaToken(soap, &this->tns__submitMediaToken::arg0);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaToken::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaToken::password);
	/* transient soap skipped */
}

int tns__submitMediaToken::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaToken(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaToken(struct soap *soap, const char *tag, int id, const tns__submitMediaToken *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitMediaToken), type))
		return soap->error;
	if (soap_out_PointerTotns__mediaToken(soap, "arg0", -1, &(a->tns__submitMediaToken::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__submitMediaToken::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__submitMediaToken::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaToken::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaToken(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaToken * SOAP_FMAC4 soap_in_tns__submitMediaToken(struct soap *soap, const char *tag, tns__submitMediaToken *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaToken *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitMediaToken, sizeof(tns__submitMediaToken), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitMediaToken)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaToken *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__mediaToken(soap, "arg0", &(a->tns__submitMediaToken::arg0), "tns:mediaToken"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__submitMediaToken::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__submitMediaToken::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaToken *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitMediaToken, 0, sizeof(tns__submitMediaToken), 0, soap_copy_tns__submitMediaToken);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__submitMediaToken::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitMediaToken);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaToken", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaToken::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaToken(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaToken * SOAP_FMAC4 soap_get_tns__submitMediaToken(struct soap *soap, tns__submitMediaToken *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaToken * SOAP_FMAC2 soap_instantiate_tns__submitMediaToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaToken(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitMediaToken, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaToken);
		if (size)
			*size = sizeof(tns__submitMediaToken);
		((tns__submitMediaToken*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaToken[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaToken);
		for (int i = 0; i < n; i++)
			((tns__submitMediaToken*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaToken*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaToken(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaToken %p -> %p\n", q, p));
	*(tns__submitMediaToken*)p = *(tns__submitMediaToken*)q;
}

void tns__submitMediaAnnotationTextWithTokenIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__submitMediaAnnotationTextWithTokenIdResponse::return_);
	/* transient soap skipped */
}

void tns__submitMediaAnnotationTextWithTokenIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__submitMediaAnnotationTextWithTokenIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaAnnotationTextWithTokenIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaAnnotationTextWithTokenIdResponse(struct soap *soap, const char *tag, int id, const tns__submitMediaAnnotationTextWithTokenIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenIdResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "return", -1, &(a->tns__submitMediaAnnotationTextWithTokenIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaAnnotationTextWithTokenIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaAnnotationTextWithTokenIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextWithTokenIdResponse * SOAP_FMAC4 soap_in_tns__submitMediaAnnotationTextWithTokenIdResponse(struct soap *soap, const char *tag, tns__submitMediaAnnotationTextWithTokenIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaAnnotationTextWithTokenIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenIdResponse, sizeof(tns__submitMediaAnnotationTextWithTokenIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaAnnotationTextWithTokenIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "return", &(a->tns__submitMediaAnnotationTextWithTokenIdResponse::return_), "xsd:long"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaAnnotationTextWithTokenIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenIdResponse, 0, sizeof(tns__submitMediaAnnotationTextWithTokenIdResponse), 0, soap_copy_tns__submitMediaAnnotationTextWithTokenIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitMediaAnnotationTextWithTokenIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaAnnotationTextWithTokenIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaAnnotationTextWithTokenIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaAnnotationTextWithTokenIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextWithTokenIdResponse * SOAP_FMAC4 soap_get_tns__submitMediaAnnotationTextWithTokenIdResponse(struct soap *soap, tns__submitMediaAnnotationTextWithTokenIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaAnnotationTextWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaAnnotationTextWithTokenIdResponse * SOAP_FMAC2 soap_instantiate_tns__submitMediaAnnotationTextWithTokenIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaAnnotationTextWithTokenIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenIdResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAnnotationTextWithTokenIdResponse);
		if (size)
			*size = sizeof(tns__submitMediaAnnotationTextWithTokenIdResponse);
		((tns__submitMediaAnnotationTextWithTokenIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAnnotationTextWithTokenIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaAnnotationTextWithTokenIdResponse);
		for (int i = 0; i < n; i++)
			((tns__submitMediaAnnotationTextWithTokenIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaAnnotationTextWithTokenIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaAnnotationTextWithTokenIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaAnnotationTextWithTokenIdResponse %p -> %p\n", q, p));
	*(tns__submitMediaAnnotationTextWithTokenIdResponse*)p = *(tns__submitMediaAnnotationTextWithTokenIdResponse*)q;
}

void tns__submitMediaAnnotationTextWithTokenId::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__submitMediaAnnotationTextWithTokenId::arg0 = NULL;
	soap_default_LONG64(soap, &this->tns__submitMediaAnnotationTextWithTokenId::arg1);
	soap_default_int(soap, &this->tns__submitMediaAnnotationTextWithTokenId::arg2);
	soap_default_LONG64(soap, &this->tns__submitMediaAnnotationTextWithTokenId::arg3);
	this->tns__submitMediaAnnotationTextWithTokenId::userName = NULL;
	this->tns__submitMediaAnnotationTextWithTokenId::password = NULL;
	/* transient soap skipped */
}

void tns__submitMediaAnnotationTextWithTokenId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAnnotationTextWithTokenId::arg0);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAnnotationTextWithTokenId::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAnnotationTextWithTokenId::password);
	/* transient soap skipped */
}

int tns__submitMediaAnnotationTextWithTokenId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaAnnotationTextWithTokenId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaAnnotationTextWithTokenId(struct soap *soap, const char *tag, int id, const tns__submitMediaAnnotationTextWithTokenId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenId), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->tns__submitMediaAnnotationTextWithTokenId::arg0), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "arg1", -1, &(a->tns__submitMediaAnnotationTextWithTokenId::arg1), ""))
		return soap->error;
	if (soap_out_int(soap, "arg2", -1, &(a->tns__submitMediaAnnotationTextWithTokenId::arg2), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "arg3", -1, &(a->tns__submitMediaAnnotationTextWithTokenId::arg3), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__submitMediaAnnotationTextWithTokenId::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__submitMediaAnnotationTextWithTokenId::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaAnnotationTextWithTokenId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaAnnotationTextWithTokenId(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextWithTokenId * SOAP_FMAC4 soap_in_tns__submitMediaAnnotationTextWithTokenId(struct soap *soap, const char *tag, tns__submitMediaAnnotationTextWithTokenId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaAnnotationTextWithTokenId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenId, sizeof(tns__submitMediaAnnotationTextWithTokenId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaAnnotationTextWithTokenId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	size_t soap_flag_arg31 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->tns__submitMediaAnnotationTextWithTokenId::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "arg1", &(a->tns__submitMediaAnnotationTextWithTokenId::arg1), "xsd:long"))
				{	soap_flag_arg11--;
					continue;
				}
			if (soap_flag_arg21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "arg2", &(a->tns__submitMediaAnnotationTextWithTokenId::arg2), "xsd:int"))
				{	soap_flag_arg21--;
					continue;
				}
			if (soap_flag_arg31 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "arg3", &(a->tns__submitMediaAnnotationTextWithTokenId::arg3), "xsd:long"))
				{	soap_flag_arg31--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__submitMediaAnnotationTextWithTokenId::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__submitMediaAnnotationTextWithTokenId::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaAnnotationTextWithTokenId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenId, 0, sizeof(tns__submitMediaAnnotationTextWithTokenId), 0, soap_copy_tns__submitMediaAnnotationTextWithTokenId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg11 > 0 || soap_flag_arg21 > 0 || soap_flag_arg31 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitMediaAnnotationTextWithTokenId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenId);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaAnnotationTextWithTokenId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaAnnotationTextWithTokenId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaAnnotationTextWithTokenId(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextWithTokenId * SOAP_FMAC4 soap_get_tns__submitMediaAnnotationTextWithTokenId(struct soap *soap, tns__submitMediaAnnotationTextWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaAnnotationTextWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaAnnotationTextWithTokenId * SOAP_FMAC2 soap_instantiate_tns__submitMediaAnnotationTextWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaAnnotationTextWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAnnotationTextWithTokenId);
		if (size)
			*size = sizeof(tns__submitMediaAnnotationTextWithTokenId);
		((tns__submitMediaAnnotationTextWithTokenId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAnnotationTextWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaAnnotationTextWithTokenId);
		for (int i = 0; i < n; i++)
			((tns__submitMediaAnnotationTextWithTokenId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaAnnotationTextWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaAnnotationTextWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaAnnotationTextWithTokenId %p -> %p\n", q, p));
	*(tns__submitMediaAnnotationTextWithTokenId*)p = *(tns__submitMediaAnnotationTextWithTokenId*)q;
}

void tns__submitMediaAnnotationTextAndTokenDigestResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__submitMediaAnnotationTextAndTokenDigestResponse::return_);
	/* transient soap skipped */
}

void tns__submitMediaAnnotationTextAndTokenDigestResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__submitMediaAnnotationTextAndTokenDigestResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaAnnotationTextAndTokenDigestResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaAnnotationTextAndTokenDigestResponse(struct soap *soap, const char *tag, int id, const tns__submitMediaAnnotationTextAndTokenDigestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigestResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "return", -1, &(a->tns__submitMediaAnnotationTextAndTokenDigestResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaAnnotationTextAndTokenDigestResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaAnnotationTextAndTokenDigestResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextAndTokenDigestResponse * SOAP_FMAC4 soap_in_tns__submitMediaAnnotationTextAndTokenDigestResponse(struct soap *soap, const char *tag, tns__submitMediaAnnotationTextAndTokenDigestResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaAnnotationTextAndTokenDigestResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigestResponse, sizeof(tns__submitMediaAnnotationTextAndTokenDigestResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigestResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaAnnotationTextAndTokenDigestResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "return", &(a->tns__submitMediaAnnotationTextAndTokenDigestResponse::return_), "xsd:long"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaAnnotationTextAndTokenDigestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigestResponse, 0, sizeof(tns__submitMediaAnnotationTextAndTokenDigestResponse), 0, soap_copy_tns__submitMediaAnnotationTextAndTokenDigestResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitMediaAnnotationTextAndTokenDigestResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigestResponse);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaAnnotationTextAndTokenDigestResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaAnnotationTextAndTokenDigestResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaAnnotationTextAndTokenDigestResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextAndTokenDigestResponse * SOAP_FMAC4 soap_get_tns__submitMediaAnnotationTextAndTokenDigestResponse(struct soap *soap, tns__submitMediaAnnotationTextAndTokenDigestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaAnnotationTextAndTokenDigestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaAnnotationTextAndTokenDigestResponse * SOAP_FMAC2 soap_instantiate_tns__submitMediaAnnotationTextAndTokenDigestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaAnnotationTextAndTokenDigestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigestResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAnnotationTextAndTokenDigestResponse);
		if (size)
			*size = sizeof(tns__submitMediaAnnotationTextAndTokenDigestResponse);
		((tns__submitMediaAnnotationTextAndTokenDigestResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAnnotationTextAndTokenDigestResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaAnnotationTextAndTokenDigestResponse);
		for (int i = 0; i < n; i++)
			((tns__submitMediaAnnotationTextAndTokenDigestResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaAnnotationTextAndTokenDigestResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaAnnotationTextAndTokenDigestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaAnnotationTextAndTokenDigestResponse %p -> %p\n", q, p));
	*(tns__submitMediaAnnotationTextAndTokenDigestResponse*)p = *(tns__submitMediaAnnotationTextAndTokenDigestResponse*)q;
}

void tns__submitMediaAnnotationTextAndTokenDigest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__submitMediaAnnotationTextAndTokenDigest::arg0 = NULL;
	soap_default_LONG64(soap, &this->tns__submitMediaAnnotationTextAndTokenDigest::arg1);
	soap_default_int(soap, &this->tns__submitMediaAnnotationTextAndTokenDigest::arg2);
	this->tns__submitMediaAnnotationTextAndTokenDigest::arg3 = NULL;
	soap_default_int(soap, &this->tns__submitMediaAnnotationTextAndTokenDigest::arg4);
	this->tns__submitMediaAnnotationTextAndTokenDigest::userName = NULL;
	this->tns__submitMediaAnnotationTextAndTokenDigest::password = NULL;
	/* transient soap skipped */
}

void tns__submitMediaAnnotationTextAndTokenDigest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAnnotationTextAndTokenDigest::arg0);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAnnotationTextAndTokenDigest::arg3);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAnnotationTextAndTokenDigest::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAnnotationTextAndTokenDigest::password);
	/* transient soap skipped */
}

int tns__submitMediaAnnotationTextAndTokenDigest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaAnnotationTextAndTokenDigest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, const char *tag, int id, const tns__submitMediaAnnotationTextAndTokenDigest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigest), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->tns__submitMediaAnnotationTextAndTokenDigest::arg0), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "arg1", -1, &(a->tns__submitMediaAnnotationTextAndTokenDigest::arg1), ""))
		return soap->error;
	if (soap_out_int(soap, "arg2", -1, &(a->tns__submitMediaAnnotationTextAndTokenDigest::arg2), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg3", -1, &(a->tns__submitMediaAnnotationTextAndTokenDigest::arg3), ""))
		return soap->error;
	if (soap_out_int(soap, "arg4", -1, &(a->tns__submitMediaAnnotationTextAndTokenDigest::arg4), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__submitMediaAnnotationTextAndTokenDigest::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__submitMediaAnnotationTextAndTokenDigest::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaAnnotationTextAndTokenDigest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaAnnotationTextAndTokenDigest(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextAndTokenDigest * SOAP_FMAC4 soap_in_tns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, const char *tag, tns__submitMediaAnnotationTextAndTokenDigest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaAnnotationTextAndTokenDigest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigest, sizeof(tns__submitMediaAnnotationTextAndTokenDigest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaAnnotationTextAndTokenDigest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	size_t soap_flag_arg31 = 1;
	size_t soap_flag_arg41 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->tns__submitMediaAnnotationTextAndTokenDigest::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "arg1", &(a->tns__submitMediaAnnotationTextAndTokenDigest::arg1), "xsd:long"))
				{	soap_flag_arg11--;
					continue;
				}
			if (soap_flag_arg21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "arg2", &(a->tns__submitMediaAnnotationTextAndTokenDigest::arg2), "xsd:int"))
				{	soap_flag_arg21--;
					continue;
				}
			if (soap_flag_arg31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg3", &(a->tns__submitMediaAnnotationTextAndTokenDigest::arg3), "xsd:string"))
				{	soap_flag_arg31--;
					continue;
				}
			if (soap_flag_arg41 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "arg4", &(a->tns__submitMediaAnnotationTextAndTokenDigest::arg4), "xsd:int"))
				{	soap_flag_arg41--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__submitMediaAnnotationTextAndTokenDigest::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__submitMediaAnnotationTextAndTokenDigest::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaAnnotationTextAndTokenDigest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigest, 0, sizeof(tns__submitMediaAnnotationTextAndTokenDigest), 0, soap_copy_tns__submitMediaAnnotationTextAndTokenDigest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg11 > 0 || soap_flag_arg21 > 0 || soap_flag_arg41 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitMediaAnnotationTextAndTokenDigest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigest);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaAnnotationTextAndTokenDigest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaAnnotationTextAndTokenDigest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaAnnotationTextAndTokenDigest(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextAndTokenDigest * SOAP_FMAC4 soap_get_tns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, tns__submitMediaAnnotationTextAndTokenDigest *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaAnnotationTextAndTokenDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaAnnotationTextAndTokenDigest * SOAP_FMAC2 soap_instantiate_tns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaAnnotationTextAndTokenDigest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigest, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAnnotationTextAndTokenDigest);
		if (size)
			*size = sizeof(tns__submitMediaAnnotationTextAndTokenDigest);
		((tns__submitMediaAnnotationTextAndTokenDigest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAnnotationTextAndTokenDigest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaAnnotationTextAndTokenDigest);
		for (int i = 0; i < n; i++)
			((tns__submitMediaAnnotationTextAndTokenDigest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaAnnotationTextAndTokenDigest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaAnnotationTextAndTokenDigest %p -> %p\n", q, p));
	*(tns__submitMediaAnnotationTextAndTokenDigest*)p = *(tns__submitMediaAnnotationTextAndTokenDigest*)q;
}

void tns__submitMediaAnnotationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__submitMediaAnnotationResponse::return_);
	/* transient soap skipped */
}

void tns__submitMediaAnnotationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__submitMediaAnnotationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaAnnotationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaAnnotationResponse(struct soap *soap, const char *tag, int id, const tns__submitMediaAnnotationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "return", -1, &(a->tns__submitMediaAnnotationResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaAnnotationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaAnnotationResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationResponse * SOAP_FMAC4 soap_in_tns__submitMediaAnnotationResponse(struct soap *soap, const char *tag, tns__submitMediaAnnotationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaAnnotationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationResponse, sizeof(tns__submitMediaAnnotationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaAnnotationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "return", &(a->tns__submitMediaAnnotationResponse::return_), "xsd:long"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaAnnotationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationResponse, 0, sizeof(tns__submitMediaAnnotationResponse), 0, soap_copy_tns__submitMediaAnnotationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitMediaAnnotationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationResponse);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaAnnotationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaAnnotationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaAnnotationResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationResponse * SOAP_FMAC4 soap_get_tns__submitMediaAnnotationResponse(struct soap *soap, tns__submitMediaAnnotationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaAnnotationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaAnnotationResponse * SOAP_FMAC2 soap_instantiate_tns__submitMediaAnnotationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaAnnotationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAnnotationResponse);
		if (size)
			*size = sizeof(tns__submitMediaAnnotationResponse);
		((tns__submitMediaAnnotationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAnnotationResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaAnnotationResponse);
		for (int i = 0; i < n; i++)
			((tns__submitMediaAnnotationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaAnnotationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaAnnotationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaAnnotationResponse %p -> %p\n", q, p));
	*(tns__submitMediaAnnotationResponse*)p = *(tns__submitMediaAnnotationResponse*)q;
}

void tns__submitMediaAnnotation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__submitMediaAnnotation::arg0 = NULL;
	this->tns__submitMediaAnnotation::userName = NULL;
	this->tns__submitMediaAnnotation::password = NULL;
	/* transient soap skipped */
}

void tns__submitMediaAnnotation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__mediaAnnotation(soap, &this->tns__submitMediaAnnotation::arg0);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAnnotation::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAnnotation::password);
	/* transient soap skipped */
}

int tns__submitMediaAnnotation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaAnnotation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaAnnotation(struct soap *soap, const char *tag, int id, const tns__submitMediaAnnotation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotation), type))
		return soap->error;
	if (soap_out_PointerTotns__mediaAnnotation(soap, "arg0", -1, &(a->tns__submitMediaAnnotation::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__submitMediaAnnotation::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__submitMediaAnnotation::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaAnnotation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaAnnotation(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaAnnotation * SOAP_FMAC4 soap_in_tns__submitMediaAnnotation(struct soap *soap, const char *tag, tns__submitMediaAnnotation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaAnnotation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotation, sizeof(tns__submitMediaAnnotation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitMediaAnnotation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaAnnotation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__mediaAnnotation(soap, "arg0", &(a->tns__submitMediaAnnotation::arg0), "tns:mediaAnnotation"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__submitMediaAnnotation::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__submitMediaAnnotation::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaAnnotation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotation, 0, sizeof(tns__submitMediaAnnotation), 0, soap_copy_tns__submitMediaAnnotation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__submitMediaAnnotation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotation);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaAnnotation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaAnnotation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaAnnotation(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaAnnotation * SOAP_FMAC4 soap_get_tns__submitMediaAnnotation(struct soap *soap, tns__submitMediaAnnotation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaAnnotation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaAnnotation * SOAP_FMAC2 soap_instantiate_tns__submitMediaAnnotation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaAnnotation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotation, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAnnotation);
		if (size)
			*size = sizeof(tns__submitMediaAnnotation);
		((tns__submitMediaAnnotation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAnnotation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaAnnotation);
		for (int i = 0; i < n; i++)
			((tns__submitMediaAnnotation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaAnnotation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaAnnotation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaAnnotation %p -> %p\n", q, p));
	*(tns__submitMediaAnnotation*)p = *(tns__submitMediaAnnotation*)q;
}

void tns__submitMediaAliasTextWithTokenIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__submitMediaAliasTextWithTokenIdResponse::return_);
	/* transient soap skipped */
}

void tns__submitMediaAliasTextWithTokenIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__submitMediaAliasTextWithTokenIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaAliasTextWithTokenIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaAliasTextWithTokenIdResponse(struct soap *soap, const char *tag, int id, const tns__submitMediaAliasTextWithTokenIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenIdResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "return", -1, &(a->tns__submitMediaAliasTextWithTokenIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaAliasTextWithTokenIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaAliasTextWithTokenIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaAliasTextWithTokenIdResponse * SOAP_FMAC4 soap_in_tns__submitMediaAliasTextWithTokenIdResponse(struct soap *soap, const char *tag, tns__submitMediaAliasTextWithTokenIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaAliasTextWithTokenIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenIdResponse, sizeof(tns__submitMediaAliasTextWithTokenIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaAliasTextWithTokenIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "return", &(a->tns__submitMediaAliasTextWithTokenIdResponse::return_), "xsd:long"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaAliasTextWithTokenIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenIdResponse, 0, sizeof(tns__submitMediaAliasTextWithTokenIdResponse), 0, soap_copy_tns__submitMediaAliasTextWithTokenIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitMediaAliasTextWithTokenIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaAliasTextWithTokenIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaAliasTextWithTokenIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaAliasTextWithTokenIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaAliasTextWithTokenIdResponse * SOAP_FMAC4 soap_get_tns__submitMediaAliasTextWithTokenIdResponse(struct soap *soap, tns__submitMediaAliasTextWithTokenIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaAliasTextWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaAliasTextWithTokenIdResponse * SOAP_FMAC2 soap_instantiate_tns__submitMediaAliasTextWithTokenIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaAliasTextWithTokenIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenIdResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAliasTextWithTokenIdResponse);
		if (size)
			*size = sizeof(tns__submitMediaAliasTextWithTokenIdResponse);
		((tns__submitMediaAliasTextWithTokenIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAliasTextWithTokenIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaAliasTextWithTokenIdResponse);
		for (int i = 0; i < n; i++)
			((tns__submitMediaAliasTextWithTokenIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaAliasTextWithTokenIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaAliasTextWithTokenIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaAliasTextWithTokenIdResponse %p -> %p\n", q, p));
	*(tns__submitMediaAliasTextWithTokenIdResponse*)p = *(tns__submitMediaAliasTextWithTokenIdResponse*)q;
}

void tns__submitMediaAliasTextWithTokenId::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__submitMediaAliasTextWithTokenId::arg0 = NULL;
	soap_default_int(soap, &this->tns__submitMediaAliasTextWithTokenId::arg1);
	soap_default_LONG64(soap, &this->tns__submitMediaAliasTextWithTokenId::arg2);
	this->tns__submitMediaAliasTextWithTokenId::userName = NULL;
	this->tns__submitMediaAliasTextWithTokenId::password = NULL;
	/* transient soap skipped */
}

void tns__submitMediaAliasTextWithTokenId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAliasTextWithTokenId::arg0);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAliasTextWithTokenId::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAliasTextWithTokenId::password);
	/* transient soap skipped */
}

int tns__submitMediaAliasTextWithTokenId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaAliasTextWithTokenId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaAliasTextWithTokenId(struct soap *soap, const char *tag, int id, const tns__submitMediaAliasTextWithTokenId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenId), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->tns__submitMediaAliasTextWithTokenId::arg0), ""))
		return soap->error;
	if (soap_out_int(soap, "arg1", -1, &(a->tns__submitMediaAliasTextWithTokenId::arg1), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "arg2", -1, &(a->tns__submitMediaAliasTextWithTokenId::arg2), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__submitMediaAliasTextWithTokenId::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__submitMediaAliasTextWithTokenId::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaAliasTextWithTokenId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaAliasTextWithTokenId(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaAliasTextWithTokenId * SOAP_FMAC4 soap_in_tns__submitMediaAliasTextWithTokenId(struct soap *soap, const char *tag, tns__submitMediaAliasTextWithTokenId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaAliasTextWithTokenId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenId, sizeof(tns__submitMediaAliasTextWithTokenId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaAliasTextWithTokenId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->tns__submitMediaAliasTextWithTokenId::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "arg1", &(a->tns__submitMediaAliasTextWithTokenId::arg1), "xsd:int"))
				{	soap_flag_arg11--;
					continue;
				}
			if (soap_flag_arg21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "arg2", &(a->tns__submitMediaAliasTextWithTokenId::arg2), "xsd:long"))
				{	soap_flag_arg21--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__submitMediaAliasTextWithTokenId::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__submitMediaAliasTextWithTokenId::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaAliasTextWithTokenId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenId, 0, sizeof(tns__submitMediaAliasTextWithTokenId), 0, soap_copy_tns__submitMediaAliasTextWithTokenId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg11 > 0 || soap_flag_arg21 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitMediaAliasTextWithTokenId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenId);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaAliasTextWithTokenId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaAliasTextWithTokenId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaAliasTextWithTokenId(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaAliasTextWithTokenId * SOAP_FMAC4 soap_get_tns__submitMediaAliasTextWithTokenId(struct soap *soap, tns__submitMediaAliasTextWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaAliasTextWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaAliasTextWithTokenId * SOAP_FMAC2 soap_instantiate_tns__submitMediaAliasTextWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaAliasTextWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAliasTextWithTokenId);
		if (size)
			*size = sizeof(tns__submitMediaAliasTextWithTokenId);
		((tns__submitMediaAliasTextWithTokenId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAliasTextWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaAliasTextWithTokenId);
		for (int i = 0; i < n; i++)
			((tns__submitMediaAliasTextWithTokenId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaAliasTextWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaAliasTextWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaAliasTextWithTokenId %p -> %p\n", q, p));
	*(tns__submitMediaAliasTextWithTokenId*)p = *(tns__submitMediaAliasTextWithTokenId*)q;
}

void tns__submitMediaAliasTextAndTokenDigestResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__submitMediaAliasTextAndTokenDigestResponse::return_);
	/* transient soap skipped */
}

void tns__submitMediaAliasTextAndTokenDigestResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__submitMediaAliasTextAndTokenDigestResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaAliasTextAndTokenDigestResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaAliasTextAndTokenDigestResponse(struct soap *soap, const char *tag, int id, const tns__submitMediaAliasTextAndTokenDigestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigestResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "return", -1, &(a->tns__submitMediaAliasTextAndTokenDigestResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaAliasTextAndTokenDigestResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaAliasTextAndTokenDigestResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaAliasTextAndTokenDigestResponse * SOAP_FMAC4 soap_in_tns__submitMediaAliasTextAndTokenDigestResponse(struct soap *soap, const char *tag, tns__submitMediaAliasTextAndTokenDigestResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaAliasTextAndTokenDigestResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigestResponse, sizeof(tns__submitMediaAliasTextAndTokenDigestResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigestResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaAliasTextAndTokenDigestResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "return", &(a->tns__submitMediaAliasTextAndTokenDigestResponse::return_), "xsd:long"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaAliasTextAndTokenDigestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigestResponse, 0, sizeof(tns__submitMediaAliasTextAndTokenDigestResponse), 0, soap_copy_tns__submitMediaAliasTextAndTokenDigestResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitMediaAliasTextAndTokenDigestResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigestResponse);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaAliasTextAndTokenDigestResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaAliasTextAndTokenDigestResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaAliasTextAndTokenDigestResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaAliasTextAndTokenDigestResponse * SOAP_FMAC4 soap_get_tns__submitMediaAliasTextAndTokenDigestResponse(struct soap *soap, tns__submitMediaAliasTextAndTokenDigestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaAliasTextAndTokenDigestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaAliasTextAndTokenDigestResponse * SOAP_FMAC2 soap_instantiate_tns__submitMediaAliasTextAndTokenDigestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaAliasTextAndTokenDigestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigestResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAliasTextAndTokenDigestResponse);
		if (size)
			*size = sizeof(tns__submitMediaAliasTextAndTokenDigestResponse);
		((tns__submitMediaAliasTextAndTokenDigestResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAliasTextAndTokenDigestResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaAliasTextAndTokenDigestResponse);
		for (int i = 0; i < n; i++)
			((tns__submitMediaAliasTextAndTokenDigestResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaAliasTextAndTokenDigestResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaAliasTextAndTokenDigestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaAliasTextAndTokenDigestResponse %p -> %p\n", q, p));
	*(tns__submitMediaAliasTextAndTokenDigestResponse*)p = *(tns__submitMediaAliasTextAndTokenDigestResponse*)q;
}

void tns__submitMediaAliasTextAndTokenDigest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__submitMediaAliasTextAndTokenDigest::arg0 = NULL;
	soap_default_int(soap, &this->tns__submitMediaAliasTextAndTokenDigest::arg1);
	this->tns__submitMediaAliasTextAndTokenDigest::arg2 = NULL;
	soap_default_int(soap, &this->tns__submitMediaAliasTextAndTokenDigest::arg3);
	this->tns__submitMediaAliasTextAndTokenDigest::userName = NULL;
	this->tns__submitMediaAliasTextAndTokenDigest::password = NULL;
	/* transient soap skipped */
}

void tns__submitMediaAliasTextAndTokenDigest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAliasTextAndTokenDigest::arg0);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAliasTextAndTokenDigest::arg2);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAliasTextAndTokenDigest::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAliasTextAndTokenDigest::password);
	/* transient soap skipped */
}

int tns__submitMediaAliasTextAndTokenDigest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaAliasTextAndTokenDigest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaAliasTextAndTokenDigest(struct soap *soap, const char *tag, int id, const tns__submitMediaAliasTextAndTokenDigest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigest), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->tns__submitMediaAliasTextAndTokenDigest::arg0), ""))
		return soap->error;
	if (soap_out_int(soap, "arg1", -1, &(a->tns__submitMediaAliasTextAndTokenDigest::arg1), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg2", -1, &(a->tns__submitMediaAliasTextAndTokenDigest::arg2), ""))
		return soap->error;
	if (soap_out_int(soap, "arg3", -1, &(a->tns__submitMediaAliasTextAndTokenDigest::arg3), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__submitMediaAliasTextAndTokenDigest::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__submitMediaAliasTextAndTokenDigest::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaAliasTextAndTokenDigest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaAliasTextAndTokenDigest(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaAliasTextAndTokenDigest * SOAP_FMAC4 soap_in_tns__submitMediaAliasTextAndTokenDigest(struct soap *soap, const char *tag, tns__submitMediaAliasTextAndTokenDigest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaAliasTextAndTokenDigest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigest, sizeof(tns__submitMediaAliasTextAndTokenDigest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaAliasTextAndTokenDigest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	size_t soap_flag_arg31 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->tns__submitMediaAliasTextAndTokenDigest::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "arg1", &(a->tns__submitMediaAliasTextAndTokenDigest::arg1), "xsd:int"))
				{	soap_flag_arg11--;
					continue;
				}
			if (soap_flag_arg21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg2", &(a->tns__submitMediaAliasTextAndTokenDigest::arg2), "xsd:string"))
				{	soap_flag_arg21--;
					continue;
				}
			if (soap_flag_arg31 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "arg3", &(a->tns__submitMediaAliasTextAndTokenDigest::arg3), "xsd:int"))
				{	soap_flag_arg31--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__submitMediaAliasTextAndTokenDigest::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__submitMediaAliasTextAndTokenDigest::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaAliasTextAndTokenDigest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigest, 0, sizeof(tns__submitMediaAliasTextAndTokenDigest), 0, soap_copy_tns__submitMediaAliasTextAndTokenDigest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg11 > 0 || soap_flag_arg31 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitMediaAliasTextAndTokenDigest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigest);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaAliasTextAndTokenDigest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaAliasTextAndTokenDigest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaAliasTextAndTokenDigest(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaAliasTextAndTokenDigest * SOAP_FMAC4 soap_get_tns__submitMediaAliasTextAndTokenDigest(struct soap *soap, tns__submitMediaAliasTextAndTokenDigest *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaAliasTextAndTokenDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaAliasTextAndTokenDigest * SOAP_FMAC2 soap_instantiate_tns__submitMediaAliasTextAndTokenDigest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaAliasTextAndTokenDigest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigest, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAliasTextAndTokenDigest);
		if (size)
			*size = sizeof(tns__submitMediaAliasTextAndTokenDigest);
		((tns__submitMediaAliasTextAndTokenDigest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAliasTextAndTokenDigest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaAliasTextAndTokenDigest);
		for (int i = 0; i < n; i++)
			((tns__submitMediaAliasTextAndTokenDigest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaAliasTextAndTokenDigest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaAliasTextAndTokenDigest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaAliasTextAndTokenDigest %p -> %p\n", q, p));
	*(tns__submitMediaAliasTextAndTokenDigest*)p = *(tns__submitMediaAliasTextAndTokenDigest*)q;
}

void tns__submitMediaAliasResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__submitMediaAliasResponse::return_);
	/* transient soap skipped */
}

void tns__submitMediaAliasResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__submitMediaAliasResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaAliasResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaAliasResponse(struct soap *soap, const char *tag, int id, const tns__submitMediaAliasResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAliasResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "return", -1, &(a->tns__submitMediaAliasResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaAliasResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaAliasResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaAliasResponse * SOAP_FMAC4 soap_in_tns__submitMediaAliasResponse(struct soap *soap, const char *tag, tns__submitMediaAliasResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaAliasResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAliasResponse, sizeof(tns__submitMediaAliasResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitMediaAliasResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaAliasResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "return", &(a->tns__submitMediaAliasResponse::return_), "xsd:long"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaAliasResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitMediaAliasResponse, 0, sizeof(tns__submitMediaAliasResponse), 0, soap_copy_tns__submitMediaAliasResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__submitMediaAliasResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitMediaAliasResponse);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaAliasResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaAliasResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaAliasResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaAliasResponse * SOAP_FMAC4 soap_get_tns__submitMediaAliasResponse(struct soap *soap, tns__submitMediaAliasResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaAliasResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaAliasResponse * SOAP_FMAC2 soap_instantiate_tns__submitMediaAliasResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaAliasResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitMediaAliasResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAliasResponse);
		if (size)
			*size = sizeof(tns__submitMediaAliasResponse);
		((tns__submitMediaAliasResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAliasResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaAliasResponse);
		for (int i = 0; i < n; i++)
			((tns__submitMediaAliasResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaAliasResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaAliasResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaAliasResponse %p -> %p\n", q, p));
	*(tns__submitMediaAliasResponse*)p = *(tns__submitMediaAliasResponse*)q;
}

void tns__submitMediaAlias::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__submitMediaAlias::arg0 = NULL;
	this->tns__submitMediaAlias::userName = NULL;
	this->tns__submitMediaAlias::password = NULL;
	/* transient soap skipped */
}

void tns__submitMediaAlias::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__mediaAlias(soap, &this->tns__submitMediaAlias::arg0);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAlias::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__submitMediaAlias::password);
	/* transient soap skipped */
}

int tns__submitMediaAlias::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__submitMediaAlias(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__submitMediaAlias(struct soap *soap, const char *tag, int id, const tns__submitMediaAlias *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAlias), type))
		return soap->error;
	if (soap_out_PointerTotns__mediaAlias(soap, "arg0", -1, &(a->tns__submitMediaAlias::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__submitMediaAlias::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__submitMediaAlias::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__submitMediaAlias::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__submitMediaAlias(soap, tag, this, type);
}

SOAP_FMAC3 tns__submitMediaAlias * SOAP_FMAC4 soap_in_tns__submitMediaAlias(struct soap *soap, const char *tag, tns__submitMediaAlias *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__submitMediaAlias *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__submitMediaAlias, sizeof(tns__submitMediaAlias), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__submitMediaAlias)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__submitMediaAlias *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__mediaAlias(soap, "arg0", &(a->tns__submitMediaAlias::arg0), "tns:mediaAlias"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__submitMediaAlias::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__submitMediaAlias::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__submitMediaAlias *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__submitMediaAlias, 0, sizeof(tns__submitMediaAlias), 0, soap_copy_tns__submitMediaAlias);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__submitMediaAlias::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__submitMediaAlias);
	if (this->soap_out(soap, tag?tag:"tns:submitMediaAlias", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__submitMediaAlias::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__submitMediaAlias(soap, this, tag, type);
}

SOAP_FMAC3 tns__submitMediaAlias * SOAP_FMAC4 soap_get_tns__submitMediaAlias(struct soap *soap, tns__submitMediaAlias *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__submitMediaAlias(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__submitMediaAlias * SOAP_FMAC2 soap_instantiate_tns__submitMediaAlias(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__submitMediaAlias(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__submitMediaAlias, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAlias);
		if (size)
			*size = sizeof(tns__submitMediaAlias);
		((tns__submitMediaAlias*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__submitMediaAlias[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__submitMediaAlias);
		for (int i = 0; i < n; i++)
			((tns__submitMediaAlias*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__submitMediaAlias*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__submitMediaAlias(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__submitMediaAlias %p -> %p\n", q, p));
	*(tns__submitMediaAlias*)p = *(tns__submitMediaAlias*)q;
}

void tns__setUserLanguageResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__setUserLanguageResponse::return_);
	/* transient soap skipped */
}

void tns__setUserLanguageResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__setUserLanguageResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__setUserLanguageResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__setUserLanguageResponse(struct soap *soap, const char *tag, int id, const tns__setUserLanguageResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__setUserLanguageResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__setUserLanguageResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__setUserLanguageResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__setUserLanguageResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__setUserLanguageResponse * SOAP_FMAC4 soap_in_tns__setUserLanguageResponse(struct soap *soap, const char *tag, tns__setUserLanguageResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__setUserLanguageResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__setUserLanguageResponse, sizeof(tns__setUserLanguageResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__setUserLanguageResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__setUserLanguageResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__setUserLanguageResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__setUserLanguageResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__setUserLanguageResponse, 0, sizeof(tns__setUserLanguageResponse), 0, soap_copy_tns__setUserLanguageResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__setUserLanguageResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__setUserLanguageResponse);
	if (this->soap_out(soap, tag?tag:"tns:setUserLanguageResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__setUserLanguageResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__setUserLanguageResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__setUserLanguageResponse * SOAP_FMAC4 soap_get_tns__setUserLanguageResponse(struct soap *soap, tns__setUserLanguageResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__setUserLanguageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__setUserLanguageResponse * SOAP_FMAC2 soap_instantiate_tns__setUserLanguageResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__setUserLanguageResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__setUserLanguageResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__setUserLanguageResponse);
		if (size)
			*size = sizeof(tns__setUserLanguageResponse);
		((tns__setUserLanguageResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__setUserLanguageResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__setUserLanguageResponse);
		for (int i = 0; i < n; i++)
			((tns__setUserLanguageResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__setUserLanguageResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__setUserLanguageResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__setUserLanguageResponse %p -> %p\n", q, p));
	*(tns__setUserLanguageResponse*)p = *(tns__setUserLanguageResponse*)q;
}

void tns__setUserLanguage::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->tns__setUserLanguage::arg0);
	this->tns__setUserLanguage::userName = NULL;
	this->tns__setUserLanguage::password = NULL;
	/* transient soap skipped */
}

void tns__setUserLanguage::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__setUserLanguage::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__setUserLanguage::password);
	/* transient soap skipped */
}

int tns__setUserLanguage::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__setUserLanguage(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__setUserLanguage(struct soap *soap, const char *tag, int id, const tns__setUserLanguage *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__setUserLanguage), type))
		return soap->error;
	if (soap_out_int(soap, "arg0", -1, &(a->tns__setUserLanguage::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__setUserLanguage::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__setUserLanguage::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__setUserLanguage::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__setUserLanguage(soap, tag, this, type);
}

SOAP_FMAC3 tns__setUserLanguage * SOAP_FMAC4 soap_in_tns__setUserLanguage(struct soap *soap, const char *tag, tns__setUserLanguage *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__setUserLanguage *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__setUserLanguage, sizeof(tns__setUserLanguage), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__setUserLanguage)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__setUserLanguage *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "arg0", &(a->tns__setUserLanguage::arg0), "xsd:int"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__setUserLanguage::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__setUserLanguage::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__setUserLanguage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__setUserLanguage, 0, sizeof(tns__setUserLanguage), 0, soap_copy_tns__setUserLanguage);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg01 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__setUserLanguage::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__setUserLanguage);
	if (this->soap_out(soap, tag?tag:"tns:setUserLanguage", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__setUserLanguage::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__setUserLanguage(soap, this, tag, type);
}

SOAP_FMAC3 tns__setUserLanguage * SOAP_FMAC4 soap_get_tns__setUserLanguage(struct soap *soap, tns__setUserLanguage *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__setUserLanguage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__setUserLanguage * SOAP_FMAC2 soap_instantiate_tns__setUserLanguage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__setUserLanguage(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__setUserLanguage, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__setUserLanguage);
		if (size)
			*size = sizeof(tns__setUserLanguage);
		((tns__setUserLanguage*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__setUserLanguage[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__setUserLanguage);
		for (int i = 0; i < n; i++)
			((tns__setUserLanguage*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__setUserLanguage*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__setUserLanguage(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__setUserLanguage %p -> %p\n", q, p));
	*(tns__setUserLanguage*)p = *(tns__setUserLanguage*)q;
}

void tns__setUserAnonymousResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__setUserAnonymousResponse::return_);
	/* transient soap skipped */
}

void tns__setUserAnonymousResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__setUserAnonymousResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__setUserAnonymousResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__setUserAnonymousResponse(struct soap *soap, const char *tag, int id, const tns__setUserAnonymousResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__setUserAnonymousResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__setUserAnonymousResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__setUserAnonymousResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__setUserAnonymousResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__setUserAnonymousResponse * SOAP_FMAC4 soap_in_tns__setUserAnonymousResponse(struct soap *soap, const char *tag, tns__setUserAnonymousResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__setUserAnonymousResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__setUserAnonymousResponse, sizeof(tns__setUserAnonymousResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__setUserAnonymousResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__setUserAnonymousResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__setUserAnonymousResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__setUserAnonymousResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__setUserAnonymousResponse, 0, sizeof(tns__setUserAnonymousResponse), 0, soap_copy_tns__setUserAnonymousResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__setUserAnonymousResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__setUserAnonymousResponse);
	if (this->soap_out(soap, tag?tag:"tns:setUserAnonymousResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__setUserAnonymousResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__setUserAnonymousResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__setUserAnonymousResponse * SOAP_FMAC4 soap_get_tns__setUserAnonymousResponse(struct soap *soap, tns__setUserAnonymousResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__setUserAnonymousResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__setUserAnonymousResponse * SOAP_FMAC2 soap_instantiate_tns__setUserAnonymousResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__setUserAnonymousResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__setUserAnonymousResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__setUserAnonymousResponse);
		if (size)
			*size = sizeof(tns__setUserAnonymousResponse);
		((tns__setUserAnonymousResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__setUserAnonymousResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__setUserAnonymousResponse);
		for (int i = 0; i < n; i++)
			((tns__setUserAnonymousResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__setUserAnonymousResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__setUserAnonymousResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__setUserAnonymousResponse %p -> %p\n", q, p));
	*(tns__setUserAnonymousResponse*)p = *(tns__setUserAnonymousResponse*)q;
}

void tns__setUserAnonymous::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__setUserAnonymous::arg0);
	this->tns__setUserAnonymous::userName = NULL;
	this->tns__setUserAnonymous::password = NULL;
	/* transient soap skipped */
}

void tns__setUserAnonymous::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__setUserAnonymous::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__setUserAnonymous::password);
	/* transient soap skipped */
}

int tns__setUserAnonymous::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__setUserAnonymous(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__setUserAnonymous(struct soap *soap, const char *tag, int id, const tns__setUserAnonymous *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__setUserAnonymous), type))
		return soap->error;
	if (soap_out_bool(soap, "arg0", -1, &(a->tns__setUserAnonymous::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__setUserAnonymous::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__setUserAnonymous::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__setUserAnonymous::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__setUserAnonymous(soap, tag, this, type);
}

SOAP_FMAC3 tns__setUserAnonymous * SOAP_FMAC4 soap_in_tns__setUserAnonymous(struct soap *soap, const char *tag, tns__setUserAnonymous *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__setUserAnonymous *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__setUserAnonymous, sizeof(tns__setUserAnonymous), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__setUserAnonymous)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__setUserAnonymous *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "arg0", &(a->tns__setUserAnonymous::arg0), "xsd:boolean"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__setUserAnonymous::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__setUserAnonymous::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__setUserAnonymous *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__setUserAnonymous, 0, sizeof(tns__setUserAnonymous), 0, soap_copy_tns__setUserAnonymous);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg01 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__setUserAnonymous::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__setUserAnonymous);
	if (this->soap_out(soap, tag?tag:"tns:setUserAnonymous", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__setUserAnonymous::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__setUserAnonymous(soap, this, tag, type);
}

SOAP_FMAC3 tns__setUserAnonymous * SOAP_FMAC4 soap_get_tns__setUserAnonymous(struct soap *soap, tns__setUserAnonymous *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__setUserAnonymous(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__setUserAnonymous * SOAP_FMAC2 soap_instantiate_tns__setUserAnonymous(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__setUserAnonymous(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__setUserAnonymous, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__setUserAnonymous);
		if (size)
			*size = sizeof(tns__setUserAnonymous);
		((tns__setUserAnonymous*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__setUserAnonymous[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__setUserAnonymous);
		for (int i = 0; i < n; i++)
			((tns__setUserAnonymous*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__setUserAnonymous*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__setUserAnonymous(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__setUserAnonymous %p -> %p\n", q, p));
	*(tns__setUserAnonymous*)p = *(tns__setUserAnonymous*)q;
}

void tns__selectUserResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__selectUserResponse::return_ = NULL;
	/* transient soap skipped */
}

void tns__selectUserResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__user(soap, &this->tns__selectUserResponse::return_);
	/* transient soap skipped */
}

int tns__selectUserResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectUserResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectUserResponse(struct soap *soap, const char *tag, int id, const tns__selectUserResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__selectUserResponse), type))
		return soap->error;
	if (soap_out_PointerTotns__user(soap, "return", -1, &(a->tns__selectUserResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectUserResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectUserResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectUserResponse * SOAP_FMAC4 soap_in_tns__selectUserResponse(struct soap *soap, const char *tag, tns__selectUserResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectUserResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__selectUserResponse, sizeof(tns__selectUserResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__selectUserResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectUserResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__user(soap, "return", &(a->tns__selectUserResponse::return_), "tns:user"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__selectUserResponse, 0, sizeof(tns__selectUserResponse), 0, soap_copy_tns__selectUserResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__selectUserResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__selectUserResponse);
	if (this->soap_out(soap, tag?tag:"tns:selectUserResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectUserResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectUserResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectUserResponse * SOAP_FMAC4 soap_get_tns__selectUserResponse(struct soap *soap, tns__selectUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectUserResponse * SOAP_FMAC2 soap_instantiate_tns__selectUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__selectUserResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectUserResponse);
		if (size)
			*size = sizeof(tns__selectUserResponse);
		((tns__selectUserResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectUserResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectUserResponse);
		for (int i = 0; i < n; i++)
			((tns__selectUserResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectUserResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectUserResponse %p -> %p\n", q, p));
	*(tns__selectUserResponse*)p = *(tns__selectUserResponse*)q;
}

void tns__selectUser::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__selectUser::userName = NULL;
	this->tns__selectUser::password = NULL;
	/* transient soap skipped */
}

void tns__selectUser::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__selectUser::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__selectUser::password);
	/* transient soap skipped */
}

int tns__selectUser::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectUser(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectUser(struct soap *soap, const char *tag, int id, const tns__selectUser *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__selectUser), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__selectUser::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__selectUser::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectUser::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectUser(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectUser * SOAP_FMAC4 soap_in_tns__selectUser(struct soap *soap, const char *tag, tns__selectUser *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectUser *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__selectUser, sizeof(tns__selectUser), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__selectUser)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectUser *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__selectUser::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__selectUser::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__selectUser, 0, sizeof(tns__selectUser), 0, soap_copy_tns__selectUser);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__selectUser::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__selectUser);
	if (this->soap_out(soap, tag?tag:"tns:selectUser", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectUser::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectUser(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectUser * SOAP_FMAC4 soap_get_tns__selectUser(struct soap *soap, tns__selectUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectUser * SOAP_FMAC2 soap_instantiate_tns__selectUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__selectUser, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectUser);
		if (size)
			*size = sizeof(tns__selectUser);
		((tns__selectUser*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectUser[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectUser);
		for (int i = 0; i < n; i++)
			((tns__selectUser*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectUser*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectUser %p -> %p\n", q, p));
	*(tns__selectUser*)p = *(tns__selectUser*)q;
}

void tns__selectRelatedMediaAnnotationsWithTokenIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTotns__mediaAnnotation(soap, &this->tns__selectRelatedMediaAnnotationsWithTokenIdResponse::return_);
	/* transient soap skipped */
}

void tns__selectRelatedMediaAnnotationsWithTokenIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTotns__mediaAnnotation(soap, &this->tns__selectRelatedMediaAnnotationsWithTokenIdResponse::return_);
	/* transient soap skipped */
}

int tns__selectRelatedMediaAnnotationsWithTokenIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(struct soap *soap, const char *tag, int id, const tns__selectRelatedMediaAnnotationsWithTokenIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenIdResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTotns__mediaAnnotation(soap, "return", -1, &(a->tns__selectRelatedMediaAnnotationsWithTokenIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectRelatedMediaAnnotationsWithTokenIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectRelatedMediaAnnotationsWithTokenIdResponse * SOAP_FMAC4 soap_in_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(struct soap *soap, const char *tag, tns__selectRelatedMediaAnnotationsWithTokenIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectRelatedMediaAnnotationsWithTokenIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenIdResponse, sizeof(tns__selectRelatedMediaAnnotationsWithTokenIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectRelatedMediaAnnotationsWithTokenIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTotns__mediaAnnotation(soap, "return", &(a->tns__selectRelatedMediaAnnotationsWithTokenIdResponse::return_), "tns:mediaAnnotation"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectRelatedMediaAnnotationsWithTokenIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenIdResponse, 0, sizeof(tns__selectRelatedMediaAnnotationsWithTokenIdResponse), 0, soap_copy_tns__selectRelatedMediaAnnotationsWithTokenIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__selectRelatedMediaAnnotationsWithTokenIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:selectRelatedMediaAnnotationsWithTokenIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectRelatedMediaAnnotationsWithTokenIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectRelatedMediaAnnotationsWithTokenIdResponse * SOAP_FMAC4 soap_get_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(struct soap *soap, tns__selectRelatedMediaAnnotationsWithTokenIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectRelatedMediaAnnotationsWithTokenIdResponse * SOAP_FMAC2 soap_instantiate_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenIdResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectRelatedMediaAnnotationsWithTokenIdResponse);
		if (size)
			*size = sizeof(tns__selectRelatedMediaAnnotationsWithTokenIdResponse);
		((tns__selectRelatedMediaAnnotationsWithTokenIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectRelatedMediaAnnotationsWithTokenIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectRelatedMediaAnnotationsWithTokenIdResponse);
		for (int i = 0; i < n; i++)
			((tns__selectRelatedMediaAnnotationsWithTokenIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectRelatedMediaAnnotationsWithTokenIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectRelatedMediaAnnotationsWithTokenIdResponse %p -> %p\n", q, p));
	*(tns__selectRelatedMediaAnnotationsWithTokenIdResponse*)p = *(tns__selectRelatedMediaAnnotationsWithTokenIdResponse*)q;
}

void tns__selectRelatedMediaAnnotationsWithTokenId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__selectRelatedMediaAnnotationsWithTokenId::arg0);
	/* transient soap skipped */
}

void tns__selectRelatedMediaAnnotationsWithTokenId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__selectRelatedMediaAnnotationsWithTokenId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectRelatedMediaAnnotationsWithTokenId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, const char *tag, int id, const tns__selectRelatedMediaAnnotationsWithTokenId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "arg0", -1, &(a->tns__selectRelatedMediaAnnotationsWithTokenId::arg0), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectRelatedMediaAnnotationsWithTokenId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectRelatedMediaAnnotationsWithTokenId(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectRelatedMediaAnnotationsWithTokenId * SOAP_FMAC4 soap_in_tns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, const char *tag, tns__selectRelatedMediaAnnotationsWithTokenId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectRelatedMediaAnnotationsWithTokenId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenId, sizeof(tns__selectRelatedMediaAnnotationsWithTokenId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectRelatedMediaAnnotationsWithTokenId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "arg0", &(a->tns__selectRelatedMediaAnnotationsWithTokenId::arg0), "xsd:long"))
				{	soap_flag_arg01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectRelatedMediaAnnotationsWithTokenId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenId, 0, sizeof(tns__selectRelatedMediaAnnotationsWithTokenId), 0, soap_copy_tns__selectRelatedMediaAnnotationsWithTokenId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg01 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__selectRelatedMediaAnnotationsWithTokenId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenId);
	if (this->soap_out(soap, tag?tag:"tns:selectRelatedMediaAnnotationsWithTokenId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectRelatedMediaAnnotationsWithTokenId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectRelatedMediaAnnotationsWithTokenId(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectRelatedMediaAnnotationsWithTokenId * SOAP_FMAC4 soap_get_tns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, tns__selectRelatedMediaAnnotationsWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectRelatedMediaAnnotationsWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectRelatedMediaAnnotationsWithTokenId * SOAP_FMAC2 soap_instantiate_tns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectRelatedMediaAnnotationsWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectRelatedMediaAnnotationsWithTokenId);
		if (size)
			*size = sizeof(tns__selectRelatedMediaAnnotationsWithTokenId);
		((tns__selectRelatedMediaAnnotationsWithTokenId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectRelatedMediaAnnotationsWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectRelatedMediaAnnotationsWithTokenId);
		for (int i = 0; i < n; i++)
			((tns__selectRelatedMediaAnnotationsWithTokenId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectRelatedMediaAnnotationsWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectRelatedMediaAnnotationsWithTokenId %p -> %p\n", q, p));
	*(tns__selectRelatedMediaAnnotationsWithTokenId*)p = *(tns__selectRelatedMediaAnnotationsWithTokenId*)q;
}

void tns__selectMediaTokenWithIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__selectMediaTokenWithIdResponse::return_ = NULL;
	/* transient soap skipped */
}

void tns__selectMediaTokenWithIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__mediaToken(soap, &this->tns__selectMediaTokenWithIdResponse::return_);
	/* transient soap skipped */
}

int tns__selectMediaTokenWithIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectMediaTokenWithIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectMediaTokenWithIdResponse(struct soap *soap, const char *tag, int id, const tns__selectMediaTokenWithIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithIdResponse), type))
		return soap->error;
	if (soap_out_PointerTotns__mediaToken(soap, "return", -1, &(a->tns__selectMediaTokenWithIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectMediaTokenWithIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectMediaTokenWithIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectMediaTokenWithIdResponse * SOAP_FMAC4 soap_in_tns__selectMediaTokenWithIdResponse(struct soap *soap, const char *tag, tns__selectMediaTokenWithIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectMediaTokenWithIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithIdResponse, sizeof(tns__selectMediaTokenWithIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectMediaTokenWithIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__mediaToken(soap, "return", &(a->tns__selectMediaTokenWithIdResponse::return_), "tns:mediaToken"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectMediaTokenWithIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithIdResponse, 0, sizeof(tns__selectMediaTokenWithIdResponse), 0, soap_copy_tns__selectMediaTokenWithIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__selectMediaTokenWithIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:selectMediaTokenWithIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectMediaTokenWithIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectMediaTokenWithIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectMediaTokenWithIdResponse * SOAP_FMAC4 soap_get_tns__selectMediaTokenWithIdResponse(struct soap *soap, tns__selectMediaTokenWithIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectMediaTokenWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectMediaTokenWithIdResponse * SOAP_FMAC2 soap_instantiate_tns__selectMediaTokenWithIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectMediaTokenWithIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithIdResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaTokenWithIdResponse);
		if (size)
			*size = sizeof(tns__selectMediaTokenWithIdResponse);
		((tns__selectMediaTokenWithIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaTokenWithIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectMediaTokenWithIdResponse);
		for (int i = 0; i < n; i++)
			((tns__selectMediaTokenWithIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectMediaTokenWithIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectMediaTokenWithIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectMediaTokenWithIdResponse %p -> %p\n", q, p));
	*(tns__selectMediaTokenWithIdResponse*)p = *(tns__selectMediaTokenWithIdResponse*)q;
}

void tns__selectMediaTokenWithId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__selectMediaTokenWithId::arg0);
	/* transient soap skipped */
}

void tns__selectMediaTokenWithId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__selectMediaTokenWithId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectMediaTokenWithId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectMediaTokenWithId(struct soap *soap, const char *tag, int id, const tns__selectMediaTokenWithId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "arg0", -1, &(a->tns__selectMediaTokenWithId::arg0), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectMediaTokenWithId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectMediaTokenWithId(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectMediaTokenWithId * SOAP_FMAC4 soap_in_tns__selectMediaTokenWithId(struct soap *soap, const char *tag, tns__selectMediaTokenWithId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectMediaTokenWithId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithId, sizeof(tns__selectMediaTokenWithId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectMediaTokenWithId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "arg0", &(a->tns__selectMediaTokenWithId::arg0), "xsd:long"))
				{	soap_flag_arg01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectMediaTokenWithId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithId, 0, sizeof(tns__selectMediaTokenWithId), 0, soap_copy_tns__selectMediaTokenWithId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg01 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__selectMediaTokenWithId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithId);
	if (this->soap_out(soap, tag?tag:"tns:selectMediaTokenWithId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectMediaTokenWithId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectMediaTokenWithId(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectMediaTokenWithId * SOAP_FMAC4 soap_get_tns__selectMediaTokenWithId(struct soap *soap, tns__selectMediaTokenWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectMediaTokenWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectMediaTokenWithId * SOAP_FMAC2 soap_instantiate_tns__selectMediaTokenWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectMediaTokenWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaTokenWithId);
		if (size)
			*size = sizeof(tns__selectMediaTokenWithId);
		((tns__selectMediaTokenWithId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaTokenWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectMediaTokenWithId);
		for (int i = 0; i < n; i++)
			((tns__selectMediaTokenWithId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectMediaTokenWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectMediaTokenWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectMediaTokenWithId %p -> %p\n", q, p));
	*(tns__selectMediaTokenWithId*)p = *(tns__selectMediaTokenWithId*)q;
}

void tns__selectMediaTokenWithDigestResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__selectMediaTokenWithDigestResponse::return_ = NULL;
	/* transient soap skipped */
}

void tns__selectMediaTokenWithDigestResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__mediaToken(soap, &this->tns__selectMediaTokenWithDigestResponse::return_);
	/* transient soap skipped */
}

int tns__selectMediaTokenWithDigestResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectMediaTokenWithDigestResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectMediaTokenWithDigestResponse(struct soap *soap, const char *tag, int id, const tns__selectMediaTokenWithDigestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigestResponse), type))
		return soap->error;
	if (soap_out_PointerTotns__mediaToken(soap, "return", -1, &(a->tns__selectMediaTokenWithDigestResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectMediaTokenWithDigestResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectMediaTokenWithDigestResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectMediaTokenWithDigestResponse * SOAP_FMAC4 soap_in_tns__selectMediaTokenWithDigestResponse(struct soap *soap, const char *tag, tns__selectMediaTokenWithDigestResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectMediaTokenWithDigestResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigestResponse, sizeof(tns__selectMediaTokenWithDigestResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigestResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectMediaTokenWithDigestResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__mediaToken(soap, "return", &(a->tns__selectMediaTokenWithDigestResponse::return_), "tns:mediaToken"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectMediaTokenWithDigestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigestResponse, 0, sizeof(tns__selectMediaTokenWithDigestResponse), 0, soap_copy_tns__selectMediaTokenWithDigestResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__selectMediaTokenWithDigestResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigestResponse);
	if (this->soap_out(soap, tag?tag:"tns:selectMediaTokenWithDigestResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectMediaTokenWithDigestResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectMediaTokenWithDigestResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectMediaTokenWithDigestResponse * SOAP_FMAC4 soap_get_tns__selectMediaTokenWithDigestResponse(struct soap *soap, tns__selectMediaTokenWithDigestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectMediaTokenWithDigestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectMediaTokenWithDigestResponse * SOAP_FMAC2 soap_instantiate_tns__selectMediaTokenWithDigestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectMediaTokenWithDigestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigestResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaTokenWithDigestResponse);
		if (size)
			*size = sizeof(tns__selectMediaTokenWithDigestResponse);
		((tns__selectMediaTokenWithDigestResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaTokenWithDigestResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectMediaTokenWithDigestResponse);
		for (int i = 0; i < n; i++)
			((tns__selectMediaTokenWithDigestResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectMediaTokenWithDigestResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectMediaTokenWithDigestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectMediaTokenWithDigestResponse %p -> %p\n", q, p));
	*(tns__selectMediaTokenWithDigestResponse*)p = *(tns__selectMediaTokenWithDigestResponse*)q;
}

void tns__selectMediaTokenWithDigest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__selectMediaTokenWithDigest::arg0 = NULL;
	soap_default_int(soap, &this->tns__selectMediaTokenWithDigest::arg1);
	/* transient soap skipped */
}

void tns__selectMediaTokenWithDigest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__selectMediaTokenWithDigest::arg0);
	/* transient soap skipped */
}

int tns__selectMediaTokenWithDigest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectMediaTokenWithDigest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectMediaTokenWithDigest(struct soap *soap, const char *tag, int id, const tns__selectMediaTokenWithDigest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigest), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->tns__selectMediaTokenWithDigest::arg0), ""))
		return soap->error;
	if (soap_out_int(soap, "arg1", -1, &(a->tns__selectMediaTokenWithDigest::arg1), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectMediaTokenWithDigest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectMediaTokenWithDigest(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectMediaTokenWithDigest * SOAP_FMAC4 soap_in_tns__selectMediaTokenWithDigest(struct soap *soap, const char *tag, tns__selectMediaTokenWithDigest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectMediaTokenWithDigest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigest, sizeof(tns__selectMediaTokenWithDigest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectMediaTokenWithDigest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->tns__selectMediaTokenWithDigest::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "arg1", &(a->tns__selectMediaTokenWithDigest::arg1), "xsd:int"))
				{	soap_flag_arg11--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectMediaTokenWithDigest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigest, 0, sizeof(tns__selectMediaTokenWithDigest), 0, soap_copy_tns__selectMediaTokenWithDigest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg11 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__selectMediaTokenWithDigest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigest);
	if (this->soap_out(soap, tag?tag:"tns:selectMediaTokenWithDigest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectMediaTokenWithDigest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectMediaTokenWithDigest(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectMediaTokenWithDigest * SOAP_FMAC4 soap_get_tns__selectMediaTokenWithDigest(struct soap *soap, tns__selectMediaTokenWithDigest *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectMediaTokenWithDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectMediaTokenWithDigest * SOAP_FMAC2 soap_instantiate_tns__selectMediaTokenWithDigest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectMediaTokenWithDigest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigest, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaTokenWithDigest);
		if (size)
			*size = sizeof(tns__selectMediaTokenWithDigest);
		((tns__selectMediaTokenWithDigest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaTokenWithDigest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectMediaTokenWithDigest);
		for (int i = 0; i < n; i++)
			((tns__selectMediaTokenWithDigest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectMediaTokenWithDigest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectMediaTokenWithDigest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectMediaTokenWithDigest %p -> %p\n", q, p));
	*(tns__selectMediaTokenWithDigest*)p = *(tns__selectMediaTokenWithDigest*)q;
}

void tns__selectMediaAnnotationsWithTokenIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTotns__mediaAnnotation(soap, &this->tns__selectMediaAnnotationsWithTokenIdResponse::return_);
	/* transient soap skipped */
}

void tns__selectMediaAnnotationsWithTokenIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTotns__mediaAnnotation(soap, &this->tns__selectMediaAnnotationsWithTokenIdResponse::return_);
	/* transient soap skipped */
}

int tns__selectMediaAnnotationsWithTokenIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectMediaAnnotationsWithTokenIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectMediaAnnotationsWithTokenIdResponse(struct soap *soap, const char *tag, int id, const tns__selectMediaAnnotationsWithTokenIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenIdResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTotns__mediaAnnotation(soap, "return", -1, &(a->tns__selectMediaAnnotationsWithTokenIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectMediaAnnotationsWithTokenIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectMediaAnnotationsWithTokenIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectMediaAnnotationsWithTokenIdResponse * SOAP_FMAC4 soap_in_tns__selectMediaAnnotationsWithTokenIdResponse(struct soap *soap, const char *tag, tns__selectMediaAnnotationsWithTokenIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectMediaAnnotationsWithTokenIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenIdResponse, sizeof(tns__selectMediaAnnotationsWithTokenIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectMediaAnnotationsWithTokenIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTotns__mediaAnnotation(soap, "return", &(a->tns__selectMediaAnnotationsWithTokenIdResponse::return_), "tns:mediaAnnotation"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectMediaAnnotationsWithTokenIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenIdResponse, 0, sizeof(tns__selectMediaAnnotationsWithTokenIdResponse), 0, soap_copy_tns__selectMediaAnnotationsWithTokenIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__selectMediaAnnotationsWithTokenIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:selectMediaAnnotationsWithTokenIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectMediaAnnotationsWithTokenIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectMediaAnnotationsWithTokenIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectMediaAnnotationsWithTokenIdResponse * SOAP_FMAC4 soap_get_tns__selectMediaAnnotationsWithTokenIdResponse(struct soap *soap, tns__selectMediaAnnotationsWithTokenIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectMediaAnnotationsWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectMediaAnnotationsWithTokenIdResponse * SOAP_FMAC2 soap_instantiate_tns__selectMediaAnnotationsWithTokenIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectMediaAnnotationsWithTokenIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenIdResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaAnnotationsWithTokenIdResponse);
		if (size)
			*size = sizeof(tns__selectMediaAnnotationsWithTokenIdResponse);
		((tns__selectMediaAnnotationsWithTokenIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaAnnotationsWithTokenIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectMediaAnnotationsWithTokenIdResponse);
		for (int i = 0; i < n; i++)
			((tns__selectMediaAnnotationsWithTokenIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectMediaAnnotationsWithTokenIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectMediaAnnotationsWithTokenIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectMediaAnnotationsWithTokenIdResponse %p -> %p\n", q, p));
	*(tns__selectMediaAnnotationsWithTokenIdResponse*)p = *(tns__selectMediaAnnotationsWithTokenIdResponse*)q;
}

void tns__selectMediaAnnotationsWithTokenId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__selectMediaAnnotationsWithTokenId::arg0);
	/* transient soap skipped */
}

void tns__selectMediaAnnotationsWithTokenId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__selectMediaAnnotationsWithTokenId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectMediaAnnotationsWithTokenId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectMediaAnnotationsWithTokenId(struct soap *soap, const char *tag, int id, const tns__selectMediaAnnotationsWithTokenId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "arg0", -1, &(a->tns__selectMediaAnnotationsWithTokenId::arg0), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectMediaAnnotationsWithTokenId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectMediaAnnotationsWithTokenId(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectMediaAnnotationsWithTokenId * SOAP_FMAC4 soap_in_tns__selectMediaAnnotationsWithTokenId(struct soap *soap, const char *tag, tns__selectMediaAnnotationsWithTokenId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectMediaAnnotationsWithTokenId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenId, sizeof(tns__selectMediaAnnotationsWithTokenId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectMediaAnnotationsWithTokenId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "arg0", &(a->tns__selectMediaAnnotationsWithTokenId::arg0), "xsd:long"))
				{	soap_flag_arg01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectMediaAnnotationsWithTokenId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenId, 0, sizeof(tns__selectMediaAnnotationsWithTokenId), 0, soap_copy_tns__selectMediaAnnotationsWithTokenId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg01 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__selectMediaAnnotationsWithTokenId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenId);
	if (this->soap_out(soap, tag?tag:"tns:selectMediaAnnotationsWithTokenId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectMediaAnnotationsWithTokenId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectMediaAnnotationsWithTokenId(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectMediaAnnotationsWithTokenId * SOAP_FMAC4 soap_get_tns__selectMediaAnnotationsWithTokenId(struct soap *soap, tns__selectMediaAnnotationsWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectMediaAnnotationsWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectMediaAnnotationsWithTokenId * SOAP_FMAC2 soap_instantiate_tns__selectMediaAnnotationsWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectMediaAnnotationsWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaAnnotationsWithTokenId);
		if (size)
			*size = sizeof(tns__selectMediaAnnotationsWithTokenId);
		((tns__selectMediaAnnotationsWithTokenId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaAnnotationsWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectMediaAnnotationsWithTokenId);
		for (int i = 0; i < n; i++)
			((tns__selectMediaAnnotationsWithTokenId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectMediaAnnotationsWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectMediaAnnotationsWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectMediaAnnotationsWithTokenId %p -> %p\n", q, p));
	*(tns__selectMediaAnnotationsWithTokenId*)p = *(tns__selectMediaAnnotationsWithTokenId*)q;
}

void tns__selectMediaAliasesWithTokenIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTotns__mediaAlias(soap, &this->tns__selectMediaAliasesWithTokenIdResponse::return_);
	/* transient soap skipped */
}

void tns__selectMediaAliasesWithTokenIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTotns__mediaAlias(soap, &this->tns__selectMediaAliasesWithTokenIdResponse::return_);
	/* transient soap skipped */
}

int tns__selectMediaAliasesWithTokenIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectMediaAliasesWithTokenIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectMediaAliasesWithTokenIdResponse(struct soap *soap, const char *tag, int id, const tns__selectMediaAliasesWithTokenIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenIdResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTotns__mediaAlias(soap, "return", -1, &(a->tns__selectMediaAliasesWithTokenIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectMediaAliasesWithTokenIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectMediaAliasesWithTokenIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectMediaAliasesWithTokenIdResponse * SOAP_FMAC4 soap_in_tns__selectMediaAliasesWithTokenIdResponse(struct soap *soap, const char *tag, tns__selectMediaAliasesWithTokenIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectMediaAliasesWithTokenIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenIdResponse, sizeof(tns__selectMediaAliasesWithTokenIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectMediaAliasesWithTokenIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTotns__mediaAlias(soap, "return", &(a->tns__selectMediaAliasesWithTokenIdResponse::return_), "tns:mediaAlias"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectMediaAliasesWithTokenIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenIdResponse, 0, sizeof(tns__selectMediaAliasesWithTokenIdResponse), 0, soap_copy_tns__selectMediaAliasesWithTokenIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__selectMediaAliasesWithTokenIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:selectMediaAliasesWithTokenIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectMediaAliasesWithTokenIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectMediaAliasesWithTokenIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectMediaAliasesWithTokenIdResponse * SOAP_FMAC4 soap_get_tns__selectMediaAliasesWithTokenIdResponse(struct soap *soap, tns__selectMediaAliasesWithTokenIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectMediaAliasesWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectMediaAliasesWithTokenIdResponse * SOAP_FMAC2 soap_instantiate_tns__selectMediaAliasesWithTokenIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectMediaAliasesWithTokenIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenIdResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaAliasesWithTokenIdResponse);
		if (size)
			*size = sizeof(tns__selectMediaAliasesWithTokenIdResponse);
		((tns__selectMediaAliasesWithTokenIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaAliasesWithTokenIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectMediaAliasesWithTokenIdResponse);
		for (int i = 0; i < n; i++)
			((tns__selectMediaAliasesWithTokenIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectMediaAliasesWithTokenIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectMediaAliasesWithTokenIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectMediaAliasesWithTokenIdResponse %p -> %p\n", q, p));
	*(tns__selectMediaAliasesWithTokenIdResponse*)p = *(tns__selectMediaAliasesWithTokenIdResponse*)q;
}

void tns__selectMediaAliasesWithTokenId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__selectMediaAliasesWithTokenId::arg0);
	/* transient soap skipped */
}

void tns__selectMediaAliasesWithTokenId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__selectMediaAliasesWithTokenId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__selectMediaAliasesWithTokenId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__selectMediaAliasesWithTokenId(struct soap *soap, const char *tag, int id, const tns__selectMediaAliasesWithTokenId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "arg0", -1, &(a->tns__selectMediaAliasesWithTokenId::arg0), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__selectMediaAliasesWithTokenId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__selectMediaAliasesWithTokenId(soap, tag, this, type);
}

SOAP_FMAC3 tns__selectMediaAliasesWithTokenId * SOAP_FMAC4 soap_in_tns__selectMediaAliasesWithTokenId(struct soap *soap, const char *tag, tns__selectMediaAliasesWithTokenId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__selectMediaAliasesWithTokenId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenId, sizeof(tns__selectMediaAliasesWithTokenId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__selectMediaAliasesWithTokenId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "arg0", &(a->tns__selectMediaAliasesWithTokenId::arg0), "xsd:long"))
				{	soap_flag_arg01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__selectMediaAliasesWithTokenId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenId, 0, sizeof(tns__selectMediaAliasesWithTokenId), 0, soap_copy_tns__selectMediaAliasesWithTokenId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg01 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__selectMediaAliasesWithTokenId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenId);
	if (this->soap_out(soap, tag?tag:"tns:selectMediaAliasesWithTokenId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__selectMediaAliasesWithTokenId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__selectMediaAliasesWithTokenId(soap, this, tag, type);
}

SOAP_FMAC3 tns__selectMediaAliasesWithTokenId * SOAP_FMAC4 soap_get_tns__selectMediaAliasesWithTokenId(struct soap *soap, tns__selectMediaAliasesWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__selectMediaAliasesWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__selectMediaAliasesWithTokenId * SOAP_FMAC2 soap_instantiate_tns__selectMediaAliasesWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__selectMediaAliasesWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaAliasesWithTokenId);
		if (size)
			*size = sizeof(tns__selectMediaAliasesWithTokenId);
		((tns__selectMediaAliasesWithTokenId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__selectMediaAliasesWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__selectMediaAliasesWithTokenId);
		for (int i = 0; i < n; i++)
			((tns__selectMediaAliasesWithTokenId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__selectMediaAliasesWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__selectMediaAliasesWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__selectMediaAliasesWithTokenId %p -> %p\n", q, p));
	*(tns__selectMediaAliasesWithTokenId*)p = *(tns__selectMediaAliasesWithTokenId*)q;
}

void tns__isConnectedResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__isConnectedResponse::return_);
	/* transient soap skipped */
}

void tns__isConnectedResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__isConnectedResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__isConnectedResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__isConnectedResponse(struct soap *soap, const char *tag, int id, const tns__isConnectedResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__isConnectedResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__isConnectedResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__isConnectedResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__isConnectedResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__isConnectedResponse * SOAP_FMAC4 soap_in_tns__isConnectedResponse(struct soap *soap, const char *tag, tns__isConnectedResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__isConnectedResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__isConnectedResponse, sizeof(tns__isConnectedResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__isConnectedResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__isConnectedResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__isConnectedResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__isConnectedResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__isConnectedResponse, 0, sizeof(tns__isConnectedResponse), 0, soap_copy_tns__isConnectedResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__isConnectedResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__isConnectedResponse);
	if (this->soap_out(soap, tag?tag:"tns:isConnectedResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__isConnectedResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__isConnectedResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__isConnectedResponse * SOAP_FMAC4 soap_get_tns__isConnectedResponse(struct soap *soap, tns__isConnectedResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__isConnectedResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__isConnectedResponse * SOAP_FMAC2 soap_instantiate_tns__isConnectedResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__isConnectedResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__isConnectedResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__isConnectedResponse);
		if (size)
			*size = sizeof(tns__isConnectedResponse);
		((tns__isConnectedResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__isConnectedResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__isConnectedResponse);
		for (int i = 0; i < n; i++)
			((tns__isConnectedResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__isConnectedResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__isConnectedResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__isConnectedResponse %p -> %p\n", q, p));
	*(tns__isConnectedResponse*)p = *(tns__isConnectedResponse*)q;
}

void tns__isConnected::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void tns__isConnected::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__isConnected::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__isConnected(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__isConnected(struct soap *soap, const char *tag, int id, const tns__isConnected *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__isConnected), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__isConnected::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__isConnected(soap, tag, this, type);
}

SOAP_FMAC3 tns__isConnected * SOAP_FMAC4 soap_in_tns__isConnected(struct soap *soap, const char *tag, tns__isConnected *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__isConnected *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__isConnected, sizeof(tns__isConnected), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__isConnected)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__isConnected *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__isConnected *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__isConnected, 0, sizeof(tns__isConnected), 0, soap_copy_tns__isConnected);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__isConnected::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__isConnected);
	if (this->soap_out(soap, tag?tag:"tns:isConnected", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__isConnected::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__isConnected(soap, this, tag, type);
}

SOAP_FMAC3 tns__isConnected * SOAP_FMAC4 soap_get_tns__isConnected(struct soap *soap, tns__isConnected *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__isConnected(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__isConnected * SOAP_FMAC2 soap_instantiate_tns__isConnected(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__isConnected(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__isConnected, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__isConnected);
		if (size)
			*size = sizeof(tns__isConnected);
		((tns__isConnected*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__isConnected[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__isConnected);
		for (int i = 0; i < n; i++)
			((tns__isConnected*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__isConnected*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__isConnected(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__isConnected %p -> %p\n", q, p));
	*(tns__isConnected*)p = *(tns__isConnected*)q;
}

void tns__isClientUpdatedResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__isClientUpdatedResponse::return_);
	/* transient soap skipped */
}

void tns__isClientUpdatedResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__isClientUpdatedResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__isClientUpdatedResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__isClientUpdatedResponse(struct soap *soap, const char *tag, int id, const tns__isClientUpdatedResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__isClientUpdatedResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__isClientUpdatedResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__isClientUpdatedResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__isClientUpdatedResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__isClientUpdatedResponse * SOAP_FMAC4 soap_in_tns__isClientUpdatedResponse(struct soap *soap, const char *tag, tns__isClientUpdatedResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__isClientUpdatedResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__isClientUpdatedResponse, sizeof(tns__isClientUpdatedResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__isClientUpdatedResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__isClientUpdatedResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__isClientUpdatedResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__isClientUpdatedResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__isClientUpdatedResponse, 0, sizeof(tns__isClientUpdatedResponse), 0, soap_copy_tns__isClientUpdatedResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__isClientUpdatedResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__isClientUpdatedResponse);
	if (this->soap_out(soap, tag?tag:"tns:isClientUpdatedResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__isClientUpdatedResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__isClientUpdatedResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__isClientUpdatedResponse * SOAP_FMAC4 soap_get_tns__isClientUpdatedResponse(struct soap *soap, tns__isClientUpdatedResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__isClientUpdatedResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__isClientUpdatedResponse * SOAP_FMAC2 soap_instantiate_tns__isClientUpdatedResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__isClientUpdatedResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__isClientUpdatedResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__isClientUpdatedResponse);
		if (size)
			*size = sizeof(tns__isClientUpdatedResponse);
		((tns__isClientUpdatedResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__isClientUpdatedResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__isClientUpdatedResponse);
		for (int i = 0; i < n; i++)
			((tns__isClientUpdatedResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__isClientUpdatedResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__isClientUpdatedResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__isClientUpdatedResponse %p -> %p\n", q, p));
	*(tns__isClientUpdatedResponse*)p = *(tns__isClientUpdatedResponse*)q;
}

void tns__isClientUpdated::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__isClientUpdated::arg0 = NULL;
	/* transient soap skipped */
}

void tns__isClientUpdated::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__isClientUpdated::arg0);
	/* transient soap skipped */
}

int tns__isClientUpdated::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__isClientUpdated(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__isClientUpdated(struct soap *soap, const char *tag, int id, const tns__isClientUpdated *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__isClientUpdated), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->tns__isClientUpdated::arg0), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__isClientUpdated::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__isClientUpdated(soap, tag, this, type);
}

SOAP_FMAC3 tns__isClientUpdated * SOAP_FMAC4 soap_in_tns__isClientUpdated(struct soap *soap, const char *tag, tns__isClientUpdated *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__isClientUpdated *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__isClientUpdated, sizeof(tns__isClientUpdated), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__isClientUpdated)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__isClientUpdated *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->tns__isClientUpdated::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__isClientUpdated *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__isClientUpdated, 0, sizeof(tns__isClientUpdated), 0, soap_copy_tns__isClientUpdated);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__isClientUpdated::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__isClientUpdated);
	if (this->soap_out(soap, tag?tag:"tns:isClientUpdated", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__isClientUpdated::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__isClientUpdated(soap, this, tag, type);
}

SOAP_FMAC3 tns__isClientUpdated * SOAP_FMAC4 soap_get_tns__isClientUpdated(struct soap *soap, tns__isClientUpdated *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__isClientUpdated(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__isClientUpdated * SOAP_FMAC2 soap_instantiate_tns__isClientUpdated(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__isClientUpdated(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__isClientUpdated, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__isClientUpdated);
		if (size)
			*size = sizeof(tns__isClientUpdated);
		((tns__isClientUpdated*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__isClientUpdated[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__isClientUpdated);
		for (int i = 0; i < n; i++)
			((tns__isClientUpdated*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__isClientUpdated*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__isClientUpdated(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__isClientUpdated %p -> %p\n", q, p));
	*(tns__isClientUpdated*)p = *(tns__isClientUpdated*)q;
}

void tns__curseMediaTokenWithIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__curseMediaTokenWithIdResponse::return_);
	/* transient soap skipped */
}

void tns__curseMediaTokenWithIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__curseMediaTokenWithIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__curseMediaTokenWithIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__curseMediaTokenWithIdResponse(struct soap *soap, const char *tag, int id, const tns__curseMediaTokenWithIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__curseMediaTokenWithIdResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__curseMediaTokenWithIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__curseMediaTokenWithIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__curseMediaTokenWithIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__curseMediaTokenWithIdResponse * SOAP_FMAC4 soap_in_tns__curseMediaTokenWithIdResponse(struct soap *soap, const char *tag, tns__curseMediaTokenWithIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__curseMediaTokenWithIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__curseMediaTokenWithIdResponse, sizeof(tns__curseMediaTokenWithIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__curseMediaTokenWithIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__curseMediaTokenWithIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__curseMediaTokenWithIdResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__curseMediaTokenWithIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__curseMediaTokenWithIdResponse, 0, sizeof(tns__curseMediaTokenWithIdResponse), 0, soap_copy_tns__curseMediaTokenWithIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__curseMediaTokenWithIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__curseMediaTokenWithIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:curseMediaTokenWithIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__curseMediaTokenWithIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__curseMediaTokenWithIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__curseMediaTokenWithIdResponse * SOAP_FMAC4 soap_get_tns__curseMediaTokenWithIdResponse(struct soap *soap, tns__curseMediaTokenWithIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__curseMediaTokenWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__curseMediaTokenWithIdResponse * SOAP_FMAC2 soap_instantiate_tns__curseMediaTokenWithIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__curseMediaTokenWithIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__curseMediaTokenWithIdResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__curseMediaTokenWithIdResponse);
		if (size)
			*size = sizeof(tns__curseMediaTokenWithIdResponse);
		((tns__curseMediaTokenWithIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__curseMediaTokenWithIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__curseMediaTokenWithIdResponse);
		for (int i = 0; i < n; i++)
			((tns__curseMediaTokenWithIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__curseMediaTokenWithIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__curseMediaTokenWithIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__curseMediaTokenWithIdResponse %p -> %p\n", q, p));
	*(tns__curseMediaTokenWithIdResponse*)p = *(tns__curseMediaTokenWithIdResponse*)q;
}

void tns__curseMediaTokenWithId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__curseMediaTokenWithId::arg0);
	this->tns__curseMediaTokenWithId::userName = NULL;
	this->tns__curseMediaTokenWithId::password = NULL;
	/* transient soap skipped */
}

void tns__curseMediaTokenWithId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__curseMediaTokenWithId::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__curseMediaTokenWithId::password);
	/* transient soap skipped */
}

int tns__curseMediaTokenWithId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__curseMediaTokenWithId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__curseMediaTokenWithId(struct soap *soap, const char *tag, int id, const tns__curseMediaTokenWithId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__curseMediaTokenWithId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "arg0", -1, &(a->tns__curseMediaTokenWithId::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__curseMediaTokenWithId::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__curseMediaTokenWithId::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__curseMediaTokenWithId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__curseMediaTokenWithId(soap, tag, this, type);
}

SOAP_FMAC3 tns__curseMediaTokenWithId * SOAP_FMAC4 soap_in_tns__curseMediaTokenWithId(struct soap *soap, const char *tag, tns__curseMediaTokenWithId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__curseMediaTokenWithId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__curseMediaTokenWithId, sizeof(tns__curseMediaTokenWithId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__curseMediaTokenWithId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__curseMediaTokenWithId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "arg0", &(a->tns__curseMediaTokenWithId::arg0), "xsd:long"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__curseMediaTokenWithId::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__curseMediaTokenWithId::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__curseMediaTokenWithId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__curseMediaTokenWithId, 0, sizeof(tns__curseMediaTokenWithId), 0, soap_copy_tns__curseMediaTokenWithId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg01 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__curseMediaTokenWithId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__curseMediaTokenWithId);
	if (this->soap_out(soap, tag?tag:"tns:curseMediaTokenWithId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__curseMediaTokenWithId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__curseMediaTokenWithId(soap, this, tag, type);
}

SOAP_FMAC3 tns__curseMediaTokenWithId * SOAP_FMAC4 soap_get_tns__curseMediaTokenWithId(struct soap *soap, tns__curseMediaTokenWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__curseMediaTokenWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__curseMediaTokenWithId * SOAP_FMAC2 soap_instantiate_tns__curseMediaTokenWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__curseMediaTokenWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__curseMediaTokenWithId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__curseMediaTokenWithId);
		if (size)
			*size = sizeof(tns__curseMediaTokenWithId);
		((tns__curseMediaTokenWithId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__curseMediaTokenWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__curseMediaTokenWithId);
		for (int i = 0; i < n; i++)
			((tns__curseMediaTokenWithId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__curseMediaTokenWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__curseMediaTokenWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__curseMediaTokenWithId %p -> %p\n", q, p));
	*(tns__curseMediaTokenWithId*)p = *(tns__curseMediaTokenWithId*)q;
}

void tns__curseMediaAnnotationWithIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__curseMediaAnnotationWithIdResponse::return_);
	/* transient soap skipped */
}

void tns__curseMediaAnnotationWithIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__curseMediaAnnotationWithIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__curseMediaAnnotationWithIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__curseMediaAnnotationWithIdResponse(struct soap *soap, const char *tag, int id, const tns__curseMediaAnnotationWithIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__curseMediaAnnotationWithIdResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__curseMediaAnnotationWithIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__curseMediaAnnotationWithIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__curseMediaAnnotationWithIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__curseMediaAnnotationWithIdResponse * SOAP_FMAC4 soap_in_tns__curseMediaAnnotationWithIdResponse(struct soap *soap, const char *tag, tns__curseMediaAnnotationWithIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__curseMediaAnnotationWithIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__curseMediaAnnotationWithIdResponse, sizeof(tns__curseMediaAnnotationWithIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__curseMediaAnnotationWithIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__curseMediaAnnotationWithIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__curseMediaAnnotationWithIdResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__curseMediaAnnotationWithIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__curseMediaAnnotationWithIdResponse, 0, sizeof(tns__curseMediaAnnotationWithIdResponse), 0, soap_copy_tns__curseMediaAnnotationWithIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__curseMediaAnnotationWithIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__curseMediaAnnotationWithIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:curseMediaAnnotationWithIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__curseMediaAnnotationWithIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__curseMediaAnnotationWithIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__curseMediaAnnotationWithIdResponse * SOAP_FMAC4 soap_get_tns__curseMediaAnnotationWithIdResponse(struct soap *soap, tns__curseMediaAnnotationWithIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__curseMediaAnnotationWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__curseMediaAnnotationWithIdResponse * SOAP_FMAC2 soap_instantiate_tns__curseMediaAnnotationWithIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__curseMediaAnnotationWithIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__curseMediaAnnotationWithIdResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__curseMediaAnnotationWithIdResponse);
		if (size)
			*size = sizeof(tns__curseMediaAnnotationWithIdResponse);
		((tns__curseMediaAnnotationWithIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__curseMediaAnnotationWithIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__curseMediaAnnotationWithIdResponse);
		for (int i = 0; i < n; i++)
			((tns__curseMediaAnnotationWithIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__curseMediaAnnotationWithIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__curseMediaAnnotationWithIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__curseMediaAnnotationWithIdResponse %p -> %p\n", q, p));
	*(tns__curseMediaAnnotationWithIdResponse*)p = *(tns__curseMediaAnnotationWithIdResponse*)q;
}

void tns__curseMediaAnnotationWithId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__curseMediaAnnotationWithId::arg0);
	this->tns__curseMediaAnnotationWithId::userName = NULL;
	this->tns__curseMediaAnnotationWithId::password = NULL;
	/* transient soap skipped */
}

void tns__curseMediaAnnotationWithId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__curseMediaAnnotationWithId::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__curseMediaAnnotationWithId::password);
	/* transient soap skipped */
}

int tns__curseMediaAnnotationWithId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__curseMediaAnnotationWithId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__curseMediaAnnotationWithId(struct soap *soap, const char *tag, int id, const tns__curseMediaAnnotationWithId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__curseMediaAnnotationWithId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "arg0", -1, &(a->tns__curseMediaAnnotationWithId::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__curseMediaAnnotationWithId::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__curseMediaAnnotationWithId::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__curseMediaAnnotationWithId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__curseMediaAnnotationWithId(soap, tag, this, type);
}

SOAP_FMAC3 tns__curseMediaAnnotationWithId * SOAP_FMAC4 soap_in_tns__curseMediaAnnotationWithId(struct soap *soap, const char *tag, tns__curseMediaAnnotationWithId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__curseMediaAnnotationWithId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__curseMediaAnnotationWithId, sizeof(tns__curseMediaAnnotationWithId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__curseMediaAnnotationWithId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__curseMediaAnnotationWithId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "arg0", &(a->tns__curseMediaAnnotationWithId::arg0), "xsd:long"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__curseMediaAnnotationWithId::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__curseMediaAnnotationWithId::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__curseMediaAnnotationWithId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__curseMediaAnnotationWithId, 0, sizeof(tns__curseMediaAnnotationWithId), 0, soap_copy_tns__curseMediaAnnotationWithId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg01 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__curseMediaAnnotationWithId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__curseMediaAnnotationWithId);
	if (this->soap_out(soap, tag?tag:"tns:curseMediaAnnotationWithId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__curseMediaAnnotationWithId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__curseMediaAnnotationWithId(soap, this, tag, type);
}

SOAP_FMAC3 tns__curseMediaAnnotationWithId * SOAP_FMAC4 soap_get_tns__curseMediaAnnotationWithId(struct soap *soap, tns__curseMediaAnnotationWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__curseMediaAnnotationWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__curseMediaAnnotationWithId * SOAP_FMAC2 soap_instantiate_tns__curseMediaAnnotationWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__curseMediaAnnotationWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__curseMediaAnnotationWithId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__curseMediaAnnotationWithId);
		if (size)
			*size = sizeof(tns__curseMediaAnnotationWithId);
		((tns__curseMediaAnnotationWithId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__curseMediaAnnotationWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__curseMediaAnnotationWithId);
		for (int i = 0; i < n; i++)
			((tns__curseMediaAnnotationWithId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__curseMediaAnnotationWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__curseMediaAnnotationWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__curseMediaAnnotationWithId %p -> %p\n", q, p));
	*(tns__curseMediaAnnotationWithId*)p = *(tns__curseMediaAnnotationWithId*)q;
}

void tns__curseMediaAliasWithIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__curseMediaAliasWithIdResponse::return_);
	/* transient soap skipped */
}

void tns__curseMediaAliasWithIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__curseMediaAliasWithIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__curseMediaAliasWithIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__curseMediaAliasWithIdResponse(struct soap *soap, const char *tag, int id, const tns__curseMediaAliasWithIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__curseMediaAliasWithIdResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__curseMediaAliasWithIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__curseMediaAliasWithIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__curseMediaAliasWithIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__curseMediaAliasWithIdResponse * SOAP_FMAC4 soap_in_tns__curseMediaAliasWithIdResponse(struct soap *soap, const char *tag, tns__curseMediaAliasWithIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__curseMediaAliasWithIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__curseMediaAliasWithIdResponse, sizeof(tns__curseMediaAliasWithIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__curseMediaAliasWithIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__curseMediaAliasWithIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__curseMediaAliasWithIdResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__curseMediaAliasWithIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__curseMediaAliasWithIdResponse, 0, sizeof(tns__curseMediaAliasWithIdResponse), 0, soap_copy_tns__curseMediaAliasWithIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__curseMediaAliasWithIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__curseMediaAliasWithIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:curseMediaAliasWithIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__curseMediaAliasWithIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__curseMediaAliasWithIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__curseMediaAliasWithIdResponse * SOAP_FMAC4 soap_get_tns__curseMediaAliasWithIdResponse(struct soap *soap, tns__curseMediaAliasWithIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__curseMediaAliasWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__curseMediaAliasWithIdResponse * SOAP_FMAC2 soap_instantiate_tns__curseMediaAliasWithIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__curseMediaAliasWithIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__curseMediaAliasWithIdResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__curseMediaAliasWithIdResponse);
		if (size)
			*size = sizeof(tns__curseMediaAliasWithIdResponse);
		((tns__curseMediaAliasWithIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__curseMediaAliasWithIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__curseMediaAliasWithIdResponse);
		for (int i = 0; i < n; i++)
			((tns__curseMediaAliasWithIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__curseMediaAliasWithIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__curseMediaAliasWithIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__curseMediaAliasWithIdResponse %p -> %p\n", q, p));
	*(tns__curseMediaAliasWithIdResponse*)p = *(tns__curseMediaAliasWithIdResponse*)q;
}

void tns__curseMediaAliasWithId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__curseMediaAliasWithId::arg0);
	this->tns__curseMediaAliasWithId::userName = NULL;
	this->tns__curseMediaAliasWithId::password = NULL;
	/* transient soap skipped */
}

void tns__curseMediaAliasWithId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__curseMediaAliasWithId::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__curseMediaAliasWithId::password);
	/* transient soap skipped */
}

int tns__curseMediaAliasWithId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__curseMediaAliasWithId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__curseMediaAliasWithId(struct soap *soap, const char *tag, int id, const tns__curseMediaAliasWithId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__curseMediaAliasWithId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "arg0", -1, &(a->tns__curseMediaAliasWithId::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__curseMediaAliasWithId::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__curseMediaAliasWithId::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__curseMediaAliasWithId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__curseMediaAliasWithId(soap, tag, this, type);
}

SOAP_FMAC3 tns__curseMediaAliasWithId * SOAP_FMAC4 soap_in_tns__curseMediaAliasWithId(struct soap *soap, const char *tag, tns__curseMediaAliasWithId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__curseMediaAliasWithId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__curseMediaAliasWithId, sizeof(tns__curseMediaAliasWithId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__curseMediaAliasWithId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__curseMediaAliasWithId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "arg0", &(a->tns__curseMediaAliasWithId::arg0), "xsd:long"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__curseMediaAliasWithId::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__curseMediaAliasWithId::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__curseMediaAliasWithId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__curseMediaAliasWithId, 0, sizeof(tns__curseMediaAliasWithId), 0, soap_copy_tns__curseMediaAliasWithId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg01 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__curseMediaAliasWithId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__curseMediaAliasWithId);
	if (this->soap_out(soap, tag?tag:"tns:curseMediaAliasWithId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__curseMediaAliasWithId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__curseMediaAliasWithId(soap, this, tag, type);
}

SOAP_FMAC3 tns__curseMediaAliasWithId * SOAP_FMAC4 soap_get_tns__curseMediaAliasWithId(struct soap *soap, tns__curseMediaAliasWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__curseMediaAliasWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__curseMediaAliasWithId * SOAP_FMAC2 soap_instantiate_tns__curseMediaAliasWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__curseMediaAliasWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__curseMediaAliasWithId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__curseMediaAliasWithId);
		if (size)
			*size = sizeof(tns__curseMediaAliasWithId);
		((tns__curseMediaAliasWithId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__curseMediaAliasWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__curseMediaAliasWithId);
		for (int i = 0; i < n; i++)
			((tns__curseMediaAliasWithId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__curseMediaAliasWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__curseMediaAliasWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__curseMediaAliasWithId %p -> %p\n", q, p));
	*(tns__curseMediaAliasWithId*)p = *(tns__curseMediaAliasWithId*)q;
}

void tns__chatResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__chatResponse::return_ = NULL;
	/* transient soap skipped */
}

void tns__chatResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__chatResponse::return_);
	/* transient soap skipped */
}

int tns__chatResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__chatResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__chatResponse(struct soap *soap, const char *tag, int id, const tns__chatResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__chatResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &(a->tns__chatResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__chatResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__chatResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__chatResponse * SOAP_FMAC4 soap_in_tns__chatResponse(struct soap *soap, const char *tag, tns__chatResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__chatResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__chatResponse, sizeof(tns__chatResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__chatResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__chatResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "return", &(a->tns__chatResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__chatResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__chatResponse, 0, sizeof(tns__chatResponse), 0, soap_copy_tns__chatResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__chatResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__chatResponse);
	if (this->soap_out(soap, tag?tag:"tns:chatResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__chatResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__chatResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__chatResponse * SOAP_FMAC4 soap_get_tns__chatResponse(struct soap *soap, tns__chatResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__chatResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__chatResponse * SOAP_FMAC2 soap_instantiate_tns__chatResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__chatResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__chatResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__chatResponse);
		if (size)
			*size = sizeof(tns__chatResponse);
		((tns__chatResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__chatResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__chatResponse);
		for (int i = 0; i < n; i++)
			((tns__chatResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__chatResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__chatResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__chatResponse %p -> %p\n", q, p));
	*(tns__chatResponse*)p = *(tns__chatResponse*)q;
}

void tns__chat::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tns__chat::arg0 = NULL;
	/* transient soap skipped */
}

void tns__chat::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__chat::arg0);
	/* transient soap skipped */
}

int tns__chat::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__chat(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__chat(struct soap *soap, const char *tag, int id, const tns__chat *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__chat), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->tns__chat::arg0), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__chat::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__chat(soap, tag, this, type);
}

SOAP_FMAC3 tns__chat * SOAP_FMAC4 soap_in_tns__chat(struct soap *soap, const char *tag, tns__chat *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__chat *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__chat, sizeof(tns__chat), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__chat)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__chat *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->tns__chat::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__chat *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__chat, 0, sizeof(tns__chat), 0, soap_copy_tns__chat);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tns__chat::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__chat);
	if (this->soap_out(soap, tag?tag:"tns:chat", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__chat::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__chat(soap, this, tag, type);
}

SOAP_FMAC3 tns__chat * SOAP_FMAC4 soap_get_tns__chat(struct soap *soap, tns__chat *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__chat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__chat * SOAP_FMAC2 soap_instantiate_tns__chat(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__chat(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__chat, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__chat);
		if (size)
			*size = sizeof(tns__chat);
		((tns__chat*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__chat[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__chat);
		for (int i = 0; i < n; i++)
			((tns__chat*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__chat*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__chat(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__chat %p -> %p\n", q, p));
	*(tns__chat*)p = *(tns__chat*)q;
}

void tns__blockUserWithIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__blockUserWithIdResponse::return_);
	/* transient soap skipped */
}

void tns__blockUserWithIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__blockUserWithIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__blockUserWithIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__blockUserWithIdResponse(struct soap *soap, const char *tag, int id, const tns__blockUserWithIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__blockUserWithIdResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__blockUserWithIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__blockUserWithIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__blockUserWithIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__blockUserWithIdResponse * SOAP_FMAC4 soap_in_tns__blockUserWithIdResponse(struct soap *soap, const char *tag, tns__blockUserWithIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__blockUserWithIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__blockUserWithIdResponse, sizeof(tns__blockUserWithIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__blockUserWithIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__blockUserWithIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__blockUserWithIdResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__blockUserWithIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__blockUserWithIdResponse, 0, sizeof(tns__blockUserWithIdResponse), 0, soap_copy_tns__blockUserWithIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__blockUserWithIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__blockUserWithIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:blockUserWithIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__blockUserWithIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__blockUserWithIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__blockUserWithIdResponse * SOAP_FMAC4 soap_get_tns__blockUserWithIdResponse(struct soap *soap, tns__blockUserWithIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__blockUserWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__blockUserWithIdResponse * SOAP_FMAC2 soap_instantiate_tns__blockUserWithIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__blockUserWithIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__blockUserWithIdResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__blockUserWithIdResponse);
		if (size)
			*size = sizeof(tns__blockUserWithIdResponse);
		((tns__blockUserWithIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__blockUserWithIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__blockUserWithIdResponse);
		for (int i = 0; i < n; i++)
			((tns__blockUserWithIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__blockUserWithIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__blockUserWithIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__blockUserWithIdResponse %p -> %p\n", q, p));
	*(tns__blockUserWithIdResponse*)p = *(tns__blockUserWithIdResponse*)q;
}

void tns__blockUserWithId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__blockUserWithId::arg0);
	this->tns__blockUserWithId::userName = NULL;
	this->tns__blockUserWithId::password = NULL;
	/* transient soap skipped */
}

void tns__blockUserWithId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__blockUserWithId::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__blockUserWithId::password);
	/* transient soap skipped */
}

int tns__blockUserWithId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__blockUserWithId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__blockUserWithId(struct soap *soap, const char *tag, int id, const tns__blockUserWithId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__blockUserWithId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "arg0", -1, &(a->tns__blockUserWithId::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__blockUserWithId::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__blockUserWithId::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__blockUserWithId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__blockUserWithId(soap, tag, this, type);
}

SOAP_FMAC3 tns__blockUserWithId * SOAP_FMAC4 soap_in_tns__blockUserWithId(struct soap *soap, const char *tag, tns__blockUserWithId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__blockUserWithId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__blockUserWithId, sizeof(tns__blockUserWithId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__blockUserWithId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__blockUserWithId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "arg0", &(a->tns__blockUserWithId::arg0), "xsd:long"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__blockUserWithId::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__blockUserWithId::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__blockUserWithId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__blockUserWithId, 0, sizeof(tns__blockUserWithId), 0, soap_copy_tns__blockUserWithId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg01 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__blockUserWithId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__blockUserWithId);
	if (this->soap_out(soap, tag?tag:"tns:blockUserWithId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__blockUserWithId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__blockUserWithId(soap, this, tag, type);
}

SOAP_FMAC3 tns__blockUserWithId * SOAP_FMAC4 soap_get_tns__blockUserWithId(struct soap *soap, tns__blockUserWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__blockUserWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__blockUserWithId * SOAP_FMAC2 soap_instantiate_tns__blockUserWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__blockUserWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__blockUserWithId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__blockUserWithId);
		if (size)
			*size = sizeof(tns__blockUserWithId);
		((tns__blockUserWithId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__blockUserWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__blockUserWithId);
		for (int i = 0; i < n; i++)
			((tns__blockUserWithId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__blockUserWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__blockUserWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__blockUserWithId %p -> %p\n", q, p));
	*(tns__blockUserWithId*)p = *(tns__blockUserWithId*)q;
}

void tns__blockMediaAnnotationWithIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__blockMediaAnnotationWithIdResponse::return_);
	/* transient soap skipped */
}

void tns__blockMediaAnnotationWithIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__blockMediaAnnotationWithIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__blockMediaAnnotationWithIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__blockMediaAnnotationWithIdResponse(struct soap *soap, const char *tag, int id, const tns__blockMediaAnnotationWithIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__blockMediaAnnotationWithIdResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__blockMediaAnnotationWithIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__blockMediaAnnotationWithIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__blockMediaAnnotationWithIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__blockMediaAnnotationWithIdResponse * SOAP_FMAC4 soap_in_tns__blockMediaAnnotationWithIdResponse(struct soap *soap, const char *tag, tns__blockMediaAnnotationWithIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__blockMediaAnnotationWithIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__blockMediaAnnotationWithIdResponse, sizeof(tns__blockMediaAnnotationWithIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__blockMediaAnnotationWithIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__blockMediaAnnotationWithIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__blockMediaAnnotationWithIdResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__blockMediaAnnotationWithIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__blockMediaAnnotationWithIdResponse, 0, sizeof(tns__blockMediaAnnotationWithIdResponse), 0, soap_copy_tns__blockMediaAnnotationWithIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__blockMediaAnnotationWithIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__blockMediaAnnotationWithIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:blockMediaAnnotationWithIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__blockMediaAnnotationWithIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__blockMediaAnnotationWithIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__blockMediaAnnotationWithIdResponse * SOAP_FMAC4 soap_get_tns__blockMediaAnnotationWithIdResponse(struct soap *soap, tns__blockMediaAnnotationWithIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__blockMediaAnnotationWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__blockMediaAnnotationWithIdResponse * SOAP_FMAC2 soap_instantiate_tns__blockMediaAnnotationWithIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__blockMediaAnnotationWithIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__blockMediaAnnotationWithIdResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__blockMediaAnnotationWithIdResponse);
		if (size)
			*size = sizeof(tns__blockMediaAnnotationWithIdResponse);
		((tns__blockMediaAnnotationWithIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__blockMediaAnnotationWithIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__blockMediaAnnotationWithIdResponse);
		for (int i = 0; i < n; i++)
			((tns__blockMediaAnnotationWithIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__blockMediaAnnotationWithIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__blockMediaAnnotationWithIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__blockMediaAnnotationWithIdResponse %p -> %p\n", q, p));
	*(tns__blockMediaAnnotationWithIdResponse*)p = *(tns__blockMediaAnnotationWithIdResponse*)q;
}

void tns__blockMediaAnnotationWithId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__blockMediaAnnotationWithId::arg0);
	this->tns__blockMediaAnnotationWithId::userName = NULL;
	this->tns__blockMediaAnnotationWithId::password = NULL;
	/* transient soap skipped */
}

void tns__blockMediaAnnotationWithId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__blockMediaAnnotationWithId::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__blockMediaAnnotationWithId::password);
	/* transient soap skipped */
}

int tns__blockMediaAnnotationWithId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__blockMediaAnnotationWithId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__blockMediaAnnotationWithId(struct soap *soap, const char *tag, int id, const tns__blockMediaAnnotationWithId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__blockMediaAnnotationWithId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "arg0", -1, &(a->tns__blockMediaAnnotationWithId::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__blockMediaAnnotationWithId::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__blockMediaAnnotationWithId::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__blockMediaAnnotationWithId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__blockMediaAnnotationWithId(soap, tag, this, type);
}

SOAP_FMAC3 tns__blockMediaAnnotationWithId * SOAP_FMAC4 soap_in_tns__blockMediaAnnotationWithId(struct soap *soap, const char *tag, tns__blockMediaAnnotationWithId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__blockMediaAnnotationWithId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__blockMediaAnnotationWithId, sizeof(tns__blockMediaAnnotationWithId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__blockMediaAnnotationWithId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__blockMediaAnnotationWithId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "arg0", &(a->tns__blockMediaAnnotationWithId::arg0), "xsd:long"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__blockMediaAnnotationWithId::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__blockMediaAnnotationWithId::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__blockMediaAnnotationWithId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__blockMediaAnnotationWithId, 0, sizeof(tns__blockMediaAnnotationWithId), 0, soap_copy_tns__blockMediaAnnotationWithId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg01 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__blockMediaAnnotationWithId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__blockMediaAnnotationWithId);
	if (this->soap_out(soap, tag?tag:"tns:blockMediaAnnotationWithId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__blockMediaAnnotationWithId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__blockMediaAnnotationWithId(soap, this, tag, type);
}

SOAP_FMAC3 tns__blockMediaAnnotationWithId * SOAP_FMAC4 soap_get_tns__blockMediaAnnotationWithId(struct soap *soap, tns__blockMediaAnnotationWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__blockMediaAnnotationWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__blockMediaAnnotationWithId * SOAP_FMAC2 soap_instantiate_tns__blockMediaAnnotationWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__blockMediaAnnotationWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__blockMediaAnnotationWithId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__blockMediaAnnotationWithId);
		if (size)
			*size = sizeof(tns__blockMediaAnnotationWithId);
		((tns__blockMediaAnnotationWithId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__blockMediaAnnotationWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__blockMediaAnnotationWithId);
		for (int i = 0; i < n; i++)
			((tns__blockMediaAnnotationWithId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__blockMediaAnnotationWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__blockMediaAnnotationWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__blockMediaAnnotationWithId %p -> %p\n", q, p));
	*(tns__blockMediaAnnotationWithId*)p = *(tns__blockMediaAnnotationWithId*)q;
}

void tns__blockMediaAliasWithIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__blockMediaAliasWithIdResponse::return_);
	/* transient soap skipped */
}

void tns__blockMediaAliasWithIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__blockMediaAliasWithIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__blockMediaAliasWithIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__blockMediaAliasWithIdResponse(struct soap *soap, const char *tag, int id, const tns__blockMediaAliasWithIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__blockMediaAliasWithIdResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__blockMediaAliasWithIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__blockMediaAliasWithIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__blockMediaAliasWithIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__blockMediaAliasWithIdResponse * SOAP_FMAC4 soap_in_tns__blockMediaAliasWithIdResponse(struct soap *soap, const char *tag, tns__blockMediaAliasWithIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__blockMediaAliasWithIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__blockMediaAliasWithIdResponse, sizeof(tns__blockMediaAliasWithIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__blockMediaAliasWithIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__blockMediaAliasWithIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__blockMediaAliasWithIdResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__blockMediaAliasWithIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__blockMediaAliasWithIdResponse, 0, sizeof(tns__blockMediaAliasWithIdResponse), 0, soap_copy_tns__blockMediaAliasWithIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__blockMediaAliasWithIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__blockMediaAliasWithIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:blockMediaAliasWithIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__blockMediaAliasWithIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__blockMediaAliasWithIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__blockMediaAliasWithIdResponse * SOAP_FMAC4 soap_get_tns__blockMediaAliasWithIdResponse(struct soap *soap, tns__blockMediaAliasWithIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__blockMediaAliasWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__blockMediaAliasWithIdResponse * SOAP_FMAC2 soap_instantiate_tns__blockMediaAliasWithIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__blockMediaAliasWithIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__blockMediaAliasWithIdResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__blockMediaAliasWithIdResponse);
		if (size)
			*size = sizeof(tns__blockMediaAliasWithIdResponse);
		((tns__blockMediaAliasWithIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__blockMediaAliasWithIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__blockMediaAliasWithIdResponse);
		for (int i = 0; i < n; i++)
			((tns__blockMediaAliasWithIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__blockMediaAliasWithIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__blockMediaAliasWithIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__blockMediaAliasWithIdResponse %p -> %p\n", q, p));
	*(tns__blockMediaAliasWithIdResponse*)p = *(tns__blockMediaAliasWithIdResponse*)q;
}

void tns__blockMediaAliasWithId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__blockMediaAliasWithId::arg0);
	this->tns__blockMediaAliasWithId::userName = NULL;
	this->tns__blockMediaAliasWithId::password = NULL;
	/* transient soap skipped */
}

void tns__blockMediaAliasWithId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__blockMediaAliasWithId::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__blockMediaAliasWithId::password);
	/* transient soap skipped */
}

int tns__blockMediaAliasWithId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__blockMediaAliasWithId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__blockMediaAliasWithId(struct soap *soap, const char *tag, int id, const tns__blockMediaAliasWithId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__blockMediaAliasWithId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "arg0", -1, &(a->tns__blockMediaAliasWithId::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__blockMediaAliasWithId::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__blockMediaAliasWithId::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__blockMediaAliasWithId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__blockMediaAliasWithId(soap, tag, this, type);
}

SOAP_FMAC3 tns__blockMediaAliasWithId * SOAP_FMAC4 soap_in_tns__blockMediaAliasWithId(struct soap *soap, const char *tag, tns__blockMediaAliasWithId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__blockMediaAliasWithId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__blockMediaAliasWithId, sizeof(tns__blockMediaAliasWithId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__blockMediaAliasWithId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__blockMediaAliasWithId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "arg0", &(a->tns__blockMediaAliasWithId::arg0), "xsd:long"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__blockMediaAliasWithId::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__blockMediaAliasWithId::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__blockMediaAliasWithId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__blockMediaAliasWithId, 0, sizeof(tns__blockMediaAliasWithId), 0, soap_copy_tns__blockMediaAliasWithId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg01 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__blockMediaAliasWithId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__blockMediaAliasWithId);
	if (this->soap_out(soap, tag?tag:"tns:blockMediaAliasWithId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__blockMediaAliasWithId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__blockMediaAliasWithId(soap, this, tag, type);
}

SOAP_FMAC3 tns__blockMediaAliasWithId * SOAP_FMAC4 soap_get_tns__blockMediaAliasWithId(struct soap *soap, tns__blockMediaAliasWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__blockMediaAliasWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__blockMediaAliasWithId * SOAP_FMAC2 soap_instantiate_tns__blockMediaAliasWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__blockMediaAliasWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__blockMediaAliasWithId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__blockMediaAliasWithId);
		if (size)
			*size = sizeof(tns__blockMediaAliasWithId);
		((tns__blockMediaAliasWithId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__blockMediaAliasWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__blockMediaAliasWithId);
		for (int i = 0; i < n; i++)
			((tns__blockMediaAliasWithId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__blockMediaAliasWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__blockMediaAliasWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__blockMediaAliasWithId %p -> %p\n", q, p));
	*(tns__blockMediaAliasWithId*)p = *(tns__blockMediaAliasWithId*)q;
}

void tns__blessMediaTokenWithIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__blessMediaTokenWithIdResponse::return_);
	/* transient soap skipped */
}

void tns__blessMediaTokenWithIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__blessMediaTokenWithIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__blessMediaTokenWithIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__blessMediaTokenWithIdResponse(struct soap *soap, const char *tag, int id, const tns__blessMediaTokenWithIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__blessMediaTokenWithIdResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__blessMediaTokenWithIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__blessMediaTokenWithIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__blessMediaTokenWithIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__blessMediaTokenWithIdResponse * SOAP_FMAC4 soap_in_tns__blessMediaTokenWithIdResponse(struct soap *soap, const char *tag, tns__blessMediaTokenWithIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__blessMediaTokenWithIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__blessMediaTokenWithIdResponse, sizeof(tns__blessMediaTokenWithIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__blessMediaTokenWithIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__blessMediaTokenWithIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__blessMediaTokenWithIdResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__blessMediaTokenWithIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__blessMediaTokenWithIdResponse, 0, sizeof(tns__blessMediaTokenWithIdResponse), 0, soap_copy_tns__blessMediaTokenWithIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__blessMediaTokenWithIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__blessMediaTokenWithIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:blessMediaTokenWithIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__blessMediaTokenWithIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__blessMediaTokenWithIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__blessMediaTokenWithIdResponse * SOAP_FMAC4 soap_get_tns__blessMediaTokenWithIdResponse(struct soap *soap, tns__blessMediaTokenWithIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__blessMediaTokenWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__blessMediaTokenWithIdResponse * SOAP_FMAC2 soap_instantiate_tns__blessMediaTokenWithIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__blessMediaTokenWithIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__blessMediaTokenWithIdResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__blessMediaTokenWithIdResponse);
		if (size)
			*size = sizeof(tns__blessMediaTokenWithIdResponse);
		((tns__blessMediaTokenWithIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__blessMediaTokenWithIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__blessMediaTokenWithIdResponse);
		for (int i = 0; i < n; i++)
			((tns__blessMediaTokenWithIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__blessMediaTokenWithIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__blessMediaTokenWithIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__blessMediaTokenWithIdResponse %p -> %p\n", q, p));
	*(tns__blessMediaTokenWithIdResponse*)p = *(tns__blessMediaTokenWithIdResponse*)q;
}

void tns__blessMediaTokenWithId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__blessMediaTokenWithId::arg0);
	this->tns__blessMediaTokenWithId::userName = NULL;
	this->tns__blessMediaTokenWithId::password = NULL;
	/* transient soap skipped */
}

void tns__blessMediaTokenWithId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__blessMediaTokenWithId::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__blessMediaTokenWithId::password);
	/* transient soap skipped */
}

int tns__blessMediaTokenWithId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__blessMediaTokenWithId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__blessMediaTokenWithId(struct soap *soap, const char *tag, int id, const tns__blessMediaTokenWithId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__blessMediaTokenWithId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "arg0", -1, &(a->tns__blessMediaTokenWithId::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__blessMediaTokenWithId::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__blessMediaTokenWithId::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__blessMediaTokenWithId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__blessMediaTokenWithId(soap, tag, this, type);
}

SOAP_FMAC3 tns__blessMediaTokenWithId * SOAP_FMAC4 soap_in_tns__blessMediaTokenWithId(struct soap *soap, const char *tag, tns__blessMediaTokenWithId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__blessMediaTokenWithId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__blessMediaTokenWithId, sizeof(tns__blessMediaTokenWithId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__blessMediaTokenWithId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__blessMediaTokenWithId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "arg0", &(a->tns__blessMediaTokenWithId::arg0), "xsd:long"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__blessMediaTokenWithId::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__blessMediaTokenWithId::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__blessMediaTokenWithId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__blessMediaTokenWithId, 0, sizeof(tns__blessMediaTokenWithId), 0, soap_copy_tns__blessMediaTokenWithId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg01 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__blessMediaTokenWithId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__blessMediaTokenWithId);
	if (this->soap_out(soap, tag?tag:"tns:blessMediaTokenWithId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__blessMediaTokenWithId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__blessMediaTokenWithId(soap, this, tag, type);
}

SOAP_FMAC3 tns__blessMediaTokenWithId * SOAP_FMAC4 soap_get_tns__blessMediaTokenWithId(struct soap *soap, tns__blessMediaTokenWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__blessMediaTokenWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__blessMediaTokenWithId * SOAP_FMAC2 soap_instantiate_tns__blessMediaTokenWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__blessMediaTokenWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__blessMediaTokenWithId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__blessMediaTokenWithId);
		if (size)
			*size = sizeof(tns__blessMediaTokenWithId);
		((tns__blessMediaTokenWithId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__blessMediaTokenWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__blessMediaTokenWithId);
		for (int i = 0; i < n; i++)
			((tns__blessMediaTokenWithId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__blessMediaTokenWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__blessMediaTokenWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__blessMediaTokenWithId %p -> %p\n", q, p));
	*(tns__blessMediaTokenWithId*)p = *(tns__blessMediaTokenWithId*)q;
}

void tns__blessMediaAnnotationWithIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__blessMediaAnnotationWithIdResponse::return_);
	/* transient soap skipped */
}

void tns__blessMediaAnnotationWithIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__blessMediaAnnotationWithIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__blessMediaAnnotationWithIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__blessMediaAnnotationWithIdResponse(struct soap *soap, const char *tag, int id, const tns__blessMediaAnnotationWithIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithIdResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__blessMediaAnnotationWithIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__blessMediaAnnotationWithIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__blessMediaAnnotationWithIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__blessMediaAnnotationWithIdResponse * SOAP_FMAC4 soap_in_tns__blessMediaAnnotationWithIdResponse(struct soap *soap, const char *tag, tns__blessMediaAnnotationWithIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__blessMediaAnnotationWithIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithIdResponse, sizeof(tns__blessMediaAnnotationWithIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__blessMediaAnnotationWithIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__blessMediaAnnotationWithIdResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__blessMediaAnnotationWithIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithIdResponse, 0, sizeof(tns__blessMediaAnnotationWithIdResponse), 0, soap_copy_tns__blessMediaAnnotationWithIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__blessMediaAnnotationWithIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:blessMediaAnnotationWithIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__blessMediaAnnotationWithIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__blessMediaAnnotationWithIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__blessMediaAnnotationWithIdResponse * SOAP_FMAC4 soap_get_tns__blessMediaAnnotationWithIdResponse(struct soap *soap, tns__blessMediaAnnotationWithIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__blessMediaAnnotationWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__blessMediaAnnotationWithIdResponse * SOAP_FMAC2 soap_instantiate_tns__blessMediaAnnotationWithIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__blessMediaAnnotationWithIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithIdResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__blessMediaAnnotationWithIdResponse);
		if (size)
			*size = sizeof(tns__blessMediaAnnotationWithIdResponse);
		((tns__blessMediaAnnotationWithIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__blessMediaAnnotationWithIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__blessMediaAnnotationWithIdResponse);
		for (int i = 0; i < n; i++)
			((tns__blessMediaAnnotationWithIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__blessMediaAnnotationWithIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__blessMediaAnnotationWithIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__blessMediaAnnotationWithIdResponse %p -> %p\n", q, p));
	*(tns__blessMediaAnnotationWithIdResponse*)p = *(tns__blessMediaAnnotationWithIdResponse*)q;
}

void tns__blessMediaAnnotationWithId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__blessMediaAnnotationWithId::arg0);
	this->tns__blessMediaAnnotationWithId::userName = NULL;
	this->tns__blessMediaAnnotationWithId::password = NULL;
	/* transient soap skipped */
}

void tns__blessMediaAnnotationWithId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__blessMediaAnnotationWithId::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__blessMediaAnnotationWithId::password);
	/* transient soap skipped */
}

int tns__blessMediaAnnotationWithId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__blessMediaAnnotationWithId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__blessMediaAnnotationWithId(struct soap *soap, const char *tag, int id, const tns__blessMediaAnnotationWithId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "arg0", -1, &(a->tns__blessMediaAnnotationWithId::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__blessMediaAnnotationWithId::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__blessMediaAnnotationWithId::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__blessMediaAnnotationWithId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__blessMediaAnnotationWithId(soap, tag, this, type);
}

SOAP_FMAC3 tns__blessMediaAnnotationWithId * SOAP_FMAC4 soap_in_tns__blessMediaAnnotationWithId(struct soap *soap, const char *tag, tns__blessMediaAnnotationWithId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__blessMediaAnnotationWithId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithId, sizeof(tns__blessMediaAnnotationWithId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__blessMediaAnnotationWithId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "arg0", &(a->tns__blessMediaAnnotationWithId::arg0), "xsd:long"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__blessMediaAnnotationWithId::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__blessMediaAnnotationWithId::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__blessMediaAnnotationWithId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithId, 0, sizeof(tns__blessMediaAnnotationWithId), 0, soap_copy_tns__blessMediaAnnotationWithId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg01 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__blessMediaAnnotationWithId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithId);
	if (this->soap_out(soap, tag?tag:"tns:blessMediaAnnotationWithId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__blessMediaAnnotationWithId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__blessMediaAnnotationWithId(soap, this, tag, type);
}

SOAP_FMAC3 tns__blessMediaAnnotationWithId * SOAP_FMAC4 soap_get_tns__blessMediaAnnotationWithId(struct soap *soap, tns__blessMediaAnnotationWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__blessMediaAnnotationWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__blessMediaAnnotationWithId * SOAP_FMAC2 soap_instantiate_tns__blessMediaAnnotationWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__blessMediaAnnotationWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__blessMediaAnnotationWithId);
		if (size)
			*size = sizeof(tns__blessMediaAnnotationWithId);
		((tns__blessMediaAnnotationWithId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__blessMediaAnnotationWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__blessMediaAnnotationWithId);
		for (int i = 0; i < n; i++)
			((tns__blessMediaAnnotationWithId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__blessMediaAnnotationWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__blessMediaAnnotationWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__blessMediaAnnotationWithId %p -> %p\n", q, p));
	*(tns__blessMediaAnnotationWithId*)p = *(tns__blessMediaAnnotationWithId*)q;
}

void tns__blessMediaAliasWithIdResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tns__blessMediaAliasWithIdResponse::return_);
	/* transient soap skipped */
}

void tns__blessMediaAliasWithIdResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int tns__blessMediaAliasWithIdResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__blessMediaAliasWithIdResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__blessMediaAliasWithIdResponse(struct soap *soap, const char *tag, int id, const tns__blessMediaAliasWithIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__blessMediaAliasWithIdResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->tns__blessMediaAliasWithIdResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__blessMediaAliasWithIdResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__blessMediaAliasWithIdResponse(soap, tag, this, type);
}

SOAP_FMAC3 tns__blessMediaAliasWithIdResponse * SOAP_FMAC4 soap_in_tns__blessMediaAliasWithIdResponse(struct soap *soap, const char *tag, tns__blessMediaAliasWithIdResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__blessMediaAliasWithIdResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__blessMediaAliasWithIdResponse, sizeof(tns__blessMediaAliasWithIdResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__blessMediaAliasWithIdResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__blessMediaAliasWithIdResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->tns__blessMediaAliasWithIdResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__blessMediaAliasWithIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__blessMediaAliasWithIdResponse, 0, sizeof(tns__blessMediaAliasWithIdResponse), 0, soap_copy_tns__blessMediaAliasWithIdResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__blessMediaAliasWithIdResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__blessMediaAliasWithIdResponse);
	if (this->soap_out(soap, tag?tag:"tns:blessMediaAliasWithIdResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__blessMediaAliasWithIdResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__blessMediaAliasWithIdResponse(soap, this, tag, type);
}

SOAP_FMAC3 tns__blessMediaAliasWithIdResponse * SOAP_FMAC4 soap_get_tns__blessMediaAliasWithIdResponse(struct soap *soap, tns__blessMediaAliasWithIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__blessMediaAliasWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__blessMediaAliasWithIdResponse * SOAP_FMAC2 soap_instantiate_tns__blessMediaAliasWithIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__blessMediaAliasWithIdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__blessMediaAliasWithIdResponse, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__blessMediaAliasWithIdResponse);
		if (size)
			*size = sizeof(tns__blessMediaAliasWithIdResponse);
		((tns__blessMediaAliasWithIdResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__blessMediaAliasWithIdResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__blessMediaAliasWithIdResponse);
		for (int i = 0; i < n; i++)
			((tns__blessMediaAliasWithIdResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__blessMediaAliasWithIdResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__blessMediaAliasWithIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__blessMediaAliasWithIdResponse %p -> %p\n", q, p));
	*(tns__blessMediaAliasWithIdResponse*)p = *(tns__blessMediaAliasWithIdResponse*)q;
}

void tns__blessMediaAliasWithId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->tns__blessMediaAliasWithId::arg0);
	this->tns__blessMediaAliasWithId::userName = NULL;
	this->tns__blessMediaAliasWithId::password = NULL;
	/* transient soap skipped */
}

void tns__blessMediaAliasWithId::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__blessMediaAliasWithId::userName);
	soap_serialize_PointerTostd__string(soap, &this->tns__blessMediaAliasWithId::password);
	/* transient soap skipped */
}

int tns__blessMediaAliasWithId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__blessMediaAliasWithId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__blessMediaAliasWithId(struct soap *soap, const char *tag, int id, const tns__blessMediaAliasWithId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__blessMediaAliasWithId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "arg0", -1, &(a->tns__blessMediaAliasWithId::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userName", -1, &(a->tns__blessMediaAliasWithId::userName), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__blessMediaAliasWithId::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__blessMediaAliasWithId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__blessMediaAliasWithId(soap, tag, this, type);
}

SOAP_FMAC3 tns__blessMediaAliasWithId * SOAP_FMAC4 soap_in_tns__blessMediaAliasWithId(struct soap *soap, const char *tag, tns__blessMediaAliasWithId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__blessMediaAliasWithId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__blessMediaAliasWithId, sizeof(tns__blessMediaAliasWithId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__blessMediaAliasWithId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__blessMediaAliasWithId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_userName1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "arg0", &(a->tns__blessMediaAliasWithId::arg0), "xsd:long"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_userName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userName", &(a->tns__blessMediaAliasWithId::userName), "xsd:string"))
				{	soap_flag_userName1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__blessMediaAliasWithId::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__blessMediaAliasWithId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__blessMediaAliasWithId, 0, sizeof(tns__blessMediaAliasWithId), 0, soap_copy_tns__blessMediaAliasWithId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg01 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__blessMediaAliasWithId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__blessMediaAliasWithId);
	if (this->soap_out(soap, tag?tag:"tns:blessMediaAliasWithId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__blessMediaAliasWithId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__blessMediaAliasWithId(soap, this, tag, type);
}

SOAP_FMAC3 tns__blessMediaAliasWithId * SOAP_FMAC4 soap_get_tns__blessMediaAliasWithId(struct soap *soap, tns__blessMediaAliasWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__blessMediaAliasWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__blessMediaAliasWithId * SOAP_FMAC2 soap_instantiate_tns__blessMediaAliasWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__blessMediaAliasWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__blessMediaAliasWithId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__blessMediaAliasWithId);
		if (size)
			*size = sizeof(tns__blessMediaAliasWithId);
		((tns__blessMediaAliasWithId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__blessMediaAliasWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__blessMediaAliasWithId);
		for (int i = 0; i < n; i++)
			((tns__blessMediaAliasWithId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__blessMediaAliasWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__blessMediaAliasWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__blessMediaAliasWithId %p -> %p\n", q, p));
	*(tns__blessMediaAliasWithId*)p = *(tns__blessMediaAliasWithId*)q;
}

void tns__user::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->tns__user::annotCount);
	soap_default_int(soap, &this->tns__user::blessedCount);
	soap_default_int(soap, &this->tns__user::blockedCount);
	soap_default_LONG64(soap, &this->tns__user::createTime);
	soap_default_int(soap, &this->tns__user::cursedCount);
	this->tns__user::email = NULL;
	soap_default_LONG64(soap, &this->tns__user::flags);
	soap_default_LONG64(soap, &this->tns__user::groupId);
	soap_default_LONG64(soap, &this->tns__user::id);
	soap_default_int(soap, &this->tns__user::language);
	soap_default_LONG64(soap, &this->tns__user::loginTime);
	this->tns__user::name = NULL;
	this->tns__user::nickname = NULL;
	this->tns__user::password = NULL;
	soap_default_int(soap, &this->tns__user::status);
	/* transient soap skipped */
}

void tns__user::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__user::email);
	soap_serialize_PointerTostd__string(soap, &this->tns__user::name);
	soap_serialize_PointerTostd__string(soap, &this->tns__user::nickname);
	soap_serialize_PointerTostd__string(soap, &this->tns__user::password);
	/* transient soap skipped */
}

int tns__user::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__user(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__user(struct soap *soap, const char *tag, int id, const tns__user *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__user), type))
		return soap->error;
	if (soap_out_int(soap, "annotCount", -1, &(a->tns__user::annotCount), ""))
		return soap->error;
	if (soap_out_int(soap, "blessedCount", -1, &(a->tns__user::blessedCount), ""))
		return soap->error;
	if (soap_out_int(soap, "blockedCount", -1, &(a->tns__user::blockedCount), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "createTime", -1, &(a->tns__user::createTime), ""))
		return soap->error;
	if (soap_out_int(soap, "cursedCount", -1, &(a->tns__user::cursedCount), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "email", -1, &(a->tns__user::email), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "flags", -1, &(a->tns__user::flags), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "groupId", -1, &(a->tns__user::groupId), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "id", -1, &(a->tns__user::id), ""))
		return soap->error;
	if (soap_out_int(soap, "language", -1, &(a->tns__user::language), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "loginTime", -1, &(a->tns__user::loginTime), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "name", -1, &(a->tns__user::name), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "nickname", -1, &(a->tns__user::nickname), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "password", -1, &(a->tns__user::password), ""))
		return soap->error;
	if (soap_out_int(soap, "status", -1, &(a->tns__user::status), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__user::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__user(soap, tag, this, type);
}

SOAP_FMAC3 tns__user * SOAP_FMAC4 soap_in_tns__user(struct soap *soap, const char *tag, tns__user *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__user *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__user, sizeof(tns__user), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__user)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__user *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_annotCount1 = 1;
	size_t soap_flag_blessedCount1 = 1;
	size_t soap_flag_blockedCount1 = 1;
	size_t soap_flag_createTime1 = 1;
	size_t soap_flag_cursedCount1 = 1;
	size_t soap_flag_email1 = 1;
	size_t soap_flag_flags1 = 1;
	size_t soap_flag_groupId1 = 1;
	size_t soap_flag_id1 = 1;
	size_t soap_flag_language1 = 1;
	size_t soap_flag_loginTime1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_nickname1 = 1;
	size_t soap_flag_password1 = 1;
	size_t soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_annotCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "annotCount", &(a->tns__user::annotCount), "xsd:int"))
				{	soap_flag_annotCount1--;
					continue;
				}
			if (soap_flag_blessedCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "blessedCount", &(a->tns__user::blessedCount), "xsd:int"))
				{	soap_flag_blessedCount1--;
					continue;
				}
			if (soap_flag_blockedCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "blockedCount", &(a->tns__user::blockedCount), "xsd:int"))
				{	soap_flag_blockedCount1--;
					continue;
				}
			if (soap_flag_createTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "createTime", &(a->tns__user::createTime), "xsd:long"))
				{	soap_flag_createTime1--;
					continue;
				}
			if (soap_flag_cursedCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "cursedCount", &(a->tns__user::cursedCount), "xsd:int"))
				{	soap_flag_cursedCount1--;
					continue;
				}
			if (soap_flag_email1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "email", &(a->tns__user::email), "xsd:string"))
				{	soap_flag_email1--;
					continue;
				}
			if (soap_flag_flags1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "flags", &(a->tns__user::flags), "xsd:long"))
				{	soap_flag_flags1--;
					continue;
				}
			if (soap_flag_groupId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "groupId", &(a->tns__user::groupId), "xsd:long"))
				{	soap_flag_groupId1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "id", &(a->tns__user::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_language1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "language", &(a->tns__user::language), "xsd:int"))
				{	soap_flag_language1--;
					continue;
				}
			if (soap_flag_loginTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "loginTime", &(a->tns__user::loginTime), "xsd:long"))
				{	soap_flag_loginTime1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "name", &(a->tns__user::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_nickname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "nickname", &(a->tns__user::nickname), "xsd:string"))
				{	soap_flag_nickname1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "password", &(a->tns__user::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "status", &(a->tns__user::status), "xsd:int"))
				{	soap_flag_status1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__user *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__user, 0, sizeof(tns__user), 0, soap_copy_tns__user);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_annotCount1 > 0 || soap_flag_blessedCount1 > 0 || soap_flag_blockedCount1 > 0 || soap_flag_createTime1 > 0 || soap_flag_cursedCount1 > 0 || soap_flag_flags1 > 0 || soap_flag_groupId1 > 0 || soap_flag_id1 > 0 || soap_flag_language1 > 0 || soap_flag_loginTime1 > 0 || soap_flag_status1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__user::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__user);
	if (this->soap_out(soap, tag?tag:"tns:user", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__user::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__user(soap, this, tag, type);
}

SOAP_FMAC3 tns__user * SOAP_FMAC4 soap_get_tns__user(struct soap *soap, tns__user *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__user(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__user * SOAP_FMAC2 soap_instantiate_tns__user(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__user(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__user, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__user);
		if (size)
			*size = sizeof(tns__user);
		((tns__user*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__user[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__user);
		for (int i = 0; i < n; i++)
			((tns__user*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__user*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__user(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__user %p -> %p\n", q, p));
	*(tns__user*)p = *(tns__user*)q;
}

void tns__mediaAlias::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->tns__mediaAlias::blessedCount);
	soap_default_int(soap, &this->tns__mediaAlias::blockedCount);
	soap_default_int(soap, &this->tns__mediaAlias::cursedCount);
	soap_default_LONG64(soap, &this->tns__mediaAlias::flags);
	soap_default_LONG64(soap, &this->tns__mediaAlias::id);
	soap_default_int(soap, &this->tns__mediaAlias::language);
	soap_default_LONG64(soap, &this->tns__mediaAlias::userId);
	soap_default_int(soap, &this->tns__mediaAlias::status);
	this->tns__mediaAlias::text = NULL;
	soap_default_LONG64(soap, &this->tns__mediaAlias::tokenId);
	soap_default_int(soap, &this->tns__mediaAlias::type);
	soap_default_LONG64(soap, &this->tns__mediaAlias::updateTime);
	/* transient soap skipped */
}

void tns__mediaAlias::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__mediaAlias::text);
	/* transient soap skipped */
}

int tns__mediaAlias::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__mediaAlias(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__mediaAlias(struct soap *soap, const char *tag, int id, const tns__mediaAlias *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__mediaAlias), type))
		return soap->error;
	if (soap_out_int(soap, "blessedCount", -1, &(a->tns__mediaAlias::blessedCount), ""))
		return soap->error;
	if (soap_out_int(soap, "blockedCount", -1, &(a->tns__mediaAlias::blockedCount), ""))
		return soap->error;
	if (soap_out_int(soap, "cursedCount", -1, &(a->tns__mediaAlias::cursedCount), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "flags", -1, &(a->tns__mediaAlias::flags), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "id", -1, &(a->tns__mediaAlias::id), ""))
		return soap->error;
	if (soap_out_int(soap, "language", -1, &(a->tns__mediaAlias::language), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "userId", -1, &(a->tns__mediaAlias::userId), ""))
		return soap->error;
	if (soap_out_int(soap, "status", -1, &(a->tns__mediaAlias::status), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "text", -1, &(a->tns__mediaAlias::text), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "tokenId", -1, &(a->tns__mediaAlias::tokenId), ""))
		return soap->error;
	if (soap_out_int(soap, "type", -1, &(a->tns__mediaAlias::type), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "updateTime", -1, &(a->tns__mediaAlias::updateTime), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__mediaAlias::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__mediaAlias(soap, tag, this, type);
}

SOAP_FMAC3 tns__mediaAlias * SOAP_FMAC4 soap_in_tns__mediaAlias(struct soap *soap, const char *tag, tns__mediaAlias *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__mediaAlias *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__mediaAlias, sizeof(tns__mediaAlias), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__mediaAlias)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__mediaAlias *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_blessedCount1 = 1;
	size_t soap_flag_blockedCount1 = 1;
	size_t soap_flag_cursedCount1 = 1;
	size_t soap_flag_flags1 = 1;
	size_t soap_flag_id1 = 1;
	size_t soap_flag_language1 = 1;
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_text1 = 1;
	size_t soap_flag_tokenId1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_updateTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_blessedCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "blessedCount", &(a->tns__mediaAlias::blessedCount), "xsd:int"))
				{	soap_flag_blessedCount1--;
					continue;
				}
			if (soap_flag_blockedCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "blockedCount", &(a->tns__mediaAlias::blockedCount), "xsd:int"))
				{	soap_flag_blockedCount1--;
					continue;
				}
			if (soap_flag_cursedCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "cursedCount", &(a->tns__mediaAlias::cursedCount), "xsd:int"))
				{	soap_flag_cursedCount1--;
					continue;
				}
			if (soap_flag_flags1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "flags", &(a->tns__mediaAlias::flags), "xsd:long"))
				{	soap_flag_flags1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "id", &(a->tns__mediaAlias::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_language1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "language", &(a->tns__mediaAlias::language), "xsd:int"))
				{	soap_flag_language1--;
					continue;
				}
			if (soap_flag_userId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "userId", &(a->tns__mediaAlias::userId), "xsd:long"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "status", &(a->tns__mediaAlias::status), "xsd:int"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_text1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "text", &(a->tns__mediaAlias::text), "xsd:string"))
				{	soap_flag_text1--;
					continue;
				}
			if (soap_flag_tokenId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "tokenId", &(a->tns__mediaAlias::tokenId), "xsd:long"))
				{	soap_flag_tokenId1--;
					continue;
				}
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "type", &(a->tns__mediaAlias::type), "xsd:int"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_updateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "updateTime", &(a->tns__mediaAlias::updateTime), "xsd:long"))
				{	soap_flag_updateTime1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__mediaAlias *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__mediaAlias, 0, sizeof(tns__mediaAlias), 0, soap_copy_tns__mediaAlias);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_blessedCount1 > 0 || soap_flag_blockedCount1 > 0 || soap_flag_cursedCount1 > 0 || soap_flag_flags1 > 0 || soap_flag_id1 > 0 || soap_flag_language1 > 0 || soap_flag_userId1 > 0 || soap_flag_status1 > 0 || soap_flag_tokenId1 > 0 || soap_flag_type1 > 0 || soap_flag_updateTime1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__mediaAlias::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__mediaAlias);
	if (this->soap_out(soap, tag?tag:"tns:mediaAlias", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__mediaAlias::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__mediaAlias(soap, this, tag, type);
}

SOAP_FMAC3 tns__mediaAlias * SOAP_FMAC4 soap_get_tns__mediaAlias(struct soap *soap, tns__mediaAlias *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__mediaAlias(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__mediaAlias * SOAP_FMAC2 soap_instantiate_tns__mediaAlias(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__mediaAlias(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__mediaAlias, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__mediaAlias);
		if (size)
			*size = sizeof(tns__mediaAlias);
		((tns__mediaAlias*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__mediaAlias[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__mediaAlias);
		for (int i = 0; i < n; i++)
			((tns__mediaAlias*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__mediaAlias*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__mediaAlias(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__mediaAlias %p -> %p\n", q, p));
	*(tns__mediaAlias*)p = *(tns__mediaAlias*)q;
}

void tns__mediaToken::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->tns__mediaToken::annotCount);
	soap_default_int(soap, &this->tns__mediaToken::blessedCount);
	soap_default_int(soap, &this->tns__mediaToken::blockedCount);
	soap_default_LONG64(soap, &this->tns__mediaToken::createTime);
	soap_default_int(soap, &this->tns__mediaToken::cursedCount);
	this->tns__mediaToken::digest = NULL;
	soap_default_int(soap, &this->tns__mediaToken::digestType);
	soap_default_LONG64(soap, &this->tns__mediaToken::flags);
	soap_default_LONG64(soap, &this->tns__mediaToken::id);
	soap_default_int(soap, &this->tns__mediaToken::type);
	soap_default_int(soap, &this->tns__mediaToken::status);
	soap_default_LONG64(soap, &this->tns__mediaToken::userId);
	soap_default_int(soap, &this->tns__mediaToken::visitedCount);
	/* transient soap skipped */
}

void tns__mediaToken::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__mediaToken::digest);
	/* transient soap skipped */
}

int tns__mediaToken::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__mediaToken(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__mediaToken(struct soap *soap, const char *tag, int id, const tns__mediaToken *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__mediaToken), type))
		return soap->error;
	if (soap_out_int(soap, "annotCount", -1, &(a->tns__mediaToken::annotCount), ""))
		return soap->error;
	if (soap_out_int(soap, "blessedCount", -1, &(a->tns__mediaToken::blessedCount), ""))
		return soap->error;
	if (soap_out_int(soap, "blockedCount", -1, &(a->tns__mediaToken::blockedCount), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "createTime", -1, &(a->tns__mediaToken::createTime), ""))
		return soap->error;
	if (soap_out_int(soap, "cursedCount", -1, &(a->tns__mediaToken::cursedCount), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "digest", -1, &(a->tns__mediaToken::digest), ""))
		return soap->error;
	if (soap_out_int(soap, "digestType", -1, &(a->tns__mediaToken::digestType), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "flags", -1, &(a->tns__mediaToken::flags), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "id", -1, &(a->tns__mediaToken::id), ""))
		return soap->error;
	if (soap_out_int(soap, "type", -1, &(a->tns__mediaToken::type), ""))
		return soap->error;
	if (soap_out_int(soap, "status", -1, &(a->tns__mediaToken::status), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "userId", -1, &(a->tns__mediaToken::userId), ""))
		return soap->error;
	if (soap_out_int(soap, "visitedCount", -1, &(a->tns__mediaToken::visitedCount), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__mediaToken::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__mediaToken(soap, tag, this, type);
}

SOAP_FMAC3 tns__mediaToken * SOAP_FMAC4 soap_in_tns__mediaToken(struct soap *soap, const char *tag, tns__mediaToken *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__mediaToken *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__mediaToken, sizeof(tns__mediaToken), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__mediaToken)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__mediaToken *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_annotCount1 = 1;
	size_t soap_flag_blessedCount1 = 1;
	size_t soap_flag_blockedCount1 = 1;
	size_t soap_flag_createTime1 = 1;
	size_t soap_flag_cursedCount1 = 1;
	size_t soap_flag_digest1 = 1;
	size_t soap_flag_digestType1 = 1;
	size_t soap_flag_flags1 = 1;
	size_t soap_flag_id1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_userId1 = 1;
	size_t soap_flag_visitedCount1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_annotCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "annotCount", &(a->tns__mediaToken::annotCount), "xsd:int"))
				{	soap_flag_annotCount1--;
					continue;
				}
			if (soap_flag_blessedCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "blessedCount", &(a->tns__mediaToken::blessedCount), "xsd:int"))
				{	soap_flag_blessedCount1--;
					continue;
				}
			if (soap_flag_blockedCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "blockedCount", &(a->tns__mediaToken::blockedCount), "xsd:int"))
				{	soap_flag_blockedCount1--;
					continue;
				}
			if (soap_flag_createTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "createTime", &(a->tns__mediaToken::createTime), "xsd:long"))
				{	soap_flag_createTime1--;
					continue;
				}
			if (soap_flag_cursedCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "cursedCount", &(a->tns__mediaToken::cursedCount), "xsd:int"))
				{	soap_flag_cursedCount1--;
					continue;
				}
			if (soap_flag_digest1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "digest", &(a->tns__mediaToken::digest), "xsd:string"))
				{	soap_flag_digest1--;
					continue;
				}
			if (soap_flag_digestType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "digestType", &(a->tns__mediaToken::digestType), "xsd:int"))
				{	soap_flag_digestType1--;
					continue;
				}
			if (soap_flag_flags1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "flags", &(a->tns__mediaToken::flags), "xsd:long"))
				{	soap_flag_flags1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "id", &(a->tns__mediaToken::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "type", &(a->tns__mediaToken::type), "xsd:int"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "status", &(a->tns__mediaToken::status), "xsd:int"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_userId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "userId", &(a->tns__mediaToken::userId), "xsd:long"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_visitedCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "visitedCount", &(a->tns__mediaToken::visitedCount), "xsd:int"))
				{	soap_flag_visitedCount1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__mediaToken *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__mediaToken, 0, sizeof(tns__mediaToken), 0, soap_copy_tns__mediaToken);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_annotCount1 > 0 || soap_flag_blessedCount1 > 0 || soap_flag_blockedCount1 > 0 || soap_flag_createTime1 > 0 || soap_flag_cursedCount1 > 0 || soap_flag_digestType1 > 0 || soap_flag_flags1 > 0 || soap_flag_id1 > 0 || soap_flag_type1 > 0 || soap_flag_status1 > 0 || soap_flag_userId1 > 0 || soap_flag_visitedCount1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__mediaToken::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__mediaToken);
	if (this->soap_out(soap, tag?tag:"tns:mediaToken", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__mediaToken::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__mediaToken(soap, this, tag, type);
}

SOAP_FMAC3 tns__mediaToken * SOAP_FMAC4 soap_get_tns__mediaToken(struct soap *soap, tns__mediaToken *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__mediaToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__mediaToken * SOAP_FMAC2 soap_instantiate_tns__mediaToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__mediaToken(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__mediaToken, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__mediaToken);
		if (size)
			*size = sizeof(tns__mediaToken);
		((tns__mediaToken*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__mediaToken[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__mediaToken);
		for (int i = 0; i < n; i++)
			((tns__mediaToken*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__mediaToken*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__mediaToken(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__mediaToken %p -> %p\n", q, p));
	*(tns__mediaToken*)p = *(tns__mediaToken*)q;
}

void tns__mediaAnnotation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->tns__mediaAnnotation::blessedCount);
	soap_default_int(soap, &this->tns__mediaAnnotation::blockedCount);
	soap_default_LONG64(soap, &this->tns__mediaAnnotation::createTime);
	soap_default_int(soap, &this->tns__mediaAnnotation::cursedCount);
	soap_default_LONG64(soap, &this->tns__mediaAnnotation::flags);
	soap_default_LONG64(soap, &this->tns__mediaAnnotation::id);
	soap_default_int(soap, &this->tns__mediaAnnotation::language);
	soap_default_LONG64(soap, &this->tns__mediaAnnotation::pos);
	soap_default_int(soap, &this->tns__mediaAnnotation::posType);
	soap_default_int(soap, &this->tns__mediaAnnotation::time);
	this->tns__mediaAnnotation::userAlias = NULL;
	soap_default_int(soap, &this->tns__mediaAnnotation::status);
	this->tns__mediaAnnotation::text = NULL;
	soap_default_LONG64(soap, &this->tns__mediaAnnotation::tokenId);
	soap_default_LONG64(soap, &this->tns__mediaAnnotation::updateTime);
	soap_default_LONG64(soap, &this->tns__mediaAnnotation::userId);
	/* transient soap skipped */
}

void tns__mediaAnnotation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->tns__mediaAnnotation::userAlias);
	soap_serialize_PointerTostd__string(soap, &this->tns__mediaAnnotation::text);
	/* transient soap skipped */
}

int tns__mediaAnnotation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__mediaAnnotation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tns__mediaAnnotation(struct soap *soap, const char *tag, int id, const tns__mediaAnnotation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_tns__mediaAnnotation), type))
		return soap->error;
	if (soap_out_int(soap, "blessedCount", -1, &(a->tns__mediaAnnotation::blessedCount), ""))
		return soap->error;
	if (soap_out_int(soap, "blockedCount", -1, &(a->tns__mediaAnnotation::blockedCount), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "createTime", -1, &(a->tns__mediaAnnotation::createTime), ""))
		return soap->error;
	if (soap_out_int(soap, "cursedCount", -1, &(a->tns__mediaAnnotation::cursedCount), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "flags", -1, &(a->tns__mediaAnnotation::flags), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "id", -1, &(a->tns__mediaAnnotation::id), ""))
		return soap->error;
	if (soap_out_int(soap, "language", -1, &(a->tns__mediaAnnotation::language), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "pos", -1, &(a->tns__mediaAnnotation::pos), ""))
		return soap->error;
	if (soap_out_int(soap, "posType", -1, &(a->tns__mediaAnnotation::posType), ""))
		return soap->error;
	if (soap_out_int(soap, "time", -1, &(a->tns__mediaAnnotation::time), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "userAlias", -1, &(a->tns__mediaAnnotation::userAlias), ""))
		return soap->error;
	if (soap_out_int(soap, "status", -1, &(a->tns__mediaAnnotation::status), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "text", -1, &(a->tns__mediaAnnotation::text), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "tokenId", -1, &(a->tns__mediaAnnotation::tokenId), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "updateTime", -1, &(a->tns__mediaAnnotation::updateTime), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "userId", -1, &(a->tns__mediaAnnotation::userId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *tns__mediaAnnotation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__mediaAnnotation(soap, tag, this, type);
}

SOAP_FMAC3 tns__mediaAnnotation * SOAP_FMAC4 soap_in_tns__mediaAnnotation(struct soap *soap, const char *tag, tns__mediaAnnotation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tns__mediaAnnotation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_tns__mediaAnnotation, sizeof(tns__mediaAnnotation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ServerSoap_tns__mediaAnnotation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tns__mediaAnnotation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_blessedCount1 = 1;
	size_t soap_flag_blockedCount1 = 1;
	size_t soap_flag_createTime1 = 1;
	size_t soap_flag_cursedCount1 = 1;
	size_t soap_flag_flags1 = 1;
	size_t soap_flag_id1 = 1;
	size_t soap_flag_language1 = 1;
	size_t soap_flag_pos1 = 1;
	size_t soap_flag_posType1 = 1;
	size_t soap_flag_time1 = 1;
	size_t soap_flag_userAlias1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_text1 = 1;
	size_t soap_flag_tokenId1 = 1;
	size_t soap_flag_updateTime1 = 1;
	size_t soap_flag_userId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_blessedCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "blessedCount", &(a->tns__mediaAnnotation::blessedCount), "xsd:int"))
				{	soap_flag_blessedCount1--;
					continue;
				}
			if (soap_flag_blockedCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "blockedCount", &(a->tns__mediaAnnotation::blockedCount), "xsd:int"))
				{	soap_flag_blockedCount1--;
					continue;
				}
			if (soap_flag_createTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "createTime", &(a->tns__mediaAnnotation::createTime), "xsd:long"))
				{	soap_flag_createTime1--;
					continue;
				}
			if (soap_flag_cursedCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "cursedCount", &(a->tns__mediaAnnotation::cursedCount), "xsd:int"))
				{	soap_flag_cursedCount1--;
					continue;
				}
			if (soap_flag_flags1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "flags", &(a->tns__mediaAnnotation::flags), "xsd:long"))
				{	soap_flag_flags1--;
					continue;
				}
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "id", &(a->tns__mediaAnnotation::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_language1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "language", &(a->tns__mediaAnnotation::language), "xsd:int"))
				{	soap_flag_language1--;
					continue;
				}
			if (soap_flag_pos1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "pos", &(a->tns__mediaAnnotation::pos), "xsd:long"))
				{	soap_flag_pos1--;
					continue;
				}
			if (soap_flag_posType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "posType", &(a->tns__mediaAnnotation::posType), "xsd:int"))
				{	soap_flag_posType1--;
					continue;
				}
			if (soap_flag_time1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "time", &(a->tns__mediaAnnotation::time), "xsd:int"))
				{	soap_flag_time1--;
					continue;
				}
			if (soap_flag_userAlias1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "userAlias", &(a->tns__mediaAnnotation::userAlias), "xsd:string"))
				{	soap_flag_userAlias1--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "status", &(a->tns__mediaAnnotation::status), "xsd:int"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_text1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "text", &(a->tns__mediaAnnotation::text), "xsd:string"))
				{	soap_flag_text1--;
					continue;
				}
			if (soap_flag_tokenId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "tokenId", &(a->tns__mediaAnnotation::tokenId), "xsd:long"))
				{	soap_flag_tokenId1--;
					continue;
				}
			if (soap_flag_updateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "updateTime", &(a->tns__mediaAnnotation::updateTime), "xsd:long"))
				{	soap_flag_updateTime1--;
					continue;
				}
			if (soap_flag_userId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "userId", &(a->tns__mediaAnnotation::userId), "xsd:long"))
				{	soap_flag_userId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tns__mediaAnnotation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_tns__mediaAnnotation, 0, sizeof(tns__mediaAnnotation), 0, soap_copy_tns__mediaAnnotation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_blessedCount1 > 0 || soap_flag_blockedCount1 > 0 || soap_flag_createTime1 > 0 || soap_flag_cursedCount1 > 0 || soap_flag_flags1 > 0 || soap_flag_id1 > 0 || soap_flag_language1 > 0 || soap_flag_pos1 > 0 || soap_flag_posType1 > 0 || soap_flag_time1 > 0 || soap_flag_status1 > 0 || soap_flag_tokenId1 > 0 || soap_flag_updateTime1 > 0 || soap_flag_userId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tns__mediaAnnotation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ServerSoap_tns__mediaAnnotation);
	if (this->soap_out(soap, tag?tag:"tns:mediaAnnotation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tns__mediaAnnotation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__mediaAnnotation(soap, this, tag, type);
}

SOAP_FMAC3 tns__mediaAnnotation * SOAP_FMAC4 soap_get_tns__mediaAnnotation(struct soap *soap, tns__mediaAnnotation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__mediaAnnotation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tns__mediaAnnotation * SOAP_FMAC2 soap_instantiate_tns__mediaAnnotation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__mediaAnnotation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_tns__mediaAnnotation, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tns__mediaAnnotation);
		if (size)
			*size = sizeof(tns__mediaAnnotation);
		((tns__mediaAnnotation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(tns__mediaAnnotation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(tns__mediaAnnotation);
		for (int i = 0; i < n; i++)
			((tns__mediaAnnotation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (tns__mediaAnnotation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tns__mediaAnnotation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tns__mediaAnnotation %p -> %p\n", q, p));
	*(tns__mediaAnnotation*)p = *(tns__mediaAnnotation*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_SOAP_ENV__Fault, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_SOAP_ENV__Reason, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_SOAP_ENV__Detail, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_SOAP_ENV__Code, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ServerSoap_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ServerSoap_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ServerSoap_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_SOAP_ENV__Header, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__updateMediaAnnotationTextWithId(struct soap *soap, struct __tns__updateMediaAnnotationTextWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__updateMediaAnnotationTextWithId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__updateMediaAnnotationTextWithId(struct soap *soap, const struct __tns__updateMediaAnnotationTextWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__updateMediaAnnotationTextWithId(soap, &a->tns__updateMediaAnnotationTextWithId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__updateMediaAnnotationTextWithId(struct soap *soap, const char *tag, int id, const struct __tns__updateMediaAnnotationTextWithId *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__updateMediaAnnotationTextWithId(soap, "tns:updateMediaAnnotationTextWithId", -1, &a->tns__updateMediaAnnotationTextWithId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__updateMediaAnnotationTextWithId * SOAP_FMAC4 soap_in___tns__updateMediaAnnotationTextWithId(struct soap *soap, const char *tag, struct __tns__updateMediaAnnotationTextWithId *a, const char *type)
{
	size_t soap_flag_tns__updateMediaAnnotationTextWithId_ = 1;
	short soap_flag;
	a = (struct __tns__updateMediaAnnotationTextWithId *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__updateMediaAnnotationTextWithId, sizeof(struct __tns__updateMediaAnnotationTextWithId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__updateMediaAnnotationTextWithId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__updateMediaAnnotationTextWithId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__updateMediaAnnotationTextWithId(soap, "tns:updateMediaAnnotationTextWithId", &a->tns__updateMediaAnnotationTextWithId_, "tns:updateMediaAnnotationTextWithId"))
				{	soap_flag_tns__updateMediaAnnotationTextWithId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__updateMediaAnnotationTextWithId(struct soap *soap, const struct __tns__updateMediaAnnotationTextWithId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__updateMediaAnnotationTextWithId(soap, tag?tag:"-tns:updateMediaAnnotationTextWithId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__updateMediaAnnotationTextWithId * SOAP_FMAC4 soap_get___tns__updateMediaAnnotationTextWithId(struct soap *soap, struct __tns__updateMediaAnnotationTextWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__updateMediaAnnotationTextWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__updateMediaAnnotationTextWithId * SOAP_FMAC2 soap_instantiate___tns__updateMediaAnnotationTextWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__updateMediaAnnotationTextWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__updateMediaAnnotationTextWithId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__updateMediaAnnotationTextWithId);
		if (size)
			*size = sizeof(struct __tns__updateMediaAnnotationTextWithId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__updateMediaAnnotationTextWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__updateMediaAnnotationTextWithId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__updateMediaAnnotationTextWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__updateMediaAnnotationTextWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__updateMediaAnnotationTextWithId %p -> %p\n", q, p));
	*(struct __tns__updateMediaAnnotationTextWithId*)p = *(struct __tns__updateMediaAnnotationTextWithId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__submitMediaTokenDigest(struct soap *soap, struct __tns__submitMediaTokenDigest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__submitMediaTokenDigest_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__submitMediaTokenDigest(struct soap *soap, const struct __tns__submitMediaTokenDigest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__submitMediaTokenDigest(soap, &a->tns__submitMediaTokenDigest_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__submitMediaTokenDigest(struct soap *soap, const char *tag, int id, const struct __tns__submitMediaTokenDigest *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__submitMediaTokenDigest(soap, "tns:submitMediaTokenDigest", -1, &a->tns__submitMediaTokenDigest_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaTokenDigest * SOAP_FMAC4 soap_in___tns__submitMediaTokenDigest(struct soap *soap, const char *tag, struct __tns__submitMediaTokenDigest *a, const char *type)
{
	size_t soap_flag_tns__submitMediaTokenDigest_ = 1;
	short soap_flag;
	a = (struct __tns__submitMediaTokenDigest *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__submitMediaTokenDigest, sizeof(struct __tns__submitMediaTokenDigest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__submitMediaTokenDigest(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__submitMediaTokenDigest_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__submitMediaTokenDigest(soap, "tns:submitMediaTokenDigest", &a->tns__submitMediaTokenDigest_, "tns:submitMediaTokenDigest"))
				{	soap_flag_tns__submitMediaTokenDigest_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__submitMediaTokenDigest(struct soap *soap, const struct __tns__submitMediaTokenDigest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__submitMediaTokenDigest(soap, tag?tag:"-tns:submitMediaTokenDigest", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaTokenDigest * SOAP_FMAC4 soap_get___tns__submitMediaTokenDigest(struct soap *soap, struct __tns__submitMediaTokenDigest *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__submitMediaTokenDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__submitMediaTokenDigest * SOAP_FMAC2 soap_instantiate___tns__submitMediaTokenDigest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__submitMediaTokenDigest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__submitMediaTokenDigest, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaTokenDigest);
		if (size)
			*size = sizeof(struct __tns__submitMediaTokenDigest);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaTokenDigest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__submitMediaTokenDigest);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__submitMediaTokenDigest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__submitMediaTokenDigest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__submitMediaTokenDigest %p -> %p\n", q, p));
	*(struct __tns__submitMediaTokenDigest*)p = *(struct __tns__submitMediaTokenDigest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__submitMediaToken(struct soap *soap, struct __tns__submitMediaToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__submitMediaToken_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__submitMediaToken(struct soap *soap, const struct __tns__submitMediaToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__submitMediaToken(soap, &a->tns__submitMediaToken_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__submitMediaToken(struct soap *soap, const char *tag, int id, const struct __tns__submitMediaToken *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__submitMediaToken(soap, "tns:submitMediaToken", -1, &a->tns__submitMediaToken_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaToken * SOAP_FMAC4 soap_in___tns__submitMediaToken(struct soap *soap, const char *tag, struct __tns__submitMediaToken *a, const char *type)
{
	size_t soap_flag_tns__submitMediaToken_ = 1;
	short soap_flag;
	a = (struct __tns__submitMediaToken *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__submitMediaToken, sizeof(struct __tns__submitMediaToken), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__submitMediaToken(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__submitMediaToken_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__submitMediaToken(soap, "tns:submitMediaToken", &a->tns__submitMediaToken_, "tns:submitMediaToken"))
				{	soap_flag_tns__submitMediaToken_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__submitMediaToken(struct soap *soap, const struct __tns__submitMediaToken *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__submitMediaToken(soap, tag?tag:"-tns:submitMediaToken", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaToken * SOAP_FMAC4 soap_get___tns__submitMediaToken(struct soap *soap, struct __tns__submitMediaToken *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__submitMediaToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__submitMediaToken * SOAP_FMAC2 soap_instantiate___tns__submitMediaToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__submitMediaToken(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__submitMediaToken, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaToken);
		if (size)
			*size = sizeof(struct __tns__submitMediaToken);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaToken[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__submitMediaToken);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__submitMediaToken*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__submitMediaToken(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__submitMediaToken %p -> %p\n", q, p));
	*(struct __tns__submitMediaToken*)p = *(struct __tns__submitMediaToken*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__submitMediaAnnotationTextWithTokenId(struct soap *soap, struct __tns__submitMediaAnnotationTextWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__submitMediaAnnotationTextWithTokenId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__submitMediaAnnotationTextWithTokenId(struct soap *soap, const struct __tns__submitMediaAnnotationTextWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__submitMediaAnnotationTextWithTokenId(soap, &a->tns__submitMediaAnnotationTextWithTokenId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__submitMediaAnnotationTextWithTokenId(struct soap *soap, const char *tag, int id, const struct __tns__submitMediaAnnotationTextWithTokenId *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__submitMediaAnnotationTextWithTokenId(soap, "tns:submitMediaAnnotationTextWithTokenId", -1, &a->tns__submitMediaAnnotationTextWithTokenId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaAnnotationTextWithTokenId * SOAP_FMAC4 soap_in___tns__submitMediaAnnotationTextWithTokenId(struct soap *soap, const char *tag, struct __tns__submitMediaAnnotationTextWithTokenId *a, const char *type)
{
	size_t soap_flag_tns__submitMediaAnnotationTextWithTokenId_ = 1;
	short soap_flag;
	a = (struct __tns__submitMediaAnnotationTextWithTokenId *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__submitMediaAnnotationTextWithTokenId, sizeof(struct __tns__submitMediaAnnotationTextWithTokenId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__submitMediaAnnotationTextWithTokenId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__submitMediaAnnotationTextWithTokenId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__submitMediaAnnotationTextWithTokenId(soap, "tns:submitMediaAnnotationTextWithTokenId", &a->tns__submitMediaAnnotationTextWithTokenId_, "tns:submitMediaAnnotationTextWithTokenId"))
				{	soap_flag_tns__submitMediaAnnotationTextWithTokenId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__submitMediaAnnotationTextWithTokenId(struct soap *soap, const struct __tns__submitMediaAnnotationTextWithTokenId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__submitMediaAnnotationTextWithTokenId(soap, tag?tag:"-tns:submitMediaAnnotationTextWithTokenId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaAnnotationTextWithTokenId * SOAP_FMAC4 soap_get___tns__submitMediaAnnotationTextWithTokenId(struct soap *soap, struct __tns__submitMediaAnnotationTextWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__submitMediaAnnotationTextWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__submitMediaAnnotationTextWithTokenId * SOAP_FMAC2 soap_instantiate___tns__submitMediaAnnotationTextWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__submitMediaAnnotationTextWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__submitMediaAnnotationTextWithTokenId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaAnnotationTextWithTokenId);
		if (size)
			*size = sizeof(struct __tns__submitMediaAnnotationTextWithTokenId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaAnnotationTextWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__submitMediaAnnotationTextWithTokenId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__submitMediaAnnotationTextWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__submitMediaAnnotationTextWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__submitMediaAnnotationTextWithTokenId %p -> %p\n", q, p));
	*(struct __tns__submitMediaAnnotationTextWithTokenId*)p = *(struct __tns__submitMediaAnnotationTextWithTokenId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, struct __tns__submitMediaAnnotationTextAndTokenDigest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__submitMediaAnnotationTextAndTokenDigest_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, const struct __tns__submitMediaAnnotationTextAndTokenDigest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__submitMediaAnnotationTextAndTokenDigest(soap, &a->tns__submitMediaAnnotationTextAndTokenDigest_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, const char *tag, int id, const struct __tns__submitMediaAnnotationTextAndTokenDigest *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__submitMediaAnnotationTextAndTokenDigest(soap, "tns:submitMediaAnnotationTextAndTokenDigest", -1, &a->tns__submitMediaAnnotationTextAndTokenDigest_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaAnnotationTextAndTokenDigest * SOAP_FMAC4 soap_in___tns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, const char *tag, struct __tns__submitMediaAnnotationTextAndTokenDigest *a, const char *type)
{
	size_t soap_flag_tns__submitMediaAnnotationTextAndTokenDigest_ = 1;
	short soap_flag;
	a = (struct __tns__submitMediaAnnotationTextAndTokenDigest *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__submitMediaAnnotationTextAndTokenDigest, sizeof(struct __tns__submitMediaAnnotationTextAndTokenDigest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__submitMediaAnnotationTextAndTokenDigest(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__submitMediaAnnotationTextAndTokenDigest_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__submitMediaAnnotationTextAndTokenDigest(soap, "tns:submitMediaAnnotationTextAndTokenDigest", &a->tns__submitMediaAnnotationTextAndTokenDigest_, "tns:submitMediaAnnotationTextAndTokenDigest"))
				{	soap_flag_tns__submitMediaAnnotationTextAndTokenDigest_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, const struct __tns__submitMediaAnnotationTextAndTokenDigest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__submitMediaAnnotationTextAndTokenDigest(soap, tag?tag:"-tns:submitMediaAnnotationTextAndTokenDigest", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaAnnotationTextAndTokenDigest * SOAP_FMAC4 soap_get___tns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, struct __tns__submitMediaAnnotationTextAndTokenDigest *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__submitMediaAnnotationTextAndTokenDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__submitMediaAnnotationTextAndTokenDigest * SOAP_FMAC2 soap_instantiate___tns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__submitMediaAnnotationTextAndTokenDigest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__submitMediaAnnotationTextAndTokenDigest, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaAnnotationTextAndTokenDigest);
		if (size)
			*size = sizeof(struct __tns__submitMediaAnnotationTextAndTokenDigest);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaAnnotationTextAndTokenDigest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__submitMediaAnnotationTextAndTokenDigest);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__submitMediaAnnotationTextAndTokenDigest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__submitMediaAnnotationTextAndTokenDigest %p -> %p\n", q, p));
	*(struct __tns__submitMediaAnnotationTextAndTokenDigest*)p = *(struct __tns__submitMediaAnnotationTextAndTokenDigest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__submitMediaAnnotation(struct soap *soap, struct __tns__submitMediaAnnotation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__submitMediaAnnotation_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__submitMediaAnnotation(struct soap *soap, const struct __tns__submitMediaAnnotation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__submitMediaAnnotation(soap, &a->tns__submitMediaAnnotation_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__submitMediaAnnotation(struct soap *soap, const char *tag, int id, const struct __tns__submitMediaAnnotation *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__submitMediaAnnotation(soap, "tns:submitMediaAnnotation", -1, &a->tns__submitMediaAnnotation_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaAnnotation * SOAP_FMAC4 soap_in___tns__submitMediaAnnotation(struct soap *soap, const char *tag, struct __tns__submitMediaAnnotation *a, const char *type)
{
	size_t soap_flag_tns__submitMediaAnnotation_ = 1;
	short soap_flag;
	a = (struct __tns__submitMediaAnnotation *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__submitMediaAnnotation, sizeof(struct __tns__submitMediaAnnotation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__submitMediaAnnotation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__submitMediaAnnotation_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__submitMediaAnnotation(soap, "tns:submitMediaAnnotation", &a->tns__submitMediaAnnotation_, "tns:submitMediaAnnotation"))
				{	soap_flag_tns__submitMediaAnnotation_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__submitMediaAnnotation(struct soap *soap, const struct __tns__submitMediaAnnotation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__submitMediaAnnotation(soap, tag?tag:"-tns:submitMediaAnnotation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaAnnotation * SOAP_FMAC4 soap_get___tns__submitMediaAnnotation(struct soap *soap, struct __tns__submitMediaAnnotation *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__submitMediaAnnotation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__submitMediaAnnotation * SOAP_FMAC2 soap_instantiate___tns__submitMediaAnnotation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__submitMediaAnnotation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__submitMediaAnnotation, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaAnnotation);
		if (size)
			*size = sizeof(struct __tns__submitMediaAnnotation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaAnnotation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__submitMediaAnnotation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__submitMediaAnnotation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__submitMediaAnnotation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__submitMediaAnnotation %p -> %p\n", q, p));
	*(struct __tns__submitMediaAnnotation*)p = *(struct __tns__submitMediaAnnotation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__submitMediaAliasTextWithTokenId(struct soap *soap, struct __tns__submitMediaAliasTextWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__submitMediaAliasTextWithTokenId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__submitMediaAliasTextWithTokenId(struct soap *soap, const struct __tns__submitMediaAliasTextWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__submitMediaAliasTextWithTokenId(soap, &a->tns__submitMediaAliasTextWithTokenId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__submitMediaAliasTextWithTokenId(struct soap *soap, const char *tag, int id, const struct __tns__submitMediaAliasTextWithTokenId *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__submitMediaAliasTextWithTokenId(soap, "tns:submitMediaAliasTextWithTokenId", -1, &a->tns__submitMediaAliasTextWithTokenId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaAliasTextWithTokenId * SOAP_FMAC4 soap_in___tns__submitMediaAliasTextWithTokenId(struct soap *soap, const char *tag, struct __tns__submitMediaAliasTextWithTokenId *a, const char *type)
{
	size_t soap_flag_tns__submitMediaAliasTextWithTokenId_ = 1;
	short soap_flag;
	a = (struct __tns__submitMediaAliasTextWithTokenId *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__submitMediaAliasTextWithTokenId, sizeof(struct __tns__submitMediaAliasTextWithTokenId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__submitMediaAliasTextWithTokenId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__submitMediaAliasTextWithTokenId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__submitMediaAliasTextWithTokenId(soap, "tns:submitMediaAliasTextWithTokenId", &a->tns__submitMediaAliasTextWithTokenId_, "tns:submitMediaAliasTextWithTokenId"))
				{	soap_flag_tns__submitMediaAliasTextWithTokenId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__submitMediaAliasTextWithTokenId(struct soap *soap, const struct __tns__submitMediaAliasTextWithTokenId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__submitMediaAliasTextWithTokenId(soap, tag?tag:"-tns:submitMediaAliasTextWithTokenId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaAliasTextWithTokenId * SOAP_FMAC4 soap_get___tns__submitMediaAliasTextWithTokenId(struct soap *soap, struct __tns__submitMediaAliasTextWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__submitMediaAliasTextWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__submitMediaAliasTextWithTokenId * SOAP_FMAC2 soap_instantiate___tns__submitMediaAliasTextWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__submitMediaAliasTextWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__submitMediaAliasTextWithTokenId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaAliasTextWithTokenId);
		if (size)
			*size = sizeof(struct __tns__submitMediaAliasTextWithTokenId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaAliasTextWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__submitMediaAliasTextWithTokenId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__submitMediaAliasTextWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__submitMediaAliasTextWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__submitMediaAliasTextWithTokenId %p -> %p\n", q, p));
	*(struct __tns__submitMediaAliasTextWithTokenId*)p = *(struct __tns__submitMediaAliasTextWithTokenId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__submitMediaAliasTextAndTokenDigest(struct soap *soap, struct __tns__submitMediaAliasTextAndTokenDigest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__submitMediaAliasTextAndTokenDigest_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__submitMediaAliasTextAndTokenDigest(struct soap *soap, const struct __tns__submitMediaAliasTextAndTokenDigest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__submitMediaAliasTextAndTokenDigest(soap, &a->tns__submitMediaAliasTextAndTokenDigest_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__submitMediaAliasTextAndTokenDigest(struct soap *soap, const char *tag, int id, const struct __tns__submitMediaAliasTextAndTokenDigest *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__submitMediaAliasTextAndTokenDigest(soap, "tns:submitMediaAliasTextAndTokenDigest", -1, &a->tns__submitMediaAliasTextAndTokenDigest_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaAliasTextAndTokenDigest * SOAP_FMAC4 soap_in___tns__submitMediaAliasTextAndTokenDigest(struct soap *soap, const char *tag, struct __tns__submitMediaAliasTextAndTokenDigest *a, const char *type)
{
	size_t soap_flag_tns__submitMediaAliasTextAndTokenDigest_ = 1;
	short soap_flag;
	a = (struct __tns__submitMediaAliasTextAndTokenDigest *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__submitMediaAliasTextAndTokenDigest, sizeof(struct __tns__submitMediaAliasTextAndTokenDigest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__submitMediaAliasTextAndTokenDigest(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__submitMediaAliasTextAndTokenDigest_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__submitMediaAliasTextAndTokenDigest(soap, "tns:submitMediaAliasTextAndTokenDigest", &a->tns__submitMediaAliasTextAndTokenDigest_, "tns:submitMediaAliasTextAndTokenDigest"))
				{	soap_flag_tns__submitMediaAliasTextAndTokenDigest_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__submitMediaAliasTextAndTokenDigest(struct soap *soap, const struct __tns__submitMediaAliasTextAndTokenDigest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__submitMediaAliasTextAndTokenDigest(soap, tag?tag:"-tns:submitMediaAliasTextAndTokenDigest", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaAliasTextAndTokenDigest * SOAP_FMAC4 soap_get___tns__submitMediaAliasTextAndTokenDigest(struct soap *soap, struct __tns__submitMediaAliasTextAndTokenDigest *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__submitMediaAliasTextAndTokenDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__submitMediaAliasTextAndTokenDigest * SOAP_FMAC2 soap_instantiate___tns__submitMediaAliasTextAndTokenDigest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__submitMediaAliasTextAndTokenDigest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__submitMediaAliasTextAndTokenDigest, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaAliasTextAndTokenDigest);
		if (size)
			*size = sizeof(struct __tns__submitMediaAliasTextAndTokenDigest);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaAliasTextAndTokenDigest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__submitMediaAliasTextAndTokenDigest);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__submitMediaAliasTextAndTokenDigest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__submitMediaAliasTextAndTokenDigest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__submitMediaAliasTextAndTokenDigest %p -> %p\n", q, p));
	*(struct __tns__submitMediaAliasTextAndTokenDigest*)p = *(struct __tns__submitMediaAliasTextAndTokenDigest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__submitMediaAlias(struct soap *soap, struct __tns__submitMediaAlias *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__submitMediaAlias_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__submitMediaAlias(struct soap *soap, const struct __tns__submitMediaAlias *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__submitMediaAlias(soap, &a->tns__submitMediaAlias_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__submitMediaAlias(struct soap *soap, const char *tag, int id, const struct __tns__submitMediaAlias *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__submitMediaAlias(soap, "tns:submitMediaAlias", -1, &a->tns__submitMediaAlias_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaAlias * SOAP_FMAC4 soap_in___tns__submitMediaAlias(struct soap *soap, const char *tag, struct __tns__submitMediaAlias *a, const char *type)
{
	size_t soap_flag_tns__submitMediaAlias_ = 1;
	short soap_flag;
	a = (struct __tns__submitMediaAlias *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__submitMediaAlias, sizeof(struct __tns__submitMediaAlias), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__submitMediaAlias(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__submitMediaAlias_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__submitMediaAlias(soap, "tns:submitMediaAlias", &a->tns__submitMediaAlias_, "tns:submitMediaAlias"))
				{	soap_flag_tns__submitMediaAlias_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__submitMediaAlias(struct soap *soap, const struct __tns__submitMediaAlias *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__submitMediaAlias(soap, tag?tag:"-tns:submitMediaAlias", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__submitMediaAlias * SOAP_FMAC4 soap_get___tns__submitMediaAlias(struct soap *soap, struct __tns__submitMediaAlias *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__submitMediaAlias(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__submitMediaAlias * SOAP_FMAC2 soap_instantiate___tns__submitMediaAlias(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__submitMediaAlias(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__submitMediaAlias, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaAlias);
		if (size)
			*size = sizeof(struct __tns__submitMediaAlias);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__submitMediaAlias[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__submitMediaAlias);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__submitMediaAlias*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__submitMediaAlias(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__submitMediaAlias %p -> %p\n", q, p));
	*(struct __tns__submitMediaAlias*)p = *(struct __tns__submitMediaAlias*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__setUserLanguage(struct soap *soap, struct __tns__setUserLanguage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__setUserLanguage_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__setUserLanguage(struct soap *soap, const struct __tns__setUserLanguage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__setUserLanguage(soap, &a->tns__setUserLanguage_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__setUserLanguage(struct soap *soap, const char *tag, int id, const struct __tns__setUserLanguage *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__setUserLanguage(soap, "tns:setUserLanguage", -1, &a->tns__setUserLanguage_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__setUserLanguage * SOAP_FMAC4 soap_in___tns__setUserLanguage(struct soap *soap, const char *tag, struct __tns__setUserLanguage *a, const char *type)
{
	size_t soap_flag_tns__setUserLanguage_ = 1;
	short soap_flag;
	a = (struct __tns__setUserLanguage *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__setUserLanguage, sizeof(struct __tns__setUserLanguage), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__setUserLanguage(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__setUserLanguage_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__setUserLanguage(soap, "tns:setUserLanguage", &a->tns__setUserLanguage_, "tns:setUserLanguage"))
				{	soap_flag_tns__setUserLanguage_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__setUserLanguage(struct soap *soap, const struct __tns__setUserLanguage *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__setUserLanguage(soap, tag?tag:"-tns:setUserLanguage", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__setUserLanguage * SOAP_FMAC4 soap_get___tns__setUserLanguage(struct soap *soap, struct __tns__setUserLanguage *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__setUserLanguage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__setUserLanguage * SOAP_FMAC2 soap_instantiate___tns__setUserLanguage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__setUserLanguage(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__setUserLanguage, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__setUserLanguage);
		if (size)
			*size = sizeof(struct __tns__setUserLanguage);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__setUserLanguage[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__setUserLanguage);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__setUserLanguage*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__setUserLanguage(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__setUserLanguage %p -> %p\n", q, p));
	*(struct __tns__setUserLanguage*)p = *(struct __tns__setUserLanguage*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__setUserAnonymous(struct soap *soap, struct __tns__setUserAnonymous *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__setUserAnonymous_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__setUserAnonymous(struct soap *soap, const struct __tns__setUserAnonymous *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__setUserAnonymous(soap, &a->tns__setUserAnonymous_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__setUserAnonymous(struct soap *soap, const char *tag, int id, const struct __tns__setUserAnonymous *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__setUserAnonymous(soap, "tns:setUserAnonymous", -1, &a->tns__setUserAnonymous_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__setUserAnonymous * SOAP_FMAC4 soap_in___tns__setUserAnonymous(struct soap *soap, const char *tag, struct __tns__setUserAnonymous *a, const char *type)
{
	size_t soap_flag_tns__setUserAnonymous_ = 1;
	short soap_flag;
	a = (struct __tns__setUserAnonymous *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__setUserAnonymous, sizeof(struct __tns__setUserAnonymous), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__setUserAnonymous(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__setUserAnonymous_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__setUserAnonymous(soap, "tns:setUserAnonymous", &a->tns__setUserAnonymous_, "tns:setUserAnonymous"))
				{	soap_flag_tns__setUserAnonymous_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__setUserAnonymous(struct soap *soap, const struct __tns__setUserAnonymous *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__setUserAnonymous(soap, tag?tag:"-tns:setUserAnonymous", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__setUserAnonymous * SOAP_FMAC4 soap_get___tns__setUserAnonymous(struct soap *soap, struct __tns__setUserAnonymous *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__setUserAnonymous(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__setUserAnonymous * SOAP_FMAC2 soap_instantiate___tns__setUserAnonymous(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__setUserAnonymous(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__setUserAnonymous, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__setUserAnonymous);
		if (size)
			*size = sizeof(struct __tns__setUserAnonymous);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__setUserAnonymous[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__setUserAnonymous);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__setUserAnonymous*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__setUserAnonymous(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__setUserAnonymous %p -> %p\n", q, p));
	*(struct __tns__setUserAnonymous*)p = *(struct __tns__setUserAnonymous*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__selectUser(struct soap *soap, struct __tns__selectUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__selectUser_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__selectUser(struct soap *soap, const struct __tns__selectUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__selectUser(soap, &a->tns__selectUser_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__selectUser(struct soap *soap, const char *tag, int id, const struct __tns__selectUser *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__selectUser(soap, "tns:selectUser", -1, &a->tns__selectUser_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectUser * SOAP_FMAC4 soap_in___tns__selectUser(struct soap *soap, const char *tag, struct __tns__selectUser *a, const char *type)
{
	size_t soap_flag_tns__selectUser_ = 1;
	short soap_flag;
	a = (struct __tns__selectUser *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__selectUser, sizeof(struct __tns__selectUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__selectUser(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__selectUser_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__selectUser(soap, "tns:selectUser", &a->tns__selectUser_, "tns:selectUser"))
				{	soap_flag_tns__selectUser_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__selectUser(struct soap *soap, const struct __tns__selectUser *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__selectUser(soap, tag?tag:"-tns:selectUser", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectUser * SOAP_FMAC4 soap_get___tns__selectUser(struct soap *soap, struct __tns__selectUser *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__selectUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__selectUser * SOAP_FMAC2 soap_instantiate___tns__selectUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__selectUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__selectUser, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectUser);
		if (size)
			*size = sizeof(struct __tns__selectUser);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectUser[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__selectUser);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__selectUser*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__selectUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__selectUser %p -> %p\n", q, p));
	*(struct __tns__selectUser*)p = *(struct __tns__selectUser*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, struct __tns__selectRelatedMediaAnnotationsWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__selectRelatedMediaAnnotationsWithTokenId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, const struct __tns__selectRelatedMediaAnnotationsWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__selectRelatedMediaAnnotationsWithTokenId(soap, &a->tns__selectRelatedMediaAnnotationsWithTokenId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, const char *tag, int id, const struct __tns__selectRelatedMediaAnnotationsWithTokenId *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__selectRelatedMediaAnnotationsWithTokenId(soap, "tns:selectRelatedMediaAnnotationsWithTokenId", -1, &a->tns__selectRelatedMediaAnnotationsWithTokenId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectRelatedMediaAnnotationsWithTokenId * SOAP_FMAC4 soap_in___tns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, const char *tag, struct __tns__selectRelatedMediaAnnotationsWithTokenId *a, const char *type)
{
	size_t soap_flag_tns__selectRelatedMediaAnnotationsWithTokenId_ = 1;
	short soap_flag;
	a = (struct __tns__selectRelatedMediaAnnotationsWithTokenId *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__selectRelatedMediaAnnotationsWithTokenId, sizeof(struct __tns__selectRelatedMediaAnnotationsWithTokenId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__selectRelatedMediaAnnotationsWithTokenId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__selectRelatedMediaAnnotationsWithTokenId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__selectRelatedMediaAnnotationsWithTokenId(soap, "tns:selectRelatedMediaAnnotationsWithTokenId", &a->tns__selectRelatedMediaAnnotationsWithTokenId_, "tns:selectRelatedMediaAnnotationsWithTokenId"))
				{	soap_flag_tns__selectRelatedMediaAnnotationsWithTokenId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, const struct __tns__selectRelatedMediaAnnotationsWithTokenId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__selectRelatedMediaAnnotationsWithTokenId(soap, tag?tag:"-tns:selectRelatedMediaAnnotationsWithTokenId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectRelatedMediaAnnotationsWithTokenId * SOAP_FMAC4 soap_get___tns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, struct __tns__selectRelatedMediaAnnotationsWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__selectRelatedMediaAnnotationsWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__selectRelatedMediaAnnotationsWithTokenId * SOAP_FMAC2 soap_instantiate___tns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__selectRelatedMediaAnnotationsWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__selectRelatedMediaAnnotationsWithTokenId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectRelatedMediaAnnotationsWithTokenId);
		if (size)
			*size = sizeof(struct __tns__selectRelatedMediaAnnotationsWithTokenId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectRelatedMediaAnnotationsWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__selectRelatedMediaAnnotationsWithTokenId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__selectRelatedMediaAnnotationsWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__selectRelatedMediaAnnotationsWithTokenId %p -> %p\n", q, p));
	*(struct __tns__selectRelatedMediaAnnotationsWithTokenId*)p = *(struct __tns__selectRelatedMediaAnnotationsWithTokenId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__selectMediaTokenWithId(struct soap *soap, struct __tns__selectMediaTokenWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__selectMediaTokenWithId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__selectMediaTokenWithId(struct soap *soap, const struct __tns__selectMediaTokenWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__selectMediaTokenWithId(soap, &a->tns__selectMediaTokenWithId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__selectMediaTokenWithId(struct soap *soap, const char *tag, int id, const struct __tns__selectMediaTokenWithId *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__selectMediaTokenWithId(soap, "tns:selectMediaTokenWithId", -1, &a->tns__selectMediaTokenWithId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectMediaTokenWithId * SOAP_FMAC4 soap_in___tns__selectMediaTokenWithId(struct soap *soap, const char *tag, struct __tns__selectMediaTokenWithId *a, const char *type)
{
	size_t soap_flag_tns__selectMediaTokenWithId_ = 1;
	short soap_flag;
	a = (struct __tns__selectMediaTokenWithId *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__selectMediaTokenWithId, sizeof(struct __tns__selectMediaTokenWithId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__selectMediaTokenWithId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__selectMediaTokenWithId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__selectMediaTokenWithId(soap, "tns:selectMediaTokenWithId", &a->tns__selectMediaTokenWithId_, "tns:selectMediaTokenWithId"))
				{	soap_flag_tns__selectMediaTokenWithId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__selectMediaTokenWithId(struct soap *soap, const struct __tns__selectMediaTokenWithId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__selectMediaTokenWithId(soap, tag?tag:"-tns:selectMediaTokenWithId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectMediaTokenWithId * SOAP_FMAC4 soap_get___tns__selectMediaTokenWithId(struct soap *soap, struct __tns__selectMediaTokenWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__selectMediaTokenWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__selectMediaTokenWithId * SOAP_FMAC2 soap_instantiate___tns__selectMediaTokenWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__selectMediaTokenWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__selectMediaTokenWithId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectMediaTokenWithId);
		if (size)
			*size = sizeof(struct __tns__selectMediaTokenWithId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectMediaTokenWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__selectMediaTokenWithId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__selectMediaTokenWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__selectMediaTokenWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__selectMediaTokenWithId %p -> %p\n", q, p));
	*(struct __tns__selectMediaTokenWithId*)p = *(struct __tns__selectMediaTokenWithId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__selectMediaTokenWithDigest(struct soap *soap, struct __tns__selectMediaTokenWithDigest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__selectMediaTokenWithDigest_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__selectMediaTokenWithDigest(struct soap *soap, const struct __tns__selectMediaTokenWithDigest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__selectMediaTokenWithDigest(soap, &a->tns__selectMediaTokenWithDigest_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__selectMediaTokenWithDigest(struct soap *soap, const char *tag, int id, const struct __tns__selectMediaTokenWithDigest *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__selectMediaTokenWithDigest(soap, "tns:selectMediaTokenWithDigest", -1, &a->tns__selectMediaTokenWithDigest_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectMediaTokenWithDigest * SOAP_FMAC4 soap_in___tns__selectMediaTokenWithDigest(struct soap *soap, const char *tag, struct __tns__selectMediaTokenWithDigest *a, const char *type)
{
	size_t soap_flag_tns__selectMediaTokenWithDigest_ = 1;
	short soap_flag;
	a = (struct __tns__selectMediaTokenWithDigest *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__selectMediaTokenWithDigest, sizeof(struct __tns__selectMediaTokenWithDigest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__selectMediaTokenWithDigest(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__selectMediaTokenWithDigest_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__selectMediaTokenWithDigest(soap, "tns:selectMediaTokenWithDigest", &a->tns__selectMediaTokenWithDigest_, "tns:selectMediaTokenWithDigest"))
				{	soap_flag_tns__selectMediaTokenWithDigest_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__selectMediaTokenWithDigest(struct soap *soap, const struct __tns__selectMediaTokenWithDigest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__selectMediaTokenWithDigest(soap, tag?tag:"-tns:selectMediaTokenWithDigest", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectMediaTokenWithDigest * SOAP_FMAC4 soap_get___tns__selectMediaTokenWithDigest(struct soap *soap, struct __tns__selectMediaTokenWithDigest *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__selectMediaTokenWithDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__selectMediaTokenWithDigest * SOAP_FMAC2 soap_instantiate___tns__selectMediaTokenWithDigest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__selectMediaTokenWithDigest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__selectMediaTokenWithDigest, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectMediaTokenWithDigest);
		if (size)
			*size = sizeof(struct __tns__selectMediaTokenWithDigest);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectMediaTokenWithDigest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__selectMediaTokenWithDigest);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__selectMediaTokenWithDigest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__selectMediaTokenWithDigest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__selectMediaTokenWithDigest %p -> %p\n", q, p));
	*(struct __tns__selectMediaTokenWithDigest*)p = *(struct __tns__selectMediaTokenWithDigest*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__selectMediaAnnotationsWithTokenId(struct soap *soap, struct __tns__selectMediaAnnotationsWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__selectMediaAnnotationsWithTokenId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__selectMediaAnnotationsWithTokenId(struct soap *soap, const struct __tns__selectMediaAnnotationsWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__selectMediaAnnotationsWithTokenId(soap, &a->tns__selectMediaAnnotationsWithTokenId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__selectMediaAnnotationsWithTokenId(struct soap *soap, const char *tag, int id, const struct __tns__selectMediaAnnotationsWithTokenId *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__selectMediaAnnotationsWithTokenId(soap, "tns:selectMediaAnnotationsWithTokenId", -1, &a->tns__selectMediaAnnotationsWithTokenId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectMediaAnnotationsWithTokenId * SOAP_FMAC4 soap_in___tns__selectMediaAnnotationsWithTokenId(struct soap *soap, const char *tag, struct __tns__selectMediaAnnotationsWithTokenId *a, const char *type)
{
	size_t soap_flag_tns__selectMediaAnnotationsWithTokenId_ = 1;
	short soap_flag;
	a = (struct __tns__selectMediaAnnotationsWithTokenId *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__selectMediaAnnotationsWithTokenId, sizeof(struct __tns__selectMediaAnnotationsWithTokenId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__selectMediaAnnotationsWithTokenId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__selectMediaAnnotationsWithTokenId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__selectMediaAnnotationsWithTokenId(soap, "tns:selectMediaAnnotationsWithTokenId", &a->tns__selectMediaAnnotationsWithTokenId_, "tns:selectMediaAnnotationsWithTokenId"))
				{	soap_flag_tns__selectMediaAnnotationsWithTokenId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__selectMediaAnnotationsWithTokenId(struct soap *soap, const struct __tns__selectMediaAnnotationsWithTokenId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__selectMediaAnnotationsWithTokenId(soap, tag?tag:"-tns:selectMediaAnnotationsWithTokenId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectMediaAnnotationsWithTokenId * SOAP_FMAC4 soap_get___tns__selectMediaAnnotationsWithTokenId(struct soap *soap, struct __tns__selectMediaAnnotationsWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__selectMediaAnnotationsWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__selectMediaAnnotationsWithTokenId * SOAP_FMAC2 soap_instantiate___tns__selectMediaAnnotationsWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__selectMediaAnnotationsWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__selectMediaAnnotationsWithTokenId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectMediaAnnotationsWithTokenId);
		if (size)
			*size = sizeof(struct __tns__selectMediaAnnotationsWithTokenId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectMediaAnnotationsWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__selectMediaAnnotationsWithTokenId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__selectMediaAnnotationsWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__selectMediaAnnotationsWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__selectMediaAnnotationsWithTokenId %p -> %p\n", q, p));
	*(struct __tns__selectMediaAnnotationsWithTokenId*)p = *(struct __tns__selectMediaAnnotationsWithTokenId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__selectMediaAliasesWithTokenId(struct soap *soap, struct __tns__selectMediaAliasesWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__selectMediaAliasesWithTokenId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__selectMediaAliasesWithTokenId(struct soap *soap, const struct __tns__selectMediaAliasesWithTokenId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__selectMediaAliasesWithTokenId(soap, &a->tns__selectMediaAliasesWithTokenId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__selectMediaAliasesWithTokenId(struct soap *soap, const char *tag, int id, const struct __tns__selectMediaAliasesWithTokenId *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__selectMediaAliasesWithTokenId(soap, "tns:selectMediaAliasesWithTokenId", -1, &a->tns__selectMediaAliasesWithTokenId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectMediaAliasesWithTokenId * SOAP_FMAC4 soap_in___tns__selectMediaAliasesWithTokenId(struct soap *soap, const char *tag, struct __tns__selectMediaAliasesWithTokenId *a, const char *type)
{
	size_t soap_flag_tns__selectMediaAliasesWithTokenId_ = 1;
	short soap_flag;
	a = (struct __tns__selectMediaAliasesWithTokenId *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__selectMediaAliasesWithTokenId, sizeof(struct __tns__selectMediaAliasesWithTokenId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__selectMediaAliasesWithTokenId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__selectMediaAliasesWithTokenId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__selectMediaAliasesWithTokenId(soap, "tns:selectMediaAliasesWithTokenId", &a->tns__selectMediaAliasesWithTokenId_, "tns:selectMediaAliasesWithTokenId"))
				{	soap_flag_tns__selectMediaAliasesWithTokenId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__selectMediaAliasesWithTokenId(struct soap *soap, const struct __tns__selectMediaAliasesWithTokenId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__selectMediaAliasesWithTokenId(soap, tag?tag:"-tns:selectMediaAliasesWithTokenId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__selectMediaAliasesWithTokenId * SOAP_FMAC4 soap_get___tns__selectMediaAliasesWithTokenId(struct soap *soap, struct __tns__selectMediaAliasesWithTokenId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__selectMediaAliasesWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__selectMediaAliasesWithTokenId * SOAP_FMAC2 soap_instantiate___tns__selectMediaAliasesWithTokenId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__selectMediaAliasesWithTokenId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__selectMediaAliasesWithTokenId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectMediaAliasesWithTokenId);
		if (size)
			*size = sizeof(struct __tns__selectMediaAliasesWithTokenId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__selectMediaAliasesWithTokenId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__selectMediaAliasesWithTokenId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__selectMediaAliasesWithTokenId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__selectMediaAliasesWithTokenId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__selectMediaAliasesWithTokenId %p -> %p\n", q, p));
	*(struct __tns__selectMediaAliasesWithTokenId*)p = *(struct __tns__selectMediaAliasesWithTokenId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__isConnected(struct soap *soap, struct __tns__isConnected *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__isConnected_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__isConnected(struct soap *soap, const struct __tns__isConnected *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__isConnected(soap, &a->tns__isConnected_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__isConnected(struct soap *soap, const char *tag, int id, const struct __tns__isConnected *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__isConnected(soap, "tns:isConnected", -1, &a->tns__isConnected_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__isConnected * SOAP_FMAC4 soap_in___tns__isConnected(struct soap *soap, const char *tag, struct __tns__isConnected *a, const char *type)
{
	size_t soap_flag_tns__isConnected_ = 1;
	short soap_flag;
	a = (struct __tns__isConnected *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__isConnected, sizeof(struct __tns__isConnected), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__isConnected(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__isConnected_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__isConnected(soap, "tns:isConnected", &a->tns__isConnected_, "tns:isConnected"))
				{	soap_flag_tns__isConnected_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__isConnected(struct soap *soap, const struct __tns__isConnected *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__isConnected(soap, tag?tag:"-tns:isConnected", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__isConnected * SOAP_FMAC4 soap_get___tns__isConnected(struct soap *soap, struct __tns__isConnected *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__isConnected(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__isConnected * SOAP_FMAC2 soap_instantiate___tns__isConnected(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__isConnected(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__isConnected, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__isConnected);
		if (size)
			*size = sizeof(struct __tns__isConnected);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__isConnected[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__isConnected);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__isConnected*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__isConnected(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__isConnected %p -> %p\n", q, p));
	*(struct __tns__isConnected*)p = *(struct __tns__isConnected*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__isClientUpdated(struct soap *soap, struct __tns__isClientUpdated *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__isClientUpdated_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__isClientUpdated(struct soap *soap, const struct __tns__isClientUpdated *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__isClientUpdated(soap, &a->tns__isClientUpdated_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__isClientUpdated(struct soap *soap, const char *tag, int id, const struct __tns__isClientUpdated *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__isClientUpdated(soap, "tns:isClientUpdated", -1, &a->tns__isClientUpdated_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__isClientUpdated * SOAP_FMAC4 soap_in___tns__isClientUpdated(struct soap *soap, const char *tag, struct __tns__isClientUpdated *a, const char *type)
{
	size_t soap_flag_tns__isClientUpdated_ = 1;
	short soap_flag;
	a = (struct __tns__isClientUpdated *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__isClientUpdated, sizeof(struct __tns__isClientUpdated), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__isClientUpdated(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__isClientUpdated_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__isClientUpdated(soap, "tns:isClientUpdated", &a->tns__isClientUpdated_, "tns:isClientUpdated"))
				{	soap_flag_tns__isClientUpdated_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__isClientUpdated(struct soap *soap, const struct __tns__isClientUpdated *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__isClientUpdated(soap, tag?tag:"-tns:isClientUpdated", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__isClientUpdated * SOAP_FMAC4 soap_get___tns__isClientUpdated(struct soap *soap, struct __tns__isClientUpdated *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__isClientUpdated(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__isClientUpdated * SOAP_FMAC2 soap_instantiate___tns__isClientUpdated(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__isClientUpdated(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__isClientUpdated, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__isClientUpdated);
		if (size)
			*size = sizeof(struct __tns__isClientUpdated);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__isClientUpdated[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__isClientUpdated);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__isClientUpdated*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__isClientUpdated(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__isClientUpdated %p -> %p\n", q, p));
	*(struct __tns__isClientUpdated*)p = *(struct __tns__isClientUpdated*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__curseMediaTokenWithId(struct soap *soap, struct __tns__curseMediaTokenWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__curseMediaTokenWithId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__curseMediaTokenWithId(struct soap *soap, const struct __tns__curseMediaTokenWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__curseMediaTokenWithId(soap, &a->tns__curseMediaTokenWithId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__curseMediaTokenWithId(struct soap *soap, const char *tag, int id, const struct __tns__curseMediaTokenWithId *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__curseMediaTokenWithId(soap, "tns:curseMediaTokenWithId", -1, &a->tns__curseMediaTokenWithId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__curseMediaTokenWithId * SOAP_FMAC4 soap_in___tns__curseMediaTokenWithId(struct soap *soap, const char *tag, struct __tns__curseMediaTokenWithId *a, const char *type)
{
	size_t soap_flag_tns__curseMediaTokenWithId_ = 1;
	short soap_flag;
	a = (struct __tns__curseMediaTokenWithId *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__curseMediaTokenWithId, sizeof(struct __tns__curseMediaTokenWithId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__curseMediaTokenWithId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__curseMediaTokenWithId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__curseMediaTokenWithId(soap, "tns:curseMediaTokenWithId", &a->tns__curseMediaTokenWithId_, "tns:curseMediaTokenWithId"))
				{	soap_flag_tns__curseMediaTokenWithId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__curseMediaTokenWithId(struct soap *soap, const struct __tns__curseMediaTokenWithId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__curseMediaTokenWithId(soap, tag?tag:"-tns:curseMediaTokenWithId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__curseMediaTokenWithId * SOAP_FMAC4 soap_get___tns__curseMediaTokenWithId(struct soap *soap, struct __tns__curseMediaTokenWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__curseMediaTokenWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__curseMediaTokenWithId * SOAP_FMAC2 soap_instantiate___tns__curseMediaTokenWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__curseMediaTokenWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__curseMediaTokenWithId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__curseMediaTokenWithId);
		if (size)
			*size = sizeof(struct __tns__curseMediaTokenWithId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__curseMediaTokenWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__curseMediaTokenWithId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__curseMediaTokenWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__curseMediaTokenWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__curseMediaTokenWithId %p -> %p\n", q, p));
	*(struct __tns__curseMediaTokenWithId*)p = *(struct __tns__curseMediaTokenWithId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__curseMediaAnnotationWithId(struct soap *soap, struct __tns__curseMediaAnnotationWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__curseMediaAnnotationWithId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__curseMediaAnnotationWithId(struct soap *soap, const struct __tns__curseMediaAnnotationWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__curseMediaAnnotationWithId(soap, &a->tns__curseMediaAnnotationWithId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__curseMediaAnnotationWithId(struct soap *soap, const char *tag, int id, const struct __tns__curseMediaAnnotationWithId *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__curseMediaAnnotationWithId(soap, "tns:curseMediaAnnotationWithId", -1, &a->tns__curseMediaAnnotationWithId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__curseMediaAnnotationWithId * SOAP_FMAC4 soap_in___tns__curseMediaAnnotationWithId(struct soap *soap, const char *tag, struct __tns__curseMediaAnnotationWithId *a, const char *type)
{
	size_t soap_flag_tns__curseMediaAnnotationWithId_ = 1;
	short soap_flag;
	a = (struct __tns__curseMediaAnnotationWithId *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__curseMediaAnnotationWithId, sizeof(struct __tns__curseMediaAnnotationWithId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__curseMediaAnnotationWithId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__curseMediaAnnotationWithId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__curseMediaAnnotationWithId(soap, "tns:curseMediaAnnotationWithId", &a->tns__curseMediaAnnotationWithId_, "tns:curseMediaAnnotationWithId"))
				{	soap_flag_tns__curseMediaAnnotationWithId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__curseMediaAnnotationWithId(struct soap *soap, const struct __tns__curseMediaAnnotationWithId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__curseMediaAnnotationWithId(soap, tag?tag:"-tns:curseMediaAnnotationWithId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__curseMediaAnnotationWithId * SOAP_FMAC4 soap_get___tns__curseMediaAnnotationWithId(struct soap *soap, struct __tns__curseMediaAnnotationWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__curseMediaAnnotationWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__curseMediaAnnotationWithId * SOAP_FMAC2 soap_instantiate___tns__curseMediaAnnotationWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__curseMediaAnnotationWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__curseMediaAnnotationWithId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__curseMediaAnnotationWithId);
		if (size)
			*size = sizeof(struct __tns__curseMediaAnnotationWithId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__curseMediaAnnotationWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__curseMediaAnnotationWithId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__curseMediaAnnotationWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__curseMediaAnnotationWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__curseMediaAnnotationWithId %p -> %p\n", q, p));
	*(struct __tns__curseMediaAnnotationWithId*)p = *(struct __tns__curseMediaAnnotationWithId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__curseMediaAliasWithId(struct soap *soap, struct __tns__curseMediaAliasWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__curseMediaAliasWithId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__curseMediaAliasWithId(struct soap *soap, const struct __tns__curseMediaAliasWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__curseMediaAliasWithId(soap, &a->tns__curseMediaAliasWithId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__curseMediaAliasWithId(struct soap *soap, const char *tag, int id, const struct __tns__curseMediaAliasWithId *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__curseMediaAliasWithId(soap, "tns:curseMediaAliasWithId", -1, &a->tns__curseMediaAliasWithId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__curseMediaAliasWithId * SOAP_FMAC4 soap_in___tns__curseMediaAliasWithId(struct soap *soap, const char *tag, struct __tns__curseMediaAliasWithId *a, const char *type)
{
	size_t soap_flag_tns__curseMediaAliasWithId_ = 1;
	short soap_flag;
	a = (struct __tns__curseMediaAliasWithId *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__curseMediaAliasWithId, sizeof(struct __tns__curseMediaAliasWithId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__curseMediaAliasWithId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__curseMediaAliasWithId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__curseMediaAliasWithId(soap, "tns:curseMediaAliasWithId", &a->tns__curseMediaAliasWithId_, "tns:curseMediaAliasWithId"))
				{	soap_flag_tns__curseMediaAliasWithId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__curseMediaAliasWithId(struct soap *soap, const struct __tns__curseMediaAliasWithId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__curseMediaAliasWithId(soap, tag?tag:"-tns:curseMediaAliasWithId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__curseMediaAliasWithId * SOAP_FMAC4 soap_get___tns__curseMediaAliasWithId(struct soap *soap, struct __tns__curseMediaAliasWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__curseMediaAliasWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__curseMediaAliasWithId * SOAP_FMAC2 soap_instantiate___tns__curseMediaAliasWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__curseMediaAliasWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__curseMediaAliasWithId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__curseMediaAliasWithId);
		if (size)
			*size = sizeof(struct __tns__curseMediaAliasWithId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__curseMediaAliasWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__curseMediaAliasWithId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__curseMediaAliasWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__curseMediaAliasWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__curseMediaAliasWithId %p -> %p\n", q, p));
	*(struct __tns__curseMediaAliasWithId*)p = *(struct __tns__curseMediaAliasWithId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__chat(struct soap *soap, struct __tns__chat *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__chat_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__chat(struct soap *soap, const struct __tns__chat *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__chat(soap, &a->tns__chat_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__chat(struct soap *soap, const char *tag, int id, const struct __tns__chat *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__chat(soap, "tns:chat", -1, &a->tns__chat_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__chat * SOAP_FMAC4 soap_in___tns__chat(struct soap *soap, const char *tag, struct __tns__chat *a, const char *type)
{
	size_t soap_flag_tns__chat_ = 1;
	short soap_flag;
	a = (struct __tns__chat *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__chat, sizeof(struct __tns__chat), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__chat(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__chat_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__chat(soap, "tns:chat", &a->tns__chat_, "tns:chat"))
				{	soap_flag_tns__chat_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__chat(struct soap *soap, const struct __tns__chat *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__chat(soap, tag?tag:"-tns:chat", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__chat * SOAP_FMAC4 soap_get___tns__chat(struct soap *soap, struct __tns__chat *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__chat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__chat * SOAP_FMAC2 soap_instantiate___tns__chat(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__chat(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__chat, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__chat);
		if (size)
			*size = sizeof(struct __tns__chat);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__chat[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__chat);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__chat*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__chat(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__chat %p -> %p\n", q, p));
	*(struct __tns__chat*)p = *(struct __tns__chat*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__blockUserWithId(struct soap *soap, struct __tns__blockUserWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__blockUserWithId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__blockUserWithId(struct soap *soap, const struct __tns__blockUserWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__blockUserWithId(soap, &a->tns__blockUserWithId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__blockUserWithId(struct soap *soap, const char *tag, int id, const struct __tns__blockUserWithId *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__blockUserWithId(soap, "tns:blockUserWithId", -1, &a->tns__blockUserWithId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__blockUserWithId * SOAP_FMAC4 soap_in___tns__blockUserWithId(struct soap *soap, const char *tag, struct __tns__blockUserWithId *a, const char *type)
{
	size_t soap_flag_tns__blockUserWithId_ = 1;
	short soap_flag;
	a = (struct __tns__blockUserWithId *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__blockUserWithId, sizeof(struct __tns__blockUserWithId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__blockUserWithId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__blockUserWithId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__blockUserWithId(soap, "tns:blockUserWithId", &a->tns__blockUserWithId_, "tns:blockUserWithId"))
				{	soap_flag_tns__blockUserWithId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__blockUserWithId(struct soap *soap, const struct __tns__blockUserWithId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__blockUserWithId(soap, tag?tag:"-tns:blockUserWithId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__blockUserWithId * SOAP_FMAC4 soap_get___tns__blockUserWithId(struct soap *soap, struct __tns__blockUserWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__blockUserWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__blockUserWithId * SOAP_FMAC2 soap_instantiate___tns__blockUserWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__blockUserWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__blockUserWithId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__blockUserWithId);
		if (size)
			*size = sizeof(struct __tns__blockUserWithId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__blockUserWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__blockUserWithId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__blockUserWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__blockUserWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__blockUserWithId %p -> %p\n", q, p));
	*(struct __tns__blockUserWithId*)p = *(struct __tns__blockUserWithId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__blockMediaAnnotationWithId(struct soap *soap, struct __tns__blockMediaAnnotationWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__blockMediaAnnotationWithId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__blockMediaAnnotationWithId(struct soap *soap, const struct __tns__blockMediaAnnotationWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__blockMediaAnnotationWithId(soap, &a->tns__blockMediaAnnotationWithId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__blockMediaAnnotationWithId(struct soap *soap, const char *tag, int id, const struct __tns__blockMediaAnnotationWithId *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__blockMediaAnnotationWithId(soap, "tns:blockMediaAnnotationWithId", -1, &a->tns__blockMediaAnnotationWithId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__blockMediaAnnotationWithId * SOAP_FMAC4 soap_in___tns__blockMediaAnnotationWithId(struct soap *soap, const char *tag, struct __tns__blockMediaAnnotationWithId *a, const char *type)
{
	size_t soap_flag_tns__blockMediaAnnotationWithId_ = 1;
	short soap_flag;
	a = (struct __tns__blockMediaAnnotationWithId *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__blockMediaAnnotationWithId, sizeof(struct __tns__blockMediaAnnotationWithId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__blockMediaAnnotationWithId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__blockMediaAnnotationWithId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__blockMediaAnnotationWithId(soap, "tns:blockMediaAnnotationWithId", &a->tns__blockMediaAnnotationWithId_, "tns:blockMediaAnnotationWithId"))
				{	soap_flag_tns__blockMediaAnnotationWithId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__blockMediaAnnotationWithId(struct soap *soap, const struct __tns__blockMediaAnnotationWithId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__blockMediaAnnotationWithId(soap, tag?tag:"-tns:blockMediaAnnotationWithId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__blockMediaAnnotationWithId * SOAP_FMAC4 soap_get___tns__blockMediaAnnotationWithId(struct soap *soap, struct __tns__blockMediaAnnotationWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__blockMediaAnnotationWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__blockMediaAnnotationWithId * SOAP_FMAC2 soap_instantiate___tns__blockMediaAnnotationWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__blockMediaAnnotationWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__blockMediaAnnotationWithId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__blockMediaAnnotationWithId);
		if (size)
			*size = sizeof(struct __tns__blockMediaAnnotationWithId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__blockMediaAnnotationWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__blockMediaAnnotationWithId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__blockMediaAnnotationWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__blockMediaAnnotationWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__blockMediaAnnotationWithId %p -> %p\n", q, p));
	*(struct __tns__blockMediaAnnotationWithId*)p = *(struct __tns__blockMediaAnnotationWithId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__blockMediaAliasWithId(struct soap *soap, struct __tns__blockMediaAliasWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__blockMediaAliasWithId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__blockMediaAliasWithId(struct soap *soap, const struct __tns__blockMediaAliasWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__blockMediaAliasWithId(soap, &a->tns__blockMediaAliasWithId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__blockMediaAliasWithId(struct soap *soap, const char *tag, int id, const struct __tns__blockMediaAliasWithId *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__blockMediaAliasWithId(soap, "tns:blockMediaAliasWithId", -1, &a->tns__blockMediaAliasWithId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__blockMediaAliasWithId * SOAP_FMAC4 soap_in___tns__blockMediaAliasWithId(struct soap *soap, const char *tag, struct __tns__blockMediaAliasWithId *a, const char *type)
{
	size_t soap_flag_tns__blockMediaAliasWithId_ = 1;
	short soap_flag;
	a = (struct __tns__blockMediaAliasWithId *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__blockMediaAliasWithId, sizeof(struct __tns__blockMediaAliasWithId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__blockMediaAliasWithId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__blockMediaAliasWithId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__blockMediaAliasWithId(soap, "tns:blockMediaAliasWithId", &a->tns__blockMediaAliasWithId_, "tns:blockMediaAliasWithId"))
				{	soap_flag_tns__blockMediaAliasWithId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__blockMediaAliasWithId(struct soap *soap, const struct __tns__blockMediaAliasWithId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__blockMediaAliasWithId(soap, tag?tag:"-tns:blockMediaAliasWithId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__blockMediaAliasWithId * SOAP_FMAC4 soap_get___tns__blockMediaAliasWithId(struct soap *soap, struct __tns__blockMediaAliasWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__blockMediaAliasWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__blockMediaAliasWithId * SOAP_FMAC2 soap_instantiate___tns__blockMediaAliasWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__blockMediaAliasWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__blockMediaAliasWithId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__blockMediaAliasWithId);
		if (size)
			*size = sizeof(struct __tns__blockMediaAliasWithId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__blockMediaAliasWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__blockMediaAliasWithId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__blockMediaAliasWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__blockMediaAliasWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__blockMediaAliasWithId %p -> %p\n", q, p));
	*(struct __tns__blockMediaAliasWithId*)p = *(struct __tns__blockMediaAliasWithId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__blessMediaTokenWithId(struct soap *soap, struct __tns__blessMediaTokenWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__blessMediaTokenWithId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__blessMediaTokenWithId(struct soap *soap, const struct __tns__blessMediaTokenWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__blessMediaTokenWithId(soap, &a->tns__blessMediaTokenWithId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__blessMediaTokenWithId(struct soap *soap, const char *tag, int id, const struct __tns__blessMediaTokenWithId *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__blessMediaTokenWithId(soap, "tns:blessMediaTokenWithId", -1, &a->tns__blessMediaTokenWithId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__blessMediaTokenWithId * SOAP_FMAC4 soap_in___tns__blessMediaTokenWithId(struct soap *soap, const char *tag, struct __tns__blessMediaTokenWithId *a, const char *type)
{
	size_t soap_flag_tns__blessMediaTokenWithId_ = 1;
	short soap_flag;
	a = (struct __tns__blessMediaTokenWithId *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__blessMediaTokenWithId, sizeof(struct __tns__blessMediaTokenWithId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__blessMediaTokenWithId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__blessMediaTokenWithId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__blessMediaTokenWithId(soap, "tns:blessMediaTokenWithId", &a->tns__blessMediaTokenWithId_, "tns:blessMediaTokenWithId"))
				{	soap_flag_tns__blessMediaTokenWithId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__blessMediaTokenWithId(struct soap *soap, const struct __tns__blessMediaTokenWithId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__blessMediaTokenWithId(soap, tag?tag:"-tns:blessMediaTokenWithId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__blessMediaTokenWithId * SOAP_FMAC4 soap_get___tns__blessMediaTokenWithId(struct soap *soap, struct __tns__blessMediaTokenWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__blessMediaTokenWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__blessMediaTokenWithId * SOAP_FMAC2 soap_instantiate___tns__blessMediaTokenWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__blessMediaTokenWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__blessMediaTokenWithId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__blessMediaTokenWithId);
		if (size)
			*size = sizeof(struct __tns__blessMediaTokenWithId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__blessMediaTokenWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__blessMediaTokenWithId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__blessMediaTokenWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__blessMediaTokenWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__blessMediaTokenWithId %p -> %p\n", q, p));
	*(struct __tns__blessMediaTokenWithId*)p = *(struct __tns__blessMediaTokenWithId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__blessMediaAnnotationWithId(struct soap *soap, struct __tns__blessMediaAnnotationWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__blessMediaAnnotationWithId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__blessMediaAnnotationWithId(struct soap *soap, const struct __tns__blessMediaAnnotationWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__blessMediaAnnotationWithId(soap, &a->tns__blessMediaAnnotationWithId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__blessMediaAnnotationWithId(struct soap *soap, const char *tag, int id, const struct __tns__blessMediaAnnotationWithId *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__blessMediaAnnotationWithId(soap, "tns:blessMediaAnnotationWithId", -1, &a->tns__blessMediaAnnotationWithId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__blessMediaAnnotationWithId * SOAP_FMAC4 soap_in___tns__blessMediaAnnotationWithId(struct soap *soap, const char *tag, struct __tns__blessMediaAnnotationWithId *a, const char *type)
{
	size_t soap_flag_tns__blessMediaAnnotationWithId_ = 1;
	short soap_flag;
	a = (struct __tns__blessMediaAnnotationWithId *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__blessMediaAnnotationWithId, sizeof(struct __tns__blessMediaAnnotationWithId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__blessMediaAnnotationWithId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__blessMediaAnnotationWithId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__blessMediaAnnotationWithId(soap, "tns:blessMediaAnnotationWithId", &a->tns__blessMediaAnnotationWithId_, "tns:blessMediaAnnotationWithId"))
				{	soap_flag_tns__blessMediaAnnotationWithId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__blessMediaAnnotationWithId(struct soap *soap, const struct __tns__blessMediaAnnotationWithId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__blessMediaAnnotationWithId(soap, tag?tag:"-tns:blessMediaAnnotationWithId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__blessMediaAnnotationWithId * SOAP_FMAC4 soap_get___tns__blessMediaAnnotationWithId(struct soap *soap, struct __tns__blessMediaAnnotationWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__blessMediaAnnotationWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__blessMediaAnnotationWithId * SOAP_FMAC2 soap_instantiate___tns__blessMediaAnnotationWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__blessMediaAnnotationWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__blessMediaAnnotationWithId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__blessMediaAnnotationWithId);
		if (size)
			*size = sizeof(struct __tns__blessMediaAnnotationWithId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__blessMediaAnnotationWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__blessMediaAnnotationWithId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__blessMediaAnnotationWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__blessMediaAnnotationWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__blessMediaAnnotationWithId %p -> %p\n", q, p));
	*(struct __tns__blessMediaAnnotationWithId*)p = *(struct __tns__blessMediaAnnotationWithId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tns__blessMediaAliasWithId(struct soap *soap, struct __tns__blessMediaAliasWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tns__blessMediaAliasWithId_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tns__blessMediaAliasWithId(struct soap *soap, const struct __tns__blessMediaAliasWithId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotns__blessMediaAliasWithId(soap, &a->tns__blessMediaAliasWithId_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tns__blessMediaAliasWithId(struct soap *soap, const char *tag, int id, const struct __tns__blessMediaAliasWithId *a, const char *type)
{	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTotns__blessMediaAliasWithId(soap, "tns:blessMediaAliasWithId", -1, &a->tns__blessMediaAliasWithId_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__blessMediaAliasWithId * SOAP_FMAC4 soap_in___tns__blessMediaAliasWithId(struct soap *soap, const char *tag, struct __tns__blessMediaAliasWithId *a, const char *type)
{
	size_t soap_flag_tns__blessMediaAliasWithId_ = 1;
	short soap_flag;
	a = (struct __tns__blessMediaAliasWithId *)soap_id_enter(soap, "", a, SOAP_TYPE_ServerSoap___tns__blessMediaAliasWithId, sizeof(struct __tns__blessMediaAliasWithId), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tns__blessMediaAliasWithId(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tns__blessMediaAliasWithId_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotns__blessMediaAliasWithId(soap, "tns:blessMediaAliasWithId", &a->tns__blessMediaAliasWithId_, "tns:blessMediaAliasWithId"))
				{	soap_flag_tns__blessMediaAliasWithId_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tns__blessMediaAliasWithId(struct soap *soap, const struct __tns__blessMediaAliasWithId *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tns__blessMediaAliasWithId(soap, tag?tag:"-tns:blessMediaAliasWithId", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tns__blessMediaAliasWithId * SOAP_FMAC4 soap_get___tns__blessMediaAliasWithId(struct soap *soap, struct __tns__blessMediaAliasWithId *p, const char *tag, const char *type)
{
	if ((p = soap_in___tns__blessMediaAliasWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tns__blessMediaAliasWithId * SOAP_FMAC2 soap_instantiate___tns__blessMediaAliasWithId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tns__blessMediaAliasWithId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap___tns__blessMediaAliasWithId, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__blessMediaAliasWithId);
		if (size)
			*size = sizeof(struct __tns__blessMediaAliasWithId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __tns__blessMediaAliasWithId[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __tns__blessMediaAliasWithId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __tns__blessMediaAliasWithId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tns__blessMediaAliasWithId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tns__blessMediaAliasWithId %p -> %p\n", q, p));
	*(struct __tns__blessMediaAliasWithId*)p = *(struct __tns__blessMediaAliasWithId*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__updateMediaAnnotationTextWithIdResponse(struct soap *soap, tns__updateMediaAnnotationTextWithIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__updateMediaAnnotationTextWithIdResponse(struct soap *soap, const char *tag, int id, tns__updateMediaAnnotationTextWithIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__updateMediaAnnotationTextWithIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__updateMediaAnnotationTextWithIdResponse(struct soap *soap, const char *tag, tns__updateMediaAnnotationTextWithIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__updateMediaAnnotationTextWithIdResponse **)soap_malloc(soap, sizeof(tns__updateMediaAnnotationTextWithIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__updateMediaAnnotationTextWithIdResponse *)soap_instantiate_tns__updateMediaAnnotationTextWithIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__updateMediaAnnotationTextWithIdResponse ** p = (tns__updateMediaAnnotationTextWithIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithIdResponse, sizeof(tns__updateMediaAnnotationTextWithIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__updateMediaAnnotationTextWithIdResponse(struct soap *soap, tns__updateMediaAnnotationTextWithIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__updateMediaAnnotationTextWithIdResponse);
	if (soap_out_PointerTotns__updateMediaAnnotationTextWithIdResponse(soap, tag?tag:"tns:updateMediaAnnotationTextWithIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__updateMediaAnnotationTextWithIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__updateMediaAnnotationTextWithIdResponse(struct soap *soap, tns__updateMediaAnnotationTextWithIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__updateMediaAnnotationTextWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__updateMediaAnnotationTextWithId(struct soap *soap, tns__updateMediaAnnotationTextWithId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__updateMediaAnnotationTextWithId(struct soap *soap, const char *tag, int id, tns__updateMediaAnnotationTextWithId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__updateMediaAnnotationTextWithId ** SOAP_FMAC4 soap_in_PointerTotns__updateMediaAnnotationTextWithId(struct soap *soap, const char *tag, tns__updateMediaAnnotationTextWithId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__updateMediaAnnotationTextWithId **)soap_malloc(soap, sizeof(tns__updateMediaAnnotationTextWithId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__updateMediaAnnotationTextWithId *)soap_instantiate_tns__updateMediaAnnotationTextWithId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__updateMediaAnnotationTextWithId ** p = (tns__updateMediaAnnotationTextWithId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithId, sizeof(tns__updateMediaAnnotationTextWithId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__updateMediaAnnotationTextWithId(struct soap *soap, tns__updateMediaAnnotationTextWithId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__updateMediaAnnotationTextWithId);
	if (soap_out_PointerTotns__updateMediaAnnotationTextWithId(soap, tag?tag:"tns:updateMediaAnnotationTextWithId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__updateMediaAnnotationTextWithId ** SOAP_FMAC4 soap_get_PointerTotns__updateMediaAnnotationTextWithId(struct soap *soap, tns__updateMediaAnnotationTextWithId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__updateMediaAnnotationTextWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaTokenDigestResponse(struct soap *soap, tns__submitMediaTokenDigestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigestResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaTokenDigestResponse(struct soap *soap, const char *tag, int id, tns__submitMediaTokenDigestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigestResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaTokenDigestResponse ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaTokenDigestResponse(struct soap *soap, const char *tag, tns__submitMediaTokenDigestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaTokenDigestResponse **)soap_malloc(soap, sizeof(tns__submitMediaTokenDigestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaTokenDigestResponse *)soap_instantiate_tns__submitMediaTokenDigestResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaTokenDigestResponse ** p = (tns__submitMediaTokenDigestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigestResponse, sizeof(tns__submitMediaTokenDigestResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaTokenDigestResponse(struct soap *soap, tns__submitMediaTokenDigestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitMediaTokenDigestResponse);
	if (soap_out_PointerTotns__submitMediaTokenDigestResponse(soap, tag?tag:"tns:submitMediaTokenDigestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaTokenDigestResponse ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaTokenDigestResponse(struct soap *soap, tns__submitMediaTokenDigestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaTokenDigestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaTokenDigest(struct soap *soap, tns__submitMediaTokenDigest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaTokenDigest(struct soap *soap, const char *tag, int id, tns__submitMediaTokenDigest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaTokenDigest ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaTokenDigest(struct soap *soap, const char *tag, tns__submitMediaTokenDigest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaTokenDigest **)soap_malloc(soap, sizeof(tns__submitMediaTokenDigest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaTokenDigest *)soap_instantiate_tns__submitMediaTokenDigest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaTokenDigest ** p = (tns__submitMediaTokenDigest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigest, sizeof(tns__submitMediaTokenDigest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaTokenDigest(struct soap *soap, tns__submitMediaTokenDigest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitMediaTokenDigest);
	if (soap_out_PointerTotns__submitMediaTokenDigest(soap, tag?tag:"tns:submitMediaTokenDigest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaTokenDigest ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaTokenDigest(struct soap *soap, tns__submitMediaTokenDigest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaTokenDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaTokenResponse(struct soap *soap, tns__submitMediaTokenResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitMediaTokenResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaTokenResponse(struct soap *soap, const char *tag, int id, tns__submitMediaTokenResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitMediaTokenResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaTokenResponse ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaTokenResponse(struct soap *soap, const char *tag, tns__submitMediaTokenResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaTokenResponse **)soap_malloc(soap, sizeof(tns__submitMediaTokenResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaTokenResponse *)soap_instantiate_tns__submitMediaTokenResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaTokenResponse ** p = (tns__submitMediaTokenResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitMediaTokenResponse, sizeof(tns__submitMediaTokenResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaTokenResponse(struct soap *soap, tns__submitMediaTokenResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitMediaTokenResponse);
	if (soap_out_PointerTotns__submitMediaTokenResponse(soap, tag?tag:"tns:submitMediaTokenResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaTokenResponse ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaTokenResponse(struct soap *soap, tns__submitMediaTokenResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaTokenResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaToken(struct soap *soap, tns__submitMediaToken *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitMediaToken))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaToken(struct soap *soap, const char *tag, int id, tns__submitMediaToken *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitMediaToken);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaToken ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaToken(struct soap *soap, const char *tag, tns__submitMediaToken **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaToken **)soap_malloc(soap, sizeof(tns__submitMediaToken *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaToken *)soap_instantiate_tns__submitMediaToken(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaToken ** p = (tns__submitMediaToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitMediaToken, sizeof(tns__submitMediaToken), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaToken(struct soap *soap, tns__submitMediaToken *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitMediaToken);
	if (soap_out_PointerTotns__submitMediaToken(soap, tag?tag:"tns:submitMediaToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaToken ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaToken(struct soap *soap, tns__submitMediaToken **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse(struct soap *soap, tns__submitMediaAnnotationTextWithTokenIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse(struct soap *soap, const char *tag, int id, tns__submitMediaAnnotationTextWithTokenIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextWithTokenIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse(struct soap *soap, const char *tag, tns__submitMediaAnnotationTextWithTokenIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaAnnotationTextWithTokenIdResponse **)soap_malloc(soap, sizeof(tns__submitMediaAnnotationTextWithTokenIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaAnnotationTextWithTokenIdResponse *)soap_instantiate_tns__submitMediaAnnotationTextWithTokenIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaAnnotationTextWithTokenIdResponse ** p = (tns__submitMediaAnnotationTextWithTokenIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenIdResponse, sizeof(tns__submitMediaAnnotationTextWithTokenIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse(struct soap *soap, tns__submitMediaAnnotationTextWithTokenIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse);
	if (soap_out_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse(soap, tag?tag:"tns:submitMediaAnnotationTextWithTokenIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextWithTokenIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse(struct soap *soap, tns__submitMediaAnnotationTextWithTokenIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaAnnotationTextWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaAnnotationTextWithTokenId(struct soap *soap, tns__submitMediaAnnotationTextWithTokenId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaAnnotationTextWithTokenId(struct soap *soap, const char *tag, int id, tns__submitMediaAnnotationTextWithTokenId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextWithTokenId ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaAnnotationTextWithTokenId(struct soap *soap, const char *tag, tns__submitMediaAnnotationTextWithTokenId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaAnnotationTextWithTokenId **)soap_malloc(soap, sizeof(tns__submitMediaAnnotationTextWithTokenId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaAnnotationTextWithTokenId *)soap_instantiate_tns__submitMediaAnnotationTextWithTokenId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaAnnotationTextWithTokenId ** p = (tns__submitMediaAnnotationTextWithTokenId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenId, sizeof(tns__submitMediaAnnotationTextWithTokenId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaAnnotationTextWithTokenId(struct soap *soap, tns__submitMediaAnnotationTextWithTokenId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotationTextWithTokenId);
	if (soap_out_PointerTotns__submitMediaAnnotationTextWithTokenId(soap, tag?tag:"tns:submitMediaAnnotationTextWithTokenId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextWithTokenId ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaAnnotationTextWithTokenId(struct soap *soap, tns__submitMediaAnnotationTextWithTokenId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaAnnotationTextWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse(struct soap *soap, tns__submitMediaAnnotationTextAndTokenDigestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigestResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse(struct soap *soap, const char *tag, int id, tns__submitMediaAnnotationTextAndTokenDigestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigestResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextAndTokenDigestResponse ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse(struct soap *soap, const char *tag, tns__submitMediaAnnotationTextAndTokenDigestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaAnnotationTextAndTokenDigestResponse **)soap_malloc(soap, sizeof(tns__submitMediaAnnotationTextAndTokenDigestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaAnnotationTextAndTokenDigestResponse *)soap_instantiate_tns__submitMediaAnnotationTextAndTokenDigestResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaAnnotationTextAndTokenDigestResponse ** p = (tns__submitMediaAnnotationTextAndTokenDigestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigestResponse, sizeof(tns__submitMediaAnnotationTextAndTokenDigestResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse(struct soap *soap, tns__submitMediaAnnotationTextAndTokenDigestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse);
	if (soap_out_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse(soap, tag?tag:"tns:submitMediaAnnotationTextAndTokenDigestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextAndTokenDigestResponse ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse(struct soap *soap, tns__submitMediaAnnotationTextAndTokenDigestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaAnnotationTextAndTokenDigestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, tns__submitMediaAnnotationTextAndTokenDigest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, const char *tag, int id, tns__submitMediaAnnotationTextAndTokenDigest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextAndTokenDigest ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, const char *tag, tns__submitMediaAnnotationTextAndTokenDigest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaAnnotationTextAndTokenDigest **)soap_malloc(soap, sizeof(tns__submitMediaAnnotationTextAndTokenDigest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaAnnotationTextAndTokenDigest *)soap_instantiate_tns__submitMediaAnnotationTextAndTokenDigest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaAnnotationTextAndTokenDigest ** p = (tns__submitMediaAnnotationTextAndTokenDigest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigest, sizeof(tns__submitMediaAnnotationTextAndTokenDigest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, tns__submitMediaAnnotationTextAndTokenDigest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotationTextAndTokenDigest);
	if (soap_out_PointerTotns__submitMediaAnnotationTextAndTokenDigest(soap, tag?tag:"tns:submitMediaAnnotationTextAndTokenDigest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaAnnotationTextAndTokenDigest ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaAnnotationTextAndTokenDigest(struct soap *soap, tns__submitMediaAnnotationTextAndTokenDigest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaAnnotationTextAndTokenDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaAnnotationResponse(struct soap *soap, tns__submitMediaAnnotationResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaAnnotationResponse(struct soap *soap, const char *tag, int id, tns__submitMediaAnnotationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaAnnotationResponse ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaAnnotationResponse(struct soap *soap, const char *tag, tns__submitMediaAnnotationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaAnnotationResponse **)soap_malloc(soap, sizeof(tns__submitMediaAnnotationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaAnnotationResponse *)soap_instantiate_tns__submitMediaAnnotationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaAnnotationResponse ** p = (tns__submitMediaAnnotationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationResponse, sizeof(tns__submitMediaAnnotationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaAnnotationResponse(struct soap *soap, tns__submitMediaAnnotationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotationResponse);
	if (soap_out_PointerTotns__submitMediaAnnotationResponse(soap, tag?tag:"tns:submitMediaAnnotationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaAnnotationResponse ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaAnnotationResponse(struct soap *soap, tns__submitMediaAnnotationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaAnnotationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaAnnotation(struct soap *soap, tns__submitMediaAnnotation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaAnnotation(struct soap *soap, const char *tag, int id, tns__submitMediaAnnotation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaAnnotation ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaAnnotation(struct soap *soap, const char *tag, tns__submitMediaAnnotation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaAnnotation **)soap_malloc(soap, sizeof(tns__submitMediaAnnotation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaAnnotation *)soap_instantiate_tns__submitMediaAnnotation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaAnnotation ** p = (tns__submitMediaAnnotation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitMediaAnnotation, sizeof(tns__submitMediaAnnotation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaAnnotation(struct soap *soap, tns__submitMediaAnnotation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAnnotation);
	if (soap_out_PointerTotns__submitMediaAnnotation(soap, tag?tag:"tns:submitMediaAnnotation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaAnnotation ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaAnnotation(struct soap *soap, tns__submitMediaAnnotation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaAnnotation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaAliasTextWithTokenIdResponse(struct soap *soap, tns__submitMediaAliasTextWithTokenIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaAliasTextWithTokenIdResponse(struct soap *soap, const char *tag, int id, tns__submitMediaAliasTextWithTokenIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaAliasTextWithTokenIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaAliasTextWithTokenIdResponse(struct soap *soap, const char *tag, tns__submitMediaAliasTextWithTokenIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaAliasTextWithTokenIdResponse **)soap_malloc(soap, sizeof(tns__submitMediaAliasTextWithTokenIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaAliasTextWithTokenIdResponse *)soap_instantiate_tns__submitMediaAliasTextWithTokenIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaAliasTextWithTokenIdResponse ** p = (tns__submitMediaAliasTextWithTokenIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenIdResponse, sizeof(tns__submitMediaAliasTextWithTokenIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaAliasTextWithTokenIdResponse(struct soap *soap, tns__submitMediaAliasTextWithTokenIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAliasTextWithTokenIdResponse);
	if (soap_out_PointerTotns__submitMediaAliasTextWithTokenIdResponse(soap, tag?tag:"tns:submitMediaAliasTextWithTokenIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaAliasTextWithTokenIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaAliasTextWithTokenIdResponse(struct soap *soap, tns__submitMediaAliasTextWithTokenIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaAliasTextWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaAliasTextWithTokenId(struct soap *soap, tns__submitMediaAliasTextWithTokenId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaAliasTextWithTokenId(struct soap *soap, const char *tag, int id, tns__submitMediaAliasTextWithTokenId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaAliasTextWithTokenId ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaAliasTextWithTokenId(struct soap *soap, const char *tag, tns__submitMediaAliasTextWithTokenId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaAliasTextWithTokenId **)soap_malloc(soap, sizeof(tns__submitMediaAliasTextWithTokenId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaAliasTextWithTokenId *)soap_instantiate_tns__submitMediaAliasTextWithTokenId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaAliasTextWithTokenId ** p = (tns__submitMediaAliasTextWithTokenId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenId, sizeof(tns__submitMediaAliasTextWithTokenId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaAliasTextWithTokenId(struct soap *soap, tns__submitMediaAliasTextWithTokenId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAliasTextWithTokenId);
	if (soap_out_PointerTotns__submitMediaAliasTextWithTokenId(soap, tag?tag:"tns:submitMediaAliasTextWithTokenId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaAliasTextWithTokenId ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaAliasTextWithTokenId(struct soap *soap, tns__submitMediaAliasTextWithTokenId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaAliasTextWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaAliasTextAndTokenDigestResponse(struct soap *soap, tns__submitMediaAliasTextAndTokenDigestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigestResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaAliasTextAndTokenDigestResponse(struct soap *soap, const char *tag, int id, tns__submitMediaAliasTextAndTokenDigestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigestResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaAliasTextAndTokenDigestResponse ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaAliasTextAndTokenDigestResponse(struct soap *soap, const char *tag, tns__submitMediaAliasTextAndTokenDigestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaAliasTextAndTokenDigestResponse **)soap_malloc(soap, sizeof(tns__submitMediaAliasTextAndTokenDigestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaAliasTextAndTokenDigestResponse *)soap_instantiate_tns__submitMediaAliasTextAndTokenDigestResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaAliasTextAndTokenDigestResponse ** p = (tns__submitMediaAliasTextAndTokenDigestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigestResponse, sizeof(tns__submitMediaAliasTextAndTokenDigestResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaAliasTextAndTokenDigestResponse(struct soap *soap, tns__submitMediaAliasTextAndTokenDigestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAliasTextAndTokenDigestResponse);
	if (soap_out_PointerTotns__submitMediaAliasTextAndTokenDigestResponse(soap, tag?tag:"tns:submitMediaAliasTextAndTokenDigestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaAliasTextAndTokenDigestResponse ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaAliasTextAndTokenDigestResponse(struct soap *soap, tns__submitMediaAliasTextAndTokenDigestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaAliasTextAndTokenDigestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaAliasTextAndTokenDigest(struct soap *soap, tns__submitMediaAliasTextAndTokenDigest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaAliasTextAndTokenDigest(struct soap *soap, const char *tag, int id, tns__submitMediaAliasTextAndTokenDigest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaAliasTextAndTokenDigest ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaAliasTextAndTokenDigest(struct soap *soap, const char *tag, tns__submitMediaAliasTextAndTokenDigest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaAliasTextAndTokenDigest **)soap_malloc(soap, sizeof(tns__submitMediaAliasTextAndTokenDigest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaAliasTextAndTokenDigest *)soap_instantiate_tns__submitMediaAliasTextAndTokenDigest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaAliasTextAndTokenDigest ** p = (tns__submitMediaAliasTextAndTokenDigest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigest, sizeof(tns__submitMediaAliasTextAndTokenDigest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaAliasTextAndTokenDigest(struct soap *soap, tns__submitMediaAliasTextAndTokenDigest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAliasTextAndTokenDigest);
	if (soap_out_PointerTotns__submitMediaAliasTextAndTokenDigest(soap, tag?tag:"tns:submitMediaAliasTextAndTokenDigest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaAliasTextAndTokenDigest ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaAliasTextAndTokenDigest(struct soap *soap, tns__submitMediaAliasTextAndTokenDigest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaAliasTextAndTokenDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaAliasResponse(struct soap *soap, tns__submitMediaAliasResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitMediaAliasResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaAliasResponse(struct soap *soap, const char *tag, int id, tns__submitMediaAliasResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitMediaAliasResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaAliasResponse ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaAliasResponse(struct soap *soap, const char *tag, tns__submitMediaAliasResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaAliasResponse **)soap_malloc(soap, sizeof(tns__submitMediaAliasResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaAliasResponse *)soap_instantiate_tns__submitMediaAliasResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaAliasResponse ** p = (tns__submitMediaAliasResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitMediaAliasResponse, sizeof(tns__submitMediaAliasResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaAliasResponse(struct soap *soap, tns__submitMediaAliasResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAliasResponse);
	if (soap_out_PointerTotns__submitMediaAliasResponse(soap, tag?tag:"tns:submitMediaAliasResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaAliasResponse ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaAliasResponse(struct soap *soap, tns__submitMediaAliasResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaAliasResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__submitMediaAlias(struct soap *soap, tns__submitMediaAlias *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__submitMediaAlias))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__submitMediaAlias(struct soap *soap, const char *tag, int id, tns__submitMediaAlias *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__submitMediaAlias);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__submitMediaAlias ** SOAP_FMAC4 soap_in_PointerTotns__submitMediaAlias(struct soap *soap, const char *tag, tns__submitMediaAlias **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__submitMediaAlias **)soap_malloc(soap, sizeof(tns__submitMediaAlias *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__submitMediaAlias *)soap_instantiate_tns__submitMediaAlias(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__submitMediaAlias ** p = (tns__submitMediaAlias **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__submitMediaAlias, sizeof(tns__submitMediaAlias), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__submitMediaAlias(struct soap *soap, tns__submitMediaAlias *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__submitMediaAlias);
	if (soap_out_PointerTotns__submitMediaAlias(soap, tag?tag:"tns:submitMediaAlias", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__submitMediaAlias ** SOAP_FMAC4 soap_get_PointerTotns__submitMediaAlias(struct soap *soap, tns__submitMediaAlias **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__submitMediaAlias(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__setUserLanguageResponse(struct soap *soap, tns__setUserLanguageResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__setUserLanguageResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__setUserLanguageResponse(struct soap *soap, const char *tag, int id, tns__setUserLanguageResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__setUserLanguageResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__setUserLanguageResponse ** SOAP_FMAC4 soap_in_PointerTotns__setUserLanguageResponse(struct soap *soap, const char *tag, tns__setUserLanguageResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__setUserLanguageResponse **)soap_malloc(soap, sizeof(tns__setUserLanguageResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__setUserLanguageResponse *)soap_instantiate_tns__setUserLanguageResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__setUserLanguageResponse ** p = (tns__setUserLanguageResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__setUserLanguageResponse, sizeof(tns__setUserLanguageResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__setUserLanguageResponse(struct soap *soap, tns__setUserLanguageResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__setUserLanguageResponse);
	if (soap_out_PointerTotns__setUserLanguageResponse(soap, tag?tag:"tns:setUserLanguageResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__setUserLanguageResponse ** SOAP_FMAC4 soap_get_PointerTotns__setUserLanguageResponse(struct soap *soap, tns__setUserLanguageResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__setUserLanguageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__setUserLanguage(struct soap *soap, tns__setUserLanguage *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__setUserLanguage))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__setUserLanguage(struct soap *soap, const char *tag, int id, tns__setUserLanguage *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__setUserLanguage);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__setUserLanguage ** SOAP_FMAC4 soap_in_PointerTotns__setUserLanguage(struct soap *soap, const char *tag, tns__setUserLanguage **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__setUserLanguage **)soap_malloc(soap, sizeof(tns__setUserLanguage *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__setUserLanguage *)soap_instantiate_tns__setUserLanguage(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__setUserLanguage ** p = (tns__setUserLanguage **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__setUserLanguage, sizeof(tns__setUserLanguage), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__setUserLanguage(struct soap *soap, tns__setUserLanguage *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__setUserLanguage);
	if (soap_out_PointerTotns__setUserLanguage(soap, tag?tag:"tns:setUserLanguage", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__setUserLanguage ** SOAP_FMAC4 soap_get_PointerTotns__setUserLanguage(struct soap *soap, tns__setUserLanguage **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__setUserLanguage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__setUserAnonymousResponse(struct soap *soap, tns__setUserAnonymousResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__setUserAnonymousResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__setUserAnonymousResponse(struct soap *soap, const char *tag, int id, tns__setUserAnonymousResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__setUserAnonymousResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__setUserAnonymousResponse ** SOAP_FMAC4 soap_in_PointerTotns__setUserAnonymousResponse(struct soap *soap, const char *tag, tns__setUserAnonymousResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__setUserAnonymousResponse **)soap_malloc(soap, sizeof(tns__setUserAnonymousResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__setUserAnonymousResponse *)soap_instantiate_tns__setUserAnonymousResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__setUserAnonymousResponse ** p = (tns__setUserAnonymousResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__setUserAnonymousResponse, sizeof(tns__setUserAnonymousResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__setUserAnonymousResponse(struct soap *soap, tns__setUserAnonymousResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__setUserAnonymousResponse);
	if (soap_out_PointerTotns__setUserAnonymousResponse(soap, tag?tag:"tns:setUserAnonymousResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__setUserAnonymousResponse ** SOAP_FMAC4 soap_get_PointerTotns__setUserAnonymousResponse(struct soap *soap, tns__setUserAnonymousResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__setUserAnonymousResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__setUserAnonymous(struct soap *soap, tns__setUserAnonymous *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__setUserAnonymous))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__setUserAnonymous(struct soap *soap, const char *tag, int id, tns__setUserAnonymous *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__setUserAnonymous);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__setUserAnonymous ** SOAP_FMAC4 soap_in_PointerTotns__setUserAnonymous(struct soap *soap, const char *tag, tns__setUserAnonymous **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__setUserAnonymous **)soap_malloc(soap, sizeof(tns__setUserAnonymous *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__setUserAnonymous *)soap_instantiate_tns__setUserAnonymous(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__setUserAnonymous ** p = (tns__setUserAnonymous **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__setUserAnonymous, sizeof(tns__setUserAnonymous), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__setUserAnonymous(struct soap *soap, tns__setUserAnonymous *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__setUserAnonymous);
	if (soap_out_PointerTotns__setUserAnonymous(soap, tag?tag:"tns:setUserAnonymous", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__setUserAnonymous ** SOAP_FMAC4 soap_get_PointerTotns__setUserAnonymous(struct soap *soap, tns__setUserAnonymous **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__setUserAnonymous(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectUserResponse(struct soap *soap, tns__selectUserResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__selectUserResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectUserResponse(struct soap *soap, const char *tag, int id, tns__selectUserResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__selectUserResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectUserResponse ** SOAP_FMAC4 soap_in_PointerTotns__selectUserResponse(struct soap *soap, const char *tag, tns__selectUserResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectUserResponse **)soap_malloc(soap, sizeof(tns__selectUserResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectUserResponse *)soap_instantiate_tns__selectUserResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectUserResponse ** p = (tns__selectUserResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__selectUserResponse, sizeof(tns__selectUserResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectUserResponse(struct soap *soap, tns__selectUserResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__selectUserResponse);
	if (soap_out_PointerTotns__selectUserResponse(soap, tag?tag:"tns:selectUserResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectUserResponse ** SOAP_FMAC4 soap_get_PointerTotns__selectUserResponse(struct soap *soap, tns__selectUserResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectUser(struct soap *soap, tns__selectUser *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__selectUser))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectUser(struct soap *soap, const char *tag, int id, tns__selectUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__selectUser);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectUser ** SOAP_FMAC4 soap_in_PointerTotns__selectUser(struct soap *soap, const char *tag, tns__selectUser **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectUser **)soap_malloc(soap, sizeof(tns__selectUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectUser *)soap_instantiate_tns__selectUser(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectUser ** p = (tns__selectUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__selectUser, sizeof(tns__selectUser), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectUser(struct soap *soap, tns__selectUser *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__selectUser);
	if (soap_out_PointerTotns__selectUser(soap, tag?tag:"tns:selectUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectUser ** SOAP_FMAC4 soap_get_PointerTotns__selectUser(struct soap *soap, tns__selectUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse(struct soap *soap, tns__selectRelatedMediaAnnotationsWithTokenIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse(struct soap *soap, const char *tag, int id, tns__selectRelatedMediaAnnotationsWithTokenIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectRelatedMediaAnnotationsWithTokenIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse(struct soap *soap, const char *tag, tns__selectRelatedMediaAnnotationsWithTokenIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectRelatedMediaAnnotationsWithTokenIdResponse **)soap_malloc(soap, sizeof(tns__selectRelatedMediaAnnotationsWithTokenIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectRelatedMediaAnnotationsWithTokenIdResponse *)soap_instantiate_tns__selectRelatedMediaAnnotationsWithTokenIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectRelatedMediaAnnotationsWithTokenIdResponse ** p = (tns__selectRelatedMediaAnnotationsWithTokenIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenIdResponse, sizeof(tns__selectRelatedMediaAnnotationsWithTokenIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse(struct soap *soap, tns__selectRelatedMediaAnnotationsWithTokenIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse);
	if (soap_out_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse(soap, tag?tag:"tns:selectRelatedMediaAnnotationsWithTokenIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectRelatedMediaAnnotationsWithTokenIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse(struct soap *soap, tns__selectRelatedMediaAnnotationsWithTokenIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectRelatedMediaAnnotationsWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, tns__selectRelatedMediaAnnotationsWithTokenId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, const char *tag, int id, tns__selectRelatedMediaAnnotationsWithTokenId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectRelatedMediaAnnotationsWithTokenId ** SOAP_FMAC4 soap_in_PointerTotns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, const char *tag, tns__selectRelatedMediaAnnotationsWithTokenId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectRelatedMediaAnnotationsWithTokenId **)soap_malloc(soap, sizeof(tns__selectRelatedMediaAnnotationsWithTokenId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectRelatedMediaAnnotationsWithTokenId *)soap_instantiate_tns__selectRelatedMediaAnnotationsWithTokenId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectRelatedMediaAnnotationsWithTokenId ** p = (tns__selectRelatedMediaAnnotationsWithTokenId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenId, sizeof(tns__selectRelatedMediaAnnotationsWithTokenId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, tns__selectRelatedMediaAnnotationsWithTokenId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__selectRelatedMediaAnnotationsWithTokenId);
	if (soap_out_PointerTotns__selectRelatedMediaAnnotationsWithTokenId(soap, tag?tag:"tns:selectRelatedMediaAnnotationsWithTokenId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectRelatedMediaAnnotationsWithTokenId ** SOAP_FMAC4 soap_get_PointerTotns__selectRelatedMediaAnnotationsWithTokenId(struct soap *soap, tns__selectRelatedMediaAnnotationsWithTokenId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectRelatedMediaAnnotationsWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectMediaTokenWithIdResponse(struct soap *soap, tns__selectMediaTokenWithIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectMediaTokenWithIdResponse(struct soap *soap, const char *tag, int id, tns__selectMediaTokenWithIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectMediaTokenWithIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__selectMediaTokenWithIdResponse(struct soap *soap, const char *tag, tns__selectMediaTokenWithIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectMediaTokenWithIdResponse **)soap_malloc(soap, sizeof(tns__selectMediaTokenWithIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectMediaTokenWithIdResponse *)soap_instantiate_tns__selectMediaTokenWithIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectMediaTokenWithIdResponse ** p = (tns__selectMediaTokenWithIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithIdResponse, sizeof(tns__selectMediaTokenWithIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectMediaTokenWithIdResponse(struct soap *soap, tns__selectMediaTokenWithIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__selectMediaTokenWithIdResponse);
	if (soap_out_PointerTotns__selectMediaTokenWithIdResponse(soap, tag?tag:"tns:selectMediaTokenWithIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectMediaTokenWithIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__selectMediaTokenWithIdResponse(struct soap *soap, tns__selectMediaTokenWithIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectMediaTokenWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectMediaTokenWithId(struct soap *soap, tns__selectMediaTokenWithId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectMediaTokenWithId(struct soap *soap, const char *tag, int id, tns__selectMediaTokenWithId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectMediaTokenWithId ** SOAP_FMAC4 soap_in_PointerTotns__selectMediaTokenWithId(struct soap *soap, const char *tag, tns__selectMediaTokenWithId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectMediaTokenWithId **)soap_malloc(soap, sizeof(tns__selectMediaTokenWithId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectMediaTokenWithId *)soap_instantiate_tns__selectMediaTokenWithId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectMediaTokenWithId ** p = (tns__selectMediaTokenWithId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithId, sizeof(tns__selectMediaTokenWithId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectMediaTokenWithId(struct soap *soap, tns__selectMediaTokenWithId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__selectMediaTokenWithId);
	if (soap_out_PointerTotns__selectMediaTokenWithId(soap, tag?tag:"tns:selectMediaTokenWithId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectMediaTokenWithId ** SOAP_FMAC4 soap_get_PointerTotns__selectMediaTokenWithId(struct soap *soap, tns__selectMediaTokenWithId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectMediaTokenWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectMediaTokenWithDigestResponse(struct soap *soap, tns__selectMediaTokenWithDigestResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigestResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectMediaTokenWithDigestResponse(struct soap *soap, const char *tag, int id, tns__selectMediaTokenWithDigestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigestResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectMediaTokenWithDigestResponse ** SOAP_FMAC4 soap_in_PointerTotns__selectMediaTokenWithDigestResponse(struct soap *soap, const char *tag, tns__selectMediaTokenWithDigestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectMediaTokenWithDigestResponse **)soap_malloc(soap, sizeof(tns__selectMediaTokenWithDigestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectMediaTokenWithDigestResponse *)soap_instantiate_tns__selectMediaTokenWithDigestResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectMediaTokenWithDigestResponse ** p = (tns__selectMediaTokenWithDigestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigestResponse, sizeof(tns__selectMediaTokenWithDigestResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectMediaTokenWithDigestResponse(struct soap *soap, tns__selectMediaTokenWithDigestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__selectMediaTokenWithDigestResponse);
	if (soap_out_PointerTotns__selectMediaTokenWithDigestResponse(soap, tag?tag:"tns:selectMediaTokenWithDigestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectMediaTokenWithDigestResponse ** SOAP_FMAC4 soap_get_PointerTotns__selectMediaTokenWithDigestResponse(struct soap *soap, tns__selectMediaTokenWithDigestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectMediaTokenWithDigestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectMediaTokenWithDigest(struct soap *soap, tns__selectMediaTokenWithDigest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectMediaTokenWithDigest(struct soap *soap, const char *tag, int id, tns__selectMediaTokenWithDigest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectMediaTokenWithDigest ** SOAP_FMAC4 soap_in_PointerTotns__selectMediaTokenWithDigest(struct soap *soap, const char *tag, tns__selectMediaTokenWithDigest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectMediaTokenWithDigest **)soap_malloc(soap, sizeof(tns__selectMediaTokenWithDigest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectMediaTokenWithDigest *)soap_instantiate_tns__selectMediaTokenWithDigest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectMediaTokenWithDigest ** p = (tns__selectMediaTokenWithDigest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigest, sizeof(tns__selectMediaTokenWithDigest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectMediaTokenWithDigest(struct soap *soap, tns__selectMediaTokenWithDigest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__selectMediaTokenWithDigest);
	if (soap_out_PointerTotns__selectMediaTokenWithDigest(soap, tag?tag:"tns:selectMediaTokenWithDigest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectMediaTokenWithDigest ** SOAP_FMAC4 soap_get_PointerTotns__selectMediaTokenWithDigest(struct soap *soap, tns__selectMediaTokenWithDigest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectMediaTokenWithDigest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectMediaAnnotationsWithTokenIdResponse(struct soap *soap, tns__selectMediaAnnotationsWithTokenIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectMediaAnnotationsWithTokenIdResponse(struct soap *soap, const char *tag, int id, tns__selectMediaAnnotationsWithTokenIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectMediaAnnotationsWithTokenIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__selectMediaAnnotationsWithTokenIdResponse(struct soap *soap, const char *tag, tns__selectMediaAnnotationsWithTokenIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectMediaAnnotationsWithTokenIdResponse **)soap_malloc(soap, sizeof(tns__selectMediaAnnotationsWithTokenIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectMediaAnnotationsWithTokenIdResponse *)soap_instantiate_tns__selectMediaAnnotationsWithTokenIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectMediaAnnotationsWithTokenIdResponse ** p = (tns__selectMediaAnnotationsWithTokenIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenIdResponse, sizeof(tns__selectMediaAnnotationsWithTokenIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectMediaAnnotationsWithTokenIdResponse(struct soap *soap, tns__selectMediaAnnotationsWithTokenIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__selectMediaAnnotationsWithTokenIdResponse);
	if (soap_out_PointerTotns__selectMediaAnnotationsWithTokenIdResponse(soap, tag?tag:"tns:selectMediaAnnotationsWithTokenIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectMediaAnnotationsWithTokenIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__selectMediaAnnotationsWithTokenIdResponse(struct soap *soap, tns__selectMediaAnnotationsWithTokenIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectMediaAnnotationsWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectMediaAnnotationsWithTokenId(struct soap *soap, tns__selectMediaAnnotationsWithTokenId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectMediaAnnotationsWithTokenId(struct soap *soap, const char *tag, int id, tns__selectMediaAnnotationsWithTokenId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectMediaAnnotationsWithTokenId ** SOAP_FMAC4 soap_in_PointerTotns__selectMediaAnnotationsWithTokenId(struct soap *soap, const char *tag, tns__selectMediaAnnotationsWithTokenId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectMediaAnnotationsWithTokenId **)soap_malloc(soap, sizeof(tns__selectMediaAnnotationsWithTokenId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectMediaAnnotationsWithTokenId *)soap_instantiate_tns__selectMediaAnnotationsWithTokenId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectMediaAnnotationsWithTokenId ** p = (tns__selectMediaAnnotationsWithTokenId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenId, sizeof(tns__selectMediaAnnotationsWithTokenId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectMediaAnnotationsWithTokenId(struct soap *soap, tns__selectMediaAnnotationsWithTokenId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__selectMediaAnnotationsWithTokenId);
	if (soap_out_PointerTotns__selectMediaAnnotationsWithTokenId(soap, tag?tag:"tns:selectMediaAnnotationsWithTokenId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectMediaAnnotationsWithTokenId ** SOAP_FMAC4 soap_get_PointerTotns__selectMediaAnnotationsWithTokenId(struct soap *soap, tns__selectMediaAnnotationsWithTokenId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectMediaAnnotationsWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectMediaAliasesWithTokenIdResponse(struct soap *soap, tns__selectMediaAliasesWithTokenIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectMediaAliasesWithTokenIdResponse(struct soap *soap, const char *tag, int id, tns__selectMediaAliasesWithTokenIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectMediaAliasesWithTokenIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__selectMediaAliasesWithTokenIdResponse(struct soap *soap, const char *tag, tns__selectMediaAliasesWithTokenIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectMediaAliasesWithTokenIdResponse **)soap_malloc(soap, sizeof(tns__selectMediaAliasesWithTokenIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectMediaAliasesWithTokenIdResponse *)soap_instantiate_tns__selectMediaAliasesWithTokenIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectMediaAliasesWithTokenIdResponse ** p = (tns__selectMediaAliasesWithTokenIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenIdResponse, sizeof(tns__selectMediaAliasesWithTokenIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectMediaAliasesWithTokenIdResponse(struct soap *soap, tns__selectMediaAliasesWithTokenIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__selectMediaAliasesWithTokenIdResponse);
	if (soap_out_PointerTotns__selectMediaAliasesWithTokenIdResponse(soap, tag?tag:"tns:selectMediaAliasesWithTokenIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectMediaAliasesWithTokenIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__selectMediaAliasesWithTokenIdResponse(struct soap *soap, tns__selectMediaAliasesWithTokenIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectMediaAliasesWithTokenIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__selectMediaAliasesWithTokenId(struct soap *soap, tns__selectMediaAliasesWithTokenId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__selectMediaAliasesWithTokenId(struct soap *soap, const char *tag, int id, tns__selectMediaAliasesWithTokenId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__selectMediaAliasesWithTokenId ** SOAP_FMAC4 soap_in_PointerTotns__selectMediaAliasesWithTokenId(struct soap *soap, const char *tag, tns__selectMediaAliasesWithTokenId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__selectMediaAliasesWithTokenId **)soap_malloc(soap, sizeof(tns__selectMediaAliasesWithTokenId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__selectMediaAliasesWithTokenId *)soap_instantiate_tns__selectMediaAliasesWithTokenId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__selectMediaAliasesWithTokenId ** p = (tns__selectMediaAliasesWithTokenId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenId, sizeof(tns__selectMediaAliasesWithTokenId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__selectMediaAliasesWithTokenId(struct soap *soap, tns__selectMediaAliasesWithTokenId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__selectMediaAliasesWithTokenId);
	if (soap_out_PointerTotns__selectMediaAliasesWithTokenId(soap, tag?tag:"tns:selectMediaAliasesWithTokenId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__selectMediaAliasesWithTokenId ** SOAP_FMAC4 soap_get_PointerTotns__selectMediaAliasesWithTokenId(struct soap *soap, tns__selectMediaAliasesWithTokenId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__selectMediaAliasesWithTokenId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__isConnectedResponse(struct soap *soap, tns__isConnectedResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__isConnectedResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__isConnectedResponse(struct soap *soap, const char *tag, int id, tns__isConnectedResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__isConnectedResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__isConnectedResponse ** SOAP_FMAC4 soap_in_PointerTotns__isConnectedResponse(struct soap *soap, const char *tag, tns__isConnectedResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__isConnectedResponse **)soap_malloc(soap, sizeof(tns__isConnectedResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__isConnectedResponse *)soap_instantiate_tns__isConnectedResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__isConnectedResponse ** p = (tns__isConnectedResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__isConnectedResponse, sizeof(tns__isConnectedResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__isConnectedResponse(struct soap *soap, tns__isConnectedResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__isConnectedResponse);
	if (soap_out_PointerTotns__isConnectedResponse(soap, tag?tag:"tns:isConnectedResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__isConnectedResponse ** SOAP_FMAC4 soap_get_PointerTotns__isConnectedResponse(struct soap *soap, tns__isConnectedResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__isConnectedResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__isConnected(struct soap *soap, tns__isConnected *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__isConnected))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__isConnected(struct soap *soap, const char *tag, int id, tns__isConnected *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__isConnected);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__isConnected ** SOAP_FMAC4 soap_in_PointerTotns__isConnected(struct soap *soap, const char *tag, tns__isConnected **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__isConnected **)soap_malloc(soap, sizeof(tns__isConnected *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__isConnected *)soap_instantiate_tns__isConnected(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__isConnected ** p = (tns__isConnected **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__isConnected, sizeof(tns__isConnected), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__isConnected(struct soap *soap, tns__isConnected *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__isConnected);
	if (soap_out_PointerTotns__isConnected(soap, tag?tag:"tns:isConnected", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__isConnected ** SOAP_FMAC4 soap_get_PointerTotns__isConnected(struct soap *soap, tns__isConnected **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__isConnected(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__isClientUpdatedResponse(struct soap *soap, tns__isClientUpdatedResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__isClientUpdatedResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__isClientUpdatedResponse(struct soap *soap, const char *tag, int id, tns__isClientUpdatedResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__isClientUpdatedResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__isClientUpdatedResponse ** SOAP_FMAC4 soap_in_PointerTotns__isClientUpdatedResponse(struct soap *soap, const char *tag, tns__isClientUpdatedResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__isClientUpdatedResponse **)soap_malloc(soap, sizeof(tns__isClientUpdatedResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__isClientUpdatedResponse *)soap_instantiate_tns__isClientUpdatedResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__isClientUpdatedResponse ** p = (tns__isClientUpdatedResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__isClientUpdatedResponse, sizeof(tns__isClientUpdatedResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__isClientUpdatedResponse(struct soap *soap, tns__isClientUpdatedResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__isClientUpdatedResponse);
	if (soap_out_PointerTotns__isClientUpdatedResponse(soap, tag?tag:"tns:isClientUpdatedResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__isClientUpdatedResponse ** SOAP_FMAC4 soap_get_PointerTotns__isClientUpdatedResponse(struct soap *soap, tns__isClientUpdatedResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__isClientUpdatedResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__isClientUpdated(struct soap *soap, tns__isClientUpdated *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__isClientUpdated))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__isClientUpdated(struct soap *soap, const char *tag, int id, tns__isClientUpdated *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__isClientUpdated);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__isClientUpdated ** SOAP_FMAC4 soap_in_PointerTotns__isClientUpdated(struct soap *soap, const char *tag, tns__isClientUpdated **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__isClientUpdated **)soap_malloc(soap, sizeof(tns__isClientUpdated *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__isClientUpdated *)soap_instantiate_tns__isClientUpdated(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__isClientUpdated ** p = (tns__isClientUpdated **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__isClientUpdated, sizeof(tns__isClientUpdated), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__isClientUpdated(struct soap *soap, tns__isClientUpdated *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__isClientUpdated);
	if (soap_out_PointerTotns__isClientUpdated(soap, tag?tag:"tns:isClientUpdated", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__isClientUpdated ** SOAP_FMAC4 soap_get_PointerTotns__isClientUpdated(struct soap *soap, tns__isClientUpdated **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__isClientUpdated(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__curseMediaTokenWithIdResponse(struct soap *soap, tns__curseMediaTokenWithIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__curseMediaTokenWithIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__curseMediaTokenWithIdResponse(struct soap *soap, const char *tag, int id, tns__curseMediaTokenWithIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__curseMediaTokenWithIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__curseMediaTokenWithIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__curseMediaTokenWithIdResponse(struct soap *soap, const char *tag, tns__curseMediaTokenWithIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__curseMediaTokenWithIdResponse **)soap_malloc(soap, sizeof(tns__curseMediaTokenWithIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__curseMediaTokenWithIdResponse *)soap_instantiate_tns__curseMediaTokenWithIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__curseMediaTokenWithIdResponse ** p = (tns__curseMediaTokenWithIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__curseMediaTokenWithIdResponse, sizeof(tns__curseMediaTokenWithIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__curseMediaTokenWithIdResponse(struct soap *soap, tns__curseMediaTokenWithIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__curseMediaTokenWithIdResponse);
	if (soap_out_PointerTotns__curseMediaTokenWithIdResponse(soap, tag?tag:"tns:curseMediaTokenWithIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__curseMediaTokenWithIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__curseMediaTokenWithIdResponse(struct soap *soap, tns__curseMediaTokenWithIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__curseMediaTokenWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__curseMediaTokenWithId(struct soap *soap, tns__curseMediaTokenWithId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__curseMediaTokenWithId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__curseMediaTokenWithId(struct soap *soap, const char *tag, int id, tns__curseMediaTokenWithId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__curseMediaTokenWithId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__curseMediaTokenWithId ** SOAP_FMAC4 soap_in_PointerTotns__curseMediaTokenWithId(struct soap *soap, const char *tag, tns__curseMediaTokenWithId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__curseMediaTokenWithId **)soap_malloc(soap, sizeof(tns__curseMediaTokenWithId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__curseMediaTokenWithId *)soap_instantiate_tns__curseMediaTokenWithId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__curseMediaTokenWithId ** p = (tns__curseMediaTokenWithId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__curseMediaTokenWithId, sizeof(tns__curseMediaTokenWithId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__curseMediaTokenWithId(struct soap *soap, tns__curseMediaTokenWithId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__curseMediaTokenWithId);
	if (soap_out_PointerTotns__curseMediaTokenWithId(soap, tag?tag:"tns:curseMediaTokenWithId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__curseMediaTokenWithId ** SOAP_FMAC4 soap_get_PointerTotns__curseMediaTokenWithId(struct soap *soap, tns__curseMediaTokenWithId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__curseMediaTokenWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__curseMediaAnnotationWithIdResponse(struct soap *soap, tns__curseMediaAnnotationWithIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__curseMediaAnnotationWithIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__curseMediaAnnotationWithIdResponse(struct soap *soap, const char *tag, int id, tns__curseMediaAnnotationWithIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__curseMediaAnnotationWithIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__curseMediaAnnotationWithIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__curseMediaAnnotationWithIdResponse(struct soap *soap, const char *tag, tns__curseMediaAnnotationWithIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__curseMediaAnnotationWithIdResponse **)soap_malloc(soap, sizeof(tns__curseMediaAnnotationWithIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__curseMediaAnnotationWithIdResponse *)soap_instantiate_tns__curseMediaAnnotationWithIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__curseMediaAnnotationWithIdResponse ** p = (tns__curseMediaAnnotationWithIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__curseMediaAnnotationWithIdResponse, sizeof(tns__curseMediaAnnotationWithIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__curseMediaAnnotationWithIdResponse(struct soap *soap, tns__curseMediaAnnotationWithIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__curseMediaAnnotationWithIdResponse);
	if (soap_out_PointerTotns__curseMediaAnnotationWithIdResponse(soap, tag?tag:"tns:curseMediaAnnotationWithIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__curseMediaAnnotationWithIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__curseMediaAnnotationWithIdResponse(struct soap *soap, tns__curseMediaAnnotationWithIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__curseMediaAnnotationWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__curseMediaAnnotationWithId(struct soap *soap, tns__curseMediaAnnotationWithId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__curseMediaAnnotationWithId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__curseMediaAnnotationWithId(struct soap *soap, const char *tag, int id, tns__curseMediaAnnotationWithId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__curseMediaAnnotationWithId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__curseMediaAnnotationWithId ** SOAP_FMAC4 soap_in_PointerTotns__curseMediaAnnotationWithId(struct soap *soap, const char *tag, tns__curseMediaAnnotationWithId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__curseMediaAnnotationWithId **)soap_malloc(soap, sizeof(tns__curseMediaAnnotationWithId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__curseMediaAnnotationWithId *)soap_instantiate_tns__curseMediaAnnotationWithId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__curseMediaAnnotationWithId ** p = (tns__curseMediaAnnotationWithId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__curseMediaAnnotationWithId, sizeof(tns__curseMediaAnnotationWithId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__curseMediaAnnotationWithId(struct soap *soap, tns__curseMediaAnnotationWithId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__curseMediaAnnotationWithId);
	if (soap_out_PointerTotns__curseMediaAnnotationWithId(soap, tag?tag:"tns:curseMediaAnnotationWithId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__curseMediaAnnotationWithId ** SOAP_FMAC4 soap_get_PointerTotns__curseMediaAnnotationWithId(struct soap *soap, tns__curseMediaAnnotationWithId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__curseMediaAnnotationWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__curseMediaAliasWithIdResponse(struct soap *soap, tns__curseMediaAliasWithIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__curseMediaAliasWithIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__curseMediaAliasWithIdResponse(struct soap *soap, const char *tag, int id, tns__curseMediaAliasWithIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__curseMediaAliasWithIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__curseMediaAliasWithIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__curseMediaAliasWithIdResponse(struct soap *soap, const char *tag, tns__curseMediaAliasWithIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__curseMediaAliasWithIdResponse **)soap_malloc(soap, sizeof(tns__curseMediaAliasWithIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__curseMediaAliasWithIdResponse *)soap_instantiate_tns__curseMediaAliasWithIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__curseMediaAliasWithIdResponse ** p = (tns__curseMediaAliasWithIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__curseMediaAliasWithIdResponse, sizeof(tns__curseMediaAliasWithIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__curseMediaAliasWithIdResponse(struct soap *soap, tns__curseMediaAliasWithIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__curseMediaAliasWithIdResponse);
	if (soap_out_PointerTotns__curseMediaAliasWithIdResponse(soap, tag?tag:"tns:curseMediaAliasWithIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__curseMediaAliasWithIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__curseMediaAliasWithIdResponse(struct soap *soap, tns__curseMediaAliasWithIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__curseMediaAliasWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__curseMediaAliasWithId(struct soap *soap, tns__curseMediaAliasWithId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__curseMediaAliasWithId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__curseMediaAliasWithId(struct soap *soap, const char *tag, int id, tns__curseMediaAliasWithId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__curseMediaAliasWithId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__curseMediaAliasWithId ** SOAP_FMAC4 soap_in_PointerTotns__curseMediaAliasWithId(struct soap *soap, const char *tag, tns__curseMediaAliasWithId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__curseMediaAliasWithId **)soap_malloc(soap, sizeof(tns__curseMediaAliasWithId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__curseMediaAliasWithId *)soap_instantiate_tns__curseMediaAliasWithId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__curseMediaAliasWithId ** p = (tns__curseMediaAliasWithId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__curseMediaAliasWithId, sizeof(tns__curseMediaAliasWithId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__curseMediaAliasWithId(struct soap *soap, tns__curseMediaAliasWithId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__curseMediaAliasWithId);
	if (soap_out_PointerTotns__curseMediaAliasWithId(soap, tag?tag:"tns:curseMediaAliasWithId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__curseMediaAliasWithId ** SOAP_FMAC4 soap_get_PointerTotns__curseMediaAliasWithId(struct soap *soap, tns__curseMediaAliasWithId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__curseMediaAliasWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__chatResponse(struct soap *soap, tns__chatResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__chatResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__chatResponse(struct soap *soap, const char *tag, int id, tns__chatResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__chatResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__chatResponse ** SOAP_FMAC4 soap_in_PointerTotns__chatResponse(struct soap *soap, const char *tag, tns__chatResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__chatResponse **)soap_malloc(soap, sizeof(tns__chatResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__chatResponse *)soap_instantiate_tns__chatResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__chatResponse ** p = (tns__chatResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__chatResponse, sizeof(tns__chatResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__chatResponse(struct soap *soap, tns__chatResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__chatResponse);
	if (soap_out_PointerTotns__chatResponse(soap, tag?tag:"tns:chatResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__chatResponse ** SOAP_FMAC4 soap_get_PointerTotns__chatResponse(struct soap *soap, tns__chatResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__chatResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__chat(struct soap *soap, tns__chat *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__chat))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__chat(struct soap *soap, const char *tag, int id, tns__chat *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__chat);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__chat ** SOAP_FMAC4 soap_in_PointerTotns__chat(struct soap *soap, const char *tag, tns__chat **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__chat **)soap_malloc(soap, sizeof(tns__chat *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__chat *)soap_instantiate_tns__chat(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__chat ** p = (tns__chat **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__chat, sizeof(tns__chat), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__chat(struct soap *soap, tns__chat *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__chat);
	if (soap_out_PointerTotns__chat(soap, tag?tag:"tns:chat", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__chat ** SOAP_FMAC4 soap_get_PointerTotns__chat(struct soap *soap, tns__chat **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__chat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__blockUserWithIdResponse(struct soap *soap, tns__blockUserWithIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__blockUserWithIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__blockUserWithIdResponse(struct soap *soap, const char *tag, int id, tns__blockUserWithIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__blockUserWithIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__blockUserWithIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__blockUserWithIdResponse(struct soap *soap, const char *tag, tns__blockUserWithIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__blockUserWithIdResponse **)soap_malloc(soap, sizeof(tns__blockUserWithIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__blockUserWithIdResponse *)soap_instantiate_tns__blockUserWithIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__blockUserWithIdResponse ** p = (tns__blockUserWithIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__blockUserWithIdResponse, sizeof(tns__blockUserWithIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__blockUserWithIdResponse(struct soap *soap, tns__blockUserWithIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__blockUserWithIdResponse);
	if (soap_out_PointerTotns__blockUserWithIdResponse(soap, tag?tag:"tns:blockUserWithIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__blockUserWithIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__blockUserWithIdResponse(struct soap *soap, tns__blockUserWithIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__blockUserWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__blockUserWithId(struct soap *soap, tns__blockUserWithId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__blockUserWithId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__blockUserWithId(struct soap *soap, const char *tag, int id, tns__blockUserWithId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__blockUserWithId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__blockUserWithId ** SOAP_FMAC4 soap_in_PointerTotns__blockUserWithId(struct soap *soap, const char *tag, tns__blockUserWithId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__blockUserWithId **)soap_malloc(soap, sizeof(tns__blockUserWithId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__blockUserWithId *)soap_instantiate_tns__blockUserWithId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__blockUserWithId ** p = (tns__blockUserWithId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__blockUserWithId, sizeof(tns__blockUserWithId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__blockUserWithId(struct soap *soap, tns__blockUserWithId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__blockUserWithId);
	if (soap_out_PointerTotns__blockUserWithId(soap, tag?tag:"tns:blockUserWithId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__blockUserWithId ** SOAP_FMAC4 soap_get_PointerTotns__blockUserWithId(struct soap *soap, tns__blockUserWithId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__blockUserWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__blockMediaAnnotationWithIdResponse(struct soap *soap, tns__blockMediaAnnotationWithIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__blockMediaAnnotationWithIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__blockMediaAnnotationWithIdResponse(struct soap *soap, const char *tag, int id, tns__blockMediaAnnotationWithIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__blockMediaAnnotationWithIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__blockMediaAnnotationWithIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__blockMediaAnnotationWithIdResponse(struct soap *soap, const char *tag, tns__blockMediaAnnotationWithIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__blockMediaAnnotationWithIdResponse **)soap_malloc(soap, sizeof(tns__blockMediaAnnotationWithIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__blockMediaAnnotationWithIdResponse *)soap_instantiate_tns__blockMediaAnnotationWithIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__blockMediaAnnotationWithIdResponse ** p = (tns__blockMediaAnnotationWithIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__blockMediaAnnotationWithIdResponse, sizeof(tns__blockMediaAnnotationWithIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__blockMediaAnnotationWithIdResponse(struct soap *soap, tns__blockMediaAnnotationWithIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__blockMediaAnnotationWithIdResponse);
	if (soap_out_PointerTotns__blockMediaAnnotationWithIdResponse(soap, tag?tag:"tns:blockMediaAnnotationWithIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__blockMediaAnnotationWithIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__blockMediaAnnotationWithIdResponse(struct soap *soap, tns__blockMediaAnnotationWithIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__blockMediaAnnotationWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__blockMediaAnnotationWithId(struct soap *soap, tns__blockMediaAnnotationWithId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__blockMediaAnnotationWithId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__blockMediaAnnotationWithId(struct soap *soap, const char *tag, int id, tns__blockMediaAnnotationWithId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__blockMediaAnnotationWithId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__blockMediaAnnotationWithId ** SOAP_FMAC4 soap_in_PointerTotns__blockMediaAnnotationWithId(struct soap *soap, const char *tag, tns__blockMediaAnnotationWithId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__blockMediaAnnotationWithId **)soap_malloc(soap, sizeof(tns__blockMediaAnnotationWithId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__blockMediaAnnotationWithId *)soap_instantiate_tns__blockMediaAnnotationWithId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__blockMediaAnnotationWithId ** p = (tns__blockMediaAnnotationWithId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__blockMediaAnnotationWithId, sizeof(tns__blockMediaAnnotationWithId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__blockMediaAnnotationWithId(struct soap *soap, tns__blockMediaAnnotationWithId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__blockMediaAnnotationWithId);
	if (soap_out_PointerTotns__blockMediaAnnotationWithId(soap, tag?tag:"tns:blockMediaAnnotationWithId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__blockMediaAnnotationWithId ** SOAP_FMAC4 soap_get_PointerTotns__blockMediaAnnotationWithId(struct soap *soap, tns__blockMediaAnnotationWithId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__blockMediaAnnotationWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__blockMediaAliasWithIdResponse(struct soap *soap, tns__blockMediaAliasWithIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__blockMediaAliasWithIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__blockMediaAliasWithIdResponse(struct soap *soap, const char *tag, int id, tns__blockMediaAliasWithIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__blockMediaAliasWithIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__blockMediaAliasWithIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__blockMediaAliasWithIdResponse(struct soap *soap, const char *tag, tns__blockMediaAliasWithIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__blockMediaAliasWithIdResponse **)soap_malloc(soap, sizeof(tns__blockMediaAliasWithIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__blockMediaAliasWithIdResponse *)soap_instantiate_tns__blockMediaAliasWithIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__blockMediaAliasWithIdResponse ** p = (tns__blockMediaAliasWithIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__blockMediaAliasWithIdResponse, sizeof(tns__blockMediaAliasWithIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__blockMediaAliasWithIdResponse(struct soap *soap, tns__blockMediaAliasWithIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__blockMediaAliasWithIdResponse);
	if (soap_out_PointerTotns__blockMediaAliasWithIdResponse(soap, tag?tag:"tns:blockMediaAliasWithIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__blockMediaAliasWithIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__blockMediaAliasWithIdResponse(struct soap *soap, tns__blockMediaAliasWithIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__blockMediaAliasWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__blockMediaAliasWithId(struct soap *soap, tns__blockMediaAliasWithId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__blockMediaAliasWithId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__blockMediaAliasWithId(struct soap *soap, const char *tag, int id, tns__blockMediaAliasWithId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__blockMediaAliasWithId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__blockMediaAliasWithId ** SOAP_FMAC4 soap_in_PointerTotns__blockMediaAliasWithId(struct soap *soap, const char *tag, tns__blockMediaAliasWithId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__blockMediaAliasWithId **)soap_malloc(soap, sizeof(tns__blockMediaAliasWithId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__blockMediaAliasWithId *)soap_instantiate_tns__blockMediaAliasWithId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__blockMediaAliasWithId ** p = (tns__blockMediaAliasWithId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__blockMediaAliasWithId, sizeof(tns__blockMediaAliasWithId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__blockMediaAliasWithId(struct soap *soap, tns__blockMediaAliasWithId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__blockMediaAliasWithId);
	if (soap_out_PointerTotns__blockMediaAliasWithId(soap, tag?tag:"tns:blockMediaAliasWithId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__blockMediaAliasWithId ** SOAP_FMAC4 soap_get_PointerTotns__blockMediaAliasWithId(struct soap *soap, tns__blockMediaAliasWithId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__blockMediaAliasWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__blessMediaTokenWithIdResponse(struct soap *soap, tns__blessMediaTokenWithIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__blessMediaTokenWithIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__blessMediaTokenWithIdResponse(struct soap *soap, const char *tag, int id, tns__blessMediaTokenWithIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__blessMediaTokenWithIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__blessMediaTokenWithIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__blessMediaTokenWithIdResponse(struct soap *soap, const char *tag, tns__blessMediaTokenWithIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__blessMediaTokenWithIdResponse **)soap_malloc(soap, sizeof(tns__blessMediaTokenWithIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__blessMediaTokenWithIdResponse *)soap_instantiate_tns__blessMediaTokenWithIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__blessMediaTokenWithIdResponse ** p = (tns__blessMediaTokenWithIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__blessMediaTokenWithIdResponse, sizeof(tns__blessMediaTokenWithIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__blessMediaTokenWithIdResponse(struct soap *soap, tns__blessMediaTokenWithIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__blessMediaTokenWithIdResponse);
	if (soap_out_PointerTotns__blessMediaTokenWithIdResponse(soap, tag?tag:"tns:blessMediaTokenWithIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__blessMediaTokenWithIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__blessMediaTokenWithIdResponse(struct soap *soap, tns__blessMediaTokenWithIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__blessMediaTokenWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__blessMediaTokenWithId(struct soap *soap, tns__blessMediaTokenWithId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__blessMediaTokenWithId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__blessMediaTokenWithId(struct soap *soap, const char *tag, int id, tns__blessMediaTokenWithId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__blessMediaTokenWithId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__blessMediaTokenWithId ** SOAP_FMAC4 soap_in_PointerTotns__blessMediaTokenWithId(struct soap *soap, const char *tag, tns__blessMediaTokenWithId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__blessMediaTokenWithId **)soap_malloc(soap, sizeof(tns__blessMediaTokenWithId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__blessMediaTokenWithId *)soap_instantiate_tns__blessMediaTokenWithId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__blessMediaTokenWithId ** p = (tns__blessMediaTokenWithId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__blessMediaTokenWithId, sizeof(tns__blessMediaTokenWithId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__blessMediaTokenWithId(struct soap *soap, tns__blessMediaTokenWithId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__blessMediaTokenWithId);
	if (soap_out_PointerTotns__blessMediaTokenWithId(soap, tag?tag:"tns:blessMediaTokenWithId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__blessMediaTokenWithId ** SOAP_FMAC4 soap_get_PointerTotns__blessMediaTokenWithId(struct soap *soap, tns__blessMediaTokenWithId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__blessMediaTokenWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__blessMediaAnnotationWithIdResponse(struct soap *soap, tns__blessMediaAnnotationWithIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__blessMediaAnnotationWithIdResponse(struct soap *soap, const char *tag, int id, tns__blessMediaAnnotationWithIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__blessMediaAnnotationWithIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__blessMediaAnnotationWithIdResponse(struct soap *soap, const char *tag, tns__blessMediaAnnotationWithIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__blessMediaAnnotationWithIdResponse **)soap_malloc(soap, sizeof(tns__blessMediaAnnotationWithIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__blessMediaAnnotationWithIdResponse *)soap_instantiate_tns__blessMediaAnnotationWithIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__blessMediaAnnotationWithIdResponse ** p = (tns__blessMediaAnnotationWithIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithIdResponse, sizeof(tns__blessMediaAnnotationWithIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__blessMediaAnnotationWithIdResponse(struct soap *soap, tns__blessMediaAnnotationWithIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__blessMediaAnnotationWithIdResponse);
	if (soap_out_PointerTotns__blessMediaAnnotationWithIdResponse(soap, tag?tag:"tns:blessMediaAnnotationWithIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__blessMediaAnnotationWithIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__blessMediaAnnotationWithIdResponse(struct soap *soap, tns__blessMediaAnnotationWithIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__blessMediaAnnotationWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__blessMediaAnnotationWithId(struct soap *soap, tns__blessMediaAnnotationWithId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__blessMediaAnnotationWithId(struct soap *soap, const char *tag, int id, tns__blessMediaAnnotationWithId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__blessMediaAnnotationWithId ** SOAP_FMAC4 soap_in_PointerTotns__blessMediaAnnotationWithId(struct soap *soap, const char *tag, tns__blessMediaAnnotationWithId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__blessMediaAnnotationWithId **)soap_malloc(soap, sizeof(tns__blessMediaAnnotationWithId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__blessMediaAnnotationWithId *)soap_instantiate_tns__blessMediaAnnotationWithId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__blessMediaAnnotationWithId ** p = (tns__blessMediaAnnotationWithId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithId, sizeof(tns__blessMediaAnnotationWithId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__blessMediaAnnotationWithId(struct soap *soap, tns__blessMediaAnnotationWithId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__blessMediaAnnotationWithId);
	if (soap_out_PointerTotns__blessMediaAnnotationWithId(soap, tag?tag:"tns:blessMediaAnnotationWithId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__blessMediaAnnotationWithId ** SOAP_FMAC4 soap_get_PointerTotns__blessMediaAnnotationWithId(struct soap *soap, tns__blessMediaAnnotationWithId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__blessMediaAnnotationWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__blessMediaAliasWithIdResponse(struct soap *soap, tns__blessMediaAliasWithIdResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__blessMediaAliasWithIdResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__blessMediaAliasWithIdResponse(struct soap *soap, const char *tag, int id, tns__blessMediaAliasWithIdResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__blessMediaAliasWithIdResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__blessMediaAliasWithIdResponse ** SOAP_FMAC4 soap_in_PointerTotns__blessMediaAliasWithIdResponse(struct soap *soap, const char *tag, tns__blessMediaAliasWithIdResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__blessMediaAliasWithIdResponse **)soap_malloc(soap, sizeof(tns__blessMediaAliasWithIdResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__blessMediaAliasWithIdResponse *)soap_instantiate_tns__blessMediaAliasWithIdResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__blessMediaAliasWithIdResponse ** p = (tns__blessMediaAliasWithIdResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__blessMediaAliasWithIdResponse, sizeof(tns__blessMediaAliasWithIdResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__blessMediaAliasWithIdResponse(struct soap *soap, tns__blessMediaAliasWithIdResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__blessMediaAliasWithIdResponse);
	if (soap_out_PointerTotns__blessMediaAliasWithIdResponse(soap, tag?tag:"tns:blessMediaAliasWithIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__blessMediaAliasWithIdResponse ** SOAP_FMAC4 soap_get_PointerTotns__blessMediaAliasWithIdResponse(struct soap *soap, tns__blessMediaAliasWithIdResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__blessMediaAliasWithIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__blessMediaAliasWithId(struct soap *soap, tns__blessMediaAliasWithId *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__blessMediaAliasWithId))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__blessMediaAliasWithId(struct soap *soap, const char *tag, int id, tns__blessMediaAliasWithId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__blessMediaAliasWithId);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__blessMediaAliasWithId ** SOAP_FMAC4 soap_in_PointerTotns__blessMediaAliasWithId(struct soap *soap, const char *tag, tns__blessMediaAliasWithId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__blessMediaAliasWithId **)soap_malloc(soap, sizeof(tns__blessMediaAliasWithId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__blessMediaAliasWithId *)soap_instantiate_tns__blessMediaAliasWithId(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__blessMediaAliasWithId ** p = (tns__blessMediaAliasWithId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__blessMediaAliasWithId, sizeof(tns__blessMediaAliasWithId), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__blessMediaAliasWithId(struct soap *soap, tns__blessMediaAliasWithId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__blessMediaAliasWithId);
	if (soap_out_PointerTotns__blessMediaAliasWithId(soap, tag?tag:"tns:blessMediaAliasWithId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__blessMediaAliasWithId ** SOAP_FMAC4 soap_get_PointerTotns__blessMediaAliasWithId(struct soap *soap, tns__blessMediaAliasWithId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__blessMediaAliasWithId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__user(struct soap *soap, tns__user *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__user))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__user(struct soap *soap, const char *tag, int id, tns__user *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__user);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__user ** SOAP_FMAC4 soap_in_PointerTotns__user(struct soap *soap, const char *tag, tns__user **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__user **)soap_malloc(soap, sizeof(tns__user *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__user *)soap_instantiate_tns__user(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__user ** p = (tns__user **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__user, sizeof(tns__user), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__user(struct soap *soap, tns__user *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__user);
	if (soap_out_PointerTotns__user(soap, tag?tag:"tns:user", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__user ** SOAP_FMAC4 soap_get_PointerTotns__user(struct soap *soap, tns__user **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__user(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__mediaToken(struct soap *soap, tns__mediaToken *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__mediaToken))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__mediaToken(struct soap *soap, const char *tag, int id, tns__mediaToken *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__mediaToken);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__mediaToken ** SOAP_FMAC4 soap_in_PointerTotns__mediaToken(struct soap *soap, const char *tag, tns__mediaToken **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__mediaToken **)soap_malloc(soap, sizeof(tns__mediaToken *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__mediaToken *)soap_instantiate_tns__mediaToken(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__mediaToken ** p = (tns__mediaToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__mediaToken, sizeof(tns__mediaToken), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__mediaToken(struct soap *soap, tns__mediaToken *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__mediaToken);
	if (soap_out_PointerTotns__mediaToken(soap, tag?tag:"tns:mediaToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__mediaToken ** SOAP_FMAC4 soap_get_PointerTotns__mediaToken(struct soap *soap, tns__mediaToken **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__mediaToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__mediaAnnotation(struct soap *soap, tns__mediaAnnotation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__mediaAnnotation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__mediaAnnotation(struct soap *soap, const char *tag, int id, tns__mediaAnnotation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__mediaAnnotation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__mediaAnnotation ** SOAP_FMAC4 soap_in_PointerTotns__mediaAnnotation(struct soap *soap, const char *tag, tns__mediaAnnotation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__mediaAnnotation **)soap_malloc(soap, sizeof(tns__mediaAnnotation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__mediaAnnotation *)soap_instantiate_tns__mediaAnnotation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__mediaAnnotation ** p = (tns__mediaAnnotation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__mediaAnnotation, sizeof(tns__mediaAnnotation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__mediaAnnotation(struct soap *soap, tns__mediaAnnotation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__mediaAnnotation);
	if (soap_out_PointerTotns__mediaAnnotation(soap, tag?tag:"tns:mediaAnnotation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__mediaAnnotation ** SOAP_FMAC4 soap_get_PointerTotns__mediaAnnotation(struct soap *soap, tns__mediaAnnotation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__mediaAnnotation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotns__mediaAlias(struct soap *soap, tns__mediaAlias *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_tns__mediaAlias))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotns__mediaAlias(struct soap *soap, const char *tag, int id, tns__mediaAlias *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_tns__mediaAlias);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tns__mediaAlias ** SOAP_FMAC4 soap_in_PointerTotns__mediaAlias(struct soap *soap, const char *tag, tns__mediaAlias **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tns__mediaAlias **)soap_malloc(soap, sizeof(tns__mediaAlias *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tns__mediaAlias *)soap_instantiate_tns__mediaAlias(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tns__mediaAlias ** p = (tns__mediaAlias **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_tns__mediaAlias, sizeof(tns__mediaAlias), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotns__mediaAlias(struct soap *soap, tns__mediaAlias *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTotns__mediaAlias);
	if (soap_out_PointerTotns__mediaAlias(soap, tag?tag:"tns:mediaAlias", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tns__mediaAlias ** SOAP_FMAC4 soap_get_PointerTotns__mediaAlias(struct soap *soap, tns__mediaAlias **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__mediaAlias(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ServerSoap_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ServerSoap_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ServerSoap_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ServerSoap__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_ServerSoap__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ServerSoap_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_ServerSoap_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_ServerSoap_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ServerSoap_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTotns__mediaAnnotation(struct soap *soap, std::vector<tns__mediaAnnotation * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTotns__mediaAnnotation(struct soap *soap, const std::vector<tns__mediaAnnotation * >*a)
{
	for (std::vector<tns__mediaAnnotation * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTotns__mediaAnnotation(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTotns__mediaAnnotation(struct soap *soap, const char *tag, int id, const std::vector<tns__mediaAnnotation * >*a, const char *type)
{
	for (std::vector<tns__mediaAnnotation * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTotns__mediaAnnotation(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tns__mediaAnnotation * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTotns__mediaAnnotation(struct soap *soap, const char *tag, std::vector<tns__mediaAnnotation * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTotns__mediaAnnotation(soap, -1)))
		return NULL;
	tns__mediaAnnotation *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ServerSoap_tns__mediaAnnotation, SOAP_TYPE_ServerSoap_std__vectorTemplateOfPointerTotns__mediaAnnotation, sizeof(tns__mediaAnnotation), 1))
				break;
			if (!soap_in_PointerTotns__mediaAnnotation(soap, tag, NULL, "tns:mediaAnnotation"))
				break;
		}
		else
		{
			if (!soap_in_PointerTotns__mediaAnnotation(soap, tag, &n, "tns:mediaAnnotation"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tns__mediaAnnotation * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTotns__mediaAnnotation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTotns__mediaAnnotation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_std__vectorTemplateOfPointerTotns__mediaAnnotation, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tns__mediaAnnotation * >);
		if (size)
			*size = sizeof(std::vector<tns__mediaAnnotation * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tns__mediaAnnotation * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<tns__mediaAnnotation * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<tns__mediaAnnotation * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTotns__mediaAnnotation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<tns__mediaAnnotation * > %p -> %p\n", q, p));
	*(std::vector<tns__mediaAnnotation * >*)p = *(std::vector<tns__mediaAnnotation * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTotns__mediaAlias(struct soap *soap, std::vector<tns__mediaAlias * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTotns__mediaAlias(struct soap *soap, const std::vector<tns__mediaAlias * >*a)
{
	for (std::vector<tns__mediaAlias * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTotns__mediaAlias(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTotns__mediaAlias(struct soap *soap, const char *tag, int id, const std::vector<tns__mediaAlias * >*a, const char *type)
{
	for (std::vector<tns__mediaAlias * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTotns__mediaAlias(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tns__mediaAlias * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTotns__mediaAlias(struct soap *soap, const char *tag, std::vector<tns__mediaAlias * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTotns__mediaAlias(soap, -1)))
		return NULL;
	tns__mediaAlias *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ServerSoap_tns__mediaAlias, SOAP_TYPE_ServerSoap_std__vectorTemplateOfPointerTotns__mediaAlias, sizeof(tns__mediaAlias), 1))
				break;
			if (!soap_in_PointerTotns__mediaAlias(soap, tag, NULL, "tns:mediaAlias"))
				break;
		}
		else
		{
			if (!soap_in_PointerTotns__mediaAlias(soap, tag, &n, "tns:mediaAlias"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tns__mediaAlias * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTotns__mediaAlias(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTotns__mediaAlias(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ServerSoap_std__vectorTemplateOfPointerTotns__mediaAlias, n, ServerSoap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tns__mediaAlias * >);
		if (size)
			*size = sizeof(std::vector<tns__mediaAlias * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<tns__mediaAlias * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<tns__mediaAlias * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<tns__mediaAlias * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTotns__mediaAlias(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<tns__mediaAlias * > %p -> %p\n", q, p));
	*(std::vector<tns__mediaAlias * >*)p = *(std::vector<tns__mediaAlias * >*)q;
}

} // namespace ServerSoap


#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of ServerSoapC.cpp */
