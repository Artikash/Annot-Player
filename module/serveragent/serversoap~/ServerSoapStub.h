/* ServerSoapStub.h
   Generated by gSOAP 2.8.5 from _serversoap.h

Copyright(C) 2000-2011, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
1) GPL or 2) Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#ifndef ServerSoapStub_H
#define ServerSoapStub_H
#include <vector>
#define SOAP_NAMESPACE_OF_ns1	""
#define SOAP_NAMESPACE_OF_tns	"http://service.annot.me/"
#ifndef WITH_NOGLOBAL
#define WITH_NOGLOBAL
#endif
#include "stdsoap2.h"

namespace ServerSoap {

/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_ServerSoap_tns__mediaAnnotation
#define SOAP_TYPE_ServerSoap_tns__mediaAnnotation (8)
/* tns:mediaAnnotation */
class SOAP_CMAC tns__mediaAnnotation
{
public:
	int blessedCount;	/* required element of type xsd:int */
	int blockedCount;	/* required element of type xsd:int */
	LONG64 createTime;	/* required element of type xsd:long */
	int cursedCount;	/* required element of type xsd:int */
	LONG64 flags;	/* required element of type xsd:long */
	LONG64 id;	/* required element of type xsd:long */
	int language;	/* required element of type xsd:int */
	LONG64 pos;	/* required element of type xsd:long */
	int posType;	/* required element of type xsd:int */
	int time;	/* required element of type xsd:int */
	std::string *userAlias;	/* optional element of type xsd:string */
	int status;	/* required element of type xsd:int */
	std::string *text;	/* optional element of type xsd:string */
	LONG64 tokenId;	/* required element of type xsd:long */
	LONG64 updateTime;	/* required element of type xsd:long */
	LONG64 userId;	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 8; } /* = unique id SOAP_TYPE_ServerSoap_tns__mediaAnnotation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__mediaAnnotation() { tns__mediaAnnotation::soap_default(NULL); }
	virtual ~tns__mediaAnnotation() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__mediaToken
#define SOAP_TYPE_ServerSoap_tns__mediaToken (9)
/* tns:mediaToken */
class SOAP_CMAC tns__mediaToken
{
public:
	int annotCount;	/* required element of type xsd:int */
	int blessedCount;	/* required element of type xsd:int */
	int blockedCount;	/* required element of type xsd:int */
	LONG64 createTime;	/* required element of type xsd:long */
	int cursedCount;	/* required element of type xsd:int */
	std::string *digest;	/* optional element of type xsd:string */
	int digestType;	/* required element of type xsd:int */
	LONG64 flags;	/* required element of type xsd:long */
	LONG64 id;	/* required element of type xsd:long */
	int type;	/* required element of type xsd:int */
	int status;	/* required element of type xsd:int */
	LONG64 userId;	/* required element of type xsd:long */
	int visitedCount;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 9; } /* = unique id SOAP_TYPE_ServerSoap_tns__mediaToken */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__mediaToken() { tns__mediaToken::soap_default(NULL); }
	virtual ~tns__mediaToken() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__mediaAlias
#define SOAP_TYPE_ServerSoap_tns__mediaAlias (10)
/* tns:mediaAlias */
class SOAP_CMAC tns__mediaAlias
{
public:
	int blessedCount;	/* required element of type xsd:int */
	int blockedCount;	/* required element of type xsd:int */
	int cursedCount;	/* required element of type xsd:int */
	LONG64 flags;	/* required element of type xsd:long */
	LONG64 id;	/* required element of type xsd:long */
	int language;	/* required element of type xsd:int */
	LONG64 userId;	/* required element of type xsd:long */
	int status;	/* required element of type xsd:int */
	std::string *text;	/* optional element of type xsd:string */
	LONG64 tokenId;	/* required element of type xsd:long */
	int type;	/* required element of type xsd:int */
	LONG64 updateTime;	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 10; } /* = unique id SOAP_TYPE_ServerSoap_tns__mediaAlias */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__mediaAlias() { tns__mediaAlias::soap_default(NULL); }
	virtual ~tns__mediaAlias() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__user
#define SOAP_TYPE_ServerSoap_tns__user (11)
/* tns:user */
class SOAP_CMAC tns__user
{
public:
	int annotCount;	/* required element of type xsd:int */
	int blessedCount;	/* required element of type xsd:int */
	int blockedCount;	/* required element of type xsd:int */
	LONG64 createTime;	/* required element of type xsd:long */
	int cursedCount;	/* required element of type xsd:int */
	std::string *email;	/* optional element of type xsd:string */
	LONG64 flags;	/* required element of type xsd:long */
	LONG64 groupId;	/* required element of type xsd:long */
	LONG64 id;	/* required element of type xsd:long */
	int language;	/* required element of type xsd:int */
	LONG64 loginTime;	/* required element of type xsd:long */
	std::string *name;	/* optional element of type xsd:string */
	std::string *nickname;	/* optional element of type xsd:string */
	std::string *password;	/* optional element of type xsd:string */
	int status;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 11; } /* = unique id SOAP_TYPE_ServerSoap_tns__user */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__user() { tns__user::soap_default(NULL); }
	virtual ~tns__user() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__blessMediaAliasWithId
#define SOAP_TYPE_ServerSoap_tns__blessMediaAliasWithId (12)
/* tns:blessMediaAliasWithId */
class SOAP_CMAC tns__blessMediaAliasWithId
{
public:
	LONG64 arg0;	/* required element of type xsd:long */
	std::string *userName;	/* optional element of type xsd:string */
	std::string *password;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 12; } /* = unique id SOAP_TYPE_ServerSoap_tns__blessMediaAliasWithId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__blessMediaAliasWithId() { tns__blessMediaAliasWithId::soap_default(NULL); }
	virtual ~tns__blessMediaAliasWithId() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__blessMediaAliasWithIdResponse
#define SOAP_TYPE_ServerSoap_tns__blessMediaAliasWithIdResponse (13)
/* tns:blessMediaAliasWithIdResponse */
class SOAP_CMAC tns__blessMediaAliasWithIdResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 13; } /* = unique id SOAP_TYPE_ServerSoap_tns__blessMediaAliasWithIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__blessMediaAliasWithIdResponse() { tns__blessMediaAliasWithIdResponse::soap_default(NULL); }
	virtual ~tns__blessMediaAliasWithIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithId
#define SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithId (14)
/* tns:blessMediaAnnotationWithId */
class SOAP_CMAC tns__blessMediaAnnotationWithId
{
public:
	LONG64 arg0;	/* required element of type xsd:long */
	std::string *userName;	/* optional element of type xsd:string */
	std::string *password;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 14; } /* = unique id SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__blessMediaAnnotationWithId() { tns__blessMediaAnnotationWithId::soap_default(NULL); }
	virtual ~tns__blessMediaAnnotationWithId() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithIdResponse
#define SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithIdResponse (15)
/* tns:blessMediaAnnotationWithIdResponse */
class SOAP_CMAC tns__blessMediaAnnotationWithIdResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 15; } /* = unique id SOAP_TYPE_ServerSoap_tns__blessMediaAnnotationWithIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__blessMediaAnnotationWithIdResponse() { tns__blessMediaAnnotationWithIdResponse::soap_default(NULL); }
	virtual ~tns__blessMediaAnnotationWithIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__blessMediaTokenWithId
#define SOAP_TYPE_ServerSoap_tns__blessMediaTokenWithId (16)
/* tns:blessMediaTokenWithId */
class SOAP_CMAC tns__blessMediaTokenWithId
{
public:
	LONG64 arg0;	/* required element of type xsd:long */
	std::string *userName;	/* optional element of type xsd:string */
	std::string *password;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 16; } /* = unique id SOAP_TYPE_ServerSoap_tns__blessMediaTokenWithId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__blessMediaTokenWithId() { tns__blessMediaTokenWithId::soap_default(NULL); }
	virtual ~tns__blessMediaTokenWithId() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__blessMediaTokenWithIdResponse
#define SOAP_TYPE_ServerSoap_tns__blessMediaTokenWithIdResponse (17)
/* tns:blessMediaTokenWithIdResponse */
class SOAP_CMAC tns__blessMediaTokenWithIdResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 17; } /* = unique id SOAP_TYPE_ServerSoap_tns__blessMediaTokenWithIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__blessMediaTokenWithIdResponse() { tns__blessMediaTokenWithIdResponse::soap_default(NULL); }
	virtual ~tns__blessMediaTokenWithIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__blockMediaAliasWithId
#define SOAP_TYPE_ServerSoap_tns__blockMediaAliasWithId (18)
/* tns:blockMediaAliasWithId */
class SOAP_CMAC tns__blockMediaAliasWithId
{
public:
	LONG64 arg0;	/* required element of type xsd:long */
	std::string *userName;	/* optional element of type xsd:string */
	std::string *password;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 18; } /* = unique id SOAP_TYPE_ServerSoap_tns__blockMediaAliasWithId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__blockMediaAliasWithId() { tns__blockMediaAliasWithId::soap_default(NULL); }
	virtual ~tns__blockMediaAliasWithId() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__blockMediaAliasWithIdResponse
#define SOAP_TYPE_ServerSoap_tns__blockMediaAliasWithIdResponse (19)
/* tns:blockMediaAliasWithIdResponse */
class SOAP_CMAC tns__blockMediaAliasWithIdResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 19; } /* = unique id SOAP_TYPE_ServerSoap_tns__blockMediaAliasWithIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__blockMediaAliasWithIdResponse() { tns__blockMediaAliasWithIdResponse::soap_default(NULL); }
	virtual ~tns__blockMediaAliasWithIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__blockMediaAnnotationWithId
#define SOAP_TYPE_ServerSoap_tns__blockMediaAnnotationWithId (20)
/* tns:blockMediaAnnotationWithId */
class SOAP_CMAC tns__blockMediaAnnotationWithId
{
public:
	LONG64 arg0;	/* required element of type xsd:long */
	std::string *userName;	/* optional element of type xsd:string */
	std::string *password;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 20; } /* = unique id SOAP_TYPE_ServerSoap_tns__blockMediaAnnotationWithId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__blockMediaAnnotationWithId() { tns__blockMediaAnnotationWithId::soap_default(NULL); }
	virtual ~tns__blockMediaAnnotationWithId() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__blockMediaAnnotationWithIdResponse
#define SOAP_TYPE_ServerSoap_tns__blockMediaAnnotationWithIdResponse (21)
/* tns:blockMediaAnnotationWithIdResponse */
class SOAP_CMAC tns__blockMediaAnnotationWithIdResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 21; } /* = unique id SOAP_TYPE_ServerSoap_tns__blockMediaAnnotationWithIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__blockMediaAnnotationWithIdResponse() { tns__blockMediaAnnotationWithIdResponse::soap_default(NULL); }
	virtual ~tns__blockMediaAnnotationWithIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__blockUserWithId
#define SOAP_TYPE_ServerSoap_tns__blockUserWithId (22)
/* tns:blockUserWithId */
class SOAP_CMAC tns__blockUserWithId
{
public:
	LONG64 arg0;	/* required element of type xsd:long */
	std::string *userName;	/* optional element of type xsd:string */
	std::string *password;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 22; } /* = unique id SOAP_TYPE_ServerSoap_tns__blockUserWithId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__blockUserWithId() { tns__blockUserWithId::soap_default(NULL); }
	virtual ~tns__blockUserWithId() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__blockUserWithIdResponse
#define SOAP_TYPE_ServerSoap_tns__blockUserWithIdResponse (23)
/* tns:blockUserWithIdResponse */
class SOAP_CMAC tns__blockUserWithIdResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 23; } /* = unique id SOAP_TYPE_ServerSoap_tns__blockUserWithIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__blockUserWithIdResponse() { tns__blockUserWithIdResponse::soap_default(NULL); }
	virtual ~tns__blockUserWithIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__chat
#define SOAP_TYPE_ServerSoap_tns__chat (24)
/* tns:chat */
class SOAP_CMAC tns__chat
{
public:
	std::string *arg0;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 24; } /* = unique id SOAP_TYPE_ServerSoap_tns__chat */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__chat() { tns__chat::soap_default(NULL); }
	virtual ~tns__chat() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__chatResponse
#define SOAP_TYPE_ServerSoap_tns__chatResponse (25)
/* tns:chatResponse */
class SOAP_CMAC tns__chatResponse
{
public:
	std::string *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 25; } /* = unique id SOAP_TYPE_ServerSoap_tns__chatResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__chatResponse() { tns__chatResponse::soap_default(NULL); }
	virtual ~tns__chatResponse() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__curseMediaAliasWithId
#define SOAP_TYPE_ServerSoap_tns__curseMediaAliasWithId (26)
/* tns:curseMediaAliasWithId */
class SOAP_CMAC tns__curseMediaAliasWithId
{
public:
	LONG64 arg0;	/* required element of type xsd:long */
	std::string *userName;	/* optional element of type xsd:string */
	std::string *password;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 26; } /* = unique id SOAP_TYPE_ServerSoap_tns__curseMediaAliasWithId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__curseMediaAliasWithId() { tns__curseMediaAliasWithId::soap_default(NULL); }
	virtual ~tns__curseMediaAliasWithId() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__curseMediaAliasWithIdResponse
#define SOAP_TYPE_ServerSoap_tns__curseMediaAliasWithIdResponse (27)
/* tns:curseMediaAliasWithIdResponse */
class SOAP_CMAC tns__curseMediaAliasWithIdResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 27; } /* = unique id SOAP_TYPE_ServerSoap_tns__curseMediaAliasWithIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__curseMediaAliasWithIdResponse() { tns__curseMediaAliasWithIdResponse::soap_default(NULL); }
	virtual ~tns__curseMediaAliasWithIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__curseMediaAnnotationWithId
#define SOAP_TYPE_ServerSoap_tns__curseMediaAnnotationWithId (28)
/* tns:curseMediaAnnotationWithId */
class SOAP_CMAC tns__curseMediaAnnotationWithId
{
public:
	LONG64 arg0;	/* required element of type xsd:long */
	std::string *userName;	/* optional element of type xsd:string */
	std::string *password;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 28; } /* = unique id SOAP_TYPE_ServerSoap_tns__curseMediaAnnotationWithId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__curseMediaAnnotationWithId() { tns__curseMediaAnnotationWithId::soap_default(NULL); }
	virtual ~tns__curseMediaAnnotationWithId() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__curseMediaAnnotationWithIdResponse
#define SOAP_TYPE_ServerSoap_tns__curseMediaAnnotationWithIdResponse (29)
/* tns:curseMediaAnnotationWithIdResponse */
class SOAP_CMAC tns__curseMediaAnnotationWithIdResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 29; } /* = unique id SOAP_TYPE_ServerSoap_tns__curseMediaAnnotationWithIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__curseMediaAnnotationWithIdResponse() { tns__curseMediaAnnotationWithIdResponse::soap_default(NULL); }
	virtual ~tns__curseMediaAnnotationWithIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__curseMediaTokenWithId
#define SOAP_TYPE_ServerSoap_tns__curseMediaTokenWithId (30)
/* tns:curseMediaTokenWithId */
class SOAP_CMAC tns__curseMediaTokenWithId
{
public:
	LONG64 arg0;	/* required element of type xsd:long */
	std::string *userName;	/* optional element of type xsd:string */
	std::string *password;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 30; } /* = unique id SOAP_TYPE_ServerSoap_tns__curseMediaTokenWithId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__curseMediaTokenWithId() { tns__curseMediaTokenWithId::soap_default(NULL); }
	virtual ~tns__curseMediaTokenWithId() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__curseMediaTokenWithIdResponse
#define SOAP_TYPE_ServerSoap_tns__curseMediaTokenWithIdResponse (31)
/* tns:curseMediaTokenWithIdResponse */
class SOAP_CMAC tns__curseMediaTokenWithIdResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 31; } /* = unique id SOAP_TYPE_ServerSoap_tns__curseMediaTokenWithIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__curseMediaTokenWithIdResponse() { tns__curseMediaTokenWithIdResponse::soap_default(NULL); }
	virtual ~tns__curseMediaTokenWithIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__deleteMediaAliasWithId
#define SOAP_TYPE_ServerSoap_tns__deleteMediaAliasWithId (32)
/* tns:deleteMediaAliasWithId */
class SOAP_CMAC tns__deleteMediaAliasWithId
{
public:
	LONG64 arg0;	/* required element of type xsd:long */
	std::string *userName;	/* optional element of type xsd:string */
	std::string *password;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 32; } /* = unique id SOAP_TYPE_ServerSoap_tns__deleteMediaAliasWithId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__deleteMediaAliasWithId() { tns__deleteMediaAliasWithId::soap_default(NULL); }
	virtual ~tns__deleteMediaAliasWithId() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__deleteMediaAliasWithIdResponse
#define SOAP_TYPE_ServerSoap_tns__deleteMediaAliasWithIdResponse (33)
/* tns:deleteMediaAliasWithIdResponse */
class SOAP_CMAC tns__deleteMediaAliasWithIdResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 33; } /* = unique id SOAP_TYPE_ServerSoap_tns__deleteMediaAliasWithIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__deleteMediaAliasWithIdResponse() { tns__deleteMediaAliasWithIdResponse::soap_default(NULL); }
	virtual ~tns__deleteMediaAliasWithIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__deleteMediaAnnotationWithId
#define SOAP_TYPE_ServerSoap_tns__deleteMediaAnnotationWithId (34)
/* tns:deleteMediaAnnotationWithId */
class SOAP_CMAC tns__deleteMediaAnnotationWithId
{
public:
	LONG64 arg0;	/* required element of type xsd:long */
	std::string *userName;	/* optional element of type xsd:string */
	std::string *password;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 34; } /* = unique id SOAP_TYPE_ServerSoap_tns__deleteMediaAnnotationWithId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__deleteMediaAnnotationWithId() { tns__deleteMediaAnnotationWithId::soap_default(NULL); }
	virtual ~tns__deleteMediaAnnotationWithId() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__deleteMediaAnnotationWithIdResponse
#define SOAP_TYPE_ServerSoap_tns__deleteMediaAnnotationWithIdResponse (35)
/* tns:deleteMediaAnnotationWithIdResponse */
class SOAP_CMAC tns__deleteMediaAnnotationWithIdResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 35; } /* = unique id SOAP_TYPE_ServerSoap_tns__deleteMediaAnnotationWithIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__deleteMediaAnnotationWithIdResponse() { tns__deleteMediaAnnotationWithIdResponse::soap_default(NULL); }
	virtual ~tns__deleteMediaAnnotationWithIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__isClientUpdated
#define SOAP_TYPE_ServerSoap_tns__isClientUpdated (36)
/* tns:isClientUpdated */
class SOAP_CMAC tns__isClientUpdated
{
public:
	std::string *arg0;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 36; } /* = unique id SOAP_TYPE_ServerSoap_tns__isClientUpdated */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__isClientUpdated() { tns__isClientUpdated::soap_default(NULL); }
	virtual ~tns__isClientUpdated() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__isClientUpdatedResponse
#define SOAP_TYPE_ServerSoap_tns__isClientUpdatedResponse (37)
/* tns:isClientUpdatedResponse */
class SOAP_CMAC tns__isClientUpdatedResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 37; } /* = unique id SOAP_TYPE_ServerSoap_tns__isClientUpdatedResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__isClientUpdatedResponse() { tns__isClientUpdatedResponse::soap_default(NULL); }
	virtual ~tns__isClientUpdatedResponse() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__isConnected
#define SOAP_TYPE_ServerSoap_tns__isConnected (38)
/* tns:isConnected */
class SOAP_CMAC tns__isConnected
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 38; } /* = unique id SOAP_TYPE_ServerSoap_tns__isConnected */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__isConnected() { tns__isConnected::soap_default(NULL); }
	virtual ~tns__isConnected() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__isConnectedResponse
#define SOAP_TYPE_ServerSoap_tns__isConnectedResponse (39)
/* tns:isConnectedResponse */
class SOAP_CMAC tns__isConnectedResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 39; } /* = unique id SOAP_TYPE_ServerSoap_tns__isConnectedResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__isConnectedResponse() { tns__isConnectedResponse::soap_default(NULL); }
	virtual ~tns__isConnectedResponse() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenId
#define SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenId (40)
/* tns:selectMediaAliasesWithTokenId */
class SOAP_CMAC tns__selectMediaAliasesWithTokenId
{
public:
	LONG64 arg0;	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 40; } /* = unique id SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__selectMediaAliasesWithTokenId() { tns__selectMediaAliasesWithTokenId::soap_default(NULL); }
	virtual ~tns__selectMediaAliasesWithTokenId() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenIdResponse
#define SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenIdResponse (41)
/* tns:selectMediaAliasesWithTokenIdResponse */
class SOAP_CMAC tns__selectMediaAliasesWithTokenIdResponse
{
public:
	std::vector<tns__mediaAlias * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tns:mediaAlias */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 41; } /* = unique id SOAP_TYPE_ServerSoap_tns__selectMediaAliasesWithTokenIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__selectMediaAliasesWithTokenIdResponse() { tns__selectMediaAliasesWithTokenIdResponse::soap_default(NULL); }
	virtual ~tns__selectMediaAliasesWithTokenIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenId
#define SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenId (42)
/* tns:selectMediaAnnotationsWithTokenId */
class SOAP_CMAC tns__selectMediaAnnotationsWithTokenId
{
public:
	LONG64 arg0;	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 42; } /* = unique id SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__selectMediaAnnotationsWithTokenId() { tns__selectMediaAnnotationsWithTokenId::soap_default(NULL); }
	virtual ~tns__selectMediaAnnotationsWithTokenId() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenIdResponse
#define SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenIdResponse (43)
/* tns:selectMediaAnnotationsWithTokenIdResponse */
class SOAP_CMAC tns__selectMediaAnnotationsWithTokenIdResponse
{
public:
	std::vector<tns__mediaAnnotation * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tns:mediaAnnotation */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 43; } /* = unique id SOAP_TYPE_ServerSoap_tns__selectMediaAnnotationsWithTokenIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__selectMediaAnnotationsWithTokenIdResponse() { tns__selectMediaAnnotationsWithTokenIdResponse::soap_default(NULL); }
	virtual ~tns__selectMediaAnnotationsWithTokenIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigest
#define SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigest (44)
/* tns:selectMediaTokenWithDigest */
class SOAP_CMAC tns__selectMediaTokenWithDigest
{
public:
	std::string *arg0;	/* optional element of type xsd:string */
	int arg1;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 44; } /* = unique id SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__selectMediaTokenWithDigest() { tns__selectMediaTokenWithDigest::soap_default(NULL); }
	virtual ~tns__selectMediaTokenWithDigest() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigestResponse
#define SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigestResponse (45)
/* tns:selectMediaTokenWithDigestResponse */
class SOAP_CMAC tns__selectMediaTokenWithDigestResponse
{
public:
	tns__mediaToken *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tns:mediaToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 45; } /* = unique id SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithDigestResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__selectMediaTokenWithDigestResponse() { tns__selectMediaTokenWithDigestResponse::soap_default(NULL); }
	virtual ~tns__selectMediaTokenWithDigestResponse() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithId
#define SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithId (46)
/* tns:selectMediaTokenWithId */
class SOAP_CMAC tns__selectMediaTokenWithId
{
public:
	LONG64 arg0;	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 46; } /* = unique id SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__selectMediaTokenWithId() { tns__selectMediaTokenWithId::soap_default(NULL); }
	virtual ~tns__selectMediaTokenWithId() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithIdResponse
#define SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithIdResponse (47)
/* tns:selectMediaTokenWithIdResponse */
class SOAP_CMAC tns__selectMediaTokenWithIdResponse
{
public:
	tns__mediaToken *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tns:mediaToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 47; } /* = unique id SOAP_TYPE_ServerSoap_tns__selectMediaTokenWithIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__selectMediaTokenWithIdResponse() { tns__selectMediaTokenWithIdResponse::soap_default(NULL); }
	virtual ~tns__selectMediaTokenWithIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenId
#define SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenId (48)
/* tns:selectRelatedMediaAnnotationsWithTokenId */
class SOAP_CMAC tns__selectRelatedMediaAnnotationsWithTokenId
{
public:
	LONG64 arg0;	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 48; } /* = unique id SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__selectRelatedMediaAnnotationsWithTokenId() { tns__selectRelatedMediaAnnotationsWithTokenId::soap_default(NULL); }
	virtual ~tns__selectRelatedMediaAnnotationsWithTokenId() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenIdResponse
#define SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenIdResponse (49)
/* tns:selectRelatedMediaAnnotationsWithTokenIdResponse */
class SOAP_CMAC tns__selectRelatedMediaAnnotationsWithTokenIdResponse
{
public:
	std::vector<tns__mediaAnnotation * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tns:mediaAnnotation */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 49; } /* = unique id SOAP_TYPE_ServerSoap_tns__selectRelatedMediaAnnotationsWithTokenIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__selectRelatedMediaAnnotationsWithTokenIdResponse() { tns__selectRelatedMediaAnnotationsWithTokenIdResponse::soap_default(NULL); }
	virtual ~tns__selectRelatedMediaAnnotationsWithTokenIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__selectUser
#define SOAP_TYPE_ServerSoap_tns__selectUser (50)
/* tns:selectUser */
class SOAP_CMAC tns__selectUser
{
public:
	std::string *userName;	/* optional element of type xsd:string */
	std::string *password;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 50; } /* = unique id SOAP_TYPE_ServerSoap_tns__selectUser */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__selectUser() { tns__selectUser::soap_default(NULL); }
	virtual ~tns__selectUser() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__selectUserResponse
#define SOAP_TYPE_ServerSoap_tns__selectUserResponse (51)
/* tns:selectUserResponse */
class SOAP_CMAC tns__selectUserResponse
{
public:
	tns__user *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type tns:user */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 51; } /* = unique id SOAP_TYPE_ServerSoap_tns__selectUserResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__selectUserResponse() { tns__selectUserResponse::soap_default(NULL); }
	virtual ~tns__selectUserResponse() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__setUserAnonymous
#define SOAP_TYPE_ServerSoap_tns__setUserAnonymous (52)
/* tns:setUserAnonymous */
class SOAP_CMAC tns__setUserAnonymous
{
public:
	bool arg0;	/* required element of type xsd:boolean */
	std::string *userName;	/* optional element of type xsd:string */
	std::string *password;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 52; } /* = unique id SOAP_TYPE_ServerSoap_tns__setUserAnonymous */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__setUserAnonymous() { tns__setUserAnonymous::soap_default(NULL); }
	virtual ~tns__setUserAnonymous() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__setUserAnonymousResponse
#define SOAP_TYPE_ServerSoap_tns__setUserAnonymousResponse (53)
/* tns:setUserAnonymousResponse */
class SOAP_CMAC tns__setUserAnonymousResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 53; } /* = unique id SOAP_TYPE_ServerSoap_tns__setUserAnonymousResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__setUserAnonymousResponse() { tns__setUserAnonymousResponse::soap_default(NULL); }
	virtual ~tns__setUserAnonymousResponse() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__setUserLanguage
#define SOAP_TYPE_ServerSoap_tns__setUserLanguage (54)
/* tns:setUserLanguage */
class SOAP_CMAC tns__setUserLanguage
{
public:
	int arg0;	/* required element of type xsd:int */
	std::string *userName;	/* optional element of type xsd:string */
	std::string *password;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 54; } /* = unique id SOAP_TYPE_ServerSoap_tns__setUserLanguage */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__setUserLanguage() { tns__setUserLanguage::soap_default(NULL); }
	virtual ~tns__setUserLanguage() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__setUserLanguageResponse
#define SOAP_TYPE_ServerSoap_tns__setUserLanguageResponse (55)
/* tns:setUserLanguageResponse */
class SOAP_CMAC tns__setUserLanguageResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 55; } /* = unique id SOAP_TYPE_ServerSoap_tns__setUserLanguageResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__setUserLanguageResponse() { tns__setUserLanguageResponse::soap_default(NULL); }
	virtual ~tns__setUserLanguageResponse() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__submitMediaAlias
#define SOAP_TYPE_ServerSoap_tns__submitMediaAlias (56)
/* tns:submitMediaAlias */
class SOAP_CMAC tns__submitMediaAlias
{
public:
	tns__mediaAlias *arg0;	/* optional element of type tns:mediaAlias */
	std::string *userName;	/* optional element of type xsd:string */
	std::string *password;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 56; } /* = unique id SOAP_TYPE_ServerSoap_tns__submitMediaAlias */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__submitMediaAlias() { tns__submitMediaAlias::soap_default(NULL); }
	virtual ~tns__submitMediaAlias() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__submitMediaAliasResponse
#define SOAP_TYPE_ServerSoap_tns__submitMediaAliasResponse (57)
/* tns:submitMediaAliasResponse */
class SOAP_CMAC tns__submitMediaAliasResponse
{
public:
	LONG64 return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 57; } /* = unique id SOAP_TYPE_ServerSoap_tns__submitMediaAliasResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__submitMediaAliasResponse() { tns__submitMediaAliasResponse::soap_default(NULL); }
	virtual ~tns__submitMediaAliasResponse() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigest
#define SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigest (58)
/* tns:submitMediaAliasTextAndTokenDigest */
class SOAP_CMAC tns__submitMediaAliasTextAndTokenDigest
{
public:
	std::string *arg0;	/* optional element of type xsd:string */
	int arg1;	/* required element of type xsd:int */
	std::string *arg2;	/* optional element of type xsd:string */
	int arg3;	/* required element of type xsd:int */
	std::string *userName;	/* optional element of type xsd:string */
	std::string *password;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 58; } /* = unique id SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__submitMediaAliasTextAndTokenDigest() { tns__submitMediaAliasTextAndTokenDigest::soap_default(NULL); }
	virtual ~tns__submitMediaAliasTextAndTokenDigest() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigestResponse
#define SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigestResponse (59)
/* tns:submitMediaAliasTextAndTokenDigestResponse */
class SOAP_CMAC tns__submitMediaAliasTextAndTokenDigestResponse
{
public:
	LONG64 return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 59; } /* = unique id SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextAndTokenDigestResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__submitMediaAliasTextAndTokenDigestResponse() { tns__submitMediaAliasTextAndTokenDigestResponse::soap_default(NULL); }
	virtual ~tns__submitMediaAliasTextAndTokenDigestResponse() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenId
#define SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenId (60)
/* tns:submitMediaAliasTextWithTokenId */
class SOAP_CMAC tns__submitMediaAliasTextWithTokenId
{
public:
	std::string *arg0;	/* optional element of type xsd:string */
	int arg1;	/* required element of type xsd:int */
	LONG64 arg2;	/* required element of type xsd:long */
	std::string *userName;	/* optional element of type xsd:string */
	std::string *password;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 60; } /* = unique id SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__submitMediaAliasTextWithTokenId() { tns__submitMediaAliasTextWithTokenId::soap_default(NULL); }
	virtual ~tns__submitMediaAliasTextWithTokenId() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenIdResponse
#define SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenIdResponse (61)
/* tns:submitMediaAliasTextWithTokenIdResponse */
class SOAP_CMAC tns__submitMediaAliasTextWithTokenIdResponse
{
public:
	LONG64 return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 61; } /* = unique id SOAP_TYPE_ServerSoap_tns__submitMediaAliasTextWithTokenIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__submitMediaAliasTextWithTokenIdResponse() { tns__submitMediaAliasTextWithTokenIdResponse::soap_default(NULL); }
	virtual ~tns__submitMediaAliasTextWithTokenIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__submitMediaAnnotation
#define SOAP_TYPE_ServerSoap_tns__submitMediaAnnotation (62)
/* tns:submitMediaAnnotation */
class SOAP_CMAC tns__submitMediaAnnotation
{
public:
	tns__mediaAnnotation *arg0;	/* optional element of type tns:mediaAnnotation */
	std::string *userName;	/* optional element of type xsd:string */
	std::string *password;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 62; } /* = unique id SOAP_TYPE_ServerSoap_tns__submitMediaAnnotation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__submitMediaAnnotation() { tns__submitMediaAnnotation::soap_default(NULL); }
	virtual ~tns__submitMediaAnnotation() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationResponse
#define SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationResponse (63)
/* tns:submitMediaAnnotationResponse */
class SOAP_CMAC tns__submitMediaAnnotationResponse
{
public:
	LONG64 return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 63; } /* = unique id SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__submitMediaAnnotationResponse() { tns__submitMediaAnnotationResponse::soap_default(NULL); }
	virtual ~tns__submitMediaAnnotationResponse() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigest
#define SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigest (64)
/* tns:submitMediaAnnotationTextAndTokenDigest */
class SOAP_CMAC tns__submitMediaAnnotationTextAndTokenDigest
{
public:
	std::string *arg0;	/* optional element of type xsd:string */
	LONG64 arg1;	/* required element of type xsd:long */
	int arg2;	/* required element of type xsd:int */
	std::string *arg3;	/* optional element of type xsd:string */
	int arg4;	/* required element of type xsd:int */
	std::string *userName;	/* optional element of type xsd:string */
	std::string *password;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 64; } /* = unique id SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__submitMediaAnnotationTextAndTokenDigest() { tns__submitMediaAnnotationTextAndTokenDigest::soap_default(NULL); }
	virtual ~tns__submitMediaAnnotationTextAndTokenDigest() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigestResponse
#define SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigestResponse (65)
/* tns:submitMediaAnnotationTextAndTokenDigestResponse */
class SOAP_CMAC tns__submitMediaAnnotationTextAndTokenDigestResponse
{
public:
	LONG64 return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 65; } /* = unique id SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextAndTokenDigestResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__submitMediaAnnotationTextAndTokenDigestResponse() { tns__submitMediaAnnotationTextAndTokenDigestResponse::soap_default(NULL); }
	virtual ~tns__submitMediaAnnotationTextAndTokenDigestResponse() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenId
#define SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenId (66)
/* tns:submitMediaAnnotationTextWithTokenId */
class SOAP_CMAC tns__submitMediaAnnotationTextWithTokenId
{
public:
	std::string *arg0;	/* optional element of type xsd:string */
	LONG64 arg1;	/* required element of type xsd:long */
	int arg2;	/* required element of type xsd:int */
	LONG64 arg3;	/* required element of type xsd:long */
	std::string *userName;	/* optional element of type xsd:string */
	std::string *password;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 66; } /* = unique id SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__submitMediaAnnotationTextWithTokenId() { tns__submitMediaAnnotationTextWithTokenId::soap_default(NULL); }
	virtual ~tns__submitMediaAnnotationTextWithTokenId() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenIdResponse
#define SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenIdResponse (67)
/* tns:submitMediaAnnotationTextWithTokenIdResponse */
class SOAP_CMAC tns__submitMediaAnnotationTextWithTokenIdResponse
{
public:
	LONG64 return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 67; } /* = unique id SOAP_TYPE_ServerSoap_tns__submitMediaAnnotationTextWithTokenIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__submitMediaAnnotationTextWithTokenIdResponse() { tns__submitMediaAnnotationTextWithTokenIdResponse::soap_default(NULL); }
	virtual ~tns__submitMediaAnnotationTextWithTokenIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__submitMediaToken
#define SOAP_TYPE_ServerSoap_tns__submitMediaToken (68)
/* tns:submitMediaToken */
class SOAP_CMAC tns__submitMediaToken
{
public:
	tns__mediaToken *arg0;	/* optional element of type tns:mediaToken */
	std::string *userName;	/* optional element of type xsd:string */
	std::string *password;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 68; } /* = unique id SOAP_TYPE_ServerSoap_tns__submitMediaToken */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__submitMediaToken() { tns__submitMediaToken::soap_default(NULL); }
	virtual ~tns__submitMediaToken() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__submitMediaTokenResponse
#define SOAP_TYPE_ServerSoap_tns__submitMediaTokenResponse (69)
/* tns:submitMediaTokenResponse */
class SOAP_CMAC tns__submitMediaTokenResponse
{
public:
	LONG64 return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 69; } /* = unique id SOAP_TYPE_ServerSoap_tns__submitMediaTokenResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__submitMediaTokenResponse() { tns__submitMediaTokenResponse::soap_default(NULL); }
	virtual ~tns__submitMediaTokenResponse() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigest
#define SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigest (70)
/* tns:submitMediaTokenDigest */
class SOAP_CMAC tns__submitMediaTokenDigest
{
public:
	std::string *arg0;	/* optional element of type xsd:string */
	int arg1;	/* required element of type xsd:int */
	int arg2;	/* required element of type xsd:int */
	std::string *userName;	/* optional element of type xsd:string */
	std::string *password;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 70; } /* = unique id SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__submitMediaTokenDigest() { tns__submitMediaTokenDigest::soap_default(NULL); }
	virtual ~tns__submitMediaTokenDigest() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigestResponse
#define SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigestResponse (71)
/* tns:submitMediaTokenDigestResponse */
class SOAP_CMAC tns__submitMediaTokenDigestResponse
{
public:
	LONG64 return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 71; } /* = unique id SOAP_TYPE_ServerSoap_tns__submitMediaTokenDigestResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__submitMediaTokenDigestResponse() { tns__submitMediaTokenDigestResponse::soap_default(NULL); }
	virtual ~tns__submitMediaTokenDigestResponse() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithId
#define SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithId (72)
/* tns:updateMediaAnnotationTextWithId */
class SOAP_CMAC tns__updateMediaAnnotationTextWithId
{
public:
	std::string *arg0;	/* optional element of type xsd:string */
	LONG64 arg1;	/* required element of type xsd:long */
	std::string *userName;	/* optional element of type xsd:string */
	std::string *password;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 72; } /* = unique id SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__updateMediaAnnotationTextWithId() { tns__updateMediaAnnotationTextWithId::soap_default(NULL); }
	virtual ~tns__updateMediaAnnotationTextWithId() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithIdResponse
#define SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithIdResponse (73)
/* tns:updateMediaAnnotationTextWithIdResponse */
class SOAP_CMAC tns__updateMediaAnnotationTextWithIdResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 73; } /* = unique id SOAP_TYPE_ServerSoap_tns__updateMediaAnnotationTextWithIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         tns__updateMediaAnnotationTextWithIdResponse() { tns__updateMediaAnnotationTextWithIdResponse::soap_default(NULL); }
	virtual ~tns__updateMediaAnnotationTextWithIdResponse() { }
};
#endif

#ifndef SOAP_TYPE_ServerSoap___tns__blessMediaAliasWithId
#define SOAP_TYPE_ServerSoap___tns__blessMediaAliasWithId (88)
/* Operation wrapper: */
struct __tns__blessMediaAliasWithId
{
public:
	tns__blessMediaAliasWithId *tns__blessMediaAliasWithId_;	/* optional element of type tns:blessMediaAliasWithId */
};
#endif

#ifndef SOAP_TYPE_ServerSoap___tns__blessMediaAnnotationWithId
#define SOAP_TYPE_ServerSoap___tns__blessMediaAnnotationWithId (92)
/* Operation wrapper: */
struct __tns__blessMediaAnnotationWithId
{
public:
	tns__blessMediaAnnotationWithId *tns__blessMediaAnnotationWithId_;	/* optional element of type tns:blessMediaAnnotationWithId */
};
#endif

#ifndef SOAP_TYPE_ServerSoap___tns__blessMediaTokenWithId
#define SOAP_TYPE_ServerSoap___tns__blessMediaTokenWithId (96)
/* Operation wrapper: */
struct __tns__blessMediaTokenWithId
{
public:
	tns__blessMediaTokenWithId *tns__blessMediaTokenWithId_;	/* optional element of type tns:blessMediaTokenWithId */
};
#endif

#ifndef SOAP_TYPE_ServerSoap___tns__blockMediaAliasWithId
#define SOAP_TYPE_ServerSoap___tns__blockMediaAliasWithId (100)
/* Operation wrapper: */
struct __tns__blockMediaAliasWithId
{
public:
	tns__blockMediaAliasWithId *tns__blockMediaAliasWithId_;	/* optional element of type tns:blockMediaAliasWithId */
};
#endif

#ifndef SOAP_TYPE_ServerSoap___tns__blockMediaAnnotationWithId
#define SOAP_TYPE_ServerSoap___tns__blockMediaAnnotationWithId (104)
/* Operation wrapper: */
struct __tns__blockMediaAnnotationWithId
{
public:
	tns__blockMediaAnnotationWithId *tns__blockMediaAnnotationWithId_;	/* optional element of type tns:blockMediaAnnotationWithId */
};
#endif

#ifndef SOAP_TYPE_ServerSoap___tns__blockUserWithId
#define SOAP_TYPE_ServerSoap___tns__blockUserWithId (108)
/* Operation wrapper: */
struct __tns__blockUserWithId
{
public:
	tns__blockUserWithId *tns__blockUserWithId_;	/* optional element of type tns:blockUserWithId */
};
#endif

#ifndef SOAP_TYPE_ServerSoap___tns__chat
#define SOAP_TYPE_ServerSoap___tns__chat (112)
/* Operation wrapper: */
struct __tns__chat
{
public:
	tns__chat *tns__chat_;	/* optional element of type tns:chat */
};
#endif

#ifndef SOAP_TYPE_ServerSoap___tns__curseMediaAliasWithId
#define SOAP_TYPE_ServerSoap___tns__curseMediaAliasWithId (116)
/* Operation wrapper: */
struct __tns__curseMediaAliasWithId
{
public:
	tns__curseMediaAliasWithId *tns__curseMediaAliasWithId_;	/* optional element of type tns:curseMediaAliasWithId */
};
#endif

#ifndef SOAP_TYPE_ServerSoap___tns__curseMediaAnnotationWithId
#define SOAP_TYPE_ServerSoap___tns__curseMediaAnnotationWithId (120)
/* Operation wrapper: */
struct __tns__curseMediaAnnotationWithId
{
public:
	tns__curseMediaAnnotationWithId *tns__curseMediaAnnotationWithId_;	/* optional element of type tns:curseMediaAnnotationWithId */
};
#endif

#ifndef SOAP_TYPE_ServerSoap___tns__curseMediaTokenWithId
#define SOAP_TYPE_ServerSoap___tns__curseMediaTokenWithId (124)
/* Operation wrapper: */
struct __tns__curseMediaTokenWithId
{
public:
	tns__curseMediaTokenWithId *tns__curseMediaTokenWithId_;	/* optional element of type tns:curseMediaTokenWithId */
};
#endif

#ifndef SOAP_TYPE_ServerSoap___tns__deleteMediaAliasWithId
#define SOAP_TYPE_ServerSoap___tns__deleteMediaAliasWithId (128)
/* Operation wrapper: */
struct __tns__deleteMediaAliasWithId
{
public:
	tns__deleteMediaAliasWithId *tns__deleteMediaAliasWithId_;	/* optional element of type tns:deleteMediaAliasWithId */
};
#endif

#ifndef SOAP_TYPE_ServerSoap___tns__deleteMediaAnnotationWithId
#define SOAP_TYPE_ServerSoap___tns__deleteMediaAnnotationWithId (132)
/* Operation wrapper: */
struct __tns__deleteMediaAnnotationWithId
{
public:
	tns__deleteMediaAnnotationWithId *tns__deleteMediaAnnotationWithId_;	/* optional element of type tns:deleteMediaAnnotationWithId */
};
#endif

#ifndef SOAP_TYPE_ServerSoap___tns__isClientUpdated
#define SOAP_TYPE_ServerSoap___tns__isClientUpdated (136)
/* Operation wrapper: */
struct __tns__isClientUpdated
{
public:
	tns__isClientUpdated *tns__isClientUpdated_;	/* optional element of type tns:isClientUpdated */
};
#endif

#ifndef SOAP_TYPE_ServerSoap___tns__isConnected
#define SOAP_TYPE_ServerSoap___tns__isConnected (140)
/* Operation wrapper: */
struct __tns__isConnected
{
public:
	tns__isConnected *tns__isConnected_;	/* optional element of type tns:isConnected */
};
#endif

#ifndef SOAP_TYPE_ServerSoap___tns__selectMediaAliasesWithTokenId
#define SOAP_TYPE_ServerSoap___tns__selectMediaAliasesWithTokenId (144)
/* Operation wrapper: */
struct __tns__selectMediaAliasesWithTokenId
{
public:
	tns__selectMediaAliasesWithTokenId *tns__selectMediaAliasesWithTokenId_;	/* optional element of type tns:selectMediaAliasesWithTokenId */
};
#endif

#ifndef SOAP_TYPE_ServerSoap___tns__selectMediaAnnotationsWithTokenId
#define SOAP_TYPE_ServerSoap___tns__selectMediaAnnotationsWithTokenId (148)
/* Operation wrapper: */
struct __tns__selectMediaAnnotationsWithTokenId
{
public:
	tns__selectMediaAnnotationsWithTokenId *tns__selectMediaAnnotationsWithTokenId_;	/* optional element of type tns:selectMediaAnnotationsWithTokenId */
};
#endif

#ifndef SOAP_TYPE_ServerSoap___tns__selectMediaTokenWithDigest
#define SOAP_TYPE_ServerSoap___tns__selectMediaTokenWithDigest (152)
/* Operation wrapper: */
struct __tns__selectMediaTokenWithDigest
{
public:
	tns__selectMediaTokenWithDigest *tns__selectMediaTokenWithDigest_;	/* optional element of type tns:selectMediaTokenWithDigest */
};
#endif

#ifndef SOAP_TYPE_ServerSoap___tns__selectMediaTokenWithId
#define SOAP_TYPE_ServerSoap___tns__selectMediaTokenWithId (156)
/* Operation wrapper: */
struct __tns__selectMediaTokenWithId
{
public:
	tns__selectMediaTokenWithId *tns__selectMediaTokenWithId_;	/* optional element of type tns:selectMediaTokenWithId */
};
#endif

#ifndef SOAP_TYPE_ServerSoap___tns__selectRelatedMediaAnnotationsWithTokenId
#define SOAP_TYPE_ServerSoap___tns__selectRelatedMediaAnnotationsWithTokenId (160)
/* Operation wrapper: */
struct __tns__selectRelatedMediaAnnotationsWithTokenId
{
public:
	tns__selectRelatedMediaAnnotationsWithTokenId *tns__selectRelatedMediaAnnotationsWithTokenId_;	/* optional element of type tns:selectRelatedMediaAnnotationsWithTokenId */
};
#endif

#ifndef SOAP_TYPE_ServerSoap___tns__selectUser
#define SOAP_TYPE_ServerSoap___tns__selectUser (164)
/* Operation wrapper: */
struct __tns__selectUser
{
public:
	tns__selectUser *tns__selectUser_;	/* optional element of type tns:selectUser */
};
#endif

#ifndef SOAP_TYPE_ServerSoap___tns__setUserAnonymous
#define SOAP_TYPE_ServerSoap___tns__setUserAnonymous (168)
/* Operation wrapper: */
struct __tns__setUserAnonymous
{
public:
	tns__setUserAnonymous *tns__setUserAnonymous_;	/* optional element of type tns:setUserAnonymous */
};
#endif

#ifndef SOAP_TYPE_ServerSoap___tns__setUserLanguage
#define SOAP_TYPE_ServerSoap___tns__setUserLanguage (172)
/* Operation wrapper: */
struct __tns__setUserLanguage
{
public:
	tns__setUserLanguage *tns__setUserLanguage_;	/* optional element of type tns:setUserLanguage */
};
#endif

#ifndef SOAP_TYPE_ServerSoap___tns__submitMediaAlias
#define SOAP_TYPE_ServerSoap___tns__submitMediaAlias (176)
/* Operation wrapper: */
struct __tns__submitMediaAlias
{
public:
	tns__submitMediaAlias *tns__submitMediaAlias_;	/* optional element of type tns:submitMediaAlias */
};
#endif

#ifndef SOAP_TYPE_ServerSoap___tns__submitMediaAliasTextAndTokenDigest
#define SOAP_TYPE_ServerSoap___tns__submitMediaAliasTextAndTokenDigest (180)
/* Operation wrapper: */
struct __tns__submitMediaAliasTextAndTokenDigest
{
public:
	tns__submitMediaAliasTextAndTokenDigest *tns__submitMediaAliasTextAndTokenDigest_;	/* optional element of type tns:submitMediaAliasTextAndTokenDigest */
};
#endif

#ifndef SOAP_TYPE_ServerSoap___tns__submitMediaAliasTextWithTokenId
#define SOAP_TYPE_ServerSoap___tns__submitMediaAliasTextWithTokenId (184)
/* Operation wrapper: */
struct __tns__submitMediaAliasTextWithTokenId
{
public:
	tns__submitMediaAliasTextWithTokenId *tns__submitMediaAliasTextWithTokenId_;	/* optional element of type tns:submitMediaAliasTextWithTokenId */
};
#endif

#ifndef SOAP_TYPE_ServerSoap___tns__submitMediaAnnotation
#define SOAP_TYPE_ServerSoap___tns__submitMediaAnnotation (188)
/* Operation wrapper: */
struct __tns__submitMediaAnnotation
{
public:
	tns__submitMediaAnnotation *tns__submitMediaAnnotation_;	/* optional element of type tns:submitMediaAnnotation */
};
#endif

#ifndef SOAP_TYPE_ServerSoap___tns__submitMediaAnnotationTextAndTokenDigest
#define SOAP_TYPE_ServerSoap___tns__submitMediaAnnotationTextAndTokenDigest (192)
/* Operation wrapper: */
struct __tns__submitMediaAnnotationTextAndTokenDigest
{
public:
	tns__submitMediaAnnotationTextAndTokenDigest *tns__submitMediaAnnotationTextAndTokenDigest_;	/* optional element of type tns:submitMediaAnnotationTextAndTokenDigest */
};
#endif

#ifndef SOAP_TYPE_ServerSoap___tns__submitMediaAnnotationTextWithTokenId
#define SOAP_TYPE_ServerSoap___tns__submitMediaAnnotationTextWithTokenId (196)
/* Operation wrapper: */
struct __tns__submitMediaAnnotationTextWithTokenId
{
public:
	tns__submitMediaAnnotationTextWithTokenId *tns__submitMediaAnnotationTextWithTokenId_;	/* optional element of type tns:submitMediaAnnotationTextWithTokenId */
};
#endif

#ifndef SOAP_TYPE_ServerSoap___tns__submitMediaToken
#define SOAP_TYPE_ServerSoap___tns__submitMediaToken (200)
/* Operation wrapper: */
struct __tns__submitMediaToken
{
public:
	tns__submitMediaToken *tns__submitMediaToken_;	/* optional element of type tns:submitMediaToken */
};
#endif

#ifndef SOAP_TYPE_ServerSoap___tns__submitMediaTokenDigest
#define SOAP_TYPE_ServerSoap___tns__submitMediaTokenDigest (204)
/* Operation wrapper: */
struct __tns__submitMediaTokenDigest
{
public:
	tns__submitMediaTokenDigest *tns__submitMediaTokenDigest_;	/* optional element of type tns:submitMediaTokenDigest */
};
#endif

#ifndef SOAP_TYPE_ServerSoap___tns__updateMediaAnnotationTextWithId
#define SOAP_TYPE_ServerSoap___tns__updateMediaAnnotationTextWithId (208)
/* Operation wrapper: */
struct __tns__updateMediaAnnotationTextWithId
{
public:
	tns__updateMediaAnnotationTextWithId *tns__updateMediaAnnotationTextWithId_;	/* optional element of type tns:updateMediaAnnotationTextWithId */
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_ServerSoap_SOAP_ENV__Header
#define SOAP_TYPE_ServerSoap_SOAP_ENV__Header (209)
/* SOAP Header: */
struct SOAP_ENV__Header
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_ServerSoap_SOAP_ENV__Code
#define SOAP_TYPE_ServerSoap_SOAP_ENV__Code (210)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_ServerSoap_SOAP_ENV__Detail
#define SOAP_TYPE_ServerSoap_SOAP_ENV__Detail (212)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_ServerSoap_SOAP_ENV__Reason
#define SOAP_TYPE_ServerSoap_SOAP_ENV__Reason (215)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_ServerSoap_SOAP_ENV__Fault
#define SOAP_TYPE_ServerSoap_SOAP_ENV__Fault (216)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
};
#endif

#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE_ServerSoap__QName
#define SOAP_TYPE_ServerSoap__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE_ServerSoap__XML
#define SOAP_TYPE_ServerSoap__XML (6)
typedef char *_XML;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


} // namespace ServerSoap


#endif

/* End of ServerSoapStub.h */
